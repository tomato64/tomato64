--- snmp/agent/mibgroup/libnetlink.h
+++ snmp/agent/mibgroup/libnetlink.h
@@ -0,0 +1,30 @@
+#ifndef __LIBNETLINK_H__
+#define __LIBNETLINK_H__ 1
+
+#include <asm/types.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+
+struct rtnl_handle
+{
+	int			fd;
+	struct sockaddr_nl	local;
+	struct sockaddr_nl	peer;
+	__u32			seq;
+	__u32			dump;
+};
+
+extern int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions);
+extern void rtnl_close(struct rtnl_handle *rth);
+extern int rtnl_wilddump_request(struct rtnl_handle *rth, int fam, int type);
+extern int rtnl_dump_request(struct rtnl_handle *rth, int type, void *req, int len);
+extern int rtnl_dump_filter(struct rtnl_handle *rth,
+			    int (*filter)(struct sockaddr_nl *, struct nlmsghdr *n, void *),
+			    void *arg1,
+			    int (*junk)(struct sockaddr_nl *,struct nlmsghdr *n, void *),
+			    void *arg2);
+
+extern int parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len);
+
+#endif /* __LIBNETLINK_H__ */
+
--- snmp/agent/mibgroup/ll_map.h
+++ snmp/agent/mibgroup/ll_map.h
@@ -0,0 +1,10 @@
+#ifndef __LL_MAP_H__
+#define __LL_MAP_H__ 1
+
+extern int ll_remember_index(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg);
+extern int ll_init_map(struct rtnl_handle *rth);
+extern int ll_name_to_index(char *name);
+extern const char *ll_index_to_name(int idx);
+extern const char *ll_idx_n2a(int idx, char *buf);
+
+#endif /* __LL_MAP_H__ */
--- snmp/agent/mibgroup/qos_access.c
+++ snmp/agent/mibgroup/qos_access.c
@@ -0,0 +1,555 @@
+
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "qos_access.h"
+#include "qos_enums.h"
+#include "qos_checkfns.h"
+#include "unistd.h"
+
+/** returns the first data point within the qosObjectTable table data.
+
+    Set the my_loop_context variable to the first data point structure
+    of your choice (from which you can find the next one).  This could
+    be anything from the first node in a linked list, to an integer
+    pointer containing the beginning of an array variable.
+
+    Set the my_data_context variable to something to be returned to
+    you later that will provide you with the data to return in a given
+    row.  This could be the same pointer as what my_loop_context is
+    set to, or something different.
+
+    The put_index_data variable contains a list of snmp variable
+    bindings, one for each index in your table.  Set the values of
+    each appropriately according to the data matching the first row
+    and return the put_index_data variable at the end of the function.
+*/
+netsnmp_variable_list *
+qosObjectTable_get_first_data_point(void **my_loop_context,
+                                    void **my_data_context,
+                                    netsnmp_variable_list * put_index_data,
+                                    netsnmp_iterator_info *mydata)
+{
+    extern struct qos_table table;
+    netsnmp_variable_list *vptr;
+
+    update_qos_table_data(&table);
+    
+    *my_loop_context = &table;
+    *my_data_context = &(table.data);
+
+    vptr = put_index_data;
+    
+    snmp_set_var_value(vptr, (u_char *) &(table.data.device_type) /** XXX: qosDeviceIndex data */ ,
+//                       sizeof(long)/** XXX: length of qosDeviceType data */ );
+                       sizeof(ASN_INTEGER)/** XXX: length of qosDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &(table.data.device_index) /** XXX: qosDeviceIndex data */ ,
+//                       sizeof(long)/** XXX: length of qosDeviceIndex data */ );
+                       sizeof(ASN_INTEGER)/** XXX: length of qosDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &(table.data.majorhandle) /** XXX: qosMajorHandle data */ ,
+                       sizeof(ASN_UNSIGNED)/** XXX: length of qosMajorHandle data */ );
+//                       sizeof(int)/** XXX: length of qosHandle data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &(table.data.minorhandle) /** XXX: qosMinorHandle data */ ,
+                       sizeof(ASN_UNSIGNED)/** XXX: length of qosMinorHandle data */ );
+//                       sizeof(int)/** XXX: length of qosHandle data */ );
+    vptr = vptr->next_variable;
+
+    return put_index_data;
+}
+
+/** functionally the same as qosObjectTable_get_first_data_point, but
+   my_loop_context has already been set to a previous value and should
+   be updated to the next in the list.  For example, if it was a
+   linked list, you might want to cast it to your local data type and
+   then return my_loop_context->next.  The my_data_context pointer
+   should be set to something you need later and the indexes in
+   put_index_data updated again. */
+netsnmp_variable_list *
+qosObjectTable_get_next_data_point(void **my_loop_context,
+                                   void **my_data_context,
+                                   netsnmp_variable_list * put_index_data,
+                                   netsnmp_iterator_info *mydata)
+{
+    netsnmp_variable_list *vptr;
+    qos_table *table;    
+
+    table = (struct qos_table*)*my_loop_context;
+
+    if(table->next==NULL) {
+	return(NULL);
+    }
+
+    table = table->next;	
+    *my_loop_context = table; 
+    *my_data_context = &(table->data);
+
+    vptr = put_index_data;
+
+    snmp_set_var_value(vptr, (u_char *) &((table->data).device_type) /** XXX: qosDeviceType data */ ,
+                       sizeof(ASN_INTEGER)/** XXX: length of qosDeviceType data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &((table->data).device_index) /** XXX: qosDeviceIndex data */ ,
+                       sizeof(ASN_INTEGER)/** XXX: length of qosDeviceIndex data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &((table->data).majorhandle) /** XXX: qosMajorHandle data */ ,
+                       sizeof(ASN_UNSIGNED)/** XXX: length of qosMajorHandle data */ );
+    vptr = vptr->next_variable;
+    snmp_set_var_value(vptr, (u_char *) &((table->data).minorhandle) /** XXX: qosMinorHandle data */ ,
+                       sizeof(ASN_UNSIGNED)/** XXX: length of qosMinorHandle data */ );
+    vptr = vptr->next_variable;
+    
+    return put_index_data;
+}
+
+/** Create a data_context for non-existent rows that SETs are performed on.
+ *  return a void * pointer which will be passed to subsequent get_XXX
+ *  and set_XXX functions for data retrival and modification during
+ *  this SET request.
+ *
+ *  The indexs are encoded (in order) into the index_data pointer if it
+ *  would be helpful to use that information.
+ */
+void           *
+qosObjectTable_create_data_context(netsnmp_variable_list * index_data)
+{
+    return NULL;                /* XXX: you likely want to return a real pointer */
+}
+
+/** If the implemented set_* functions don't operate directly on the
+   real-live data (which is actually recommended), then this function
+   can be used to take a given my_data_context pointer and "commit" it
+   to whereever the modified data needs to be put back to.  For
+   example, if this was a routing table you could publish the modified
+   routes back into the kernel at this point.
+
+   new_or_del will be set to 1 if new, or -1 if it should be deleted
+   or 0 if it is just a modification of an existing row.
+
+   If you free the data yourself, make sure to *my_data_context = NULL */
+int
+qosObjectTable_commit_row(void **my_data_context, int new_or_del)
+{
+    /** Add any necessary commit code here 
+     * return no errors.  And there shouldn't be any!!!  Ever!!!  You
+     * should have checked the values long before this. 
+     */
+    return SNMP_ERR_NOERROR;
+}
+
+
+
+// functions that return pointers to real data from qos structure (see qos_checkfns.h)
+
+long           *
+get_qosDeviceType(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosDeviceType\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(long);
+    return(&(data->device_type));
+}
+
+long           *
+get_qosDeviceIndex(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosDeviceIndex\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(long);
+    return(&(data->device_index));
+}
+
+/** XXX: return a data pointer to the data for the qosHandle column and set
+         ret_len to its proper size in bytes. */
+u_long           *
+get_qosMajorHandle(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosHandle\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->majorhandle));    
+}
+
+u_long           *
+get_qosMinorHandle(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosHandle\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->minorhandle));    
+}
+
+char *get_qosTextHandle(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosTextHandle\n");
+    data=(struct qos_data*)data_context;
+    if(data->text_handle==NULL) { return(NULL); }
+    *ret_len=sizeof(char)*strlen(data->text_handle);
+    return((data->text_handle));
+}
+
+char *get_qosTextLeaf(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosTextLeaf\n");
+    data=(struct qos_data*)data_context;
+    if(data->text_leaf==NULL) { return(NULL); }
+    *ret_len=sizeof(char)*strlen(data->text_leaf);
+    return((data->text_leaf));
+}
+
+u_long           *
+get_qosParent(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosParent\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->parent));    
+}
+
+char *get_qosTextParent(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosTextParent\n");
+    data=(struct qos_data*)data_context;
+    if(data->text_parent==NULL) { return(NULL); }
+    *ret_len=sizeof(char)*strlen(data->text_parent);
+    return((data->text_parent));
+}
+
+/** XXX: return a data pointer to the data for the qosDeviceName column and set
+         ret_len to its proper size in bytes. */
+
+char *get_qosDeviceName(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosDeviceName\n");
+    data=(struct qos_data*)data_context;
+    if(data->dev_name==NULL) { return(NULL); }
+    *ret_len=sizeof(char)*strlen(data->dev_name);
+    return((data->dev_name));
+}
+
+/** XXX: return a data pointer to the data for the qosType column and set
+         ret_len to its proper size in bytes. */
+char *get_qosType(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosType\n");
+    data=(struct qos_data*)data_context;
+    if(data->type==NULL) { return(NULL); }
+    *ret_len=sizeof(char)*strlen(data->type);
+    return((data->type));
+}
+
+/** XXX: return a data pointer to the data for the qosBytes column and set
+         ret_len to its proper size in bytes. */
+unsigned long long         *
+get_qosBytes(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosBytes\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(unsigned long long);
+    return(&(data->qosBytes));
+}
+
+/** XXX: return a data pointer to the data for the qosPackets column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosPackets(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosPackets\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosPackets));
+}
+
+/** XXX: return a data pointer to the data for the qosDropped column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosDropped(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosDropped\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosDropped));
+}
+
+/** XXX: return a data pointer to the data for the qosOverlimit column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosOverlimit(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosOverlimit\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosOverlimit));
+}
+
+/** XXX: return a data pointer to the data for the qosBps column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosBps(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosBps\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosBps));
+}
+
+/** XXX: return a data pointer to the data for the qosPps column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosPps(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosPps\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosPps));
+}
+
+/** XXX: return a data pointer to the data for the qosQlen column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosQlen(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//   snmp_log(LOG_NOTICE,"get_qosQlen\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosQlen));
+}
+
+/** XXX: return a data pointer to the data for the qosBacklog column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_qosBacklog(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosBacklog\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->qosBacklog));
+}
+
+/** XXX: return a data pointer to the data for the redEarly column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_redEarly(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_redEarly\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->redEarly));
+}
+
+/** XXX: return a data pointer to the data for the redPdrop column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_redPdrop(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_redPdrop\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->redPdrop));
+}
+
+/** XXX: return a data pointer to the data for the redOther column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_redOther(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_redOther\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->redOther));
+}
+
+/** XXX: return a data pointer to the data for the redMarked column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_redMarked(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_redMarked\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->redMarked));
+}
+
+/** XXX: return a data pointer to the data for the htbLends column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbLends(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbLends\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbLends));
+}
+
+/** XXX: return a data pointer to the data for the htbBorrows column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbBorrows(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbBorrows\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbBorrows));
+}
+
+/** XXX: return a data pointer to the data for the htbGiants column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbGiants(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbGiants\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbGiants));
+}
+
+/** XXX: return a data pointer to the data for the htbTokens column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbTokens(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbTokens\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbTokens));
+}
+
+/** XXX: return a data pointer to the data for the htbCTokens column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbCTokens(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbCTokens\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbCTokens));
+}
+
+/** XXX: return a data pointer to the data for the htbRate column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbRate(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbRate\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbRate));
+}
+
+/** XXX: return a data pointer to the data for the htbCeil column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbCeil(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbCeil\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbCeil));
+}
+
+/** XXX: return a data pointer to the data for the htbPrio column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_htbPrio(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_htbPrio\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->htbPrio));
+}
+
+/** XXX: return a data pointer to the data for the cbqBorrows column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_cbqBorrows(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_cbqBorrows\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->cbqBorrows));
+}
+
+/** XXX: return a data pointer to the data for the cbqOveractions column and set
+         ret_len to its proper size in bytes. */
+u_long         *
+get_cbqOveractions(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_cbqOveractions\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->cbqOveractions));
+}
+
+/** XXX: return a data pointer to the data for the cbqAvgidle column and set
+         ret_len to its proper size in bytes. */
+long         *
+get_cbqAvgidle(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_cbqAvgidle\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->cbqAvgidle));
+}
+
+/** XXX: return a data pointer to the data for the cbqUndertime column and set
+         ret_len to its proper size in bytes. */
+long         *
+get_cbqUndertime(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_cbqUndertime\n");
+    data=(struct qos_data*)data_context;
+    *ret_len=sizeof(u_long);
+    return(&(data->cbqUndertime));
+}
+
+char *get_qosInfo(void *data_context, size_t * ret_len)
+{
+    struct qos_data *data;
+//    snmp_log(LOG_NOTICE,"get_qosTextHandle\n");
+    data=(struct qos_data*)data_context;
+    if(data->text_handle==NULL) { return(NULL); }
+    *ret_len=sizeof(char)*strlen(data->info);
+    return((data->info));
+}
+
--- snmp/agent/mibgroup/qos_access.h
+++ snmp/agent/mibgroup/qos_access.h
@@ -0,0 +1,63 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.access_functions.conf,v 1.6 2003/09/11 22:48:49 rstory Exp $
+ */
+#ifndef QOS_ACCESS_H
+#define QOS_ACCESS_H
+
+/** User-defined data access functions for data in table qosObjectTable */
+/** row level accessors */
+//Netsnmp_First_Data_Point _get_first_data_point;
+//Netsnmp_Next_Data_Point _get_next_data_point;
+
+Netsnmp_First_Data_Point qosObjectTable_get_first_data_point;
+Netsnmp_Next_Data_Point qosObjectTable_get_next_data_point;
+
+int             qosObjectTable_commit_row(void **my_data_context,
+                                          int new_or_del);
+void           *qosObjectTable_create_data_context(netsnmp_variable_list *
+                                                   index_data);
+
+/** column accessors */
+long           *get_qosDeviceType(void *data_context, size_t * ret_len);
+long           *get_qosDeviceIndex(void *data_context, size_t * ret_len);
+u_long           *get_qosMajorHandle(void *data_context, size_t * ret_len);
+u_long           *get_qosMinorHandle(void *data_context, size_t * ret_len);
+u_long           *get_qosParent(void *data_context, size_t * ret_len);
+char 		*get_qosTextParent(void *data_context, size_t * ret_len);
+char 		*get_qosTextHandle(void *data_context, size_t * ret_len);
+char 		*get_qosTextLeaf(void *data_context, size_t * ret_len);
+char 		*get_qosDeviceName(void *data_context, size_t * ret_len);
+char 		*get_qosType(void *data_context, size_t * ret_len);
+unsigned long long         *get_qosBytes(void *data_context, size_t * ret_len);
+u_long         *get_qosPackets(void *data_context, size_t * ret_len);
+u_long         *get_qosDropped(void *data_context, size_t * ret_len);
+u_long         *get_qosOverlimit(void *data_context, size_t * ret_len);
+
+
+u_long         *get_qosBps(void *data_context, size_t * ret_len);
+u_long         *get_qosPps(void *data_context, size_t * ret_len);
+u_long         *get_qosQlen(void *data_context, size_t * ret_len);
+u_long         *get_qosBacklog(void *data_context, size_t * ret_len);
+
+u_long         *get_redEarly(void *data_context, size_t * ret_len);
+u_long         *get_redPdrop(void *data_context, size_t * ret_len);
+u_long         *get_redOther(void *data_context, size_t * ret_len);
+u_long         *get_redMarked(void *data_context, size_t * ret_len);
+
+u_long         *get_htbLends(void *data_context, size_t * ret_len);
+u_long         *get_htbBorrows(void *data_context, size_t * ret_len);
+u_long         *get_htbGiants(void *data_context, size_t * ret_len);
+u_long         *get_htbTokens(void *data_context, size_t * ret_len);
+u_long         *get_htbCTokens(void *data_context, size_t * ret_len);
+u_long         *get_htbRate(void *data_context, size_t * ret_len);
+u_long         *get_htbCeil(void *data_context, size_t * ret_len);
+u_long         *get_htbPrio(void *data_context, size_t * ret_len);
+
+u_long         *get_cbqBorrows(void *data_context, size_t * ret_len);
+u_long         *get_cbqOveractions(void *data_context, size_t * ret_len);
+long    	*get_cbqAvgidle(void *data_context, size_t * ret_len);
+long 	        *get_cbqUndertime(void *data_context, size_t * ret_len);
+char 		*get_qosInfo(void *data_context, size_t * ret_len);
+
+#endif                          /* QOS_ACCESS_H */
--- snmp/agent/mibgroup/qos.c
+++ snmp/agent/mibgroup/qos.c
@@ -0,0 +1,645 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+#include "qos.h"
+#include "qos_checkfns.h"
+#include "qos_access.h"
+
+/* 
+    As said in first lines, this file is partly autogenerated - functions had to be
+    modified to fit needs into my extension - that means that specific function 
+    for walking going through qos statistics table in memory are wrriten
+    
+    Default comments from mib2c compiler are self-explanatory - I was only info 
+    I had during developement, so it should be sufficient also to you :-)
+
+*/
+struct qos_table table;
+
+static netsnmp_oid_stash_node *undoStorage = NULL;
+static netsnmp_oid_stash_node *commitStorage = NULL;
+
+struct undoInfo {
+    void           *ptr;
+    size_t          len;
+};
+
+struct commitInfo {
+    void           *data_context;
+    int             have_committed;
+    int             new_row;
+};
+
+void
+qos_free_undoInfo(void *vptr)
+{
+    struct undoInfo *ui = vptr;
+    if (!ui)
+        return;
+    SNMP_FREE(ui->ptr);
+    SNMP_FREE(ui);
+}
+
+/** Initialize the qosObjectTable table by defining its contents and how it's structured */
+void
+initialize_table_qosObjectTable(void)
+{
+    static oid      qosObjectTable_oid[] = { 1, 3, 6, 1, 4, 1, 18756, 1 };
+    netsnmp_table_registration_info *table_info;
+    netsnmp_handler_registration *my_handler;
+    netsnmp_iterator_info *iinfo;
+
+    /** create the table registration information structures */
+    table_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
+    iinfo = SNMP_MALLOC_TYPEDEF(netsnmp_iterator_info);
+
+    /** if your table is read only, it's easiest to change the
+        HANDLER_CAN_RWRITE definition below to HANDLER_CAN_RONLY */
+    my_handler = netsnmp_create_handler_registration("qosObjectTable",
+                                                     qosObjectTable_handler,
+                                                     qosObjectTable_oid,
+                                                     OID_LENGTH
+                                                     (qosObjectTable_oid),
+                                                     HANDLER_CAN_RWRITE);
+
+    if (!my_handler || !table_info || !iinfo) {
+        snmp_log(LOG_ERR,
+                 "malloc failed in initialize_table_qosObjectTable");
+        return; /** Serious error. */
+    }
+
+    /***************************************************
+     * Setting up the table's definition
+     */
+    netsnmp_table_helper_add_indexes(table_info, 
+				     ASN_INTEGER,
+				    		/** index: qosDeviceType */
+				     ASN_INTEGER,
+                                               /** index: qosDeviceIndex */
+                                     ASN_UNSIGNED,
+                                               /** index: qosMajorHandle */
+				     ASN_UNSIGNED,
+						/* index: qosMinorHandle */
+                                     0);
+
+    /** Define the minimum and maximum accessible columns.  This
+        optimizes retrival. */
+    table_info->min_column = 1;
+    table_info->max_column = 35;
+
+    /** iterator access routines */
+    iinfo->get_first_data_point = qosObjectTable_get_first_data_point;
+    iinfo->get_next_data_point = qosObjectTable_get_next_data_point;
+
+    /** tie the two structures together */
+    iinfo->table_reginfo = table_info;
+
+    /***************************************************
+     * registering the table with the master agent
+     */
+    DEBUGMSGTL(("initialize_table_qosObjectTable",
+                "Registering table qosObjectTable as a table iterator\n"));
+    netsnmp_register_table_iterator(my_handler, iinfo);
+}
+
+/** Initializes the qos module */
+void
+init_qos(void)
+{
+  /** here we initialize all the tables we're planning on supporting */
+    initialize_table_qosObjectTable();
+    initialize_qos_table(&table);
+}
+
+/** handles requests for the qosObjectTable table, if anything else needs to be done */
+int
+qosObjectTable_handler(netsnmp_mib_handler *handler,
+                       netsnmp_handler_registration *reginfo,
+                       netsnmp_agent_request_info *reqinfo,
+                       netsnmp_request_info *requests)
+{
+
+    netsnmp_request_info *request;
+    netsnmp_table_request_info *table_info;
+    netsnmp_variable_list *var;
+    struct commitInfo *ci = NULL;
+
+    void           *data_context = NULL;
+
+    oid            *suffix;
+    size_t          suffix_len;
+
+    /** column and row index encoded portion */
+    suffix = requests->requestvb->name + reginfo->rootoid_len + 1;
+    suffix_len = requests->requestvb->name_length -
+        (reginfo->rootoid_len + 1);
+
+    for (request = requests; request; request = request->next) {
+        var = request->requestvb;
+        if (request->processed != 0)
+            continue;
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+        case MODE_SET_RESERVE1:
+            data_context = netsnmp_extract_iterator_context(request);
+            if (data_context == NULL) {
+                if (reqinfo->mode == MODE_GET) {
+                    netsnmp_set_request_error(reqinfo, request,
+                                              SNMP_NOSUCHINSTANCE);
+                    continue;
+                }
+            }
+            break;
+
+        default:               /* == the other SET modes */
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+            break;
+
+        }
+
+        /** extracts the information about the table from the request */
+        table_info = netsnmp_extract_table_info(request);
+        /** table_info->colnum contains the column number requested */
+        /** table_info->indexes contains a linked list of snmp variable
+           bindings for the indexes of the table.  Values in the list
+           have been set corresponding to the indexes of the
+           request */
+        if (table_info == NULL) {
+            continue;
+        }
+
+        switch (reqinfo->mode) {
+        case MODE_GET:
+            switch (table_info->colnum) {
+
+            case COLUMN_QOSDEVICETYPE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosDeviceIndex(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSDEVICEINDEX:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosDeviceIndex(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSMAJORHANDLE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosMajorHandle(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSMINORHANDLE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosMinorHandle(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSTEXTHANDLE:
+                {
+                    char *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosTextHandle(data_context, &retval_len);
+                    snmp_set_var_typed_value(var,ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSTEXTLEAF:
+                {
+                    char *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosTextLeaf(data_context, &retval_len);
+                    snmp_set_var_typed_value(var,ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSPARENT:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosParent(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSTEXTPARENT:
+                {
+                    char *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosTextParent(data_context, &retval_len);
+                    snmp_set_var_typed_value(var,ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSDEVICENAME:
+                {
+                    char *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosDeviceName(data_context, &retval_len);
+                    snmp_set_var_typed_value(var,ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+
+            case COLUMN_QOSTYPE:
+                {
+                    char *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosType(data_context, &retval_len);
+                    snmp_set_var_typed_value(var,ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSBYTES:
+                {
+                    unsigned long long     *retval;
+//                  u_long                 *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosBytes(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER64,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSPACKETS:
+                {
+                    u_long         *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosPackets(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSDROPPED:
+                {
+                    u_long         *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosDropped(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSOVERLIMIT:
+                {
+                    u_long         *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosOverlimit(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSBPS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosBps(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSPPS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosPps(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSQLEN:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosQlen(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSBACKLOG:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosBacklog(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSREDEARLY:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_redEarly(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSREDPDROP:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_redPdrop(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSREDOTHER:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_redOther(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSREDMARKED:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_redMarked(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBLENDS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbLends(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBBORROWS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbBorrows(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBGIANTS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbGiants(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBTOKENS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbTokens(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBCTOKENS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbCTokens(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBRATE:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbRate(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBCEIL:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbCeil(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSHTBPRIO:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_htbPrio(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_UNSIGNED,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSCBQBORROWS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_cbqBorrows(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSCBQOVERACTIONS:
+                {
+                    u_long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_cbqOveractions(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_COUNTER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSCBQAVGIDLE:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_cbqUndertime(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            case COLUMN_QOSCBQUNDERTIME:
+                {
+                    long           *retval;
+                    size_t          retval_len = 0;
+                    retval = get_cbqUndertime(data_context, &retval_len);
+                    snmp_set_var_typed_value(var, ASN_INTEGER,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+            case COLUMN_QOSINFO:
+                {
+                    char *retval;
+                    size_t          retval_len = 0;
+                    retval = get_qosInfo(data_context, &retval_len);
+                    snmp_set_var_typed_value(var,ASN_OCTET_STR,
+                                             (const u_char *) retval,
+                                             retval_len);
+                }
+                break;
+
+            default:
+                /** We shouldn't get here */
+                snmp_log(LOG_ERR,
+                         "problem encountered in qosObjectTable_handler: unknown column\n");
+            }
+            break;
+
+        case MODE_SET_RESERVE1:
+            ci = netsnmp_oid_stash_get_data(commitStorage,
+                                            suffix + 1, suffix_len - 1);
+
+            if (!ci) {
+                    /** create the commit storage info */
+                ci = SNMP_MALLOC_STRUCT(commitInfo);
+                if (!data_context) {
+                    ci->data_context =
+                        qosObjectTable_create_data_context(table_info->
+                                                           indexes);
+                    ci->new_row = 1;
+                } else {
+                    ci->data_context = data_context;
+                }
+                netsnmp_oid_stash_add_data(&commitStorage,
+                                           suffix + 1, suffix_len - 1, ci);
+            }
+            break;
+
+        case MODE_SET_RESERVE2:
+            switch (table_info->colnum) {
+            default:
+                netsnmp_set_request_error(reqinfo, request,
+                                          SNMP_ERR_NOTWRITABLE);
+                break;
+            }
+            break;
+
+        case MODE_SET_ACTION:
+            /** save a variable copy */
+            switch (table_info->colnum) {
+            }
+            break;
+
+        case MODE_SET_COMMIT:
+            if (!ci->have_committed) {
+                    /** do this once per row only */
+                qosObjectTable_commit_row(&ci->data_context, ci->new_row);
+                ci->have_committed = 1;
+            }
+            break;
+
+        case MODE_SET_UNDO:
+             /** save a variable copy */
+            switch (table_info->colnum) {
+            }
+            break;
+
+        case MODE_SET_FREE:
+            break;
+
+        default:
+            snmp_log(LOG_ERR,
+                     "problem encountered in qosObjectTable_handler: unsupported mode\n");
+        }
+    }
+
+    /** clean up after all requset processing has ended */
+    switch (reqinfo->mode) {
+    case MODE_SET_UNDO:
+    case MODE_SET_FREE:
+    case MODE_SET_COMMIT:
+        /** clear out the undo cache */
+        netsnmp_oid_stash_free(&undoStorage, qos_free_undoInfo);
+        netsnmp_oid_stash_free(&commitStorage, netsnmp_oid_stash_no_free);
+    }
+
+
+    return SNMP_ERR_NOERROR;
+}
--- snmp/agent/mibgroup/qos_checkfns.c
+++ snmp/agent/mibgroup/qos_checkfns.c
@@ -0,0 +1,114 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.check_values.conf,v 1.6 2003/06/13 18:18:04 hardaker Exp $
+ */
+
+/********************************************************************
+ *                       NOTE   NOTE   NOTE
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the qos_checkfns_local.[ch] files insead so that you
+ *   can regenerate this one as mib2c improvements are made.
+ ********************************************************************/
+
+/*
+ * standard headers 
+ */
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "qos_checkfns.h"
+#include "qos_checkfns_local.h"
+#include "qos_enums.h"
+#include<time.h>
+
+void initialize_qos_table(qos_table *table) {
+// first object in table is permanent a due to this fact declared as static
+// its initialization
+    memset(table,0,sizeof(qos_table));
+    table->next=NULL;
+    table->data.dev_name[0]=0x0;
+    table->data.type[0]=0x0;
+    table->data.text_parent[0]=0x0;
+    table->data.text_handle[0]=0x0;
+    table->data.text_leaf[0]=0x0;
+    table->data.qosBytes=0;
+    table->data.info[0]=0x0;
+}
+
+void update_qos_table_data(qos_table *table) {
+// deletes old data from qos_table and calls functions to fetch new data
+// it happens only if time between calls is greater than UPDATE_INTERVAL 
+// (located in header file)
+// memory allocations and fetch is a bit complicated and it could take 
+// relatively long time to proceed (especially in cases with lot of classes/qdisc)
+    static long old_time;
+    long actual_time;
+    long diff;
+    actual_time = (long)time(NULL);
+    diff = actual_time-old_time;
+    if(diff<UPDATE_INTERVAL) {
+	return;
+    }
+    old_time=actual_time;
+    
+    delete_old_qos_table_data(table);    
+    add_new_entries_to_table();
+    // fetches all data from kernel and stores them in linked list of structures
+}
+
+void delete_old_qos_table_data(qos_table *table) {
+    // deletes all table data except those in first pointer (they are not mallocced - static)
+    qos_table *iterator;
+    qos_table *temp=NULL;
+    iterator=table;
+
+    if(iterator->next==NULL) return;
+    iterator=iterator->next;    
+    
+    while(iterator!=NULL) {
+	temp=iterator->next;
+	free(iterator);
+	iterator=temp;
+    }
+    table->next=NULL; //delete first point in line
+    
+}
+
+qos_table* create_new_qos_table_entry() {
+// allocates a new entry into table, don't care about qos_table identifier, it should be named
+// qos_table_entry, but it's around all code :-), qos_table doesn't mean whole table, but only 
+// one entry in linked list... sorry for that
+
+    qos_table *new_entry;
+
+    new_entry = (qos_table*)malloc(sizeof(qos_table));
+
+    if(new_entry==NULL) {
+	snmp_log(LOG_WARNING,"qos-ext: create_new_qos_table_entry: cannot allocate memory for new entry\n");
+	return(NULL);
+    }
+
+    memset(new_entry,0,sizeof(qos_table));
+
+    new_entry->next=NULL;
+    new_entry->data.dev_name[0]=0x0;
+    new_entry->data.type[0]=0x0;
+    new_entry->data.text_parent[0]=0x0;
+    new_entry->data.text_handle[0]=0x0;    
+    new_entry->data.text_leaf[0]=0x0;
+    new_entry->data.qosBytes=0;
+    new_entry->data.info[0]=0x0;
+    //string initialization
+    return(new_entry);
+}
+
+qos_table* get_last_entry_in_list(qos_table *table) {
+// finds last entry in linked list of qos_table entities
+    qos_table *iterator;
+    iterator = table;
+    while(iterator->next!=NULL) {
+	iterator=iterator->next;
+    }
+    return(iterator);
+}
+
+
--- snmp/agent/mibgroup/qos_checkfns.h
+++ snmp/agent/mibgroup/qos_checkfns.h
@@ -0,0 +1,78 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate.conf,v 5.6 2003/02/20 00:52:07 hardaker Exp $
+ */
+
+/***********************************************************************
+ *   This file is auto-generated and SHOULD NOT BE EDITED by hand.
+ *   Modify the qos_checkfns_local.[ch] files instead.
+ *   (so that you can regenerate this one as mib2c improvements are made)
+ ***********************************************************************/
+#ifndef QOS_CHECKFNS_H
+#define QOS_CHECKFNS_H
+
+
+#define UPDATE_INTERVAL 10
+/** make sure we load the functions that you can modify */
+config_require(qos_checkfns_local)
+
+    /*
+     * these functions are designed to check incoming values for 
+     * columns in the qosObjectTable table for legality with respect to 
+     * datatype and value.
+     */
+typedef struct qos_data qos_data;
+struct qos_data {
+    long	device_type;
+    long	device_index;
+    u_long	majorhandle;
+    u_long	minorhandle;
+    u_long	parent;
+    char	text_parent[20];
+    char	text_handle[20];
+    char	text_leaf[20];
+    char	dev_name[10];
+    char	type[10];
+    unsigned long long	qosBytes;
+    u_long	qosPackets;
+    u_long	qosDropped;
+    u_long	qosOverlimit;
+    u_long	qosBps;
+    u_long	qosPps;
+    u_long	qosQlen;
+    u_long	qosBacklog;
+    
+    u_long	redEarly;
+    u_long	redPdrop;
+    u_long	redOther;
+    u_long	redMarked;
+    
+    u_long	htbLends;
+    u_long	htbBorrows;
+    u_long	htbGiants;
+    u_long	htbTokens;
+    u_long	htbCTokens;
+    u_long	htbRate;
+    u_long	htbCeil;
+    u_long	htbPrio;
+    
+    u_long	cbqBorrows;
+    u_long	cbqOveractions;
+    long	cbqAvgidle;
+    long	cbqUndertime;
+    char	info[256];
+};
+
+typedef struct qos_table qos_table;
+struct qos_table {
+    qos_data	data;
+    qos_table	*next;
+};
+
+void initialize_qos_table(qos_table *table);
+void update_qos_table_data(qos_table *table);     
+
+void delete_old_qos_table_data(qos_table *table);
+qos_table* create_new_qos_table_entry();
+qos_table* get_last_entry_in_list(qos_table *table);
+#endif                          /* QOS_CHECKFNS_H */
--- snmp/agent/mibgroup/qos_checkfns_local.c
+++ snmp/agent/mibgroup/qos_checkfns_local.c
@@ -0,0 +1,697 @@
+/*
+    Function from this file are mainly copied from iproute2 project, distributed under GPL
+    qos_table specific functions are written by Michal Charvat, jaazz@post.cz
+    generally I wanted to link libnetlink.a (created by iproute2 package) into snmp daemon,
+    but it didn't work well.... I'm not so familiar with library linking.
+    what happened when I've tried: compilation and linking ok, but during run relocation error
+    occured and program was terminated by kernel. (due to missing functions - but compiler
+    didn't say a word about that missing functions ... why????)
+*/
+
+/*
+ * standard headers
+ */
+
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include "qos_checkfns.h"
+#include "qos_enums.h"
+#include "qos_checkfns_local.h"
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <asm/types.h>
+#include <asm/param.h>
+#include <sys/types.h>
+#include <resolv.h>
+#include <linux/socket.h>
+#include <linux/netlink.h>
+#include <linux/rtnetlink.h>
+#include "libnetlink.h"
+#include "../../../../linux/linux-2.6/include/linux/pkt_sched.h"
+#include <linux/pkt_cls.h>
+#include <syslog.h>
+#include <fcntl.h>
+#include <net/if_arp.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <errno.h>
+#include <time.h>
+#include <sys/uio.h>
+
+#include "ll_map.h"
+#include "libnetlink.h"
+
+static int rth_initialized=0;
+
+/* call dump of netlink qos layer in kernel and adds received object into qos_table 
+ * (specifically their statistics values & some parts of configuration (htb))
+ */
+void add_new_entries_to_table() {
+	struct tcmsg t;
+	struct rtnl_handle rth;
+	extern int rth_initialized;
+	char d[16];
+
+	memset(&rth,0,sizeof(struct rtnl_handle));
+	memset(&t, 0, sizeof(t));
+	t.tcm_family = AF_UNSPEC;
+	memset(&d, 0, sizeof(d));
+	
+	if (rtnl_open(&rth, 0) < 0) {
+		snmp_log(LOG_NOTICE, "Cannot open rtnetlink");
+		return;
+	}
+
+//	if(rth_initialized==0) {
+		ll_init_map(&rth);
+//		rth_initialized=1;
+//	}
+
+	if (rtnl_dump_request(&rth, RTM_GETQDISC, &t, sizeof(t)) < 0) {
+		snmp_log(LOG_WARNING, "qos-ext: add_new_entries to table: cannot send dump request");
+		return;
+	}
+
+
+	if (rtnl_dump_filter(&rth, insert_entry, NULL, NULL, NULL) < 0) {
+		snmp_log(LOG_WARNING, "qos-ext: add_new entries to table: qdisc dump terminated");
+		return;
+	}
+
+	rtnl_close(&rth);
+
+	add_classes();
+}
+
+/* call dump of classes, these needs to be dumped on per device basis */
+void add_classes() {
+	struct tcmsg t;
+	struct rtnl_handle rth;
+	char d[16];
+
+	char line[1024];
+	FILE *dev;
+	char *p;
+
+	memset(&rth, 0, sizeof(struct rtnl_handle));
+	memset(&t, 0, sizeof(t));
+
+	t.tcm_family = AF_UNSPEC;
+	memset(&d, 0, sizeof(d));
+	
+	if (rtnl_open(&rth, 0) < 0) {
+		snmp_log(LOG_NOTICE, "Cannot open rtnetlink");
+		return;
+	}
+
+
+	dev=fopen("/proc/net/dev","r");
+	if (dev == NULL) {
+		snmp_log(LOG_WARNING, "qos-ext: cannot open /proc/net/dev for reading, class stats won't be avaiable");
+		return;
+	}
+	while(fscanf(dev,"%s",line)!=EOF) {
+	/* find existing devices */
+		p=index(line,':'); if(p==NULL) continue;
+		*p='\0';
+		/* line contains device_name.... need to translate name into index */
+		t.tcm_ifindex = ll_name_to_index(line);
+	
+		if (rtnl_dump_request(&rth, RTM_GETTCLASS, &t, sizeof(t)) < 0) {
+			/* dump all classes on device with index t.tcm_ifindex */
+			snmp_log(LOG_WARNING,"qos-ext: add_new_entries to table: cannot send dump request");
+			fclose(dev);
+			return;
+		}
+		if (rtnl_dump_filter(&rth, insert_entry, NULL, NULL, NULL) < 0) {
+			/* append all classes entris into the internal table */
+			snmp_log(LOG_WARNING, "qos-ext: add_new entries to table: class dump terminated");
+			fclose(dev);
+			return;
+		}
+	}
+	fclose(dev);
+	rtnl_close(&rth);
+}
+
+/* this function extracts data from netlink message and creates object in qos_table */
+int insert_entry(struct sockaddr_nl *who, struct nlmsghdr *n, void *a)
+{
+	extern struct qos_table table;
+	qos_table *qos_table_entry;
+	qos_table *temp;
+	char handle[20] = "unset";
+	char parent[20] = "unset";
+	char leaf[20] = "leaf";
+	char optional[20] = "";
+
+	char info[256] = "";
+	int offset = 0;
+	/* string info */
+
+	unsigned int major,minor;
+	struct tcmsg *t = NLMSG_DATA(n);
+	int len = n->nlmsg_len;
+	struct rtattr *tb[TCA_MAX+1];
+	char abuf[256];
+
+	len -= NLMSG_LENGTH(sizeof(*t));
+	if (len < 0) {
+		snmp_log(LOG_NOTICE, "insert_qdisc_entry: Wrong len of tc message:%i", len);
+		return(-1);
+	}
+
+	memset(tb, 0, sizeof(tb));
+	parse_rtattr(tb, TCA_MAX, TCA_RTA(t), len);
+
+	if (tb[TCA_KIND] == NULL) {
+		snmp_log(LOG_NOTICE, "insert_qdisc_entry: unknown kind\n");
+		return(-1);
+	}
+
+	qos_table_entry = create_new_qos_table_entry();
+	
+	if (qos_table_entry == NULL) {
+		return;
+	}
+
+	strcpy(qos_table_entry->data.type, (char*)RTA_DATA(tb[TCA_KIND]));
+
+	qos_table_entry->data.majorhandle = (t->tcm_handle >> 16) & 0x0000ffff;		/* major part of handle */
+	qos_table_entry->data.minorhandle = t->tcm_handle & 0x0000ffff;			/* minor part of handle */
+	qos_table_entry->data.parent = t->tcm_parent;					/* parent */
+
+	strcpy(qos_table_entry->data.dev_name, ll_index_to_name(t->tcm_ifindex));
+	/* sets string qosDeviceName in mib */
+
+	set_device_index_and_type(&(qos_table_entry->data.device_index), &(qos_table_entry->data.device_type), qos_table_entry->data.dev_name);
+	/* function takes string device name as input and separate it to device_index and device_type */
+
+	switch(t->tcm_parent) {
+		case TC_H_ROOT:
+			strcpy(optional, " (root)");
+			break;
+		case TC_H_INGRESS:
+			strcpy(optional, " (ingress)");
+			break;
+		default:
+			break;
+	}
+	minor = t->tcm_parent & 0x0000FFFF;
+	major = (t->tcm_parent >> 16) & 0x0000FFFF;
+	sprintf(parent, "%x:%x%s", major, minor, optional);
+	strcpy(qos_table_entry->data.text_parent, parent);
+	/* sets string parent info in mib */
+
+	sprintf(info + strlen(info), "%s%s", "parent:", parent);
+	/* one line values reporting */
+
+	strcpy(optional, "");
+	/* clear temporary optional variable */
+
+	switch(t->tcm_handle) {
+		case TC_H_ROOT:
+			strcpy(optional," (root)");
+			break;
+		case TC_H_INGRESS:
+			strcpy(optional," (ingress)");
+			break;
+		default:
+			break;
+	}
+	minor = t->tcm_handle & 0x0000FFFF;
+	major = (t->tcm_handle >> 16) & 0x0000FFFF;
+	sprintf(handle, "%x:%x%s", major, minor, optional);
+	strcpy(qos_table_entry->data.text_handle, handle);
+	/* sets string handle info in mib */
+
+	sprintf(info + strlen(info), "%s%s", " handle:", handle);
+	/* one line values reporting */
+
+	if((t->tcm_info >> 16) != 0) {
+		minor = 0;
+		major = t->tcm_info >> 16;
+		strcpy(optional, " (leaf)");
+		sprintf(leaf, "%x:%x%s", major, minor, optional);
+		strcpy(qos_table_entry->data.text_leaf, leaf);
+		/* sets leaf info if any */
+	
+		sprintf(info + strlen(info), "%s%s"," leaf:", leaf);
+		/* one line values reporting */
+	}
+
+	if (tb[TCA_STATS]) {
+		if (RTA_PAYLOAD(tb[TCA_STATS]) < sizeof(struct tc_stats))
+			snmp_log(LOG_WARNING, "qos-ext: insert into table: statistics truncated\n");
+		else {
+			struct tc_stats st;
+			unsigned long long temp;
+			unsigned long long ibytes; /* for string info reporting purpose */
+			memcpy(&st, RTA_DATA(tb[TCA_STATS]), sizeof(st));
+			ibytes=st.bytes;
+			temp = st.bytes & 0xFFFFFFFF00000000;
+			temp = temp >> 32;
+			temp = (st.bytes << 32) | temp;
+			/* this funny action translates from host (x86) representation to network data representation (ASN1)
+			 * I know it can be done in one step - but this way it's easy to understand
+			 */
+			qos_table_entry->data.qosBytes = temp;
+			qos_table_entry->data.qosPackets = st.packets;
+			qos_table_entry->data.qosDropped = st.drops;
+			qos_table_entry->data.qosOverlimit = st.overlimits;
+			qos_table_entry->data.qosBps = st.bps;
+			qos_table_entry->data.qosPps = st.pps;
+			qos_table_entry->data.qosQlen = st.qlen;
+			qos_table_entry->data.qosBacklog = st.backlog;
+			/* all standard statistic values
+			 * pps/bps value is currently (April 2004) reported only from htb classes
+			 */
+			sprintf(info+strlen(info), "%s%lli%s%i%s%i%s%i%s%i%s%i%s%i%s%i", " bytes:", ibytes, " packets:", st.packets, " drops:", st.drops,
+			                           " overlimit:", st.overlimits, " bps:", st.bps, " pps:", st.pps, " qlen:", st.qlen, " backlog:", st.backlog);
+			/* one line values reporting (column 35) */
+		}
+	}
+	if (tb[TCA_XSTATS]) {
+		if (RTA_PAYLOAD(tb[TCA_XSTATS]) < sizeof(struct xstats)) {
+		}
+		else {
+			struct xstats st;
+			memcpy(&st, RTA_DATA(tb[TCA_XSTATS]), sizeof(st));
+			/* check out, what type of qdisc/class it is and set appropriate values */
+			if ((strcmp(qos_table_entry->data.type, "red") == 0) || (strcmp(qos_table_entry->data.type, "gred") == 0)) {
+				qos_table_entry->data.redEarly = st.x1;
+				qos_table_entry->data.redPdrop = st.x2;
+				qos_table_entry->data.redOther = st.x3;
+				qos_table_entry->data.redMarked = st.x4;
+
+				sprintf(info + strlen(info), "%s%i%s%i%s%i%s%i", " redearly:", st.x1, " redpdrop:", st.x2, " redother:", st.x3, " redmarked", st.x4);
+				/* one line values reporting (column 35) */
+			}
+			if (strcmp(qos_table_entry->data.type, "cbq") == 0) {
+				qos_table_entry->data.cbqBorrows = st.x1;
+				qos_table_entry->data.cbqOveractions = st.x2;
+				qos_table_entry->data.cbqAvgidle = st.x3;
+				qos_table_entry->data.cbqUndertime = st.x4;
+
+				sprintf(info + strlen(info), "%s%i%s%i%s%i%s%i", " cbqborrows:", st.x1, " cbqoveractions:", st.x2, " cbqavgidle:", st.x3, " cbqundertime", st.x4);
+				/* one line values reporting (column 35) */
+			}
+			if (strcmp(qos_table_entry->data.type, "htb") == 0) {
+				struct tc_htb_xstats *st_htb;
+				struct rtattr *tb2[TCA_HTB_RTAB+1];
+				memset(tb2, 0, sizeof(tb2));
+				parse_rtattr(tb2, TCA_HTB_RTAB, RTA_DATA(tb[TCA_OPTIONS]), RTA_PAYLOAD(tb[TCA_OPTIONS]));
+				/* extracts htb specific parameters */
+
+				st_htb = (struct tc_htb_xstats *)&st;
+				qos_table_entry->data.htbLends = st_htb->lends;
+				qos_table_entry->data.htbBorrows = st_htb->borrows;
+				qos_table_entry->data.htbGiants = st_htb->giants;
+				qos_table_entry->data.htbTokens = st_htb->tokens;
+
+				sprintf(info + strlen(info), "%s%i%s%i%s%i%s%i", " htblends:", st_htb->lends, " htbborrows:", st_htb->borrows, " htbgiants:", st_htb->giants, " htbtokens:", st_htb->tokens);
+				/* one line values reporting (column 35) */
+
+				if (RTA_PAYLOAD(tb[TCA_XSTATS]) >= sizeof(*st_htb)) {
+					qos_table_entry->data.htbCTokens = st_htb->ctokens;
+
+					sprintf(info + strlen(info), "%s%i", " htbctokens:", st_htb->ctokens);
+					/* one line values reporting (column 35) */
+				}
+				else {
+					snmp_log(LOG_WARNING, "Ctokens value not avaiable in netlink message\n");
+				}
+
+				if (tb2[TCA_HTB_PARMS]) {
+					struct tc_htb_opt *hopt;
+					hopt = RTA_DATA(tb2[TCA_HTB_PARMS]);
+					if (RTA_PAYLOAD(tb2[TCA_HTB_PARMS]) < sizeof(*hopt)) {
+						snmp_log(LOG_WARNING, "qos-ext: htb parametrs are not all\n");
+					}
+					else {
+						qos_table_entry->data.htbCeil = hopt->ceil.rate;
+						qos_table_entry->data.htbRate = hopt->rate.rate;
+						qos_table_entry->data.htbPrio = hopt->prio;
+						/* htb rate, ceil and prio values */
+					}
+				}
+			}
+		}
+	}
+
+	strcpy(qos_table_entry->data.info,info);
+	/* one line values reporting */
+
+	temp = get_last_entry_in_list(&table); 
+	temp->next = qos_table_entry;
+	/* add stat structute into linked list */
+}
+
+/* takes device name as argument and return 2 values - ex: ppp123 -> ppp & 123 (device type & device index) */
+void set_device_index_and_type(long *device_index, long *device_type, char *string_device) {
+	int i = 0;
+	if (string_device == NULL) {
+		/* just to be sure */
+		snmp_log(LOG_WARNING, "qos-ext: set_device_index_and_type: input string is NULL\n");
+		*device_index = 0;
+		*device_type = 0;
+		return;
+	}
+	for (i = 0; i < DEVICE_COUNT; i++) {
+		/* finding appropriate device_name */
+		if (strncmp(devices[i], string_device, strlen(devices[i])) == 0) {
+			*device_type = i + 1; /* +1 because 0.0.0.0 is present everytime - it would otherwise conflit with ppp0 */
+			*device_index = atol(string_device + strlen(devices[i]));
+			return;
+		}
+	}
+	snmp_log(LOG_WARNING, "qos-ext: device type not found\n");
+	*device_index = 0;
+	*device_type = 0;
+}
+
+/* futher functions are copied from iproute2 project, because of problems with
+ * linking libnetlink.a library into snmp daemon
+ * I've changed only perror calls into snmpd_log calls
+ */
+void rtnl_close(struct rtnl_handle *rth)
+{
+	close(rth->fd);
+}
+
+int rtnl_open(struct rtnl_handle *rth, unsigned subscriptions)
+{
+	int addr_len;
+
+	memset(rth, 0, sizeof(rth));
+
+	rth->fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_ROUTE);
+	if (rth->fd < 0) {
+		snmp_log(LOG_WARNING, "cannot open netlink socket\n");
+		return -1;
+	}
+
+	memset(&rth->local, 0, sizeof(rth->local));
+	rth->local.nl_family = AF_NETLINK;
+	rth->local.nl_groups = subscriptions;
+
+	if (bind(rth->fd, (struct sockaddr*)&rth->local, sizeof(rth->local)) < 0) {
+//		perror("Cannot bind netlink socket");
+		snmp_log(LOG_NOTICE, "cannot bind netlink socket\n");
+		return -1;
+	}
+	addr_len = sizeof(rth->local);
+	if (getsockname(rth->fd, (struct sockaddr*)&rth->local, &addr_len) < 0) {
+//		perror("Cannot getsockname");
+		snmp_log(LOG_NOTICE, "canot getsockname\n");
+		return -1;
+	}
+	if (addr_len != sizeof(rth->local)) {
+//		fprintf(stderr, "Wrong address length %d\n", addr_len);
+		snmp_log(LOG_NOTICE, "wrong address length\n");
+		return -1;
+	}
+	if (rth->local.nl_family != AF_NETLINK) {
+//		fprintf(stderr, "Wrong address family %d\n", rth->local.nl_family);
+		snmp_log(LOG_NOTICE, "wrong address family\n");
+		return -1;
+	}
+	rth->seq = time(NULL);
+	return 0;
+}
+
+int rtnl_dump_request(struct rtnl_handle *rth, int type, void *req, int len)
+{
+	struct nlmsghdr nlh;
+	struct sockaddr_nl nladdr;
+	struct iovec iov[2] = { { &nlh, sizeof(nlh) }, { req, len } };
+	struct msghdr msg = {
+		(void*)&nladdr, sizeof(nladdr),
+		iov,	2,
+		NULL,	0,
+		0
+	};
+
+	memset(&nladdr, 0, sizeof(nladdr));
+	nladdr.nl_family = AF_NETLINK;
+
+	nlh.nlmsg_len = NLMSG_LENGTH(len);
+	nlh.nlmsg_type = type;
+	nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
+	nlh.nlmsg_pid = 0;
+	nlh.nlmsg_seq = rth->dump = ++rth->seq;
+
+	return sendmsg(rth->fd, &msg, 0);
+}
+
+int rtnl_wilddump_request(struct rtnl_handle *rth, int family, int type)
+{
+	struct {
+		struct nlmsghdr nlh;
+		struct rtgenmsg g;
+	} req;
+	struct sockaddr_nl nladdr;
+
+	memset(&nladdr, 0, sizeof(nladdr));
+	nladdr.nl_family = AF_NETLINK;
+
+	req.nlh.nlmsg_len = sizeof(req);
+	req.nlh.nlmsg_type = type;
+	req.nlh.nlmsg_flags = NLM_F_ROOT|NLM_F_MATCH|NLM_F_REQUEST;
+	req.nlh.nlmsg_pid = 0;
+	req.nlh.nlmsg_seq = rth->dump = ++rth->seq;
+	req.g.rtgen_family = family;
+
+	return sendto(rth->fd, (void*)&req, sizeof(req), 0, (struct sockaddr*)&nladdr, sizeof(nladdr));
+}
+
+int rtnl_dump_filter(struct rtnl_handle *rth,
+		     int (*filter)(struct sockaddr_nl *, struct nlmsghdr *n, void *),
+		     void *arg1,
+		     int (*junk)(struct sockaddr_nl *, struct nlmsghdr *n, void *),
+		     void *arg2)
+{
+	char	buf[8192];
+	struct sockaddr_nl nladdr;
+	struct iovec iov = { buf, sizeof(buf) };
+
+	while (1) {
+		int status;
+		struct nlmsghdr *h;
+
+		struct msghdr msg = {
+			(void*)&nladdr, sizeof(nladdr),
+			&iov,	1,
+			NULL,	0,
+			0
+		};
+
+		status = recvmsg(rth->fd, &msg, 0);
+
+		if (status < 0) {
+			if (errno == EINTR)
+				continue;
+//			perror("OVERRUN");
+			snmp_log(LOG_WARNING, "overrun\n");
+			continue;
+		}
+		if (status == 0) {
+//			fprintf(stderr, "EOF on netlink\n");
+			snmp_log(LOG_NOTICE, "EOF on netlink\n");
+			return -1;
+		}
+		if (msg.msg_namelen != sizeof(nladdr)) {
+//			fprintf(stderr, "sender address length == %d\n", msg.msg_namelen);
+			snmp_log(LOG_NOTICE, "sender address length\n");
+			return(1);
+		}
+
+		h = (struct nlmsghdr*)buf;
+		while (NLMSG_OK(h, status)) {
+			int err;
+
+			if (h->nlmsg_pid != rth->local.nl_pid ||
+			    h->nlmsg_seq != rth->dump) {
+				if (junk) {
+					err = junk(&nladdr, h, arg2);
+					if (err < 0)
+						return err;
+				}
+				goto skip_it;
+			}
+
+			if (h->nlmsg_type == NLMSG_DONE)
+				return 0;
+			if (h->nlmsg_type == NLMSG_ERROR) {
+				struct nlmsgerr *err = (struct nlmsgerr*)NLMSG_DATA(h);
+				if (h->nlmsg_len < NLMSG_LENGTH(sizeof(struct nlmsgerr))) {
+//					fprintf(stderr, "ERROR truncated\n");
+					snmp_log(LOG_NOTICE, "error struncated\n");
+				} else {
+					errno = -err->error;
+//					perror("RTNETLINK answers");
+					snmp_log(LOG_NOTICE, "rtnetlink failed\n");
+				}
+				return -1;
+			}
+			err = filter(&nladdr, h, arg1);
+			if (err < 0)
+				return err;
+
+skip_it:
+			h = NLMSG_NEXT(h, status);
+		}
+		if (msg.msg_flags & MSG_TRUNC) {
+//			fprintf(stderr, "Message truncated\n");
+			snmp_log(LOG_NOTICE, "message truncated\n");
+			continue;
+		}
+		if (status) {
+//			fprintf(stderr, "!!!Remnant of size %d\n", status);
+			snmp_log(LOG_NOTICE, "remnant of size\n");
+			return(1);
+		}
+	}
+}
+
+int parse_rtattr(struct rtattr *tb[], int max, struct rtattr *rta, int len)
+{
+	while (RTA_OK(rta, len)) {
+		if (rta->rta_type <= max)
+			tb[rta->rta_type] = rta;
+		rta = RTA_NEXT(rta,len);
+	}
+	if (len)
+//		fprintf(stderr, "!!!Deficit %d, rta_len=%d\n", len, rta->rta_len);
+		snmp_log(LOG_WARNING, "deficit of rta_len\n");
+	return 0;
+}
+
+
+struct idxmap
+{
+	struct idxmap * next;
+	int		index;
+	int		type;
+	int		alen;
+	unsigned	flags;
+	unsigned char	addr[8];
+	char		name[16];
+};
+
+static struct idxmap *idxmap[16];
+
+int ll_remember_index(struct sockaddr_nl *who, struct nlmsghdr *n, void *arg)
+{
+	int h;
+	struct ifinfomsg *ifi = NLMSG_DATA(n);
+	struct idxmap *im, **imp;
+	struct rtattr *tb[IFLA_MAX+1];
+
+	if (n->nlmsg_type != RTM_NEWLINK)
+		return 0;
+
+	if (n->nlmsg_len < NLMSG_LENGTH(sizeof(ifi)))
+		return -1;
+
+
+	memset(tb, 0, sizeof(tb));
+	parse_rtattr(tb, IFLA_MAX, IFLA_RTA(ifi), IFLA_PAYLOAD(n));
+	if (tb[IFLA_IFNAME] == NULL)
+		return 0;
+
+	h = ifi->ifi_index&0xF;
+
+	for (imp=&idxmap[h]; (im=*imp)!=NULL; imp = &im->next)
+		if (im->index == ifi->ifi_index)
+			break;
+
+	if (im == NULL) {
+		im = malloc(sizeof(*im));
+		if (im == NULL)
+			return 0;
+		im->next = *imp;
+		im->index = ifi->ifi_index;
+		*imp = im;
+	}
+
+	im->type = ifi->ifi_type;
+	im->flags = ifi->ifi_flags;
+	if (tb[IFLA_ADDRESS]) {
+		int alen;
+		im->alen = alen = RTA_PAYLOAD(tb[IFLA_ADDRESS]);
+		if (alen > sizeof(im->addr))
+			alen = sizeof(im->addr);
+		memcpy(im->addr, RTA_DATA(tb[IFLA_ADDRESS]), alen);
+	} else {
+		im->alen = 0;
+		memset(im->addr, 0, sizeof(im->addr));
+	}
+	strcpy(im->name, RTA_DATA(tb[IFLA_IFNAME]));
+	return 0;
+}
+
+const char *ll_idx_n2a(int idx, char *buf)
+{
+	struct idxmap *im;
+
+	if (idx == 0)
+		return "*";
+	for (im = idxmap[idx&0xF]; im; im = im->next)
+		if (im->index == idx)
+			return im->name;
+	snprintf(buf, 16, "if%d", idx);
+	return buf;
+}
+
+
+const char *ll_index_to_name(int idx)
+{
+	static char nbuf[16];
+
+	return ll_idx_n2a(idx, nbuf);
+}
+
+int ll_name_to_index(char *name)
+{
+	static char ncache[16];
+	static int icache;
+	struct idxmap *im;
+	int i;
+
+	if (name == NULL)
+		return 0;
+	if (icache && strcmp(name, ncache) == 0)
+		return icache;
+	for (i = 0; i < 16; i++) {
+		for (im = idxmap[i]; im; im = im->next) {
+			if (strcmp(im->name, name) == 0) {
+				icache = im->index;
+				strcpy(ncache, name);
+				return im->index;
+			}
+		}
+	}
+	return 0;
+}
+
+int ll_init_map(struct rtnl_handle *rth)
+{
+	if (rtnl_wilddump_request(rth, AF_UNSPEC, RTM_GETLINK) < 0) {
+//		perror("Cannot send dump request");
+		snmp_log(LOG_WARNING, "cannot send dump request\n");
+		return(-1);
+//		exit(1);
+	}
+
+	if (rtnl_dump_filter(rth, ll_remember_index, &idxmap, NULL, NULL) < 0) {
+//		fprintf(stderr, "Dump terminated\n");
+		snmp_log(LOG_WARNING, "dump terminated\n");
+//		exit(1);
+		return(-1);
+	}
+	return 0;
+}
--- snmp/agent/mibgroup/qos_checkfns_local.h
+++ snmp/agent/mibgroup/qos_checkfns_local.h
@@ -0,0 +1,38 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : : mib2c.check_values_local.conf,v 5.1 2003/05/30 23:53:15 hardaker Exp $
+ * 
+ */
+#ifndef QOS_CHECKFNS_LOCAL_H
+#define QOS_CHECKFNS_LOCAL_H
+
+#include<asm/types.h>
+#include<linux/netlink.h>
+#include<linux/rtnetlink.h>
+/*
+ * these functions are designed to check incoming values for 
+ * columns in the qosObjectTable table for legality with respect to 
+ * datatype and value according to local conventions.  You should modify
+ * them as appropriate.  They will be called from parent check_value
+ * functions that are auto-generated using mib2c and the parent functions
+ * should NOT be modified.
+ */
+
+#define DEVICE_COUNT 9
+static char* devices[] = { "ppp" , "eth" , "tap" , "tun" , "br", "wlan" , "tunl", "lo", "teql" };
+
+typedef struct xstats xstats;
+struct xstats {
+    __u32	x1;
+    __u32	x2;
+    __u32	x3;
+    __u32	x4;
+    __u32	x5;
+};
+
+
+void add_new_entries_to_table();
+void add_classes();
+void set_device_index_and_type(long *device_index,long *device_name,char *string_device);
+int insert_entry(struct sockaddr_nl *who, struct nlmsghdr *n, void *a);
+#endif                          /* QOS_CHECKFNS_H */
--- snmp/agent/mibgroup/qos_columns.h
+++ snmp/agent/mibgroup/qos_columns.h
@@ -0,0 +1,47 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_defines.conf,v 5.1 2002/05/08 05:42:47 hardaker Exp $
+ */
+#ifndef QOS_COLUMNS_H
+#define QOS_COLUMNS_H
+
+/*
+ * column number definitions for table qosObjectTable 
+ */
+#define COLUMN_QOSDEVICETYPE		1
+#define COLUMN_QOSDEVICEINDEX		2
+#define COLUMN_QOSMAJORHANDLE		3
+#define COLUMN_QOSMINORHANDLE		4
+#define COLUMN_QOSTEXTHANDLE		5
+#define COLUMN_QOSTEXTLEAF		6
+#define COLUMN_QOSPARENT		7
+#define COLUMN_QOSTEXTPARENT		8
+#define COLUMN_QOSDEVICENAME		9
+#define COLUMN_QOSTYPE			10
+#define COLUMN_QOSBYTES			11
+#define COLUMN_QOSPACKETS		12
+#define COLUMN_QOSDROPPED		13
+#define COLUMN_QOSOVERLIMIT		14
+#define COLUMN_QOSBPS			15
+#define COLUMN_QOSPPS			16
+#define COLUMN_QOSQLEN			17
+#define COLUMN_QOSBACKLOG		18
+#define COLUMN_QOSREDEARLY		19
+#define COLUMN_QOSREDPDROP		20
+#define COLUMN_QOSREDOTHER		21
+#define COLUMN_QOSREDMARKED		22
+#define COLUMN_QOSHTBLENDS		23
+#define COLUMN_QOSHTBBORROWS		24
+#define COLUMN_QOSHTBGIANTS		25
+#define COLUMN_QOSHTBTOKENS		26
+#define COLUMN_QOSHTBCTOKENS		27
+#define COLUMN_QOSHTBRATE		28
+#define COLUMN_QOSHTBCEIL		29
+#define COLUMN_QOSHTBPRIO		30
+#define COLUMN_QOSCBQBORROWS		31
+#define COLUMN_QOSCBQOVERACTIONS	32
+#define COLUMN_QOSCBQAVGIDLE		33
+#define COLUMN_QOSCBQUNDERTIME		34
+#define COLUMN_QOSINFO			35
+
+#endif                          /* QOS_COLUMNS_H */
--- snmp/agent/mibgroup/qos_enums.h
+++ snmp/agent/mibgroup/qos_enums.h
@@ -0,0 +1,8 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *  : mib2c.column_enums.conf,v 5.2 2003/02/22 04:09:25 hardaker Exp $
+ */
+#ifndef QOS_ENUMS_H
+#define QOS_ENUMS_H
+
+#endif                          /* QOS_ENUMS_H */
--- snmp/agent/mibgroup/qos.h
+++ snmp/agent/mibgroup/qos.h
@@ -0,0 +1,30 @@
+/*
+ * Note: this file originally auto-generated by mib2c using
+ *        : mib2c.iterate_access.conf,v 1.6 2003/09/29 22:30:36 hardaker Exp $
+ */
+#ifndef QOS_H
+#define QOS_H
+
+/** other required module components */
+config_require(qos_access)
+    config_require(qos_checkfns)
+
+    /*
+     * function declarations 
+     */
+     void            init_qos(void);
+     void            initialize_table_qosObjectTable(void);
+     Netsnmp_Node_Handler qosObjectTable_handler;
+
+
+/*
+ * column number definitions for table qosObjectTable 
+ */
+#include "qos_columns.h"
+
+/*
+ * enum definions 
+ */
+#include "qos_enums.h"
+
+#endif /** QOS_H */
--- snmp/agent/mibgroup/versiontag
+++ snmp/agent/mibgroup/versiontag
@@ -0,0 +1,56 @@
+#!/bin/sh
+
+DOIT=echo
+
+if [ $2 = "tag" -o $2 = "tar" ];
+then
+    VERSIONTAG="$1"
+    VERSION=`echo $1 | sed 's/Ext-*//g;s/-/./g;'`
+else
+    case "$1" in
+    Ext*) ;;
+    *)  echo "VERSION must begin with Ext"
+        exit 1 ;;
+    esac
+
+    VERSION="$1"
+    VERSIONTAG=`echo Ext-$1 | sed 's/\./-/g;'`
+fi
+
+if [ $2 = "tag" ]; then
+    echo "ERROR: tagging is now handled by the 'makerelease' script."
+    exit 1
+fi
+
+if [ $2 = "tar" ]; then
+    # gnu tar (as of 1.15.1) is unable to create portable tar archives, 
+    # especially if long file names (>100 char) are present.
+    # star is a better replacement.
+    if [ -x /usr/bin/star ]; then
+        TAR="/usr/bin/star -Hustar -z -c -f"
+    elif [ -x /bin/tar ]; then
+        echo "WARNING: about to create non-portable tar archives using GNU tar."
+        echo "You'd better install /usr/bin/star and rerun."
+        TAR="/bin/tar czf"
+    else
+        echo "neither /usr/bin/star nor /bin/tar found."
+        exit 1
+    fi
+    if [ -d CVS ]; then
+        $DOIT cvs export -d net-snmp-$VERSION -r $VERSIONTAG net-snmp
+    else
+        if [ "x$CVSUSER" = "x" ] ; then
+          CVSUSER=hardaker
+        fi
+        $DOIT cvs -d $CVSUSER@net-snmp.cvs.sourceforge.net:/cvsroot/net-snmp export -d net-snmp-$VERSION -r $VERSIONTAG net-snmp
+    fi
+    $DOIT net-snmp-$VERSION/remove-files net-snmp-$VERSION
+    $DOIT $TAR net-snmp-$VERSION.tar.gz net-snmp-$VERSION
+    $DOIT md5sum net-snmp-$VERSION.tar.gz > net-snmp-$VERSION.tar.gz.md5
+fi
+
+if [ $2 = "clean" ]; then
+    $DOIT rm -fR net-snmp-[0-9]*
+fi
+
+exit 0
--- snmp/makedepend.in
+++ snmp/makedepend.in
@@ -0,0 +1,18 @@
+#!/usr/bin/perl
+
+foreach $i (qw(snmplib/Makefile agent/Makefile agent/mibgroup/Makefile apps/Makefile apps/snmpnetstat/Makefile)) {
+    print STDERR "processing $i... ";
+    open(IN,"$i");
+    while ($_ = <IN>,!/^# DO NOT DELETE THIS LINE/) { }
+    open(OUT,">$i.in.new");
+    open(INN,"$i.in");
+    while ($_ = <INN>,!/^# DO NOT DELETE THIS LINE/) { print OUT $_; }
+    print OUT $_;
+    while ($_ = <IN>) { print OUT $_; }
+    close(IN);
+    close(OUT);
+    close(INN);
+    rename("$i.in.new","$i.in");
+    print STDERR "done\n";
+}
+
--- snmp/makefileindepend.pl
+++ snmp/makefileindepend.pl
@@ -0,0 +1,25 @@
+#!/usr/bin/perl
+
+# Move dependencies from the Makefile to the Makefile.in file, saving
+# a backup in Makefile.depend.bak.
+
+rename("Makefile.depend","Makefile.depend.bak");
+open(F,"Makefile.depend.bak");
+open(G,"Makefile");
+open(O,">Makefile.depend"); 
+$_ = <F>;
+while(!/^\# DO NOT DELETE THIS LINE/) { 
+	print O $_; 
+	$_ = <F>; 
+}
+print O $_;
+$_ = <G>; 
+while(!/^\# DO NOT DELETE THIS LINE/) { 
+	$_ = <G>; 
+} 
+
+while (<G>) {
+	next if (/:\s*$/);
+	s/\.o:/.lo:/;
+	print O $_;
+} 
--- snmp/makenosysdepend.pl
+++ snmp/makenosysdepend.pl
@@ -0,0 +1,14 @@
+#!/usr/bin/perl
+
+# hack: strip include dependancies that are probably not in our source tree.
+
+if (/^\# DO NOT DELETE THIS LINE/) {
+	$doit=1;
+}
+
+if ($doit == 1) {
+	s#[\s]*/usr/(include|lib|local)/[\S]+##g;
+	print if (! /^[^:]+\.lo:\s*$/);
+} else {
+	print;
+}
--- snmp/mibs/QOS.TXT
+++ snmp/mibs/QOS.TXT
@@ -0,0 +1,371 @@
+LINUX-KERNEL-QOS DEFINITIONS ::= BEGIN
+
+IMPORTS
+    MODULE-IDENTITY, OBJECT-TYPE, enterprises,
+    Integer32, Counter32, mib-2, Unsigned32
+        FROM SNMPv2-SMI
+    DisplayString
+        FROM SNMPv2-TC
+    MODULE-COMPLIANCE, OBJECT-GROUP
+        FROM SNMPv2-CONF;
+    
+qos MODULE-IDENTITY
+    LAST-UPDATED	"200402080000Z"
+    ORGANIZATION	"www.prokon.cz"
+    CONTACT-INFO
+	"postal:	Michal Charvat
+			Zemesska 309
+			Citoliby 439 02
+			Czech Republic
+			
+	 email:		michal@ns1.prokon.cz"
+    DESCRIPTION 
+	"QoS statistics from Linux kernel"
+    REVISION	"200402080000Z"
+    DESCRIPTION
+	"qos mib to get values from Linux kernel"
+    ::= { enterprises 18756 }	-- IANA gave me this number to use
+    
+-- top level structure
+
+qosObjectTable OBJECT-TYPE
+    SYNTAX	SEQUENCE OF QosObject
+    MAX-ACCESS	not-accessible
+    STATUS	current
+    DESCRIPTION
+	"table, where are all values stored"
+    ::= { qos 1 }
+
+qosObject OBJECT-TYPE
+    SYNTAX	QosObject
+    MAX-ACCESS	not-accessible
+    STATUS	current
+    DESCRIPTION
+	"object specifies one qdisc or class"
+    INDEX	{ qosDeviceIndex, qosMajorHandle, qosMinorHandle }
+    ::= { qosObjectTable 1 }
+    
+
+QosObject ::= SEQUENCE {
+    qosDeviceType	Counter32
+    qosDeviceIndex	INTEGER,
+    qosMajorHandle	Unsigned32,
+    qosMinorHandle	Unsigned32,
+    qosTextHandle	DisplayString,
+    qosTextLeaf		DisplayString,
+    qosParent		Unsigned32,
+    qosTextParent	DisplayString,
+    qosDeviceName	DisplayString,
+    qosType		DisplayString,
+    qosBytes		Counter32,
+    qosPackets		Counter32,
+    qosDropped		Counter32,
+    qosOverlimit	Counter32,
+    qosBps		Unsigned32,
+    qosPps		Unsigned32,
+    qosQlen		Unsigned32,
+    qosBacklog		Unsigned32,
+    qosRedEarly		Counter32,
+    qosRedDrop		Counter32,
+    qosRedOther		Counter32,
+    qosRedMarked	Counter32,
+    qosHtbLends		Counter32,
+    qosHtbBorrows	Counter32,
+    qosHtbGiants	Counter32,
+    qosHtbTokens	INTEGER,
+    qosHtbCTokens	INTEGER,
+    qosHtbRate		Unsigned32,
+    qosHtbCeil		Unsigned32,
+    qosHtbPrio		Unsigned32,
+    qosCbqBorrows	Counter32,
+    qosCbqOveractions	Counter32,
+    qosCbqAvgidle	INTEGER,
+    qosCbqUndertime	INTEGER,
+    qosInfo		DisplayString
+    }
+
+qosDeviceIndex OBJECT-TYPE
+    SYNTAX	INTEGER
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"system device number"
+    ::= { qosObject 1 }
+
+qosDeviceIndex OBJECT-TYPE
+    SYNTAX	Integer32 (0..2147483647)
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"system device number"
+    ::= { qosObject 2 }
+
+qosMajorHandle OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"major part of system handle, per device unique"
+    ::= { qosObject 3 }	
+
+qosMinorHandle OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"minor part of system handle, per device unique"
+    ::= { qosObject 4 }	
+
+qosTextHandle OBJECT-TYPE 
+    SYNTAX	DisplayString
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"literal handle - for better orientation"
+    ::= { qosObject 5 }
+
+qosTextLeaf OBJECT-TYPE 
+    SYNTAX	DisplayString
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"literal leaf - for better orientation"
+    ::= { qosObject 6 }
+
+qosParent OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"parent"
+    ::= { qosObject 7 }	
+
+qosTextParent OBJECT-TYPE 
+    SYNTAX	DisplayString
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"literal parent - for better orientation"
+    ::= { qosObject 8 }
+
+
+qosDeviceName OBJECT-TYPE 
+    SYNTAX	DisplayString
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"literal device name - for better orientation"
+    ::= { qosObject 9 }
+
+qosType OBJECT-TYPE
+    SYNTAX	DisplayString
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION
+	"literal qos type, once again, better orientation"
+    ::= { qosObject 10 }
+
+qosBytes OBJECT-TYPE
+    SYNTAX	Counter64
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts transfered bytes on object"
+    ::= { qosObject 11 }
+
+qosPackets OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts packtes"
+    ::= { qosObject 12 }
+
+qosDropped OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts dropped packets (perhaps too long a queue)"
+    ::= { qosObject 13 }
+    
+qosOverlimit OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts discarded packets - rate exceeded"
+    ::= { qosObject 14 }
+
+qosBps OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts bytes per second"
+    ::= { qosObject 15 }
+
+qosPps OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts packets per second"
+    ::= { qosObject 16 }
+
+qosQlen OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"queue length"
+    ::= { qosObject 17 }
+
+qosBacklog OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"backlog"
+    ::= { qosObject 18 }
+
+qosRedEarly OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"early red packets"
+    ::= { qosObject 19 }
+
+qosRedpdrop OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"probability dropped packets"
+    ::= { qosObject 20 }
+
+qosRedOther OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"other packets"
+    ::= { qosObject 21 }
+
+qosRedMarked OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"counts discarded packets - rate exceeded"
+    ::= { qosObject 22 }
+
+qosHtbLends OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB lended bytes"
+    ::= { qosObject 23 }
+
+qosHtbBorrows OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB borrowed packets"
+    ::= { qosObject 24 }
+
+qosHtbGiants OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB giants packets"
+    ::= { qosObject 25 }
+
+qosHtbTokens OBJECT-TYPE
+    SYNTAX	INTEGER
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB tokens in reservoir"
+    ::= { qosObject 26 }
+
+qosHtbCTokens OBJECT-TYPE
+    SYNTAX 	INTEGER
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB ceil tokens in reservoir"
+    ::= { qosObject 27 }
+
+qosHtbRate OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB class rate"
+    ::= { qosObject 28 }
+
+qosHtbCeil OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB ceil rate"
+    ::= { qosObject 29 }
+
+qosHtbPrio OBJECT-TYPE
+    SYNTAX	Unsigned32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"HTB class prio"
+    ::= { qosObject 30 }
+
+qosCbqBorrows OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"CBQ borrowed bytes"
+    ::= { qosObject 31 }
+
+qosCbqOveractions OBJECT-TYPE
+    SYNTAX	Counter32
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"CBQ Overactions"
+    ::= { qosObject 32 }
+
+qosCbqAvgidle OBJECT-TYPE
+    SYNTAX	INTEGER
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"CBQ avgidle"
+    ::= { qosObject 33 }
+
+qosCbqUndertime OBJECT-TYPE
+    SYNTAX	INTEGER
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"CBQ undertime"
+    ::= { qosObject 34 }
+
+qosInfo OBJECT-TYPE 
+    SYNTAX	DisplayString
+    MAX-ACCESS	read-only
+    STATUS	current
+    DESCRIPTION	
+	"literal parameters - for better orientation"
+    ::= { qosObject 35 }
+
+
+
+
+END
--- snmp/remove-files
+++ snmp/remove-files
@@ -0,0 +1,18 @@
+#!/bin/sh
+
+DIR="cmusnmp"
+if [ "$1" != "" ]; then
+  DIR="$1"
+fi
+
+cd $DIR
+
+touch stamp-h.in stamp-h configure
+rm -f makedepend.in
+rm -f agent/mibgroup/versiontag
+rm -f ISSUES
+rm -f makenosysdepend.pl
+rm -f makefileindepend.pl
+rm -fR win32/dist
+find . -name .cvsignore | xargs rm -f
+rm -f remove-files
--- snmp/snmpd.conf
+++ snmp/snmpd.conf
@@ -0,0 +1,105 @@
+###########################################################################
+#
+# snmpd.conf
+#
+#   - created by the snmpconf configuration program
+#
+###########################################################################
+# SECTION: Access Control Setup
+#
+#   This section defines who is allowed to talk to your running
+#   snmp agent.
+
+# rwuser: a SNMPv3 read-write user
+#   arguments:  user [noauth|auth|priv] [restriction_oid]
+
+rwuser  nikki  
+
+# rouser: a SNMPv3 read-only user
+#   arguments:  user [noauth|auth|priv] [restriction_oid]
+
+rouser  nikki  
+
+# rocommunity: a SNMPv1/SNMPv2c read-only access community name
+#   arguments:  community [default|hostname|network/bits] [oid]
+
+rocommunity  public  
+
+
+
+###########################################################################
+# SECTION: Monitor Various Aspects of the Running Host
+#
+#   The following check up on various aspects of a host.
+
+# proc: Check for processes that should be running.
+#     proc NAME [MAX=0] [MIN=0]
+#   
+#     NAME:  the name of the process to check for.  It must match
+#            exactly (ie, http will not find httpd processes).
+#     MAX:   the maximum number allowed to be running.  Defaults to 0.
+#     MIN:   the minimum number to be running.  Defaults to 0.
+#   
+#   The results are reported in the prTable section of the UCD-SNMP-MIB tree
+#   Special Case:  When the min and max numbers are both 0, it assumes
+#   you want a max of infinity and a min of 1.
+
+proc    0
+
+
+
+###########################################################################
+# SECTION: Trap Destinations
+#
+#   Here we define who the agent will send traps to.
+
+# informsink: A SNMPv2c inform (acknowledged trap) receiver
+#   arguments: host [community] [portnum]
+
+informsink  fekda traps 160
+
+# trapcommunity: Default trap sink community to use
+#   arguments: community-string
+
+trapcommunity  traps
+
+# authtrapenable: Should we send traps when authentication failures occur
+#   arguments: 1 | 2   (1 = yes, 2 = no)
+
+authtrapenable  1
+
+
+
+###########################################################################
+# SECTION: System Information Setup
+#
+#   This section defines some of the information reported in
+#   the "system" mib group in the mibII tree.
+
+# syslocation: The [typically physical] location of the system.
+#   Note that setting this value here means that when trying to
+#   perform an snmp SET operation to the sysLocation.0 variable will make
+#   the agent return the "notWritable" error code.  IE, including
+#   this token in the snmpd.conf file will disable write access to
+#   the variable.
+#   arguments:  location_string
+
+syslocation  "Tomato64"
+
+# syscontact: The contact information for the administrator
+#   Note that setting this value here means that when trying to
+#   perform an snmp SET operation to the sysContact.0 variable will make
+#   the agent return the "notWritable" error code.  IE, including
+#   this token in the snmpd.conf file will disable write access to
+#   the variable.
+#   arguments:  contact_string
+
+syscontact  Unknown
+
+# sysservices: The proper value for the sysServices object.
+#   arguments:  sysservices_number
+
+sysservices 15
+
+
+
