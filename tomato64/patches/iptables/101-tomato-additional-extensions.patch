--- iptables-1.8.x/extensions/libip6t_ROUTE.c
+++ iptables-1.8.x/extensions/libip6t_ROUTE.c
@@ -0,0 +1,239 @@
+/* Shared library add-on to iptables to add ROUTE v6 target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.1 2004/11/23
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <net/if.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+
+#include <ip6tables.h>
+#include <xtables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv6/ip6t_ROUTE.h>
+
+#ifndef XTABLES_VERSION
+#define XTABLES_VERSION IPTABLES_VERSION
+#endif
+
+/* compile IP6T_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IP6T_ROUTE_TEE
+#define IP6T_ROUTE_TEE		0x02
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute packet via this gateway `ip'\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
+"\n",
+"1.11");
+}
+
+static struct option opts[] = {
+	{ .name = "oif", .has_arg = true, .val = '1' },
+	{ .name = "iif", .has_arg = true, .val = '2' },
+	{ .name = "gw", .has_arg = true, .val = '3' },
+	{ .name = "continue", .has_arg = false, .val = '4' },
+	{ .name = "tee", .has_arg = false, .val = '5' },
+	XT_GETOPT_TABLEEND
+};
+
+/* Initialize the target. */
+static void
+init(struct xt_entry_target *t)
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw[0] = 0;
+	route_info->gw[1] = 0;
+	route_info->gw[2] = 0;
+	route_info->gw[3] = 0;
+	route_info->flags = 0;
+}
+
+
+#define IP6T_ROUTE_OPT_OIF      0x01
+#define IP6T_ROUTE_OPT_IIF      0x02
+#define IP6T_ROUTE_OPT_GW       0x04
+#define IP6T_ROUTE_OPT_CONTINUE 0x08
+#define IP6T_ROUTE_OPT_TEE      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry, struct xt_entry_target **target)
+{
+	struct ip6t_route_target_info *route_info = 
+		(struct ip6t_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IP6T_ROUTE_OPT_OIF)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IP6T_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		xtables_error(PARAMETER_PROBLEM,
+			   "--iif option not implemented");
+		break;
+
+	case '3':
+		if (*flags & IP6T_ROUTE_OPT_GW)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (!inet_pton(AF_INET6, optarg, (struct in6_addr*)&route_info->gw)) {
+			xtables_error(PARAMETER_PROBLEM,
+				   "Invalid IPv6 address %s",
+				   optarg);
+		}
+
+		*flags |= IP6T_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
+
+		route_info->flags |= IP6T_ROUTE_CONTINUE;
+		*flags |= IP6T_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	case '5':
+		if (*flags & IP6T_ROUTE_OPT_TEE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IP6T_ROUTE_OPT_CONTINUE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IP6T_ROUTE_TEE;
+		*flags |= IP6T_ROUTE_OPT_TEE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif or gw option required");
+}
+
+
+/* Prints out the targinfo. */
+static void
+print(const void *ip,
+      const struct xt_entry_target *target,
+      int numeric)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	printf(" ROUTE");
+
+	if (route_info->oif[0])
+		printf(" oif:%s", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf(" gw:%s", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf(" continue");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf(" tee");
+
+}
+
+
+static void
+save(const void *ip,
+     const struct xt_entry_target *target)
+{
+	const struct ip6t_route_target_info *route_info
+		= (const struct ip6t_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->gw[0] 
+	    || route_info->gw[1] 
+	    || route_info->gw[2] 
+	    || route_info->gw[3]) {
+		char address[INET6_ADDRSTRLEN];
+		printf(" --gw %s", inet_ntop(AF_INET6, route_info->gw, address, INET6_ADDRSTRLEN));
+	}
+
+	if (route_info->flags & IP6T_ROUTE_CONTINUE)
+		printf(" --continue");
+
+	if (route_info->flags & IP6T_ROUTE_TEE)
+		printf(" --tee");
+}
+
+
+static struct xtables_target route = {
+	.name 		= "ROUTE",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct ip6t_route_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts,
+};
+
+void _init(void)
+{
+	xtables_register_target(&route);
+}
--- iptables-1.8.x/extensions/libip6t_ROUTE.man
+++ iptables-1.8.x/extensions/libip6t_ROUTE.man
@@ -0,0 +1,15 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--gw " "IPv6_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules. Not valid in combination with `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--continue'
--- iptables-1.8.x/extensions/libip6t_web.c
+++ iptables-1.8.x/extensions/libip6t_web.c
@@ -0,0 +1,215 @@
+/*
+
+	web (experimental)
+	HTTP IPv6 client match
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv4/ipt_web.h>
+
+
+#undef IPTABLES_SAVE
+
+
+static void help(void)
+{
+	printf(
+		"web match v0.01 (experimental)\n"
+		"Copyright (C) 2006 Jonathan Zarate\n"
+		"Options:\n"
+		"[!] --http (default)   find an HTTP GET/POST request\n"
+		"[!] --host <text ...>  find in host line\n"
+		"[!] --req <text ...>   find in request\n"
+		"[!] --path <text ...>  find in request path\n"
+		"[!] --query <text ...> find in request query\n"
+		"[!] --hore <text ...>  find in host or request line\n"
+		" <text> can be:\n"
+		"  text    contains\n"
+		"  ^text   begins with\n"
+		"  text$   ends with\n"
+		"  ^text$  exact match\n");
+}
+
+static void init(struct xt_entry_match *m)
+{
+}
+
+static struct option opts[] = {
+	{ .name = "http",  .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = "host",  .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "req",   .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "path",  .has_arg = 1, .flag = 0, .val = '4' },
+	{ .name = "query", .has_arg = 1, .flag = 0, .val = '5' },
+	{ .name = "hore",  .has_arg = 1, .flag = 0, .val = '6' },
+	XT_GETOPT_TABLEEND,
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const void *v_entry,
+				 struct xt_entry_match **match)
+{
+	struct ipt_entry *entry = (struct ipt_entry*) v_entry;
+	const char *s;
+	char *e, *p;
+	int n;
+	struct ipt_web_info *info;
+
+	if ((c < '1') || (c > '6')) return 0;
+
+	if (*flags) xtables_error(PARAMETER_PROBLEM, "Multiple modes are not supported");
+	*flags = 1;
+
+	info = (struct ipt_web_info *)(*match)->data;
+	switch (c) {
+	case '2':
+		info->mode = IPT_WEB_HOST;
+		break;
+	case '3':
+		info->mode = IPT_WEB_RURI;
+		break;
+	case '4':
+		info->mode = IPT_WEB_PATH;
+		break;
+	case '5':
+		info->mode = IPT_WEB_QUERY;
+		break;
+	case '6':
+		info->mode = IPT_WEB_HORE;
+		break;
+	default:	// IPT_WEB_HTTP
+		return 1;
+	}
+
+//	if (entry->ipv6.proto != IPPROTO_TCP) {
+//		xtables_error(PARAMETER_PROBLEM, "web match requires -p tcp");
+//	}
+
+	if (invert) info->invert = 1;
+
+	// convert arg to text\0text\0\0
+	s = argv[optind - 1];
+
+	if ((p = malloc(strlen(s) + 2)) == NULL) {
+		xtables_error(PARAMETER_PROBLEM, "Not enough memory");
+	}
+
+	e = p;
+	while (*s) {
+		while ((*s == ' ') || (*s == '\n') || (*s == '\t')) ++s;
+		if (*s == 0) break;
+		while ((*s != 0) && (*s != ' ') && (*s != '\n') && (*s != '\t')) {
+			*e++ = *s++;
+		}
+		*e++ = 0;
+	}
+	n = (e - p);
+
+#if 0
+	*e = 0;
+	e = p;
+	while (*e) {
+		printf("[%s]\n", e);
+		e += strlen(e) + 1;
+	}
+#endif
+
+	if (n <= 1) {
+		xtables_error(PARAMETER_PROBLEM, "Text is too short");
+	}
+	if (n >= IPT_WEB_MAXTEXT) {
+		xtables_error(PARAMETER_PROBLEM, "Text is too long");
+	}
+	memcpy(info->text, p, n);
+	memset(info->text + n, 0, IPT_WEB_MAXTEXT - n);		// term, need to clear rest for ipt rule cmp
+	free(p);
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void print_match(const struct ipt_web_info *info)
+{
+	const char *text;
+
+	if (info->invert) printf("! ");
+
+	switch (info->mode) {
+	case IPT_WEB_HOST:
+		printf("--host");
+		break;
+	case IPT_WEB_RURI:
+		printf("--req");
+		break;
+	case IPT_WEB_PATH:
+		printf("--path");
+		break;
+	case IPT_WEB_QUERY:
+		printf("--query");
+		break;
+	case IPT_WEB_HORE:
+		printf("--hore");
+		break;
+	default:
+		printf("--http");
+		return;
+	}
+
+	text = info->text;
+	printf(" \"");
+	while (*text) {
+		while (*text) {
+			if (*text == '"') printf("\\\"");
+				else putc(*text, stdout);
+			++text;
+		}
+		++text;
+		if (*text == 0) break;
+		putc(' ', stdout);
+	}
+	printf("\" ");
+}
+
+static void print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	printf("web ");
+	print_match((const struct ipt_web_info *)match->data);
+}
+
+static void save(const void *ip, const struct xt_entry_match *match)
+{
+#ifdef IPTABLES_SAVE
+	print_match((const struct ipt_web_info *)match->data);
+#endif
+}
+
+
+static struct xtables_match web6_match = {
+	.family        = NFPROTO_IPV6,
+	.name          = "web",
+	.version       = XTABLES_VERSION,
+	.size          = XT_ALIGN(sizeof(struct ipt_web_info)),
+	.userspacesize = XT_ALIGN(sizeof(struct ipt_web_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&web6_match);
+}
--- iptables-1.8.x/extensions/libip6t_webmon.c
+++ iptables-1.8.x/extensions/libip6t_webmon.c
@@ -0,0 +1,668 @@
+/*  webmon --	An iptables extension to match URLs in HTTP requests 
+ *  		This module can match using string match or regular expressions
+ *  		Originally designed for use with Gargoyle router firmware (gargoyle-router.com)
+ *
+ *
+ *  Copyright © 2008-2011 by Eric Bishop <eric@gargoyle-router.com>
+ * 
+ *  This file is free software: you may copy, redistribute and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation, either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  This file is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <arpa/inet.h>
+
+/*
+ * in iptables 1.4.0 and higher, iptables.h includes xtables.h, which
+ * we can use to check whether we need to deal with the new requirements
+ * in pre-processor directives below
+ */
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+#include <linux/netfilter_ipv4/ipt_webmon.h>
+
+#define iptables_rule_match	xtables_rule_match
+#define iptables_match		xtables_match
+#define iptables_target		xtables_target
+#define ipt_tryload		xt_tryload
+
+/* 
+ * XTABLES_VERSION_CODE is only defined in versions 1.4.1 and later, which
+ * also require the use of xtables_register_match
+ * 
+ * Version 1.4.0 uses register_match like previous versions
+ */
+#define register_match          xtables_register_match
+
+
+#define STRIP "%d.%d.%d.%d"
+#define NIPQUAD(addr) \
+	((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[3]
+
+
+
+/* utility functions necessary for module to work across multiple iptables versions */
+//static void param_problem_exit_error(char* msg);
+
+
+static void parse_ips_and_ranges(char* addr_str, struct ipt_webmon_info *info);
+
+static char** split_on_separators(char* line, char* separators, int num_separators, int max_pieces, int include_remainder_at_max);
+static char* trim_flanking_whitespace(char* str);
+static unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length);
+
+#define DEFAULT_MAX      300
+
+#define SEARCH_LOAD_FILE 100
+#define DOMAIN_LOAD_FILE 101
+#define CLEAR_SEARCH     102
+#define CLEAR_DOMAIN     103
+
+static char* domain_load_file = NULL;
+static char* search_load_file = NULL;
+static uint32_t global_max_domains  = DEFAULT_MAX;
+static uint32_t global_max_searches = DEFAULT_MAX;
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(	"webmon options:\n");
+}
+
+static struct option opts[] = 
+{
+	{ .name = "exclude_ips",        .has_arg = 1, .flag = 0, .val = WEBMON_EXCLUDE },
+	{ .name = "include_ips",        .has_arg = 1, .flag = 0, .val = WEBMON_INCLUDE },
+	{ .name = "max_domains",        .has_arg = 1, .flag = 0, .val = WEBMON_MAXDOMAIN },
+	{ .name = "max_searches",       .has_arg = 1, .flag = 0, .val = WEBMON_MAXSEARCH },
+	{ .name = "search_load_file",   .has_arg = 1, .flag = 0, .val = SEARCH_LOAD_FILE },
+	{ .name = "domain_load_file",   .has_arg = 1, .flag = 0, .val = DOMAIN_LOAD_FILE },
+	{ .name = "clear_search",       .has_arg = 0, .flag = 0, .val = CLEAR_SEARCH },
+	{ .name = "clear_domain",       .has_arg = 0, .flag = 0, .val = CLEAR_DOMAIN },
+
+	{ .name = 0 }
+};
+
+static void webmon_init(
+	struct xt_entry_match *match
+	)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	info->max_domains=DEFAULT_MAX;
+	info->max_searches=DEFAULT_MAX;
+	info->num_exclude_ips=0;
+	info->num_exclude_ranges=0;
+	info->exclude_type = WEBMON_EXCLUDE;
+	info->ref_count = NULL;
+}
+
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(	int c, 
+			char **argv,
+			int invert,
+			unsigned int *flags,
+			const void *entry,
+			struct xt_entry_match **match
+			)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)(*match)->data;
+	int valid_arg = 1;
+	long max;
+	switch (c)
+	{
+		case WEBMON_EXCLUDE:
+			parse_ips_and_ranges(optarg, info);
+			info->exclude_type = WEBMON_EXCLUDE;
+			break;
+		case WEBMON_INCLUDE:
+			parse_ips_and_ranges(optarg, info);
+			info->exclude_type = WEBMON_INCLUDE;
+			break;
+		case WEBMON_MAXSEARCH:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_searches = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_searches = (uint32_t)max;
+				global_max_searches = info->max_searches;
+			}
+			break;
+		case WEBMON_MAXDOMAIN:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_domains = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_domains = (uint32_t)max;
+				global_max_domains = info->max_domains;
+			}
+			break;
+		case SEARCH_LOAD_FILE:
+			search_load_file = strdup(optarg);
+			break;
+		case DOMAIN_LOAD_FILE:
+			domain_load_file = strdup(optarg);
+			break;
+		case CLEAR_SEARCH:
+			search_load_file = strdup("/dev/null");
+			break;
+		case CLEAR_DOMAIN:
+			domain_load_file = strdup("/dev/null");
+			break;
+		default:
+			valid_arg = 0;
+	}
+	return valid_arg;
+
+}
+
+
+	
+static void print_webmon_args(	struct ipt_webmon_info* info )
+{
+	printf("--max_domains %ld ", (unsigned long int)info->max_domains);
+	printf("--max_searches %ld ", (unsigned long int)info->max_searches);
+	if(info->num_exclude_ips > 0 || info->num_exclude_ranges > 0)
+	{
+		int ip_index = 0;
+		char comma[3] = "";
+		printf("--%s ", (info->exclude_type == WEBMON_EXCLUDE ? "exclude_ips" : "include_ips"));
+		for(ip_index=0; ip_index < info->num_exclude_ips; ip_index++)
+		{
+			printf("%s"STRIP, comma, NIPQUAD((info->exclude_ips)[ip_index]) );
+			sprintf(comma, ",");
+		}
+		for(ip_index=0; ip_index < info->num_exclude_ranges; ip_index++)
+		{
+			struct ipt_webmon_ip_range r = (info->exclude_ranges)[ip_index];
+			printf("%s"STRIP"-"STRIP, comma, NIPQUAD(r.start), NIPQUAD(r.end) );
+			sprintf(comma, ",");
+		}
+		printf(" ");
+	}
+}
+
+
+static void do_load(char* file, uint32_t max, unsigned char type)
+{
+	if(file != NULL)
+	{
+		unsigned char* data = NULL;
+		unsigned long data_length = 0;
+		char* file_data = NULL;
+		if(strcmp(file, "/dev/null") != 0)
+		{
+			FILE* in = fopen(file, "r");
+			if(in != NULL)
+			{
+				file_data = (char*)read_entire_file(in, 4096, &data_length);
+				fclose(in);
+			}
+		}
+		if(file_data == NULL)
+		{
+			file_data=strdup("");
+		}
+		
+		if(file_data != NULL)
+		{
+			data_length = strlen(file_data) + sizeof(uint32_t)+2;
+			data = (unsigned char*)malloc(data_length);
+			if(data != NULL)
+			{
+				int sockfd = -1;
+				uint32_t* maxp = (uint32_t*)(data+1);
+				data[0] = type;
+				*maxp = max;
+				sprintf( (data+1+sizeof(uint32_t)),  "%s", file_data);
+			
+				sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+				if(sockfd >= 0)
+				{
+					setsockopt(sockfd, IPPROTO_IP, WEBMON_SET, data, data_length);
+					close(sockfd);
+				}
+				free(data);
+			}
+			free(file_data);
+		}
+	}
+
+}
+
+
+static void final_check(unsigned int flags)
+{
+	do_load(domain_load_file, global_max_domains,  WEBMON_DOMAIN);
+	do_load(search_load_file, global_max_searches, WEBMON_SEARCH);
+}
+
+/* Prints out the matchinfo. */
+static void print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	printf("WEBMON ");
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+
+	print_webmon_args(info);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const void *ip, const struct xt_entry_match *match)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	print_webmon_args(info);
+}
+
+static struct xtables_match webmon = 
+{
+	.name = 	"webmon",
+	.version = 	XTABLES_VERSION,
+	.family = 	NFPROTO_IPV6,
+	.size = 	XT_ALIGN(sizeof(struct ipt_webmon_info)),
+	.userspacesize = XT_ALIGN(sizeof(struct ipt_webmon_info)),
+	.help = 	help,
+	.init = 	webmon_init,
+	.parse = 	parse,
+	.final_check = 	final_check,
+	.print = 	print,
+	.save = 	save,
+	.extra_opts = 	opts
+};
+
+void _init(void)
+{
+  xtables_register_match(&webmon);
+}
+
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+
+/*static void param_problem_exit_error(char* msg)
+{
+	xtables_error(PARAMETER_PROBLEM, msg);
+}*/
+
+
+static void parse_ips_and_ranges(char* addr_str, struct ipt_webmon_info *info)
+{
+	char** addr_parts = split_on_separators(addr_str, ",", 1, -1, 0);
+
+	info->num_exclude_ips=0;
+	info->num_exclude_ranges = 0;
+
+	int ip_part_index;
+	for(ip_part_index=0; addr_parts[ip_part_index] != NULL; ip_part_index++)
+	{
+		char* next_str = addr_parts[ip_part_index];
+		if(strchr(next_str, '-') != NULL)
+		{
+			char** range_parts = split_on_separators(next_str, "-", 1, 2, 1);
+			char* start = trim_flanking_whitespace(range_parts[0]);
+			char* end = trim_flanking_whitespace(range_parts[1]);
+			int start_ip[4];
+			int end_ip[4];
+			int start_valid = sscanf(start, "%d.%d.%d.%d", start_ip, start_ip+1, start_ip+2, start_ip+3);
+			int end_valid = sscanf(end, "%d.%d.%d.%d", end_ip, end_ip+1, end_ip+2, end_ip+3);
+			
+			if(start_valid == 4 && end_valid == 4)
+			{
+				struct ipt_webmon_ip_range r;
+				struct in_addr sip, eip;
+				inet_pton(AF_INET, start, &sip);
+				inet_pton(AF_INET, end, &eip);
+				r.start = (uint32_t)sip.s_addr;
+				r.end   = (uint32_t)eip.s_addr;
+
+				if(info->num_exclude_ranges <  WEBMON_MAX_IP_RANGES  && (unsigned long)ntohl(r.start) < (unsigned long)ntohl(r.end) )
+				{
+					(info->exclude_ranges)[ info->num_exclude_ranges ] = r;
+					info->num_exclude_ranges = info->num_exclude_ranges + 1;
+				}
+			}
+
+			free(start);
+			free(end);	
+			free(range_parts);
+		}
+		else if(strchr(next_str, '/') != NULL)
+		{
+			char** range_parts = split_on_separators(next_str, "/", 1, 2, 1);
+			char* start = trim_flanking_whitespace(range_parts[0]);
+			char* end = trim_flanking_whitespace(range_parts[1]);
+			int base_ip[4];
+			int base_valid = sscanf(start, "%d.%d.%d.%d", base_ip, base_ip+1, base_ip+2, base_ip+3);
+			if(base_valid == 4)
+			{
+				int mask_valid = 0;
+				uint32_t mask;
+				if(strchr(end, '.') != NULL)
+				{
+					uint32_t mask_ip[4];
+					int mask_test = sscanf(end, "%d.%d.%d.%d", mask_ip, mask_ip+1, mask_ip+2, mask_ip+3);
+					if(mask_test == 4)
+					{
+						struct in_addr mask_add;
+						inet_pton(AF_INET, end, &mask_add);
+						mask = (uint32_t)mask_add.s_addr;
+						mask_valid = 1;
+					}
+				}
+				else
+				{
+					int mask_bits;
+					if( sscanf(end, "%d", &mask_bits) > 0)
+					{
+						if(mask_bits >=0 && mask_bits <= 32)
+						{
+							uint32_t byte = 0;
+							mask = 0;
+							for(byte=0; byte < 4; byte++)
+							{
+								unsigned char byte_bits = mask_bits > 8 ? 8 : mask_bits;
+								uint32_t byte_mask = 0;
+								mask_bits = mask_bits - byte_bits;
+								
+								while(byte_bits > 0)
+								{
+									byte_mask = byte_mask | (256 >> byte_bits);
+									byte_bits--;
+								}
+								mask = mask | ((uint32_t)byte_mask << (byte*8));
+								printf("mask = "STRIP"\n", NIPQUAD(mask));	
+							}
+							mask_valid = 1;
+						}
+					}
+				}
+				if(mask_valid)
+				{
+					struct ipt_webmon_ip_range r;
+					struct in_addr bip;
+					inet_pton(AF_INET, start, &bip);
+					r.start = ( ((uint32_t)bip.s_addr) & mask );
+					r.end   = ( ((uint32_t)bip.s_addr) | (~mask) );
+					if(info->num_exclude_ranges <  WEBMON_MAX_IP_RANGES && ntohl(r.start) <= ntohl(r.end) )
+					{
+						(info->exclude_ranges)[ info->num_exclude_ranges ] = r;
+						info->num_exclude_ranges = info->num_exclude_ranges + 1;
+					}
+				}
+			}
+			free(start);
+			free(end);	
+			free(range_parts);
+		}
+		else
+		{
+			int parsed_ip[4];
+			int valid = sscanf(next_str, "%d.%d.%d.%d", parsed_ip, parsed_ip+1, parsed_ip+2, parsed_ip+3);
+			if(valid == 4)
+			{
+				struct in_addr ip;
+				trim_flanking_whitespace(next_str);
+				inet_pton(AF_INET, next_str, &ip);
+				
+				if(info->num_exclude_ranges <  WEBMON_MAX_IPS)
+				{
+					(info->exclude_ips)[ info->num_exclude_ips ] = (uint32_t)ip.s_addr;
+					info->num_exclude_ips = info->num_exclude_ips + 1;
+				}
+			}
+		}
+		free(next_str);
+	}
+	free(addr_parts);
+	
+}
+
+
+
+/*
+ * line_str is the line to be parsed -- it is not modified in any way
+ * max_pieces indicates number of pieces to return, if negative this is determined dynamically
+ * include_remainder_at_max indicates whether the last piece, when max pieces are reached, 
+ * 	should be what it would normally be (0) or the entire remainder of the line (1)
+ * 	if max_pieces < 0 this parameter is ignored
+ *
+ *
+ * returns all non-separator pieces in a line
+ * result is dynamically allocated, MUST be freed after call-- even if 
+ * line is empty (you still get a valid char** pointer to to a NULL char*)
+ */
+static char** split_on_separators(char* line_str, char* separators, int num_separators, int max_pieces, int include_remainder_at_max)
+{
+	char** split;
+
+	if(line_str != NULL)
+	{
+		int split_index;
+		int non_separator_found;
+		char* dup_line;
+		char* start;
+
+		if(max_pieces < 0)
+		{
+			/* count number of separator characters in line -- this count + 1 is an upperbound on number of pieces */
+			int separator_count = 0;
+			int line_index;
+			for(line_index = 0; line_str[line_index] != '\0'; line_index++)
+			{
+				int sep_index;
+				int found = 0;
+				for(sep_index =0; found == 0 && sep_index < num_separators; sep_index++)
+				{
+					found = separators[sep_index] == line_str[line_index] ? 1 : 0;
+				}
+				separator_count = separator_count+ found;
+			}
+			max_pieces = separator_count + 1;
+		}
+		split = (char**)malloc((1+max_pieces)*sizeof(char*));
+		split_index = 0;
+		split[split_index] = NULL;
+
+
+		dup_line = strdup(line_str);
+		start = dup_line;
+		non_separator_found = 0;
+		while(non_separator_found == 0)
+		{
+			int matches = 0;
+			int sep_index;
+			for(sep_index =0; sep_index < num_separators; sep_index++)
+			{
+				matches = matches == 1 || separators[sep_index] == start[0] ? 1 : 0;
+			}
+			non_separator_found = matches==0 || start[0] == '\0' ? 1 : 0;
+			if(non_separator_found == 0)
+			{
+				start++;
+			}
+		}
+
+		while(start[0] != '\0' && split_index < max_pieces)
+		{
+			/* find first separator index */
+			int first_separator_index = 0;
+			int separator_found = 0;
+			while(	separator_found == 0 )
+			{
+				int sep_index;
+				for(sep_index =0; separator_found == 0 && sep_index < num_separators; sep_index++)
+				{
+					separator_found = separators[sep_index] == start[first_separator_index] || start[first_separator_index] == '\0' ? 1 : 0;
+				}
+				if(separator_found == 0)
+				{
+					first_separator_index++;
+				}
+			}
+			
+			/* copy next piece to split array */
+			if(first_separator_index > 0)
+			{
+				char* next_piece = NULL;
+				if(split_index +1 < max_pieces || include_remainder_at_max <= 0)
+				{
+					next_piece = (char*)malloc((first_separator_index+1)*sizeof(char));
+					memcpy(next_piece, start, first_separator_index);
+					next_piece[first_separator_index] = '\0';
+				}
+				else
+				{
+					next_piece = strdup(start);
+				}
+				split[split_index] = next_piece;
+				split[split_index+1] = NULL;
+				split_index++;
+			}
+
+
+			/* find next non-separator index, indicating start of next piece */
+			start = start+ first_separator_index;
+			non_separator_found = 0;
+			while(non_separator_found == 0)
+			{
+				int matches = 0;
+				int sep_index;
+				for(sep_index =0; sep_index < num_separators; sep_index++)
+				{
+					matches = matches == 1 || separators[sep_index] == start[0] ? 1 : 0;
+				}
+				non_separator_found = matches==0 || start[0] == '\0' ? 1 : 0;
+				if(non_separator_found == 0)
+				{
+					start++;
+				}
+			}
+		}
+		free(dup_line);
+	}
+	else
+	{
+		split = (char**)malloc((1)*sizeof(char*));
+		split[0] = NULL;
+	}
+	return split;
+}
+
+
+
+static char* trim_flanking_whitespace(char* str)
+{
+	int new_start = 0;
+	int new_length = 0;
+
+	char whitespace[5] = { ' ', '\t', '\n', '\r', '\0' };
+	int num_whitespace_chars = 4;
+	
+	
+	int str_index = 0;
+	int is_whitespace = 1;
+	int test;
+	while( (test = str[str_index]) != '\0' && is_whitespace == 1)
+	{
+		int whitespace_index;
+		is_whitespace = 0;
+		for(whitespace_index = 0; whitespace_index < num_whitespace_chars && is_whitespace == 0; whitespace_index++)
+		{
+			is_whitespace = test == whitespace[whitespace_index] ? 1 : 0;
+		}
+		str_index = is_whitespace == 1 ? str_index+1 : str_index;
+	}
+	new_start = str_index;
+
+
+	str_index = strlen(str) - 1;
+	is_whitespace = 1;
+	while( str_index >= new_start && is_whitespace == 1)
+	{
+		int whitespace_index;
+		is_whitespace = 0;
+		for(whitespace_index = 0; whitespace_index < num_whitespace_chars && is_whitespace == 0; whitespace_index++)
+		{
+			is_whitespace = str[str_index] == whitespace[whitespace_index] ? 1 : 0;
+		}
+		str_index = is_whitespace == 1 ? str_index-1 : str_index;
+	}
+	new_length = str[new_start] == '\0' ? 0 : str_index + 1 - new_start;
+	
+
+	if(new_start > 0)
+	{
+		for(str_index = 0; str_index < new_length; str_index++)
+		{
+			str[str_index] = str[str_index+new_start];
+		}
+	}
+	str[new_length] = 0;
+	return str;
+}
+
+
+static unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length)
+{
+	int max_read_size = read_block_size;
+	unsigned char* read_string = (unsigned char*)malloc(max_read_size+1);
+	unsigned long bytes_read = 0;
+	int end_found = 0;
+	while(end_found == 0)
+	{
+		int nextch = '?';
+		while(nextch != EOF && bytes_read < max_read_size)
+		{
+			nextch = fgetc(in);
+			if(nextch != EOF)
+			{
+				read_string[bytes_read] = (unsigned char)nextch;
+				bytes_read++;
+			}
+		}
+		read_string[bytes_read] = '\0';
+		end_found = (nextch == EOF) ? 1 : 0;
+		if(end_found == 0)
+		{
+			unsigned char *new_str;
+			max_read_size = max_read_size + read_block_size;
+		       	new_str = (unsigned char*)malloc(max_read_size+1);
+			memcpy(new_str, read_string, bytes_read);
+			free(read_string);
+			read_string = new_str;
+		}
+	}
+	*length = bytes_read;
+	return read_string;
+}
+
--- iptables-1.8.x/extensions/libipt_account.c
+++ iptables-1.8.x/extensions/libipt_account.c
@@ -0,0 +1,374 @@
+/* Copyright (c) 2004-2009 Piotr 'QuakeR' Gasidlo <quaker@barbara.eu.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ * 
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+//#ifdef IPTABLES_VERSION
+//#include <iptables.h>
+//#elif defined XTABLES_VERSION
+#include <xtables.h>
+//#else
+//#error IPTABLES_VERSION nor XTABLES_VERSION not defined.
+//#endif
+#include <string.h>
+#include <getopt.h>
+
+#include <linux/netfilter_ipv4/ipt_account.h>
+
+#ifndef HIPQUAD
+#define HIPQUAD(addr) \
+  ((unsigned char *)&addr)[3], \
+  ((unsigned char *)&addr)[2], \
+  ((unsigned char *)&addr)[1], \
+  ((unsigned char *)&addr)[0]
+#endif
+        
+static void help(void) {
+  printf(
+      "account v%s options:\n"
+      "--aaddr network/netmask\n"
+      " defines network/netmask for which make statistics.\n"
+      "--aname name\n"
+      " defines name of list where statistics will be kept. If no is\n"
+      " specified DEFAULT will be used.\n"
+      "--ashort\n"
+      "       table will colect only short statistics (only total counters\n"
+      "       without splitting it into protocols.\n"
+  , 
+#ifdef IPTABLES_VERSION
+  IPTABLES_VERSION
+#else
+  XTABLES_VERSION
+#endif
+  );
+};
+
+static struct option opts[] = {
+  { .name = "aaddr",  .has_arg = 1, .flag = NULL, .val = 201 },
+  { .name = "aname",  .has_arg = 1, .flag = NULL, .val = 202 },
+  { .name = "ashort", .has_arg = 0, .flag = NULL, .val = 203 },
+  { .name = 0, .has_arg = 0, .flag = 0, .val = 0 }
+};
+
+/* Helper functions for parse_network */
+int parseip(const char *parameter, u_int32_t *ip) {
+  
+  char buffer[16], *bufferptr, *dot;
+  unsigned int i, shift, part;
+
+  if (strlen(parameter) > 15)
+    return 0;
+
+  strncpy(buffer, parameter, 15);
+  buffer[15] = 0;
+
+  bufferptr = buffer;
+
+  for (i = 0, shift = 24, *ip = 0; i < 3; i++, shift -= 8) {
+    /* no dot */
+    if ((dot = strchr(bufferptr, '.')) == NULL)
+      return 0;
+    /* not a number */
+    if ((part = strtol(bufferptr, (char**)NULL, 10)) < 0) 
+      return 0; 
+    /* to big number */
+    if (part > 255)
+      return 0;
+    *ip |= part << shift;   
+    bufferptr = dot + 1;
+  }
+  /* not a number */
+  if ((part = strtol(bufferptr, (char**)NULL, 10)) < 0) 
+    return 0;
+  /* to big number */
+  if (part > 255)
+    return 0;
+  *ip |= part;
+  return 1;
+}
+
+static void parsenetwork(const char *parameter, u_int32_t *network) {
+  if (!parseip(parameter, network))
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong ip in network");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong ip in network");
+#endif
+}
+
+static void parsenetmaskasbits(const char *parameter, u_int32_t *netmask) {
+  
+  u_int32_t bits;
+  
+  if ((bits = strtol(parameter, (char **)NULL, 10)) < 0 || bits > 32)
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong netmask");
+#endif
+
+  *netmask = 0xffffffff << (32 - bits);
+}
+
+static void parsenetmaskasip(const char *parameter, u_int32_t *netmask) {
+  if (!parseip(parameter, netmask))
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong ip in netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong ip in netmask");
+#endif
+}
+
+static void parsenetmask(const char *parameter, u_int32_t *netmask) 
+{
+  if (strchr(parameter, '.') != NULL)
+    parsenetmaskasip(parameter, netmask);
+  else
+    parsenetmaskasbits(parameter, netmask);
+}
+
+static void parsenetworkandnetmask(const char *parameter, u_int32_t *network, u_int32_t *netmask) 
+{
+  
+  char buffer[32], *slash;
+
+  if (strlen(parameter) > 31)
+    /* text is to long, even for 255.255.255.255/255.255.255.255 */
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#endif
+
+  strncpy(buffer, parameter, 31);
+  buffer[31] = 0;
+
+  /* check whether netmask is given */
+  if ((slash = strchr(buffer, '/')) != NULL) {
+    parsenetmask(slash + 1, netmask);
+    *slash = 0;
+  } else
+    *netmask = 0xffffffff;
+  parsenetwork(buffer, network);
+
+  if ((*network & *netmask) != *network)
+#ifdef XTABLES_VERSION
+    xtables_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#endif
+}
+
+
+/* Function gets network & netmask from argument after --aaddr */
+static void parse_network(const char *parameter, struct t_ipt_account_info *info) {
+
+  parsenetworkandnetmask(parameter, &info->network, &info->netmask);
+  
+}
+
+/* validate netmask */
+#ifndef CONFIG_TOOLCHAIN73
+inline int valid_netmask(u_int32_t netmask) {
+#else
+int valid_netmask(u_int32_t netmask) {
+#endif
+  while (netmask & 0x80000000)
+    netmask <<= 1;
+  if (netmask != 0)
+    return 0;
+        return 1;
+}
+
+/* validate network/netmask pair */
+#ifndef CONFIG_TOOLCHAIN73
+inline int valid_network_and_netmask(struct t_ipt_account_info *info) {
+#else
+int valid_network_and_netmask(struct t_ipt_account_info *info) {
+#endif
+  if (!valid_netmask(info->netmask))
+    return 0;
+  if ((info->network & info->netmask) != info->network)
+    return 0;
+  return 1;
+}
+
+
+
+/* Function initializes match */
+#ifdef XTABLES_VERSION
+static void init(struct xt_entry_match *match)
+#else
+static void init(struct ipt_entry_match *match, 
+     unsigned int *nfcache)
+#endif  
+{
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)(match)->data;
+
+
+  /* set default table name to DEFAULT */
+  strncpy(info->name, "DEFAULT", IPT_ACCOUNT_NAME_LEN);
+  info->shortlisting = 0;
+  info->table = NULL;
+  
+}
+
+/* Function parses match's arguments */
+static int parse(int c, 
+    char **argv, 
+    int invert, 
+    unsigned int *flags,
+#ifdef XTABLES_VERSION    
+    const void *entry,
+    struct xt_entry_match **match
+#else
+    const struct ipt_entry *entry,
+    unsigned int *nfcache,
+    struct ipt_entry_match **match
+#endif 
+    )
+{ 
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)(*match)->data;
+
+  switch (c) {
+    
+    /* --aaddr */
+    case 201:
+      parse_network(optarg, info);
+      if (!valid_network_and_netmask(info))
+#ifdef XTABLES_VERSION    
+        xtables_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#else
+        exit_error(PARAMETER_PROBLEM, "account: wrong network/netmask");
+#endif
+      *flags = 1;
+      break;
+      
+    /* --aname */
+    case 202:
+      if (strlen(optarg) < IPT_ACCOUNT_NAME_LEN) {
+        strncpy(info->name, optarg, IPT_ACCOUNT_NAME_LEN);
+        info->name[IPT_ACCOUNT_NAME_LEN] = '\0';
+      } else
+#ifdef XTABLES_VERSION    
+        xtables_error(PARAMETER_PROBLEM, "account: Too long table name");      
+#else
+        exit_error(PARAMETER_PROBLEM, "account: Too long table name");      
+#endif
+      break;  
+    /* --ashort */
+    case 203:
+      info->shortlisting = 1;
+      break;
+    default:
+      return 0;     
+  }
+  return 1; 
+}
+
+/* Final check whether network/netmask was specified */
+static void final_check(unsigned int flags) {
+  if (!flags)
+#ifdef XTABLES_VERSION    
+    xtables_error(PARAMETER_PROBLEM, "account: You need specify '--aaddr' parameter");
+#else
+    exit_error(PARAMETER_PROBLEM, "account: You need specify '--aaddr' parameter");
+#endif
+}
+
+/* Function used for printing rule with account match for iptables -L */
+static void print(
+#ifdef XTABLES_VERSION    
+    const void *ip, 
+    const struct xt_entry_match *match,
+#else
+    const struct ipt_ip *ip,
+    const struct ipt_entry_match *match,
+#endif
+    int numeric) {
+  
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)match->data;
+  
+  printf("account: ");
+  printf("network/netmask: ");
+  printf("%u.%u.%u.%u/%u.%u.%u.%u ",
+      HIPQUAD(info->network),
+      HIPQUAD(info->netmask)
+        );
+  
+  printf("name: %s ", info->name);
+  if (info->shortlisting)
+    printf("short-listing ");
+}
+
+/* Function used for saving rule containing account match */
+static void save(
+#ifdef XTABLES_VERSION
+    const void *ip,
+    const struct xt_entry_match *match
+#else
+    const struct ipt_ip *ip, 
+    const struct ipt_entry_match *match
+#endif
+) {
+
+  struct t_ipt_account_info *info = (struct t_ipt_account_info *)match->data;
+  
+  printf(" --aaddr ");
+  printf("%u.%u.%u.%u/%u.%u.%u.%u ",
+       HIPQUAD(info->network),
+       HIPQUAD(info->netmask)
+         );
+  
+  printf("--aname %s", info->name);
+  if (info->shortlisting)
+    printf("--ashort ");
+}
+
+#ifdef XTABLES_VERSION
+static struct xtables_match account = {
+  .name = "account",
+  .version = XTABLES_VERSION,
+  .family = PF_INET,
+  .size = XT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .userspacesize = XT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .help = help,
+  .init = init,
+  .parse = parse,
+  .final_check = final_check,
+  .print = print,
+  .save = save,
+  .extra_opts = opts
+};
+#else
+static struct iptables_match account = {
+  .next = NULL,
+  .name = "account",
+  .version = IPTABLES_VERSION,
+  .size = IPT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .userspacesize = IPT_ALIGN(sizeof(struct t_ipt_account_info)),
+  .help = &help,
+  .init = &init,
+  .parse = &parse,
+  .final_check = &final_check,
+  .print = &print,
+  .save = &save,
+  .extra_opts = opts
+};
+#endif
+
+/* Function which registers match */
+void _init(void)
+{
+#ifdef XTABLES_VERSION
+  xtables_register_match(&account);
+#else
+  register_match(&account);
+#endif
+}
+  
--- iptables-1.8.x/extensions/libipt_condition.c
+++ iptables-1.8.x/extensions/libipt_condition.c
@@ -0,0 +1,102 @@
+/* Shared library add-on to iptables for condition match */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <xtables.h>
+
+#include<linux/netfilter_ipv4/ip_tables.h>
+#include<linux/netfilter_ipv4/ipt_condition.h>
+
+
+static void
+help(void)
+{
+	printf("condition match v%s options:\n"
+	       "--condition [!] filename       "
+	       "Match on boolean value stored in /proc file\n",
+	       XTABLES_VERSION);
+}
+
+
+static struct option opts[] = {
+	{ .name = "condition", .has_arg = true, .val = 'X' },
+	XT_GETOPT_TABLEEND
+};
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry, struct xt_entry_match **match)
+{
+	struct condition_info *info =
+	    (struct condition_info *) (*match)->data;
+
+	if (c == 'X') {
+		if (*flags)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify multiple conditions");
+
+		if (strlen(argv[optind - 1]) < CONDITION_NAME_LEN)
+			strcpy(info->name, argv[optind - 1]);
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "File name too long");
+
+		info->invert = invert;
+		*flags = 1;
+		return 1;
+	}
+
+	return 0;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "Condition match: must specify --condition");
+}
+
+
+static void
+print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct condition_info *info =
+	    (const struct condition_info *) match->data;
+
+	printf("condition %s%s ", (info->invert) ? "!" : "", info->name);
+}
+
+
+static void
+save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct condition_info *info =
+	    (const struct condition_info *) match->data;
+
+	printf("--condition %s\"%s\" ", (info->invert) ? "! " : "", info->name);
+}
+
+
+static struct xtables_match condition = {
+	.name 		= "condition",
+	.version 	= XTABLES_VERSION,
+	.size 		= XT_ALIGN(sizeof(struct condition_info)),
+	.userspacesize 	= XT_ALIGN(sizeof(struct condition_info)),
+	.help 		= &help,
+	.parse 		= &parse,
+	.final_check	= &final_check,
+	.print 		= &print,
+	.save 		= &save,
+	.extra_opts 	= opts
+};
+
+
+void
+_init(void)
+{
+	xtables_register_match(&condition);
+}
--- iptables-1.8.x/extensions/libipt_condition.man
+++ iptables-1.8.x/extensions/libipt_condition.man
@@ -0,0 +1,4 @@
+This matches if a specific /proc filename is '0' or '1'.
+.TP
+.BI "--condition " "[!] \fIfilename\fP"
+Match on boolean value stored in /proc/net/ipt_condition/filename file
--- iptables-1.8.x/extensions/libipt_geoip.c
+++ iptables-1.8.x/extensions/libipt_geoip.c
@@ -0,0 +1,337 @@
+/* Shared library add-on to iptables to add geoip match support.
+
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Copyright (c) 2004 Cookinglinux
+
+ * For comments, bugs or suggestions, please contact
+ * Samuel Jean       <sjean at cookinglinux.org>
+ * Nicolas Bouliane  <nib at cookinglinux.org>
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <stddef.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_geoip.h>
+
+static void geoip_help(void)
+{
+   printf (
+            "GeoIP v%s options:\n"
+            "        [!]   --src-cc, --source-country country[,country,country,...]\n"
+            "                                                     Match packet coming from (one of)\n"
+            "                                                     the specified country(ies)\n"
+            "\n"
+            "        [!]   --dst-cc, --destination-country country[,country,country,...]\n"
+            "                                                     Match packet going to (one of)\n"
+            "                                                     the specified country(ies)\n"
+            "\n"
+            "           NOTE: The country is inputed by its ISO3166 code.\n"
+            "\n"
+            "\n", XTABLES_VERSION
+         );
+}
+
+static struct option geoip_opts[] = {
+   {.name = "dst-cc", .has_arg = true, .val = '2'  }, /* Alias for --destination-country */
+   {.name = "destination-country", .has_arg = true, .val = '2'  },
+   {.name = "src-cc", .has_arg = true, .val = '1'  }, /* Alias for --source-country */
+   {.name = "source-country", .has_arg = true, .val = '1'  },
+   XT_GETOPT_TABLEEND,
+};
+
+static void
+geoip_init(struct xt_entry_match *m)
+{
+}
+
+/* NOT IMPLEMENTED YET
+static void geoip_free(struct geoip_info *oldmem)
+{
+}
+*/
+
+struct geoip_index {
+   u_int16_t cc;
+   u_int32_t offset;
+} __attribute__ ((packed));
+
+static struct geoip_subnet *
+get_country_subnets(u_int16_t cc, u_int32_t *count)
+{
+   FILE *ixfd, *dbfd;
+   struct geoip_subnet *subnets;
+   struct geoip_index *index_1;
+   struct stat buf;
+
+   size_t idxsz;
+   u_int16_t i;
+
+   u_int16_t db_cc = 0;
+   u_int16_t db_nsubnets = 0;
+
+   if ((ixfd = fopen("/var/geoip/geoipdb.idx", "r")) == NULL) {
+         perror("/var/geoip/geoipdb.idx");
+         xtables_error(OTHER_PROBLEM,
+               "geoip match: cannot open geoip's database index file");
+   }
+
+   stat("/var/geoip/geoipdb.idx", &buf);
+   idxsz = buf.st_size/sizeof(struct geoip_index);
+   index_1 = (struct geoip_index *)malloc(buf.st_size);
+
+   fread(index_1, buf.st_size, 1, ixfd);
+
+   for (i = 0; i < idxsz; i++)
+      if (cc == index_1[i].cc)
+         break;
+
+   if (cc != index_1[i].cc)
+      xtables_error(OTHER_PROBLEM,
+            "geoip match: sorry, '%c%c' isn't in the database\n", COUNTRY(cc));
+
+   fclose(ixfd);
+
+   if ((dbfd = fopen("/var/geoip/geoipdb.bin", "r")) == NULL) {
+      perror("/var/geoip/geoipdb.bin");
+      xtables_error(OTHER_PROBLEM,
+            "geoip match: cannot open geoip's database file");
+   }
+
+   fseek(dbfd, index_1[i].offset, SEEK_SET);
+   fread(&db_cc, sizeof(u_int16_t), 1, dbfd);
+
+   if (db_cc != cc)
+      xtables_error(OTHER_PROBLEM,
+            "geoip match: this shouldn't happened, the database might be corrupted, or there's a bug.\n"
+            "you should contact maintainers");
+
+   fread(&db_nsubnets, sizeof(u_int16_t), 1, dbfd);
+
+   subnets = (struct geoip_subnet*)malloc(db_nsubnets * sizeof(struct geoip_subnet));
+
+   if (!subnets)
+      xtables_error(OTHER_PROBLEM,
+            "geoip match: insufficient memory available");
+
+   fread(subnets, db_nsubnets * sizeof(struct geoip_subnet), 1, dbfd);
+
+   fclose(dbfd);
+   free(index_1);
+   *count = db_nsubnets;
+   return subnets;
+}
+
+static struct geoip_info *
+load_geoip_cc(u_int16_t cc)
+{
+   static struct geoip_info *ginfo;
+   ginfo = malloc(sizeof(struct geoip_info));
+
+   if (!ginfo)
+      return NULL;
+
+   ginfo->subnets = get_country_subnets(cc, &ginfo->count);
+   ginfo->cc = cc;
+
+   return ginfo;
+}
+
+static u_int16_t
+check_geoip_cc(char *cc, u_int16_t cc_used[], u_int8_t count)
+{
+   u_int8_t i;
+   u_int16_t cc_int16;
+
+   if (strlen(cc) != 2) /* Country must be 2 chars long according
+                                        to the ISO3166 standard */
+    xtables_error(PARAMETER_PROBLEM,
+         "geoip match: invalid country code '%s'", cc);
+
+   // Verification will fail if chars aren't uppercased.
+   // Make sure they are..
+   for (i = 0; i < 2; i++)
+      if (isalnum(cc[i]) != 0)
+         cc[i] = toupper(cc[i]);
+      else
+         xtables_error(PARAMETER_PROBLEM,
+               "geoip match:  invalid country code '%s'", cc);
+
+   /* Convert chars into a single 16 bit integer.
+    * FIXME:   This assumes that a country code is
+    *          exactly 2 chars long. If this is
+    *          going to change someday, this whole
+    *          match will need to be rewritten, anyway.
+    *                                  - SJ  */
+   cc_int16 = (cc[0]<<8) + cc[1];
+
+   // Check for presence of value in cc_used
+   for (i = 0; i < count; i++)
+      if (cc_int16 == cc_used[i])
+         return 0; // Present, skip it!
+
+   return cc_int16;
+}
+
+/* Based on libipt_multiport.c parsing code. */
+static u_int8_t
+parse_geoip_cc(const char *ccstr, u_int16_t *cc, struct geoip_info **mem)
+{
+   char *buffer, *cp, *next;
+   u_int8_t i, count = 0;
+   u_int16_t cctmp;
+
+   buffer = strdup(ccstr);
+   if (!buffer) xtables_error(OTHER_PROBLEM,
+         "geoip match: insufficient memory available");
+
+   for (cp = buffer, i = 0; cp && i < IPT_GEOIP_MAX; cp = next, i++)
+   {
+      next = strchr(cp, ',');
+      if (next) *next++ = '\0';
+
+      if ((cctmp = check_geoip_cc(cp, cc, count)) != 0) {
+         if ((mem[count++] = load_geoip_cc(cctmp)) == NULL)
+            xtables_error(OTHER_PROBLEM,
+                  "geoip match: insufficient memory available");
+         cc[count-1] = cctmp;
+         }
+   }
+
+   if (cp) xtables_error(PARAMETER_PROBLEM,
+         "geoip match: too many countries specified");
+   free(buffer);
+
+   if (count == 0) xtables_error(PARAMETER_PROBLEM,
+         "geoip match: don't know what happened");
+
+   return count;
+}
+
+static int
+geoip_parse(int c, char **argv, int invert, unsigned int *flags,
+                 const void *entry,
+                 struct xt_entry_match **match)
+{
+   struct ipt_geoip_info *info
+      = (struct ipt_geoip_info *)(*match)->data;
+
+    switch(c) {
+      case '1':
+         // Ensure that IPT_GEOIP_SRC *OR* IPT_GEOIP_DST haven't been used yet.
+         if (*flags & (IPT_GEOIP_SRC | IPT_GEOIP_DST))
+            xtables_error(PARAMETER_PROBLEM,
+                  "geoip match: only use --source-country *OR* --destination-country once!");
+
+         *flags |= IPT_GEOIP_SRC;
+         break;
+
+      case '2':
+         // Ensure that IPT_GEOIP_SRC *OR* IPT_GEOIP_DST haven't been used yet.
+         if (*flags & (IPT_GEOIP_SRC | IPT_GEOIP_DST))
+            xtables_error(PARAMETER_PROBLEM,
+                  "geoip match: only use --source-country *OR* --destination-country once!");
+
+         *flags |= IPT_GEOIP_DST;
+         break;
+
+      default:
+         return 0;
+    }
+
+    if (invert)
+       *flags |= IPT_GEOIP_INV;
+
+    info->count = parse_geoip_cc(argv[optind-1], info->cc, info->mem);
+    info->flags = *flags;
+    info->refcount = NULL;
+    //info->fini = &geoip_free;
+
+    return 1;
+}
+
+static void
+geoip_final_check(unsigned int flags)
+{
+   if (!flags)
+      xtables_error(PARAMETER_PROBLEM,
+            "geoip match: missing arguments");
+}
+
+static void
+geoip_print(const void *ip,
+                  const struct xt_entry_match *match,
+                  int numeric)
+{
+   const struct ipt_geoip_info *info
+      = (const struct ipt_geoip_info *)match->data;
+
+   u_int8_t i;
+
+   if (info->flags & IPT_GEOIP_SRC)
+      printf("Source ");
+   else printf("Destination ");
+
+   if (info->count > 1)
+      printf("countries: ");
+   else printf("country: ");
+
+   if (info->flags & IPT_GEOIP_INV)
+      printf("! ");
+
+   for (i = 0; i < info->count; i++)
+       printf("%s%c%c", i ? "," : "", COUNTRY(info->cc[i]));
+   printf(" ");
+}
+
+	void (*save)(const void *ip, const struct xt_entry_match *match);
+static void
+geoip_save(const void *ip,
+                 const struct xt_entry_match *match)
+{
+   const struct ipt_geoip_info *info
+      = (const struct ipt_geoip_info *)match->data;
+   u_int8_t i;
+
+   if (info->flags & IPT_GEOIP_INV)
+      printf("! ");
+
+   if (info->flags & IPT_GEOIP_SRC)
+      printf("--source-country ");
+   else printf("--destination-country ");
+
+   for (i = 0; i < info->count; i++)
+      printf("%s%c%c", i ? "," : "", COUNTRY(info->cc[i]));
+   printf(" ");
+}
+
+static struct xtables_match geoip = {
+    .family          = NFPROTO_IPV4,
+    .name            = "geoip",
+    .version         = XTABLES_VERSION,
+    .size            = XT_ALIGN(sizeof(struct ipt_geoip_info)),
+    .userspacesize   = offsetof(struct ipt_geoip_info, mem),
+    .help            = geoip_help,
+    .init            = geoip_init,
+    .parse           = geoip_parse,
+    .final_check     = geoip_final_check,
+    .print           = geoip_print,
+    .save            = geoip_save,
+    .extra_opts      = geoip_opts
+};
+
+void _init(void)
+{
+   xtables_register_match(&geoip);
+}
--- iptables-1.8.x/extensions/libipt_geoip.man
+++ iptables-1.8.x/extensions/libipt_geoip.man
@@ -0,0 +1,15 @@
+Match a packet by its source or destination country.
+.TP
+[\fB!\fR] \fB--src-cc\fR, \fB--source-country \fIcountry\fR[\fB,\fIcountry\fB,\fIcountry\fB,\fI...\fR]
+Match packet coming from (one of) the specified country(ies)
+.TP
+[\fB!\fR] \fB--dst-cc\fR, \fB--destination-country \fIcountry\fR[\fB,\fIcountry\fB,\fIcountry\fB,\fI...\fR]
+Match packet going to (one of) the specified country(ies)
+.TP
+NOTE:
+The country is inputed by its ISO3166 code.
+.P
+The only extra files you need is a binary db (geoipdb.bin) & its index file (geoipdb.idx).
+Both files are generated from a countries & subnets database with the csv2bin tool,
+available at www.cookinglinux.org/geoip/. Both files MUST also be moved in /var/geoip/
+as the shared library is statically looking for that pathname (ex.: /var/geoip/geoipdb.bin).
--- iptables-1.8.x/extensions/libipt_ipp2p.c
+++ iptables-1.8.x/extensions/libipt_ipp2p.c
@@ -0,0 +1,409 @@
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ipt_ipp2p.h>
+
+#ifdef IPT_LIB_DIR
+#define xtables_match iptables_match
+#define xtables_register_match register_match
+#endif
+
+static void
+help(void)
+{
+    printf(
+    "IPP2P v%s options:\n"
+    " --ipp2p	Grab all known p2p packets\n"
+    " --edk		[TCP&UDP]	All known eDonkey/eMule/Overnet packets\n"
+    " --dc		[TCP] 		All known Direct Connect packets\n"
+    " --kazaa	[TCP&UDP] 	All known KaZaA packets\n"
+    " --gnu		[TCP&UDP]	All known Gnutella packets\n"
+    " --bit		[TCP&UDP]	All known BitTorrent packets\n"
+    " --apple	[TCP] 		All known AppleJuice packets\n"
+    " --winmx	[TCP] 		All known WinMX\n"
+    " --soul		[TCP] 		All known SoulSeek\n"
+    " --ares		[TCP] 		All known Ares\n\n"
+    " EXPERIMENTAL protocols (please send feedback to: ipp2p@ipp2p.org) :\n"
+    " --mute		[TCP]		All known Mute packets\n"
+    " --waste	[TCP]		All known Waste packets\n"
+    " --xdcc		[TCP]		All known XDCC packets (only xdcc login)\n\n"
+    " DEBUG SUPPPORT, use only if you know why\n"
+    " --debug		Generate kernel debug output, THIS WILL SLOW DOWN THE FILTER\n"
+    "\nNote that the follwing options will have the same meaning:\n"
+    " '--ipp2p' is equal to '--edk --dc --kazaa --gnu --bit --apple --winmx --soul --ares'\n"
+    "\nIPP2P was intended for TCP only. Due to increasing usage of UDP we needed to change this.\n"
+    "You can now use -p udp to search UDP packets only or without -p switch to search UDP and TCP packets.\n"
+    "\nSee README included with this package for more details or visit http://www.ipp2p.org\n"
+    "\nExamples:\n"
+    " iptables -A FORWARD -m ipp2p --ipp2p -j MARK --set-mark 0x01\n"
+    " iptables -A FORWARD -p udp -m ipp2p --kazaa --bit -j DROP\n"
+    " iptables -A FORWARD -p tcp -m ipp2p --edk --soul -j DROP\n\n"
+    , IPP2P_VERSION);
+}
+
+static struct option opts[] = {
+	{.name = "ipp2p", .has_arg = false, .val = '1'},
+	{.name = "edk", .has_arg = false, .val = '2'},
+	{.name = "dc", .has_arg = false, .val = '7'},
+	{.name = "gnu", .has_arg = false, .val = '9'},
+	{.name = "kazaa", .has_arg = false, .val = 'a'},
+	{.name = "bit", .has_arg = false, .val = 'b'},
+	{.name = "apple", .has_arg = false, .val = 'c'},
+	{.name = "soul", .has_arg = false, .val = 'd'},
+	{.name = "winmx", .has_arg = false, .val = 'e'},
+	{.name = "ares", .has_arg = false, .val = 'f'},
+	{.name = "mute", .has_arg = false, .val = 'g'},
+	{.name = "waste", .has_arg = false, .val = 'h'},
+	{.name = "xdcc", .has_arg = false, .val = 'i'},
+	{.name = "debug", .has_arg = false, .val = 'j'},
+	XT_GETOPT_TABLEEND,
+};
+
+
+static void
+#ifdef _XTABLES_H
+init(struct xt_entry_match *m)
+#else
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+#endif
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)m->data;
+
+#ifndef _XTABLES_H
+    *nfcache |= NFC_UNKNOWN;
+#endif
+
+    /*init the module with default values*/
+    info->cmd = 0;
+    info->debug = 0;
+
+}
+
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+#ifdef _XTABLES_H
+      const void *entry, struct xt_entry_match **match)
+#else
+      const struct ipt_entry *entry, unsigned int *nfcache, struct ipt_entry_match **match)
+#endif
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)(*match)->data;
+
+    switch (c) {
+	case '1':		/*cmd: ipp2p*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified once!");
+
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");
+*/
+
+	    if ((*flags) != 0)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += SHORT_HAND_IPP2P;
+	    info->cmd = *flags;
+	    break;
+
+	case '2':		/*cmd: edk*/
+	    if ((*flags & IPP2P_EDK) == IPP2P_EDK)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--edk' may only be "
+				"specified once");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+            if ((*flags & IPP2P_DATA_EDK) == IPP2P_DATA_EDK)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--edk' OR `--edk-data' but not both of them!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += IPP2P_EDK;
+	    info->cmd = *flags;
+	    break;
+
+
+	case '7':		/*cmd: dc*/
+            if ((*flags & IPP2P_DC) == IPP2P_DC)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--dc' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+            if ((*flags & IPP2P_DATA_DC) == IPP2P_DATA_DC)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--dc' OR `--dc-data' but not both of them!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_DC;
+	    info->cmd = *flags;
+	    break;
+
+
+	case '9':		/*cmd: gnu*/
+            if ((*flags & IPP2P_GNU) == IPP2P_GNU)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--gnu' may only be "
+                                "specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+            if ((*flags & IPP2P_DATA_GNU) == IPP2P_DATA_GNU)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--gnu' OR `--gnu-data' but not both of them!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_GNU;
+	    info->cmd = *flags;
+	    break;
+
+	case 'a':		/*cmd: kazaa*/
+            if ((*flags & IPP2P_KAZAA) == IPP2P_KAZAA)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--kazaa' may only be "
+                                "specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+            if ((*flags & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--kazaa' OR `--kazaa-data' but not both of them!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_KAZAA;
+	    info->cmd = *flags;
+	    break;
+
+	case 'b':		/*cmd: bit*/
+            if ((*flags & IPP2P_BIT) == IPP2P_BIT)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--bit' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_BIT;
+	    info->cmd = *flags;
+	    break;
+
+	case 'c':		/*cmd: apple*/
+            if ((*flags & IPP2P_APPLE) == IPP2P_APPLE)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--apple' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_APPLE;
+	    info->cmd = *flags;
+	    break;
+
+
+	case 'd':		/*cmd: soul*/
+            if ((*flags & IPP2P_SOUL) == IPP2P_SOUL)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--soul' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_SOUL;
+	    info->cmd = *flags;
+	    break;
+
+
+	case 'e':		/*cmd: winmx*/
+            if ((*flags & IPP2P_WINMX) == IPP2P_WINMX)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--winmx' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WINMX;
+	    info->cmd = *flags;
+	    break;
+
+	case 'f':		/*cmd: ares*/
+            if ((*flags & IPP2P_ARES) == IPP2P_ARES)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    xtables_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_ARES;
+	    info->cmd = *flags;
+	    break;
+
+	case 'g':		/*cmd: mute*/
+            if ((*flags & IPP2P_MUTE) == IPP2P_MUTE)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--mute' may only be "
+                                "specified once!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_MUTE;
+	    info->cmd = *flags;
+	    break;
+	case 'h':		/*cmd: waste*/
+            if ((*flags & IPP2P_WASTE) == IPP2P_WASTE)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--waste' may only be "
+                                "specified once!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WASTE;
+	    info->cmd = *flags;
+	    break;
+	case 'i':		/*cmd: xdcc*/
+            if ((*flags & IPP2P_XDCC) == IPP2P_XDCC)
+            xtables_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_XDCC;
+	    info->cmd = *flags;
+	    break;
+
+	case 'j':		/*cmd: debug*/
+	    if (invert) xtables_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    info->debug = 1;
+	    break;
+
+	default:
+//            xtables_error(PARAMETER_PROBLEM,
+//	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+	    return 0;
+    }
+    return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+    if (!flags)
+            xtables_error(PARAMETER_PROBLEM,
+	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+}
+
+static void
+print(const void *ip,
+      const struct xt_entry_match *match,
+	int numeric)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+
+    printf("ipp2p v%s", IPP2P_VERSION);
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf(" --ipp2p");
+//    if ((info->cmd & SHORT_HAND_DATA) == SHORT_HAND_DATA) printf(" --ipp2p-data");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf(" --kazaa");
+//    if ((info->cmd & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA) printf(" --kazaa-data");
+//    if ((info->cmd & IPP2P_DATA_GNU) == IPP2P_DATA_GNU) printf(" --gnu-data");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf(" --gnu");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf(" --edk");
+//    if ((info->cmd & IPP2P_DATA_EDK) == IPP2P_DATA_EDK) printf(" --edk-data");
+//    if ((info->cmd & IPP2P_DATA_DC) == IPP2P_DATA_DC) printf(" --dc-data");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf(" --dc");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf(" --bit");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf(" --apple");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf(" --soul");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf(" --winmx");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf(" --ares");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf(" --debug");
+    printf(" ");
+}
+
+static void
+save(const void *ip,
+     const struct xt_entry_match *match)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf(" --ipp2p");
+//    if ((info->cmd & SHORT_HAND_DATA) == SHORT_HAND_DATA) printf(" --ipp2p-data");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf(" --kazaa");
+//    if ((info->cmd & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA) printf(" --kazaa-data");
+//    if ((info->cmd & IPP2P_DATA_GNU) == IPP2P_DATA_GNU) printf(" --gnu-data");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf(" --gnu");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf(" --edk");
+//    if ((info->cmd & IPP2P_DATA_EDK) == IPP2P_DATA_EDK) printf(" --edk-data");
+//    if ((info->cmd & IPP2P_DATA_DC) == IPP2P_DATA_DC) printf(" --dc-data");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf(" --dc");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf(" --bit");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf(" --apple");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf(" --soul");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf(" --winmx");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf(" --ares");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf(" --debug");
+}
+
+
+static
+struct xtables_match ipp2p=
+{
+    .family         = NFPROTO_IPV4,
+    .name           = "ipp2p",
+    .version        = XTABLES_VERSION,
+    .size           = XT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .userspacesize  = XT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .help           = &help,
+    .init           = &init,
+    .parse          = &parse,
+    .final_check    = &final_check,
+    .print          = &print,
+    .save           = &save,
+    .extra_opts     = opts
+};
+
+
+
+void _init(void)
+{
+    xtables_register_match(&ipp2p);
+}
--- iptables-1.8.x/extensions/libipt_ipp2p.man
+++ iptables-1.8.x/extensions/libipt_ipp2p.man
@@ -0,0 +1,43 @@
+This module matches certain packets in P2P flows. It is not
+designed to match all packets belonging to a P2P connection - 
+use IPP2P together with CONNMARK for this purpose. Also visit
+http://www.ipp2p.org for detailed information.
+
+Use it together with -p tcp or -p udp to search these protocols
+only or without -p switch to search packets of both protocols.
+
+IPP2P provides the following options:
+.TP
+.B "--edk "
+Matches as many eDonkey/eMule packets as possible.
+.TP
+.B "--kazaa "
+Matches as many KaZaA packets as possible.
+.TP
+.B "--gnu "
+Matches as many Gnutella packets as possible.
+.TP
+.B "--dc "
+Matches as many Direct Connect packets as possible.
+.TP
+.B "--bit "
+Matches BitTorrent packets.
+.TP
+.B "--apple "
+Matches AppleJuice packets.
+.TP
+.B "--soul "
+Matches some SoulSeek packets. Considered as beta, use careful!
+.TP
+.B "--winmx "
+Matches some WinMX packets. Considered as beta, use careful!
+.TP
+.B "--ares "
+Matches Ares and AresLite packets. Use together with -j DROP only.
+.TP
+.B "--ipp2p "
+Short hand for: --edk --kazaa --gnu --dc
+.TP
+.B "--debug "
+Prints some information about each hit into kernel logfile. May 
+produce huge logfiles so beware!
--- iptables-1.8.x/extensions/libipt_layer7.c
+++ iptables-1.8.x/extensions/libipt_layer7.c
@@ -0,0 +1,392 @@
+/* 
+   Shared library add-on to iptables to add layer 7 matching support. 
+  
+   By Matthew Strait <quadong@users.sf.net>, Oct 2003.
+
+   http://l7-filter.sf.net 
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License
+   as published by the Free Software Foundation; either version
+   2 of the License, or (at your option) any later version.
+   http://www.gnu.org/licenses/gpl.txt
+
+   Based on libipt_string.c (C) 2000 Emmanuel Roger <winfield@freegates.be>
+*/
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <dirent.h>
+
+#include "iptables.h"
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_layer7.h>
+
+#define MAX_FN_LEN 256
+
+static char l7dir[MAX_FN_LEN] = "\0";
+
+/* Function which prints out usage message. */
+static void layer7_help(void)
+{
+	printf(
+	"LAYER7 match v%s options:\n"
+	"--l7dir <directory>  : Look for patterns here instead of /etc/l7-protocols/\n"
+	"                       (--l7dir must be specified before --l7proto if used!)\n"
+	"--l7proto [!] <name> : Match the protocol defined in /etc/l7-protocols/name.pat\n",
+	XTABLES_VERSION);
+}
+
+static struct option layer7_opts[] = {
+	{.name = "l7proto", .has_arg = true, .val = '1' },
+	{.name = "l7dir", .has_arg = true, .val = '2' },
+	XT_GETOPT_TABLEEND,
+};
+
+/* reads filename, puts protocol info into layer7_protocol_info, number of protocols to numprotos */
+static int parse_protocol_file(char * filename, const char * protoname, struct xt_layer7_info *info)
+{
+	FILE * f;
+	char * linebuf = NULL;
+	size_t len = 0;
+
+	enum { protocol, pattern, done } datatype = protocol;
+
+	f = fopen(filename, "r");
+
+	if(!f)
+		return 0;
+
+	while(getline(&linebuf, &len, f) != -1)
+	{
+		if(strlen(linebuf) < 2 || linebuf[0] == '#')
+			continue;
+
+		/* strip the pesky newline... */
+		if(linebuf[strlen(linebuf) - 1] == '\n')
+			linebuf[strlen(linebuf) - 1] = '\0';
+
+		if(datatype == protocol)
+		{
+			/* Ignore everything on the linebuf beginning with the
+			first space or tab . For instance, this allows the
+			protocol linebuf in http.pat to be "http " (or
+			"http I am so cool") instead of just "http". */
+			if(strchr(linebuf, ' ')){
+				char * space = strchr(linebuf, ' ');
+				space[0] = '\0';
+			}
+			if(strchr(linebuf, '\t')){
+				char * space = strchr(linebuf, '\t');
+				space[0] = '\0';
+			}
+
+			/* sanity check.  First non-comment non-blank
+			linebuf must be the same as the file name. */
+			if(strcmp(linebuf, protoname))
+				xtables_error(OTHER_PROBLEM,
+					"Protocol name (%s) doesn't match file name (%s).  Bailing out\n",
+					linebuf, filename);
+
+			if(strlen(linebuf) >= MAX_PROTOCOL_LEN)
+				 xtables_error(PARAMETER_PROBLEM,
+					"Protocol name in %s too long!", filename);
+			strncpy(info->protocol, linebuf, MAX_PROTOCOL_LEN);
+
+			datatype = pattern;
+		}
+		else if(datatype == pattern)
+		{
+			if(strlen(linebuf) >= MAX_PATTERN_LEN)
+				 xtables_error(PARAMETER_PROBLEM, "Pattern in %s too long!", filename);
+			strncpy(info->pattern, linebuf, MAX_PATTERN_LEN);
+			
+			datatype = done;			
+			break;
+		}
+		else
+			xtables_error(OTHER_PROBLEM, "Internal error");
+	}
+
+	if(datatype != done)
+		xtables_error(OTHER_PROBLEM, "Failed to get all needed data from %s", filename);
+
+	if(linebuf) free(linebuf);
+	fclose(f);
+
+	return 1;
+
+/*
+	fprintf(stderr, "protocol: %s\npattern: %s\n\n",
+			info->protocol,
+			info->pattern);
+*/
+}
+
+static int hex2dec(char c)
+{
+        switch (c)
+        {
+                case '0' ... '9':
+                        return c - '0';
+                case 'a' ... 'f':
+                        return c - 'a' + 10;
+                case 'A' ... 'F':
+                        return c - 'A' + 10;
+                default:
+                        xtables_error(OTHER_PROBLEM, "hex2dec: bad value!\n");
+                        return 0;
+        }
+}
+
+/* takes a string with \xHH escapes and returns one with the characters
+they stand for */
+static char * pre_process(char * s)
+{
+	char * result = malloc(strlen(s) + 1);
+	int sindex = 0, rindex_1 = 0;
+        while( sindex < strlen(s) )
+        {
+            if( sindex + 3 < strlen(s) &&
+                s[sindex] == '\\' && s[sindex+1] == 'x' &&
+                isxdigit(s[sindex + 2]) && isxdigit(s[sindex + 3]) )
+                {
+                        /* carefully remember to call tolower here... */
+                        result[rindex_1] = tolower( hex2dec(s[sindex + 2])*16 +
+                                                  hex2dec(s[sindex + 3] ) );
+
+			switch ( result[rindex_1] )
+			{
+			case 0x24:
+			case 0x28:
+			case 0x29:
+			case 0x2a:
+			case 0x2b:
+			case 0x2e:
+			case 0x3f:
+			case 0x5b:
+			case 0x5c:
+			case 0x5d:
+			case 0x5e:
+			case 0x7c:
+				fprintf(stderr,
+					"Warning: layer7 regexp contains a control character, %c, in hex (\\x%c%c).\n"
+					"I recommend that you write this as %c or \\%c, depending on what you meant.\n",
+					result[rindex_1], s[sindex + 2], s[sindex + 3], result[rindex_1], result[rindex_1]);
+				break;
+			case 0x00:
+				fprintf(stderr,
+					"Warning: null (\\x00) in layer7 regexp.  A null terminates the regexp string!\n");
+				break;
+			default:
+				break;
+			}
+
+
+                        sindex += 3; /* 4 total */
+                }
+                else
+                        result[rindex_1] = tolower(s[sindex]);
+
+		sindex++;
+		rindex_1++;
+        }
+	result[rindex_1] = '\0';
+
+	return result;
+}
+
+#define MAX_SUBDIRS 128
+static char ** readl7dir(char * dirname)
+{
+        DIR             * scratchdir;
+        struct dirent   ** namelist;
+	char ** subdirs = malloc(MAX_SUBDIRS * sizeof(char *));
+
+        int n, d = 1;
+	subdirs[0] = "";
+
+        n = scandir(dirname, &namelist, 0, alphasort);
+
+	if (n < 0)
+	{
+            perror("scandir");
+	    xtables_error(OTHER_PROBLEM, "Couldn't open %s\n", dirname);
+	}
+        else
+	{
+		while(n--)
+		{
+			char fulldirname[MAX_FN_LEN];
+
+			snprintf(fulldirname, MAX_FN_LEN, "%s/%s", dirname, namelist[n]->d_name);
+
+                	if((scratchdir = opendir(fulldirname)) != NULL)
+			{
+				closedir(scratchdir);
+
+				if(!strcmp(namelist[n]->d_name, ".") ||
+				   !strcmp(namelist[n]->d_name, ".."))
+					/* do nothing */ ;
+				else
+				{
+					subdirs[d] = malloc(strlen(namelist[n]->d_name) + 1);
+					strcpy(subdirs[d], namelist[n]->d_name);
+					d++;
+					if(d >= MAX_SUBDIRS - 1)
+					{
+						fprintf(stderr,
+						  "Too many subdirectories, skipping the rest!\n");
+						break;
+					}
+				}
+			}
+                	free(namelist[n]);
+            	}
+            	free(namelist);
+        }
+
+	subdirs[d] = NULL;
+
+	return subdirs;
+}
+
+static void
+parse_layer7_protocol(const char *s, struct xt_layer7_info *info)
+{
+	char filename[MAX_FN_LEN];
+	char * dir = NULL;
+	char ** subdirs;
+	int n = 0, done = 0;
+
+	if(strlen(l7dir) > 0)
+		dir = l7dir;
+	else
+		dir = "/etc/l7-protocols";
+
+	subdirs = readl7dir(dir);
+
+	while(subdirs[n] != NULL)
+	{
+		int c = snprintf(filename, MAX_FN_LEN, "%s/%s/%s.pat", dir, subdirs[n], s);
+
+		//fprintf(stderr, "Trying to find pattern in %s ... ", filename);
+
+		if(c > MAX_FN_LEN)
+		{
+			xtables_error(OTHER_PROBLEM,
+				"Filename beginning with %s is too long!\n", filename);
+		}
+
+		/* read in the pattern from the file */
+		if(parse_protocol_file(filename, s, info))
+		{
+			//fprintf(stderr, "found\n");
+			done = 1;
+			break;
+		}
+		
+		//fprintf(stderr, "not found\n");
+
+		n++;
+	}
+
+	if(!done)
+		xtables_error(OTHER_PROBLEM,
+			"Couldn't find a pattern definition file for %s.\n", s);
+
+	/* process \xHH escapes and tolower everything. (our regex lib has no
+	case insensitivity option.) */
+	strncpy(info->pattern, pre_process(info->pattern), MAX_PATTERN_LEN);
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int layer7_parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry, struct xt_entry_match **match)
+{
+	struct xt_layer7_info *layer7info =
+		(struct xt_layer7_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		parse_layer7_protocol(argv[optind-1], layer7info);
+		if (invert)
+			layer7info->invert = 1;
+		*flags = 1;
+		break;
+
+	case '2':
+		/* not going to use this, but maybe we need to strip a ! anyway (?) */
+		if(strlen(argv[optind-1]) >= MAX_FN_LEN)
+			xtables_error(PARAMETER_PROBLEM, "directory name too long\n");
+
+		strncpy(l7dir, argv[optind-1], MAX_FN_LEN);
+
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check; must have specified --l7proto */
+static void layer7_final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "LAYER7 match: You must specify `--l7proto'");
+}
+
+static void print_protocol(char s[], int invert, int numeric)
+{
+	fputs("l7proto ", stdout);
+	if (invert) fputc('!', stdout);
+	printf("%s ", s);
+}
+
+/* Prints out the matchinfo. */
+static void layer7_print(const void *ip,
+      const struct xt_entry_match *match,
+      int numeric)
+{
+	printf("LAYER7 ");
+
+	print_protocol(((struct xt_layer7_info *)match->data)->protocol,
+		  ((struct xt_layer7_info *)match->data)->invert, numeric);
+}
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void layer7_save(const void *ip, const struct xt_entry_match *match)
+{
+        const struct xt_layer7_info *info =
+            (const struct xt_layer7_info*) match->data;
+
+        printf(" --l7proto %s%s", (info->invert)   ? "! ": "", info->protocol);
+}
+
+static struct xtables_match layer7_match = {
+    .family        = NFPROTO_IPV4,
+    .name          = "layer7",
+    .version       = XTABLES_VERSION,
+    .size          = XT_ALIGN(sizeof(struct xt_layer7_info)),
+    .userspacesize = XT_ALIGN(sizeof(struct xt_layer7_info)),
+    .help          = layer7_help,
+    .parse         = layer7_parse,
+    .final_check   = layer7_final_check,
+    .print         = layer7_print,
+    .save          = layer7_save,
+    .extra_opts    = layer7_opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&layer7_match);
+}
--- iptables-1.8.x/extensions/libipt_layer7.man
+++ iptables-1.8.x/extensions/libipt_layer7.man
@@ -0,0 +1,14 @@
+This module matches packets based on the application layer data of 
+their connections.  It uses regular expression matching to compare 
+the application layer data to regular expressions found it the layer7 
+configuration files.  This is an experimental module which can be found at 
+http://l7-filter.sf.net.  It takes two options.
+.TP
+.BI "--l7proto " "\fIprotocol\fP"
+Match the specified protocol.  The protocol name must match a file 
+name in /etc/l7-protocols/ or one of its first-level child directories.
+.TP
+.BI "--l7dir " "\fIdirectory\fP"
+Use \fIdirectory\fP instead of /etc/l7-protocols/.  This option must be 
+specified before --l7proto.
+
--- iptables-1.8.x/extensions/libipt_ROUTE.c
+++ iptables-1.8.x/extensions/libipt_ROUTE.c
@@ -0,0 +1,246 @@
+/* Shared library add-on to iptables to add ROUTE target support.
+ * Author : Cedric de Launois, <delaunois@info.ucl.ac.be>
+ * v 1.11 2004/11/23
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <net/if.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_ROUTE.h>
+
+/* compile IPT_ROUTE_TEE support even if kernel headers are unpatched */
+#ifndef IPT_ROUTE_TEE
+#define IPT_ROUTE_TEE		0x02
+#endif
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ROUTE target v%s options:\n"
+"    --oif   \tifname \t\tRoute packet through `ifname' network interface\n"
+"    --iif   \tifname \t\tChange packet's incoming interface to `ifname'\n"
+"    --gw    \tip     \t\tRoute packet via this gateway `ip'\n"
+"    --continue\t     \t\tRoute packet and continue traversing the\n"
+"            \t       \t\trules. Not valid with --iif or --tee.\n"
+"    --tee\t  \t\tDuplicate packet, route the duplicate,\n"
+"            \t       \t\tcontinue traversing with original packet.\n"
+"            \t       \t\tNot valid with --iif or --continue.\n"
+"\n",
+"1.11");
+}
+
+static struct option route_opts[] = {
+	{.name = "oif", .has_arg = true, .val = '1' },
+	{.name = "iif", .has_arg = true, .val = '2' },
+	{.name = "gw", .has_arg = true, .val = '3' },
+	{.name = "continue", .has_arg = false, .val = '4' },
+	{.name = "tee", .has_arg = false, .val = '5' },
+	XT_GETOPT_TABLEEND,
+};
+
+/* Initialize the target. */
+static void ROUTE_init(struct xt_entry_target *t)
+{
+	struct ipt_route_target_info *route_info = (struct ipt_route_target_info*)t->data;
+
+	route_info->oif[0] = '\0';
+	route_info->iif[0] = '\0';
+	route_info->gw = 0;
+	route_info->flags = 0;
+}
+
+
+#define IPT_ROUTE_OPT_OIF      0x01
+#define IPT_ROUTE_OPT_IIF      0x02
+#define IPT_ROUTE_OPT_GW       0x04
+#define IPT_ROUTE_OPT_CONTINUE 0x08
+#define IPT_ROUTE_OPT_TEE      0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int ROUTE_parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry, struct xt_entry_target **target)
+{
+	struct ipt_route_target_info *route_info = 
+		(struct ipt_route_target_info*)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --oif twice");
+
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't use --oif and --iif together");
+
+		if (strlen(optarg) > sizeof(route_info->oif) - 1)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->oif) - 1);
+
+		strcpy(route_info->oif, optarg);
+		*flags |= IPT_ROUTE_OPT_OIF;
+		break;
+
+	case '2':
+		if (*flags & IPT_ROUTE_OPT_IIF)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --iif twice");
+
+		if (*flags & IPT_ROUTE_OPT_OIF)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't use --iif and --oif together");
+
+		if (strlen(optarg) > sizeof(route_info->iif) - 1)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Maximum interface name length %u",
+				   sizeof(route_info->iif) - 1);
+
+		strcpy(route_info->iif, optarg);
+		*flags |= IPT_ROUTE_OPT_IIF;
+		break;
+
+	case '3':
+		if (*flags & IPT_ROUTE_OPT_GW)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --gw twice");
+
+		if (!inet_aton(optarg, (struct in_addr*)&route_info->gw)) {
+			xtables_error(PARAMETER_PROBLEM,
+				   "Invalid IP address %s",
+				   optarg);
+		}
+
+		*flags |= IPT_ROUTE_OPT_GW;
+		break;
+
+	case '4':
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue twice");
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --continue AND --tee");
+
+		route_info->flags |= IPT_ROUTE_CONTINUE;
+		*flags |= IPT_ROUTE_OPT_CONTINUE;
+
+		break;
+
+	case '5':
+		if (*flags & IPT_ROUTE_OPT_TEE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee twice");
+		if (*flags & IPT_ROUTE_OPT_CONTINUE)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Can't specify --tee AND --continue");
+
+		route_info->flags |= IPT_ROUTE_TEE;
+		*flags |= IPT_ROUTE_OPT_TEE;
+
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+		           "ROUTE target: oif, iif or gw option required");
+
+	if ((flags & (IPT_ROUTE_OPT_CONTINUE|IPT_ROUTE_OPT_TEE)) && (flags & IPT_ROUTE_OPT_IIF))
+		xtables_error(PARAMETER_PROBLEM,
+			   "ROUTE target: can't continue traversing the rules with iif option");
+}
+
+
+/* Prints out the targinfo. */
+static void
+ROUTE_print(const void *ip, const struct xt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_route_target_info *route_info
+		= (const struct ipt_route_target_info *)target->data;
+
+	printf(" ROUTE");
+
+	if (route_info->oif[0])
+		printf(" oif:%s", route_info->oif);
+
+	if (route_info->iif[0])
+		printf(" iif:%s", route_info->iif);
+
+	if (route_info->gw) {
+		struct in_addr ip_1 = { route_info->gw };
+		printf(" gw:%s", inet_ntoa(ip_1));
+	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf(" continue");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf(" tee");
+
+}
+
+
+static void ROUTE_save(const void *ip, const struct xt_entry_target *target)
+{
+	const struct ipt_route_target_info *route_info
+		= (const struct ipt_route_target_info *)target->data;
+
+	if (route_info->oif[0])
+		printf("--oif %s ", route_info->oif);
+
+	if (route_info->iif[0])
+		printf("--iif %s ", route_info->iif);
+
+	if (route_info->gw) {
+		struct in_addr ip_1 = { route_info->gw };
+		printf(" --gw %s", inet_ntoa(ip_1));
+	}
+
+	if (route_info->flags & IPT_ROUTE_CONTINUE)
+		printf(" --continue");
+
+	if (route_info->flags & IPT_ROUTE_TEE)
+		printf(" --tee");
+}
+
+
+static struct xtables_target route_target = {
+	.family		= NFPROTO_IPV4,
+	.name		= "ROUTE",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct ipt_route_target_info)),
+	.help		= help,
+	.init		= ROUTE_init,
+	.parse		= ROUTE_parse,
+	.final_check	= final_check,
+	.print		= ROUTE_print,
+	.save		= ROUTE_save,
+	.extra_opts	= route_opts
+};
+
+void _init(void)
+{
+	xtables_register_target(&route_target);
+}
--- iptables-1.8.x/extensions/libipt_ROUTE.man
+++ iptables-1.8.x/extensions/libipt_ROUTE.man
@@ -0,0 +1,18 @@
+This is used to explicitly override the core network stack's routing decision.
+.B mangle
+table.
+.TP
+.BI "--oif " "ifname"
+Route the packet through `ifname' network interface
+.TP
+.BI "--iif " "ifname"
+Change the packet's incoming interface to `ifname'
+.TP
+.BI "--gw " "IP_address"
+Route the packet via this gateway
+.TP
+.BI "--continue "
+Behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--tee'
+.TP
+.BI "--tee "
+Make a copy of the packet, and route that copy to the given destination. For the original, uncopied packet, behave like a non-terminating target and continue traversing the rules.  Not valid in combination with `--iif' or `--continue'
--- iptables-1.8.x/extensions/libipt_tos.c
+++ iptables-1.8.x/extensions/libipt_tos.c
@@ -0,0 +1,169 @@
+/* Shared library add-on to iptables to add TOS matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_tos.h>
+
+/* TOS names and values. */
+static
+struct TOS_value
+{
+	unsigned char TOS;
+	const char *name;
+} TOS_values[] = {
+	{ IPTOS_LOWDELAY,    "Minimize-Delay" },
+	{ IPTOS_THROUGHPUT,  "Maximize-Throughput" },
+	{ IPTOS_RELIABILITY, "Maximize-Reliability" },
+	{ IPTOS_MINCOST,     "Minimize-Cost" },
+	{ IPTOS_NORMALSVC,   "Normal-Service" },
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	unsigned int i;
+
+	printf(
+"TOS match v%s options:\n"
+"[!] --tos value                 Match Type of Service field from one of the\n"
+"                                following numeric or descriptive values:\n",
+XTABLES_VERSION);
+
+	for (i = 0; i < sizeof(TOS_values)/sizeof(struct TOS_value);i++)
+		printf("                                     %s %u (0x%02x)\n",
+		       TOS_values[i].name,
+                       TOS_values[i].TOS,
+                       TOS_values[i].TOS);
+	fputc('\n', stdout);
+}
+
+static struct option opts[] = {
+	{ .name = "tos", .has_arg = true, .val = '1' },
+	XT_GETOPT_TABLEEND
+};
+
+static void
+parse_tos(const char *s, struct ipt_tos_info *info)
+{
+	unsigned int i;
+	unsigned int tos;
+
+	if (xtables_strtoui(s, NULL, &tos, 0, UINT8_MAX)) {
+		if (tos == IPTOS_LOWDELAY
+		    || tos == IPTOS_THROUGHPUT
+		    || tos == IPTOS_RELIABILITY
+		    || tos == IPTOS_MINCOST
+		    || tos == IPTOS_NORMALSVC) {
+		    	info->tos = (u_int8_t )tos;
+		    	return;
+		}
+	} else {
+		for (i = 0; i<sizeof(TOS_values)/sizeof(struct TOS_value); i++)
+			if (strcasecmp(s,TOS_values[i].name) == 0) {
+				info->tos = TOS_values[i].TOS;
+				return;
+			}
+	}
+	xtables_error(PARAMETER_PROBLEM, "Bad TOS value `%s'", s);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry,
+      struct xt_entry_match **match)
+{
+	struct ipt_tos_info *tosinfo = (struct ipt_tos_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		/* Ensure that `--tos' haven't been used yet. */
+		if (*flags == 1)
+			xtables_error(PARAMETER_PROBLEM,
+					"tos match: only use --tos once!");
+
+		parse_tos(argv[optind-1], tosinfo);
+		if (invert)
+			tosinfo->invert = 1;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+print_tos(u_int8_t tos, int numeric)
+{
+	unsigned int i;
+
+	if (!numeric) {
+		for (i = 0; i<sizeof(TOS_values)/sizeof(struct TOS_value); i++)
+			if (TOS_values[i].TOS == tos) {
+				printf("%s ", TOS_values[i].name);
+				return;
+			}
+	}
+	printf("0x%02x ", tos);
+}
+
+/* Final check; must have specified --tos. */
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "TOS match: You must specify `--tos'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const void *ip,
+      const struct xt_entry_match *match,
+      int numeric)
+{
+	const struct ipt_tos_info *info = (const struct ipt_tos_info *)match->data;
+    
+	printf("TOS match ");
+	if (info->invert)
+		printf("!");
+	print_tos(info->tos, numeric);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void
+save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct ipt_tos_info *info = (const struct ipt_tos_info *)match->data;
+    
+	if (info->invert)
+		printf("! ");
+	printf("--tos ");
+	print_tos(info->tos, 0);
+}
+
+static struct xtables_match tos = { 
+	.name		= "tos",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct ipt_tos_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct ipt_tos_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&tos);
+}
--- iptables-1.8.x/extensions/libipt_TOS.c
+++ iptables-1.8.x/extensions/libipt_TOS.c
@@ -0,0 +1,174 @@
+/* Shared library add-on to iptables to add TOS target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <xtables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_TOS.h>
+
+struct tosinfo {
+	struct ipt_entry_target t;
+	struct ipt_tos_target_info tos;
+};
+
+/* TOS names and values. */
+static
+struct TOS_value
+{
+	unsigned char TOS;
+	const char *name;
+} TOS_values[] = {
+	{ IPTOS_LOWDELAY,    "Minimize-Delay" },
+	{ IPTOS_THROUGHPUT,  "Maximize-Throughput" },
+	{ IPTOS_RELIABILITY, "Maximize-Reliability" },
+	{ IPTOS_MINCOST,     "Minimize-Cost" },
+	{ IPTOS_NORMALSVC,   "Normal-Service" },
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	unsigned int i;
+
+	printf(
+"TOS target v%s options:\n"
+"  --set-tos value                   Set Type of Service field to one of the\n"
+"                                following numeric or descriptive values:\n",
+XTABLES_VERSION);
+
+	for (i = 0; i < sizeof(TOS_values)/sizeof(struct TOS_value);i++)
+		printf("                                     %s %u (0x%02x)\n",
+		       TOS_values[i].name,
+                       TOS_values[i].TOS,
+                       TOS_values[i].TOS);
+	fputc('\n', stdout);
+}
+
+static struct option opts[] = {
+	{ .name = "set-tos", .has_arg = true, .val = '1' },
+	XT_GETOPT_TABLEEND
+};
+
+/* Initialize the target. */
+static void
+init(struct xt_entry_target *t)
+{
+}
+
+static void
+parse_tos(const char *s, struct ipt_tos_target_info *info)
+{
+	unsigned int i, tos;
+
+	if (xtables_strtoui(s, NULL, &tos, 0, UINT8_MAX)) {
+		if (tos == IPTOS_LOWDELAY
+		    || tos == IPTOS_THROUGHPUT
+		    || tos == IPTOS_RELIABILITY
+		    || tos == IPTOS_MINCOST
+		    || tos == IPTOS_NORMALSVC) {
+		    	info->tos = (u_int8_t )tos;
+		    	return;
+		}
+	} else {
+		for (i = 0; i<sizeof(TOS_values)/sizeof(struct TOS_value); i++)
+			if (strcasecmp(s,TOS_values[i].name) == 0) {
+				info->tos = TOS_values[i].TOS;
+				return;
+			}
+	}
+	xtables_error(PARAMETER_PROBLEM, "Bad TOS value `%s'", s);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry,
+      struct xt_entry_target **target)
+{
+	struct ipt_tos_target_info *tosinfo
+		= (struct ipt_tos_target_info *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (*flags)
+			xtables_error(PARAMETER_PROBLEM,
+			           "TOS target: Cant specify --set-tos twice");
+		parse_tos(optarg, tosinfo);
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+		           "TOS target: Parameter --set-tos is required");
+}
+
+static void
+print_tos(u_int8_t tos, int numeric)
+{
+	unsigned int i;
+
+	if (!numeric) {
+		for (i = 0; i<sizeof(TOS_values)/sizeof(struct TOS_value); i++)
+			if (TOS_values[i].TOS == tos) {
+				printf("%s ", TOS_values[i].name);
+				return;
+			}
+	}
+	printf("0x%02x ", tos);
+}
+
+/* Prints out the targinfo. */
+static void
+print(const void *ip,
+      const struct xt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_tos_target_info *tosinfo =
+		(const struct ipt_tos_target_info *)target->data;
+	printf("TOS set ");
+	print_tos(tosinfo->tos, numeric);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const void *ip, const struct xt_entry_target *target)
+{
+	const struct ipt_tos_target_info *tosinfo =
+		(const struct ipt_tos_target_info *)target->data;
+
+	printf("--set-tos 0x%02x ", tosinfo->tos);
+}
+
+static struct xtables_target tos = {
+	.name		= "TOS",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct ipt_tos_target_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct ipt_tos_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	xtables_register_target(&tos);
+}
--- iptables-1.8.x/extensions/libipt_tos.man
+++ iptables-1.8.x/extensions/libipt_tos.man
@@ -0,0 +1,9 @@
+This module matches the 8 bits of Type of Service field in the IP
+header (ie. including the precedence bits).
+.TP
+.BI "--tos " "tos"
+The argument is either a standard name, (use
+.br
+ iptables -m tos -h
+.br
+to see the list), or a numeric value to match.
--- iptables-1.8.x/extensions/libipt_TOS.man
+++ iptables-1.8.x/extensions/libipt_TOS.man
@@ -0,0 +1,11 @@
+This is used to set the 8-bit Type of Service field in the IP header.
+It is only valid in the
+.B mangle
+table.
+.TP
+.BI "--set-tos " "tos"
+You can use a numeric TOS values, or use
+.nf
+ iptables -j TOS -h
+.fi
+to see the list of valid TOS names.
--- iptables-1.8.x/extensions/libipt_TRIGGER.c
+++ iptables-1.8.x/extensions/libipt_TRIGGER.c
@@ -0,0 +1,208 @@
+/* Port-triggering target. 
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ */
+
+/* Shared library add-on to iptables to add port-trigger support. */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <linux/poison.h>
+#include <linux/netfilter_ipv4/ipt_TRIGGER.h>
+#include <iptables.h>
+#include <xtables.h>
+#include <net/netfilter/nf_nat.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_TRIGGER.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRIGGER v%s options:\n"
+" --trigger-type (dnat|in|out)\n"
+"				Trigger type\n"
+" --trigger-proto proto\n"
+"				Trigger protocol\n"
+" --trigger-match port[-port]\n"
+"				Trigger destination port range\n"
+" --trigger-relate port[-port]\n"
+"				Port range to map related destination port range to.\n\n",
+XTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{.name = "trigger-type", .has_arg = true, .val = '1'},
+	{.name = "trigger-proto", .has_arg = true, .val = '2'},
+	{.name = "trigger-match", .has_arg = true, .val = '3'},
+	{.name = "trigger-relate", .has_arg = true, .val = '4'},
+	XT_GETOPT_TABLEEND,
+};
+
+/* Initialize the target. */
+static void
+init(struct xt_entry_target *t)
+{
+}
+
+/* Parses ports */
+static void
+parse_ports(const char *arg, u_int16_t *ports)
+{
+	const char *dash;
+	int port;
+
+	port = atoi(arg);
+	if (port == 0 || port > 65535)
+		xtables_error(PARAMETER_PROBLEM, "Port range `%s' invalid\n", arg);
+
+	dash = strchr(arg, '-');
+	if (!dash)
+		ports[0] = ports[1] = port;
+	else {
+		int maxport;
+
+		maxport = atoi(dash + 1);
+		if (maxport == 0 || maxport > 65535)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Port range `%s' invalid\n", dash+1);
+		if (maxport < port)
+			xtables_error(PARAMETER_PROBLEM,
+				   "Port range `%s' invalid\n", arg);
+		ports[0] = port;
+		ports[1] = maxport;
+	}
+}
+
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry,
+      struct xt_entry_target **target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)(*target)->data;
+
+	switch (c) {
+	case '1':
+		if (!strcasecmp(optarg, "dnat"))
+			info->type = IPT_TRIGGER_DNAT;
+		else if (!strcasecmp(optarg, "in"))
+			info->type = IPT_TRIGGER_IN;
+		else if (!strcasecmp(optarg, "out"))
+			info->type = IPT_TRIGGER_OUT;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "unknown type `%s' specified", optarg);
+		return 1;
+
+	case '2':
+		if (!strcasecmp(optarg, "tcp"))
+			info->proto = IPPROTO_TCP;
+		else if (!strcasecmp(optarg, "udp"))
+			info->proto = IPPROTO_UDP;
+		else if (!strcasecmp(optarg, "all"))
+			info->proto = 0;
+		else
+			xtables_error(PARAMETER_PROBLEM,
+				   "unknown protocol `%s' specified", optarg);
+		return 1;
+
+	case '3':
+		parse_ports(optarg, info->ports.mport);
+		return 1;
+
+	case '4':
+		parse_ports(optarg, info->ports.rport);
+		*flags |= IP_NAT_RANGE_PROTO_SPECIFIED;
+		return 1;
+
+	default:
+		return 0;
+	}
+}
+
+/* Final check; don't care. */
+static void final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const void *ip,
+      const struct xt_entry_target *target,
+      int numeric)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+
+	printf(" TRIGGER ");
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf("type:dnat ");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf("type:in ");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf("type:out ");
+
+	if (info->proto == IPPROTO_TCP)
+		printf("tcp ");
+	else if (info->proto == IPPROTO_UDP)
+		printf("udp ");
+
+	printf("match:%hu", info->ports.mport[0]);
+	if (info->ports.mport[1] > info->ports.mport[0])
+		printf("-%hu", info->ports.mport[1]);
+	printf(" ");
+
+	printf("relate:%hu", info->ports.rport[0]);
+	if (info->ports.rport[1] > info->ports.rport[0])
+		printf("-%hu", info->ports.rport[1]);
+	printf(" ");
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const void *ip, const struct xt_entry_target *target)
+{
+	struct ipt_trigger_info *info = (struct ipt_trigger_info *)target->data;
+
+	printf(" --trigger-type");
+	if (info->type == IPT_TRIGGER_DNAT)
+		printf(" dnat");
+	else if (info->type == IPT_TRIGGER_IN)
+		printf(" in");
+	else if (info->type == IPT_TRIGGER_OUT)
+		printf(" out");
+	printf(" --trigger-proto");
+	if (info->proto == IPPROTO_TCP)
+		printf(" tcp");
+	else if (info->proto == IPPROTO_UDP)
+		printf(" udp");
+	printf(" --trigger-match %hu-%hu", info->ports.mport[0], info->ports.mport[1]);
+	printf(" --trigger-relate %hu-%hu", info->ports.rport[0], info->ports.rport[1]);
+}
+
+static struct xtables_target trigger = {
+	.family		= NFPROTO_IPV4,
+	.name		= "TRIGGER",
+	.version	= XTABLES_VERSION,
+	.size		= XT_ALIGN(sizeof(struct ipt_trigger_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct ipt_trigger_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts 
+};
+
+void _init(void)
+{
+	xtables_register_target(&trigger);
+}
--- iptables-1.8.x/extensions/libipt_web.c
+++ iptables-1.8.x/extensions/libipt_web.c
@@ -0,0 +1,214 @@
+/*
+
+	web (experimental)
+	HTTP client match
+	Copyright (C) 2006 Jonathan Zarate
+
+	Licensed under GNU GPL v2 or later.
+
+*/
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_web.h>
+
+
+#undef IPTABLES_SAVE
+
+
+static void help(void)
+{
+	printf(
+		"web match v0.01 (experimental)\n"
+		"Copyright (C) 2006 Jonathan Zarate\n"
+		"Options:\n"
+		"[!] --http (default)   find an HTTP GET/POST request\n"
+		"[!] --host <text ...>  find in host line\n"
+		"[!] --req <text ...>   find in request\n"
+		"[!] --path <text ...>  find in request path\n"
+		"[!] --query <text ...> find in request query\n"
+		"[!] --hore <text ...>  find in host or request line\n"
+		" <text> can be:\n"
+		"  text    contains\n"
+		"  ^text   begins with\n"
+		"  text$   ends with\n"
+		"  ^text$  exact match\n");
+}
+
+static void init(struct xt_entry_match *m)
+{
+}
+
+static struct option opts[] = {
+	{ .name = "http",  .has_arg = 0, .flag = 0, .val = '1' },
+	{ .name = "host",  .has_arg = 1, .flag = 0, .val = '2' },
+	{ .name = "req",   .has_arg = 1, .flag = 0, .val = '3' },
+	{ .name = "path",  .has_arg = 1, .flag = 0, .val = '4' },
+	{ .name = "query", .has_arg = 1, .flag = 0, .val = '5' },
+	{ .name = "hore",  .has_arg = 1, .flag = 0, .val = '6' },
+	XT_GETOPT_TABLEEND,
+};
+
+static int parse(int c, char **argv, int invert, unsigned int *flags,
+				 const void *v_entry,
+				 struct xt_entry_match **match)
+{
+	struct ipt_entry *entry = (struct ipt_entry*) v_entry;
+	const char *s;
+	char *e, *p;
+	int n;
+	struct ipt_web_info *info;
+
+	if ((c < '1') || (c > '6')) return 0;
+
+	if (*flags) xtables_error(PARAMETER_PROBLEM, "Multiple modes are not supported");
+	*flags = 1;
+
+	info = (struct ipt_web_info *)(*match)->data;
+	switch (c) {
+	case '2':
+		info->mode = IPT_WEB_HOST;
+		break;
+	case '3':
+		info->mode = IPT_WEB_RURI;
+		break;
+	case '4':
+		info->mode = IPT_WEB_PATH;
+		break;
+	case '5':
+		info->mode = IPT_WEB_QUERY;
+		break;
+	case '6':
+		info->mode = IPT_WEB_HORE;
+		break;
+	default:	// IPT_WEB_HTTP
+		return 1;
+	}
+
+	if (entry->ip.proto != IPPROTO_TCP) {
+		xtables_error(PARAMETER_PROBLEM, "web match requires -p tcp");
+	}
+
+	if (invert) info->invert = 1;
+
+	// convert arg to text\0text\0\0
+	s = argv[optind - 1];
+
+	if ((p = malloc(strlen(s) + 2)) == NULL) {
+		xtables_error(PARAMETER_PROBLEM, "Not enough memory");
+	}
+
+	e = p;
+	while (*s) {
+		while ((*s == ' ') || (*s == '\n') || (*s == '\t')) ++s;
+		if (*s == 0) break;
+		while ((*s != 0) && (*s != ' ') && (*s != '\n') && (*s != '\t')) {
+			*e++ = *s++;
+		}
+		*e++ = 0;
+	}
+	n = (e - p);
+
+#if 0
+	*e = 0;
+	e = p;
+	while (*e) {
+		printf("[%s]\n", e);
+		e += strlen(e) + 1;
+	}
+#endif
+
+	if (n <= 1) {
+		xtables_error(PARAMETER_PROBLEM, "Text is too short");
+	}
+	if (n >= IPT_WEB_MAXTEXT) {
+		xtables_error(PARAMETER_PROBLEM, "Text is too long");
+	}
+	memcpy(info->text, p, n);
+	memset(info->text + n, 0, IPT_WEB_MAXTEXT - n);		// term, need to clear rest for ipt rule cmp
+	free(p);
+	return 1;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void print_match(const struct ipt_web_info *info)
+{
+	const char *text;
+
+	if (info->invert) printf("! ");
+
+	switch (info->mode) {
+	case IPT_WEB_HOST:
+		printf("--host");
+		break;
+	case IPT_WEB_RURI:
+		printf("--req");
+		break;
+	case IPT_WEB_PATH:
+		printf("--path");
+		break;
+	case IPT_WEB_QUERY:
+		printf("--query");
+		break;
+	case IPT_WEB_HORE:
+		printf("--hore");
+		break;
+	default:
+		printf("--http");
+		return;
+	}
+
+	text = info->text;
+	printf(" \"");
+	while (*text) {
+		while (*text) {
+			if (*text == '"') printf("\\\"");
+				else putc(*text, stdout);
+			++text;
+		}
+		++text;
+		if (*text == 0) break;
+		putc(' ', stdout);
+	}
+	printf("\" ");
+}
+
+static void print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	printf("web ");
+	print_match((const struct ipt_web_info *)match->data);
+}
+
+static void save(const void *ip, const struct xt_entry_match *match)
+{
+#ifdef IPTABLES_SAVE
+	print_match((const struct ipt_web_info *)match->data);
+#endif
+}
+
+
+static struct xtables_match web_match = {
+	.family        = NFPROTO_IPV4,
+	.name          = "web",
+	.version       = XTABLES_VERSION,
+	.size          = XT_ALIGN(sizeof(struct ipt_web_info)),
+	.userspacesize = XT_ALIGN(sizeof(struct ipt_web_info)),
+	.help          = &help,
+	.init          = &init,
+	.parse         = &parse,
+	.final_check   = &final_check,
+	.print         = &print,
+	.save          = &save,
+	.extra_opts    = opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&web_match);
+}
--- iptables-1.8.x/extensions/libipt_webmon.c
+++ iptables-1.8.x/extensions/libipt_webmon.c
@@ -0,0 +1,723 @@
+/*  webmon --	An iptables extension to match URLs in HTTP requests 
+ *  		This module can match using string match or regular expressions
+ *  		Originally designed for use with Gargoyle router firmware (gargoyle-router.com)
+ *
+ *
+ *  Copyright © 2008-2011 by Eric Bishop <eric@gargoyle-router.com>
+ * 
+ *  This file is free software: you may copy, redistribute and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation, either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  This file is distributed in the hope that it will be useful, but
+ *  WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <arpa/inet.h>
+
+/*
+ * in iptables 1.4.0 and higher, iptables.h includes xtables.h, which
+ * we can use to check whether we need to deal with the new requirements
+ * in pre-processor directives below
+ */
+
+#include <xtables.h>
+#include <linux/netfilter_ipv4/ipt_webmon.h>
+
+#ifdef _XTABLES_H
+	#define iptables_rule_match	xtables_rule_match
+	#define iptables_match		xtables_match
+	#define iptables_target		xtables_target
+	#define ipt_tryload		xt_tryload
+#endif
+
+/* 
+ * XTABLES_VERSION_CODE is only defined in versions 1.4.1 and later, which
+ * also require the use of xtables_register_match
+ * 
+ * Version 1.4.0 uses register_match like previous versions
+ */
+#ifdef XTABLES_VERSION_CODE 
+	#define register_match          xtables_register_match
+#endif
+
+
+#define STRIP "%d.%d.%d.%d"
+#define NIPQUAD(addr) \
+	((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[3]
+
+
+
+/* utility functions necessary for module to work across multiple iptables versions */
+//static void param_problem_exit_error(char* msg);
+
+
+static void parse_ips_and_ranges(char* addr_str, struct ipt_webmon_info *info);
+
+static char** split_on_separators(char* line, char* separators, int num_separators, int max_pieces, int include_remainder_at_max);
+static char* trim_flanking_whitespace(char* str);
+static unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length);
+
+#define DEFAULT_MAX      300
+
+#define SEARCH_LOAD_FILE 100
+#define DOMAIN_LOAD_FILE 101
+#define CLEAR_SEARCH     102
+#define CLEAR_DOMAIN     103
+
+static char* domain_load_file = NULL;
+static char* search_load_file = NULL;
+static uint32_t global_max_domains  = DEFAULT_MAX;
+static uint32_t global_max_searches = DEFAULT_MAX;
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+	printf(	"webmon options:\n");
+}
+
+static struct option opts[] = 
+{
+	{ .name = "exclude_ips",        .has_arg = 1, .flag = 0, .val = WEBMON_EXCLUDE },
+	{ .name = "include_ips",        .has_arg = 1, .flag = 0, .val = WEBMON_INCLUDE },
+	{ .name = "max_domains",        .has_arg = 1, .flag = 0, .val = WEBMON_MAXDOMAIN },
+	{ .name = "max_searches",       .has_arg = 1, .flag = 0, .val = WEBMON_MAXSEARCH },
+	{ .name = "search_load_file",   .has_arg = 1, .flag = 0, .val = SEARCH_LOAD_FILE },
+	{ .name = "domain_load_file",   .has_arg = 1, .flag = 0, .val = DOMAIN_LOAD_FILE },
+	{ .name = "clear_search",       .has_arg = 0, .flag = 0, .val = CLEAR_SEARCH },
+	{ .name = "clear_domain",       .has_arg = 0, .flag = 0, .val = CLEAR_DOMAIN },
+
+	{ .name = 0 }
+};
+
+static void webmon_init(
+#ifdef _XTABLES_H
+	struct xt_entry_match *match
+#else
+	struct ipt_entry_match *match, unsigned int *nfcache
+#endif
+	)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	info->max_domains=DEFAULT_MAX;
+	info->max_searches=DEFAULT_MAX;
+	info->num_exclude_ips=0;
+	info->num_exclude_ranges=0;
+	info->exclude_type = WEBMON_EXCLUDE;
+	info->ref_count = NULL;
+}
+
+
+/* Function which parses command options; returns true if it ate an option */
+static int parse(	int c, 
+			char **argv,
+			int invert,
+			unsigned int *flags,
+#ifdef XTABLES_VERSION
+			const void *entry,
+			struct xt_entry_match **match
+#else
+			const struct ipt_entry *entry,
+			unsigned int *nfcache,
+			struct ipt_entry_match **match
+#endif
+			)
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)(*match)->data;
+	int valid_arg = 1;
+	long max;
+	switch (c)
+	{
+		case WEBMON_EXCLUDE:
+			parse_ips_and_ranges(optarg, info);
+			info->exclude_type = WEBMON_EXCLUDE;
+			break;
+		case WEBMON_INCLUDE:
+			parse_ips_and_ranges(optarg, info);
+			info->exclude_type = WEBMON_INCLUDE;
+			break;
+		case WEBMON_MAXSEARCH:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_searches = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_searches = (uint32_t)max;
+				global_max_searches = info->max_searches;
+			}
+			break;
+		case WEBMON_MAXDOMAIN:
+			if( sscanf(argv[optind-1], "%ld", &max) == 0)
+			{
+				info->max_domains = DEFAULT_MAX ;
+				valid_arg = 0;
+			}
+			else
+			{
+				info->max_domains = (uint32_t)max;
+				global_max_domains = info->max_domains;
+			}
+			break;
+		case SEARCH_LOAD_FILE:
+			search_load_file = strdup(optarg);
+			break;
+		case DOMAIN_LOAD_FILE:
+			domain_load_file = strdup(optarg);
+			break;
+		case CLEAR_SEARCH:
+			search_load_file = strdup("/dev/null");
+			break;
+		case CLEAR_DOMAIN:
+			domain_load_file = strdup("/dev/null");
+			break;
+		default:
+			valid_arg = 0;
+	}
+	return valid_arg;
+
+}
+
+
+	
+static void print_webmon_args(	struct ipt_webmon_info* info )
+{
+	printf("--max_domains %ld ", (unsigned long int)info->max_domains);
+	printf("--max_searches %ld ", (unsigned long int)info->max_searches);
+	if(info->num_exclude_ips > 0 || info->num_exclude_ranges > 0)
+	{
+		int ip_index = 0;
+		char comma[3] = "";
+		printf("--%s ", (info->exclude_type == WEBMON_EXCLUDE ? "exclude_ips" : "include_ips"));
+		for(ip_index=0; ip_index < info->num_exclude_ips; ip_index++)
+		{
+			printf("%s"STRIP, comma, NIPQUAD((info->exclude_ips)[ip_index]) );
+			sprintf(comma, ",");
+		}
+		for(ip_index=0; ip_index < info->num_exclude_ranges; ip_index++)
+		{
+			struct ipt_webmon_ip_range r = (info->exclude_ranges)[ip_index];
+			printf("%s"STRIP"-"STRIP, comma, NIPQUAD(r.start), NIPQUAD(r.end) );
+			sprintf(comma, ",");
+		}
+		printf(" ");
+	}
+}
+
+
+static void do_load(char* file, uint32_t max, unsigned char type)
+{
+	if(file != NULL)
+	{
+		unsigned char* data = NULL;
+		unsigned long data_length = 0;
+		char* file_data = NULL;
+		if(strcmp(file, "/dev/null") != 0)
+		{
+			FILE* in = fopen(file, "r");
+			if(in != NULL)
+			{
+				file_data = (char*)read_entire_file(in, 4096, &data_length);
+				fclose(in);
+			}
+		}
+		if(file_data == NULL)
+		{
+			file_data=strdup("");
+		}
+		
+		if(file_data != NULL)
+		{
+			data_length = strlen(file_data) + sizeof(uint32_t)+2;
+			data = (unsigned char*)malloc(data_length);
+			if(data != NULL)
+			{
+				int sockfd = -1;
+				uint32_t* maxp = (uint32_t*)(data+1);
+				data[0] = type;
+				*maxp = max;
+				sprintf( (data+1+sizeof(uint32_t)),  "%s", file_data);
+			
+				sockfd = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
+				if(sockfd >= 0)
+				{
+					setsockopt(sockfd, IPPROTO_IP, WEBMON_SET, data, data_length);
+					close(sockfd);
+				}
+				free(data);
+			}
+			free(file_data);
+		}
+	}
+
+}
+
+
+static void final_check(unsigned int flags)
+{
+	do_load(domain_load_file, global_max_domains,  WEBMON_DOMAIN);
+	do_load(search_load_file, global_max_searches, WEBMON_SEARCH);
+}
+
+/* Prints out the matchinfo. */
+#ifdef _XTABLES_H
+static void print(const void *ip, const struct xt_entry_match *match, int numeric)
+#else	
+static void print(const struct ipt_ip *ip, const struct ipt_entry_match *match, int numeric)
+#endif
+{
+	printf("WEBMON ");
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+
+	print_webmon_args(info);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+#ifdef _XTABLES_H
+static void save(const void *ip, const struct xt_entry_match *match)
+#else
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+#endif
+{
+	struct ipt_webmon_info *info = (struct ipt_webmon_info *)match->data;
+	print_webmon_args(info);
+}
+
+
+
+
+#ifdef XTABLES_VERSION
+static struct xtables_match webmon = 
+{
+  .name = "webmon",
+  .version = XTABLES_VERSION,
+  .family = PF_INET,
+  .size = XT_ALIGN(sizeof(struct ipt_webmon_info)),
+  .userspacesize = XT_ALIGN(sizeof(struct ipt_webmon_info)),
+  .help = help,
+  .init = webmon_init,
+  .parse = parse,
+  .final_check = final_check,
+  .print = print,
+  .save = save,
+  .extra_opts = opts
+};
+#else
+static struct iptables_match webmon = 
+{ 
+	.next		= NULL,
+ 	.name		= "webmon",
+	.version = IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_webmon_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_webmon_info)),
+	.help		= &help,
+	.init           = &webmon_init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+#endif
+
+void _init(void)
+{
+#ifdef XTABLES_VERSION
+  xtables_register_match(&webmon);
+#else
+  register_match(&webmon);
+#endif
+}
+
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+
+
+
+
+
+
+/*static void param_problem_exit_error(char* msg)
+{
+	#ifdef xtables_error
+		xtables_error(PARAMETER_PROBLEM, msg);
+	#else
+		exit_error(PARAMETER_PROBLEM, msg);
+	#endif
+}*/
+
+
+static void parse_ips_and_ranges(char* addr_str, struct ipt_webmon_info *info)
+{
+	char** addr_parts = split_on_separators(addr_str, ",", 1, -1, 0);
+
+	info->num_exclude_ips=0;
+	info->num_exclude_ranges = 0;
+
+	int ip_part_index;
+	for(ip_part_index=0; addr_parts[ip_part_index] != NULL; ip_part_index++)
+	{
+		char* next_str = addr_parts[ip_part_index];
+		if(strchr(next_str, '-') != NULL)
+		{
+			char** range_parts = split_on_separators(next_str, "-", 1, 2, 1);
+			char* start = trim_flanking_whitespace(range_parts[0]);
+			char* end = trim_flanking_whitespace(range_parts[1]);
+			int start_ip[4];
+			int end_ip[4];
+			int start_valid = sscanf(start, "%d.%d.%d.%d", start_ip, start_ip+1, start_ip+2, start_ip+3);
+			int end_valid = sscanf(end, "%d.%d.%d.%d", end_ip, end_ip+1, end_ip+2, end_ip+3);
+			
+			if(start_valid == 4 && end_valid == 4)
+			{
+				struct ipt_webmon_ip_range r;
+				struct in_addr sip, eip;
+				inet_pton(AF_INET, start, &sip);
+				inet_pton(AF_INET, end, &eip);
+				r.start = (uint32_t)sip.s_addr;
+				r.end   = (uint32_t)eip.s_addr;
+
+				if(info->num_exclude_ranges <  WEBMON_MAX_IP_RANGES  && (unsigned long)ntohl(r.start) < (unsigned long)ntohl(r.end) )
+				{
+					(info->exclude_ranges)[ info->num_exclude_ranges ] = r;
+					info->num_exclude_ranges = info->num_exclude_ranges + 1;
+				}
+			}
+
+			free(start);
+			free(end);	
+			free(range_parts);
+		}
+		else if(strchr(next_str, '/') != NULL)
+		{
+			char** range_parts = split_on_separators(next_str, "/", 1, 2, 1);
+			char* start = trim_flanking_whitespace(range_parts[0]);
+			char* end = trim_flanking_whitespace(range_parts[1]);
+			int base_ip[4];
+			int base_valid = sscanf(start, "%d.%d.%d.%d", base_ip, base_ip+1, base_ip+2, base_ip+3);
+			if(base_valid == 4)
+			{
+				int mask_valid = 0;
+				uint32_t mask;
+				if(strchr(end, '.') != NULL)
+				{
+					uint32_t mask_ip[4];
+					int mask_test = sscanf(end, "%d.%d.%d.%d", mask_ip, mask_ip+1, mask_ip+2, mask_ip+3);
+					if(mask_test == 4)
+					{
+						struct in_addr mask_add;
+						inet_pton(AF_INET, end, &mask_add);
+						mask = (uint32_t)mask_add.s_addr;
+						mask_valid = 1;
+					}
+				}
+				else
+				{
+					int mask_bits;
+					if( sscanf(end, "%d", &mask_bits) > 0)
+					{
+						if(mask_bits >=0 && mask_bits <= 32)
+						{
+							uint32_t byte = 0;
+							mask = 0;
+							for(byte=0; byte < 4; byte++)
+							{
+								unsigned char byte_bits = mask_bits > 8 ? 8 : mask_bits;
+								uint32_t byte_mask = 0;
+								mask_bits = mask_bits - byte_bits;
+								
+								while(byte_bits > 0)
+								{
+									byte_mask = byte_mask | (256 >> byte_bits);
+									byte_bits--;
+								}
+								mask = mask | ((uint32_t)byte_mask << (byte*8));
+								printf("mask = "STRIP"\n", NIPQUAD(mask));	
+							}
+							mask_valid = 1;
+						}
+					}
+				}
+				if(mask_valid)
+				{
+					struct ipt_webmon_ip_range r;
+					struct in_addr bip;
+					inet_pton(AF_INET, start, &bip);
+					r.start = ( ((uint32_t)bip.s_addr) & mask );
+					r.end   = ( ((uint32_t)bip.s_addr) | (~mask) );
+					if(info->num_exclude_ranges <  WEBMON_MAX_IP_RANGES && ntohl(r.start) <= ntohl(r.end) )
+					{
+						(info->exclude_ranges)[ info->num_exclude_ranges ] = r;
+						info->num_exclude_ranges = info->num_exclude_ranges + 1;
+					}
+				}
+			}
+			free(start);
+			free(end);	
+			free(range_parts);
+		}
+		else
+		{
+			int parsed_ip[4];
+			int valid = sscanf(next_str, "%d.%d.%d.%d", parsed_ip, parsed_ip+1, parsed_ip+2, parsed_ip+3);
+			if(valid == 4)
+			{
+				struct in_addr ip;
+				trim_flanking_whitespace(next_str);
+				inet_pton(AF_INET, next_str, &ip);
+				
+				if(info->num_exclude_ranges <  WEBMON_MAX_IPS)
+				{
+					(info->exclude_ips)[ info->num_exclude_ips ] = (uint32_t)ip.s_addr;
+					info->num_exclude_ips = info->num_exclude_ips + 1;
+				}
+			}
+		}
+		free(next_str);
+	}
+	free(addr_parts);
+	
+}
+
+
+
+/*
+ * line_str is the line to be parsed -- it is not modified in any way
+ * max_pieces indicates number of pieces to return, if negative this is determined dynamically
+ * include_remainder_at_max indicates whether the last piece, when max pieces are reached, 
+ * 	should be what it would normally be (0) or the entire remainder of the line (1)
+ * 	if max_pieces < 0 this parameter is ignored
+ *
+ *
+ * returns all non-separator pieces in a line
+ * result is dynamically allocated, MUST be freed after call-- even if 
+ * line is empty (you still get a valid char** pointer to to a NULL char*)
+ */
+static char** split_on_separators(char* line_str, char* separators, int num_separators, int max_pieces, int include_remainder_at_max)
+{
+	char** split;
+
+	if(line_str != NULL)
+	{
+		int split_index;
+		int non_separator_found;
+		char* dup_line;
+		char* start;
+
+		if(max_pieces < 0)
+		{
+			/* count number of separator characters in line -- this count + 1 is an upperbound on number of pieces */
+			int separator_count = 0;
+			int line_index;
+			for(line_index = 0; line_str[line_index] != '\0'; line_index++)
+			{
+				int sep_index;
+				int found = 0;
+				for(sep_index =0; found == 0 && sep_index < num_separators; sep_index++)
+				{
+					found = separators[sep_index] == line_str[line_index] ? 1 : 0;
+				}
+				separator_count = separator_count+ found;
+			}
+			max_pieces = separator_count + 1;
+		}
+		split = (char**)malloc((1+max_pieces)*sizeof(char*));
+		split_index = 0;
+		split[split_index] = NULL;
+
+
+		dup_line = strdup(line_str);
+		start = dup_line;
+		non_separator_found = 0;
+		while(non_separator_found == 0)
+		{
+			int matches = 0;
+			int sep_index;
+			for(sep_index =0; sep_index < num_separators; sep_index++)
+			{
+				matches = matches == 1 || separators[sep_index] == start[0] ? 1 : 0;
+			}
+			non_separator_found = matches==0 || start[0] == '\0' ? 1 : 0;
+			if(non_separator_found == 0)
+			{
+				start++;
+			}
+		}
+
+		while(start[0] != '\0' && split_index < max_pieces)
+		{
+			/* find first separator index */
+			int first_separator_index = 0;
+			int separator_found = 0;
+			while(	separator_found == 0 )
+			{
+				int sep_index;
+				for(sep_index =0; separator_found == 0 && sep_index < num_separators; sep_index++)
+				{
+					separator_found = separators[sep_index] == start[first_separator_index] || start[first_separator_index] == '\0' ? 1 : 0;
+				}
+				if(separator_found == 0)
+				{
+					first_separator_index++;
+				}
+			}
+			
+			/* copy next piece to split array */
+			if(first_separator_index > 0)
+			{
+				char* next_piece = NULL;
+				if(split_index +1 < max_pieces || include_remainder_at_max <= 0)
+				{
+					next_piece = (char*)malloc((first_separator_index+1)*sizeof(char));
+					memcpy(next_piece, start, first_separator_index);
+					next_piece[first_separator_index] = '\0';
+				}
+				else
+				{
+					next_piece = strdup(start);
+				}
+				split[split_index] = next_piece;
+				split[split_index+1] = NULL;
+				split_index++;
+			}
+
+
+			/* find next non-separator index, indicating start of next piece */
+			start = start+ first_separator_index;
+			non_separator_found = 0;
+			while(non_separator_found == 0)
+			{
+				int matches = 0;
+				int sep_index;
+				for(sep_index =0; sep_index < num_separators; sep_index++)
+				{
+					matches = matches == 1 || separators[sep_index] == start[0] ? 1 : 0;
+				}
+				non_separator_found = matches==0 || start[0] == '\0' ? 1 : 0;
+				if(non_separator_found == 0)
+				{
+					start++;
+				}
+			}
+		}
+		free(dup_line);
+	}
+	else
+	{
+		split = (char**)malloc((1)*sizeof(char*));
+		split[0] = NULL;
+	}
+	return split;
+}
+
+
+
+static char* trim_flanking_whitespace(char* str)
+{
+	int new_start = 0;
+	int new_length = 0;
+
+	char whitespace[5] = { ' ', '\t', '\n', '\r', '\0' };
+	int num_whitespace_chars = 4;
+	
+	
+	int str_index = 0;
+	int is_whitespace = 1;
+	int test;
+	while( (test = str[str_index]) != '\0' && is_whitespace == 1)
+	{
+		int whitespace_index;
+		is_whitespace = 0;
+		for(whitespace_index = 0; whitespace_index < num_whitespace_chars && is_whitespace == 0; whitespace_index++)
+		{
+			is_whitespace = test == whitespace[whitespace_index] ? 1 : 0;
+		}
+		str_index = is_whitespace == 1 ? str_index+1 : str_index;
+	}
+	new_start = str_index;
+
+
+	str_index = strlen(str) - 1;
+	is_whitespace = 1;
+	while( str_index >= new_start && is_whitespace == 1)
+	{
+		int whitespace_index;
+		is_whitespace = 0;
+		for(whitespace_index = 0; whitespace_index < num_whitespace_chars && is_whitespace == 0; whitespace_index++)
+		{
+			is_whitespace = str[str_index] == whitespace[whitespace_index] ? 1 : 0;
+		}
+		str_index = is_whitespace == 1 ? str_index-1 : str_index;
+	}
+	new_length = str[new_start] == '\0' ? 0 : str_index + 1 - new_start;
+	
+
+	if(new_start > 0)
+	{
+		for(str_index = 0; str_index < new_length; str_index++)
+		{
+			str[str_index] = str[str_index+new_start];
+		}
+	}
+	str[new_length] = 0;
+	return str;
+}
+
+
+static unsigned char* read_entire_file(FILE* in, unsigned long read_block_size, unsigned long *length)
+{
+	int max_read_size = read_block_size;
+	unsigned char* read_string = (unsigned char*)malloc(max_read_size+1);
+	unsigned long bytes_read = 0;
+	int end_found = 0;
+	while(end_found == 0)
+	{
+		int nextch = '?';
+		while(nextch != EOF && bytes_read < max_read_size)
+		{
+			nextch = fgetc(in);
+			if(nextch != EOF)
+			{
+				read_string[bytes_read] = (unsigned char)nextch;
+				bytes_read++;
+			}
+		}
+		read_string[bytes_read] = '\0';
+		end_found = (nextch == EOF) ? 1 : 0;
+		if(end_found == 0)
+		{
+			unsigned char *new_str;
+			max_read_size = max_read_size + read_block_size;
+		       	new_str = (unsigned char*)malloc(max_read_size+1);
+			memcpy(new_str, read_string, bytes_read);
+			free(read_string);
+			read_string = new_str;
+		}
+	}
+	*length = bytes_read;
+	return read_string;
+}
+
--- iptables-1.8.x/extensions/libipt_webstr.c
+++ iptables-1.8.x/extensions/libipt_webstr.c
@@ -0,0 +1,241 @@
+/* Shared library add-on to iptables to add string matching support. 
+ * 
+ * Copyright (C) 2000 Emmanuel Roger  <winfield@freegates.be>
+ *
+ * ChangeLog
+ *     27.01.2001: Gianni Tedesco <gianni@ecsc.co.uk>
+ *             Changed --tos to --string in save(). Also
+ *             updated to work with slightly modified
+ *             ipt_string_info.
+ */
+
+/* Shared library add-on to iptables to add webstr matching support. 
+ *
+ * Copyright (C) 2003, CyberTAN Corporation
+ * All Rights Reserved.
+ *
+ * Description:
+ *   This is shared library, added to iptables, for web content inspection. 
+ *   It was derived from 'string' matching support, declared as above.
+ *
+ */
+
+/* iptable-1.4.0rc1 port. (ipt->xt)
+ *
+ * Copyright (C) 2008, Ralink Technology Corporation
+ * All Rights Reserved.
+ */
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+//#include <linux/netfilter_ipv4/ipt_webstr.h>
+
+#define BM_MAX_NLEN 256
+#define BM_MAX_HLEN 1024
+
+#define BLK_JAVA        0x01
+#define BLK_ACTIVE      0x02
+#define BLK_COOKIE      0x04
+#define BLK_PROXY       0x08
+
+typedef char *(*proc_ipt_search) (char *, char *, int, int);
+
+struct ipt_webstr_info {
+    char string[BM_MAX_NLEN];
+    u_int16_t invert;
+    u_int16_t len;
+    u_int8_t type;
+};
+
+enum xt_webstr_type
+{
+    IPT_WEBSTR_HOST,
+    IPT_WEBSTR_URL,
+    IPT_WEBSTR_CONTENT
+};
+
+
+
+/* Function which prints out usage message. */
+static void
+webstr_help(void)
+{
+	printf(
+"WEBSTR match v%s options:\n"
+"--webstr [!] host            Match a http string in a packet\n"
+"--webstr [!] url             Match a http string in a packet\n"
+"--webstr [!] content         Match a http string in a packet\n",
+XTABLES_VERSION);
+
+	fputc('\n', stdout);
+}
+
+static struct option webstr_opts[] = {
+	{.name = "host", .has_arg = true, .val = '1' },
+	{.name = "url", .has_arg = true, .val = '2' },
+	{.name = "content", .has_arg = true, .val = '3' },
+	XT_GETOPT_TABLEEND,
+};
+
+/* Initialize the match. */
+static void
+webstr_init(struct ipt_entry_match *m)
+{
+	return;
+}
+
+static void
+parse_string(const unsigned char *s, struct ipt_webstr_info *info)
+{	
+        if (strlen(s) <= BM_MAX_NLEN) strcpy(info->string, s);
+	else xtables_error(PARAMETER_PROBLEM, "WEBSTR too long `%s'", s);
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+webstr_parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry,
+#if 0
+      unsigned int *nfcache,
+#endif
+      struct ipt_entry_match **match)
+{
+	struct ipt_webstr_info *stringinfo = (struct ipt_webstr_info *)(*match)->data;
+
+	switch (c) {
+	case '1':
+		parse_string(argv[optind-1], stringinfo);
+		if (invert)
+			stringinfo->invert = 1;
+                stringinfo->len=strlen((char *)&stringinfo->string);
+                stringinfo->type = IPT_WEBSTR_HOST;
+		break;
+
+	case '2':
+		parse_string(argv[optind-1], stringinfo);
+		if (invert)
+			stringinfo->invert = 1;
+                stringinfo->len=strlen((char *)&stringinfo->string);
+                stringinfo->type = IPT_WEBSTR_URL;
+		break;
+
+	case '3':
+		parse_string(argv[optind-1], stringinfo);
+		if (invert)
+			stringinfo->invert = 1;
+                stringinfo->len=strlen((char *)&stringinfo->string);
+                stringinfo->type = IPT_WEBSTR_CONTENT;
+		break;
+
+	default:
+		return 0;
+	}
+
+	*flags = 1;
+	return 1;
+}
+
+static void
+print_string(char string[], int invert, int numeric)
+{
+
+	if (invert)
+		fputc('!', stdout);
+	printf("%s ",string);
+}
+
+/* Final check; must have specified --string. */
+static void
+webstr_final_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+			   "WEBSTR match: You must specify `--webstr'");
+}
+
+/* Prints out the matchinfo. */
+static void
+webstr_print(const void *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_webstr_info *stringinfo = (struct ipt_webstr_info *)match->data;
+
+	printf("WEBSTR match ");
+
+	
+	switch (stringinfo->type) {
+	case IPT_WEBSTR_HOST:
+		printf("host ");
+		break;
+
+	case IPT_WEBSTR_URL:
+		printf("url ");
+		break;
+
+	case IPT_WEBSTR_CONTENT:
+		printf("content ");
+		break;
+
+	default:
+		printf("ERROR ");
+		break;
+	}
+
+	print_string(((struct ipt_webstr_info *)match->data)->string,
+		  ((struct ipt_webstr_info *)match->data)->invert, numeric);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void
+webstr_save(const void *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_webstr_info *stringinfo = (struct ipt_webstr_info *)match->data;
+
+	switch (stringinfo->type) {
+	case IPT_WEBSTR_HOST:
+		printf(" --host ");
+		break;
+
+	case IPT_WEBSTR_URL:
+		printf(" --url ");
+		break;
+
+	case IPT_WEBSTR_CONTENT:
+		printf(" --content ");
+		break;
+
+	default:
+		printf(" ERROR ");
+		break;
+	}
+	print_string(((struct ipt_webstr_info *)match->data)->string,
+		  ((struct ipt_webstr_info *)match->data)->invert, 0);
+}
+
+static
+struct xtables_match webstr_match = {
+    .family = NFPROTO_IPV4,
+    .name = "webstr",
+    .version = XTABLES_VERSION,
+    .size = XT_ALIGN(sizeof(struct ipt_webstr_info)),
+    .userspacesize = XT_ALIGN(sizeof(struct ipt_webstr_info)),
+    .help = webstr_help,
+    .init = webstr_init,
+    .parse = webstr_parse,
+    .final_check = webstr_final_check,
+    .print = webstr_print,
+    .save = webstr_save,
+    .extra_opts = webstr_opts
+};
+
+void _init(void)
+{
+	xtables_register_match(&webstr_match);
+}
--- iptables-1.8.x/extensions/libxt_ethport.c
+++ iptables-1.8.x/extensions/libxt_ethport.c
@@ -0,0 +1,146 @@
+/*
+ * IP tables module for matching the value of the incoming ether port
+ * for Ralink SoC platform.
+ *
+ * (C) 2009 by yy_huang@ralinktech.com.tw
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include "iptables.h"
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_ethport.h>
+
+static void ethport_help(void)
+{
+	printf(
+"Ethport match v%s options\n"
+"[!] --portnum value		Match Ether port number with numerical value\n"
+"  		                This value can be in decimal (ex: 3)\n"
+"               		or in hex (ex: 0x3)\n"
+				, XTABLES_VERSION
+);
+}
+
+static const struct option ethport_opts[] = {
+	{.name = "portnum", .has_arg = true, .val = 'F'},
+	XT_GETOPT_TABLEEND,
+};
+
+static void
+parse_ethport(const char *s, struct xt_ethport_info *dinfo)
+{
+	unsigned int portnum;
+       
+	if (!xtables_strtoui(s, NULL, &portnum, 0, UINT8_MAX))
+		xtables_error(PARAMETER_PROBLEM,
+			   "Invalid portnum `%s'\n", s);
+
+	if (portnum > XT_ETHPORT_MAX)
+		xtables_error(PARAMETER_PROBLEM,
+			   "Ethport `%d` out of range\n", portnum);
+
+    	dinfo->portnum = (u_int8_t )portnum;
+    	return;
+}
+
+
+static int
+ethport_parse(int c, char **argv, int invert, unsigned int *flags,
+           const void *entry, struct xt_entry_match **match)
+{
+	struct xt_ethport_info *dinfo
+		= (struct xt_ethport_info *)(*match)->data;
+
+	switch (c) {
+	case 'F':
+		if (*flags)
+			xtables_error(PARAMETER_PROBLEM,
+			           "Ethport match: Only use --portnum ONCE!");
+		parse_ethport(argv[optind-1], dinfo);
+		if (invert)
+			dinfo->invert = 1;
+		*flags = 1;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void ethport_check(unsigned int flags)
+{
+	if (!flags)
+		xtables_error(PARAMETER_PROBLEM,
+		           "Ethport match: Parameter --portnum is required");
+}
+
+static void
+print_ethport(u_int8_t portnum, int invert, int numeric)
+{
+	if (invert)
+		fputc('!', stdout);
+
+ 	printf("0x%02x ", portnum);
+}
+
+/* Prints out the matchinfo. */
+static void
+ethport_print(const void *ip, const struct xt_entry_match *match, int numeric)
+{
+	const struct xt_ethport_info *dinfo = (const struct xt_ethport_info *)match->data;
+	printf("Ethport match ");
+	print_ethport(dinfo->portnum, dinfo->invert, numeric);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void ethport_save(const void *ip, const struct xt_entry_match *match)
+{
+	const struct xt_ethport_info *dinfo = (const struct xt_ethport_info *)match->data;
+
+	printf("--portnum ");
+	print_ethport(dinfo->portnum, dinfo->invert, 1);
+}
+
+static struct xtables_match ethport_match = {
+	.family		= NFPROTO_IPV4,
+	.name 		= "ethport",
+	.version 	= XTABLES_VERSION,
+	.size 		= XT_ALIGN(sizeof(struct xt_ethport_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_ethport_info)),
+	.help		= ethport_help,
+	.parse		= ethport_parse,
+	.final_check	= ethport_check,
+	.print		= ethport_print,
+	.save		= ethport_save,
+	.extra_opts	= ethport_opts,
+};
+
+static struct xtables_match ethport_match6 = {
+	.family		= NFPROTO_UNSPEC,
+	.name 		= "ethport",
+	.version 	= XTABLES_VERSION,
+	.size 		= XT_ALIGN(sizeof(struct xt_ethport_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_ethport_info)),
+	.help		= ethport_help,
+	.parse		= ethport_parse,
+	.final_check	= ethport_check,
+	.print		= ethport_print,
+	.save		= ethport_save,
+	.extra_opts	= ethport_opts,
+};
+
+void _init(void)
+{
+	xtables_register_match(&ethport_match);
+	xtables_register_match(&ethport_match6);
+}
--- iptables-1.8.x/extensions/libxt_IMQ.c
+++ iptables-1.8.x/extensions/libxt_IMQ.c
@@ -0,0 +1,105 @@
+/* Shared library add-on to iptables to add IMQ target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <xtables.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter/xt_IMQ.h>
+
+/* Function which prints out usage message. */
+static void IMQ_help(void)
+{
+	printf(
+"IMQ target options:\n"
+"  --todev <N>		enqueue to imq<N>, defaults to 0\n");
+
+}
+
+static struct option IMQ_opts[] = {
+	{ "todev", 1, 0, '1' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void IMQ_init(struct xt_entry_target *t)
+{
+	struct xt_imq_info *mr = (struct xt_imq_info*)t->data;
+
+	mr->todev = 0;
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int IMQ_parse(int c, char **argv, int invert, unsigned int *flags,
+      const void *entry, struct xt_entry_target **target)
+{
+	struct xt_imq_info *mr = (struct xt_imq_info*)(*target)->data;
+	
+	switch(c) {
+	case '1':
+/*		if (xtables_check_inverse(optarg, &invert, NULL, 0, argv))
+			xtables_error(PARAMETER_PROBLEM,
+				   "Unexpected `!' after --todev");
+*/
+		mr->todev=atoi(optarg);
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Prints out the targinfo. */
+static void IMQ_print(const void *ip,
+      const struct xt_entry_target *target,
+      int numeric)
+{
+	struct xt_imq_info *mr = (struct xt_imq_info*)target->data;
+
+	printf("IMQ: todev %u ", mr->todev);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void IMQ_save(const void *ip, const struct xt_entry_target *target)
+{
+	struct xt_imq_info *mr = (struct xt_imq_info*)target->data;
+
+	printf(" --todev %u", mr->todev);
+}
+
+static struct xtables_target imq_target = {
+	.name		= "IMQ",
+	.version	= XTABLES_VERSION,
+	.family		= NFPROTO_IPV4,
+	.size		= XT_ALIGN(sizeof(struct xt_imq_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_imq_info)),
+	.help		= IMQ_help,
+	.init		= IMQ_init,
+	.parse		= IMQ_parse,
+	.print		= IMQ_print,
+	.save		= IMQ_save,
+	.extra_opts	= IMQ_opts,
+};
+
+static struct xtables_target imq_target6 = {
+	.name		= "IMQ",
+	.version	= XTABLES_VERSION,
+	.family		= NFPROTO_IPV6,
+	.size		= XT_ALIGN(sizeof(struct xt_imq_info)),
+	.userspacesize	= XT_ALIGN(sizeof(struct xt_imq_info)),
+	.help		= IMQ_help,
+	.init		= IMQ_init,
+	.parse		= IMQ_parse,
+	.print		= IMQ_print,
+	.save		= IMQ_save,
+	.extra_opts	= IMQ_opts,
+};
+
+// void __attribute((constructor)) nf_ext_init(void){
+void _init(void){
+	xtables_register_target(&imq_target);
+	xtables_register_target(&imq_target6);
+}
--- iptables-1.8.x/extensions/libxt_IMQ.man
+++ iptables-1.8.x/extensions/libxt_IMQ.man
@@ -0,0 +1,15 @@
+This target is used to redirect the traffic to the IMQ driver and you can apply
+QoS rules like HTB or CBQ.
+For example you can select only traffic comming from a specific interface or
+is going out on a specific interface.
+Also it permits to capture the traffic BEFORE NAT in the case of outgoing traffic
+or AFTER NAT in the case of incomming traffic.
+.TP
+\fB\-\-to\-dev\fP \fIvalue\fP
+Set the IMQ interface where to send this traffic
+.TP
+Example:
+.TP
+Redirect incomming traffic from interface eth0 to imq0 and outgoing traffic to imq1:
+iptables \-t mangle \-A FORWARD \-i eth0 \-j IMQ \-\-to\-dev 0
+iptables \-t mangle \-A FORWARD \-o eth0 \-j IMQ \-\-to\-dev 1
--- iptables-1.8.x/iptables/xtoptions.c
+++ iptables-1.8.x/iptables/xtoptions.c
@@ -0,0 +1,1211 @@
+/*
+ *	Argument parser
+ *	Copyright © Jan Engelhardt, 2011
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License as
+ *	published by the Free Software Foundation; either version 2 of
+ *	the License, or (at your option) any later version.
+ */
+#include <ctype.h>
+#include <errno.h>
+#include <getopt.h>
+#include <limits.h>
+#include <netdb.h>
+#include <stdbool.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <syslog.h>
+#include <arpa/inet.h>
+#include <netinet/ip.h>
+#include "xtables.h"
+#include "xshared.h"
+#ifndef IPTOS_NORMALSVC
+#	define IPTOS_NORMALSVC 0
+#endif
+
+#define XTOPT_MKPTR(cb) \
+	((void *)((char *)(cb)->data + (cb)->entry->ptroff))
+
+/**
+ * Simple key-value pairs for syslog levels
+ */
+struct syslog_level {
+	char name[8];
+	uint8_t level;
+};
+
+struct tos_value_mask {
+	uint8_t value, mask;
+};
+
+static const size_t xtopt_psize[] = {
+	/*
+	 * All types not listed here, and thus essentially being initialized to
+	 * zero have zero on purpose.
+	 */
+	[XTTYPE_UINT8]       = sizeof(uint8_t),
+	[XTTYPE_UINT16]      = sizeof(uint16_t),
+	[XTTYPE_UINT32]      = sizeof(uint32_t),
+	[XTTYPE_UINT64]      = sizeof(uint64_t),
+	[XTTYPE_UINT8RC]     = sizeof(uint8_t[2]),
+	[XTTYPE_UINT16RC]    = sizeof(uint16_t[2]),
+	[XTTYPE_UINT32RC]    = sizeof(uint32_t[2]),
+	[XTTYPE_UINT64RC]    = sizeof(uint64_t[2]),
+	[XTTYPE_DOUBLE]      = sizeof(double),
+	[XTTYPE_STRING]      = -1,
+	[XTTYPE_SYSLOGLEVEL] = sizeof(uint8_t),
+	[XTTYPE_HOST]        = sizeof(union nf_inet_addr),
+	[XTTYPE_HOSTMASK]    = sizeof(union nf_inet_addr),
+	[XTTYPE_PROTOCOL]    = sizeof(uint8_t),
+	[XTTYPE_PORT]        = sizeof(uint16_t),
+	[XTTYPE_PORTRC]      = sizeof(uint16_t[2]),
+	[XTTYPE_PLENMASK]    = sizeof(union nf_inet_addr),
+	[XTTYPE_ETHERMAC]    = sizeof(uint8_t[6]),
+};
+
+/**
+ * Creates getopt options from the x6-style option map, and assigns each a
+ * getopt id.
+ */
+struct option *
+xtables_options_xfrm(struct option *orig_opts, struct option *oldopts,
+		     const struct xt_option_entry *entry, unsigned int *offset)
+{
+	unsigned int num_orig, num_old = 0, num_new, i;
+	struct option *merge, *mp;
+
+	if (entry == NULL)
+		return oldopts;
+	for (num_orig = 0; orig_opts[num_orig].name != NULL; ++num_orig)
+		;
+	if (oldopts != NULL)
+		for (num_old = 0; oldopts[num_old].name != NULL; ++num_old)
+			;
+	for (num_new = 0; entry[num_new].name != NULL; ++num_new)
+		;
+
+	/*
+	 * Since @oldopts also has @orig_opts already (and does so at the
+	 * start), skip these entries.
+	 */
+	oldopts += num_orig;
+	num_old -= num_orig;
+
+	merge = malloc(sizeof(*mp) * (num_orig + num_old + num_new + 1));
+	if (merge == NULL)
+		return NULL;
+
+	/* Let the base options -[ADI...] have precedence over everything */
+	memcpy(merge, orig_opts, sizeof(*mp) * num_orig);
+	mp = merge + num_orig;
+
+	/* Second, the new options */
+	xt_params->option_offset += XT_OPTION_OFFSET_SCALE;
+	*offset = xt_params->option_offset;
+
+	for (i = 0; i < num_new; ++i, ++mp, ++entry) {
+		mp->name         = entry->name;
+		mp->has_arg      = entry->type != XTTYPE_NONE;
+		mp->flag         = NULL;
+		mp->val          = entry->id + *offset;
+	}
+
+	/* Third, the old options */
+	memcpy(mp, oldopts, sizeof(*mp) * num_old);
+	mp += num_old;
+	xtables_free_opts(0);
+
+	/* Clear trailing entry */
+	memset(mp, 0, sizeof(*mp));
+	return merge;
+}
+
+/**
+ * Give the upper limit for a certain type.
+ */
+static uintmax_t xtopt_max_by_type(enum xt_option_type type)
+{
+	switch (type) {
+	case XTTYPE_UINT8:
+	case XTTYPE_UINT8RC:
+		return UINT8_MAX;
+	case XTTYPE_UINT16:
+	case XTTYPE_UINT16RC:
+		return UINT16_MAX;
+	case XTTYPE_UINT32:
+	case XTTYPE_UINT32RC:
+		return UINT32_MAX;
+	case XTTYPE_UINT64:
+	case XTTYPE_UINT64RC:
+		return UINT64_MAX;
+	default:
+		return 0;
+	}
+}
+
+/**
+ * Return the size of a single entity based upon a type - predominantly an
+ * XTTYPE_UINT*RC type.
+ */
+static size_t xtopt_esize_by_type(enum xt_option_type type)
+{
+	switch (type) {
+	case XTTYPE_UINT8RC:
+		return xtopt_psize[XTTYPE_UINT8];
+	case XTTYPE_UINT16RC:
+		return xtopt_psize[XTTYPE_UINT16];
+	case XTTYPE_UINT32RC:
+		return xtopt_psize[XTTYPE_UINT32];
+	case XTTYPE_UINT64RC:
+		return xtopt_psize[XTTYPE_UINT64];
+	default:
+		return xtopt_psize[type];
+	}
+}
+
+/**
+ * Require a simple integer.
+ */
+static void xtopt_parse_int(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	uintmax_t lmin = 0, lmax = xtopt_max_by_type(entry->type);
+	uintmax_t value;
+
+	if (cb->entry->min != 0)
+		lmin = cb->entry->min;
+	if (cb->entry->max != 0)
+		lmax = cb->entry->max;
+
+	if (!xtables_strtoul(cb->arg, NULL, &value, lmin, lmax))
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: bad value for option \"--%s\", "
+			"or out of range (%ju-%ju).\n",
+			cb->ext_name, entry->name, lmin, lmax);
+
+	if (entry->type == XTTYPE_UINT8) {
+		cb->val.u8 = value;
+		if (entry->flags & XTOPT_PUT)
+			*(uint8_t *)XTOPT_MKPTR(cb) = cb->val.u8;
+	} else if (entry->type == XTTYPE_UINT16) {
+		cb->val.u16 = value;
+		if (entry->flags & XTOPT_PUT)
+			*(uint16_t *)XTOPT_MKPTR(cb) = cb->val.u16;
+	} else if (entry->type == XTTYPE_UINT32) {
+		cb->val.u32 = value;
+		if (entry->flags & XTOPT_PUT)
+			*(uint32_t *)XTOPT_MKPTR(cb) = cb->val.u32;
+	} else if (entry->type == XTTYPE_UINT64) {
+		cb->val.u64 = value;
+		if (entry->flags & XTOPT_PUT)
+			*(uint64_t *)XTOPT_MKPTR(cb) = cb->val.u64;
+	}
+}
+
+/**
+ * Require a simple floating point number.
+ */
+static void xtopt_parse_float(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	double value;
+	char *end;
+
+	value = strtod(cb->arg, &end);
+	if (end == cb->arg || *end != '\0' ||
+	    (entry->min != entry->max &&
+	    (value < entry->min || value > entry->max)))
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: bad value for option \"--%s\", "
+			"or out of range (%u-%u).\n",
+			cb->ext_name, entry->name, entry->min, entry->max);
+
+	cb->val.dbl = value;
+	if (entry->flags & XTOPT_PUT)
+		*(double *)XTOPT_MKPTR(cb) = cb->val.dbl;
+}
+
+/**
+ * Copy the parsed value to the appropriate entry in cb->val.
+ */
+static void xtopt_mint_value_to_cb(struct xt_option_call *cb, uintmax_t value)
+{
+	const struct xt_option_entry *entry = cb->entry;
+
+	if (cb->nvals >= ARRAY_SIZE(cb->val.u32_range))
+		return;
+	if (entry->type == XTTYPE_UINT8RC)
+		cb->val.u8_range[cb->nvals] = value;
+	else if (entry->type == XTTYPE_UINT16RC)
+		cb->val.u16_range[cb->nvals] = value;
+	else if (entry->type == XTTYPE_UINT32RC)
+		cb->val.u32_range[cb->nvals] = value;
+	else if (entry->type == XTTYPE_UINT64RC)
+		cb->val.u64_range[cb->nvals] = value;
+}
+
+/**
+ * Copy the parsed value to the data area, using appropriate type access.
+ */
+static void xtopt_mint_value_to_ptr(struct xt_option_call *cb, void **datap,
+				    uintmax_t value)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	void *data = *datap;
+
+	if (!(entry->flags & XTOPT_PUT))
+		return;
+	if (entry->type == XTTYPE_UINT8RC)
+		*(uint8_t *)data = value;
+	else if (entry->type == XTTYPE_UINT16RC)
+		*(uint16_t *)data = value;
+	else if (entry->type == XTTYPE_UINT32RC)
+		*(uint32_t *)data = value;
+	else if (entry->type == XTTYPE_UINT64RC)
+		*(uint64_t *)data = value;
+	data += xtopt_esize_by_type(entry->type);
+	*datap = data;
+}
+
+/**
+ * Multiple integer parse routine.
+ *
+ * This function is capable of parsing any number of fields. Only the first
+ * two values from the string will be put into @cb however (and as such,
+ * @cb->val.uXX_range is just that large) to cater for the few extensions that
+ * do not have a range[2] field, but {min, max}, and which cannot use
+ * XTOPT_POINTER.
+ */
+static void xtopt_parse_mint(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	const char *arg = cb->arg;
+	size_t esize = xtopt_esize_by_type(entry->type);
+	const uintmax_t lmax = xtopt_max_by_type(entry->type);
+	void *put = XTOPT_MKPTR(cb);
+	unsigned int maxiter;
+	uintmax_t value;
+	char *end = "";
+	char sep = ':';
+
+	maxiter = entry->size / esize;
+	if (maxiter == 0)
+		maxiter = ARRAY_SIZE(cb->val.u32_range);
+	if (entry->size % esize != 0)
+		xt_params->exit_err(OTHER_PROBLEM, "%s: memory block does "
+			"not have proper size\n", __func__);
+
+	cb->nvals = 0;
+	for (arg = cb->arg, end = (char *)arg; ; arg = end + 1) {
+		if (cb->nvals == maxiter)
+			xt_params->exit_err(PARAMETER_PROBLEM, "%s: Too many "
+				"components for option \"--%s\" (max: %u)\n",
+				cb->ext_name, entry->name, maxiter);
+		if (*arg == '\0' || *arg == sep) {
+			/* Default range components when field not spec'd. */
+			end = (char *)arg;
+			value = (cb->nvals == 1) ? lmax : 0;
+		} else {
+			if (!xtables_strtoul(arg, &end, &value, 0, lmax))
+				xt_params->exit_err(PARAMETER_PROBLEM,
+					"%s: bad value for option \"--%s\" near "
+					"\"%s\", or out of range (0-%ju).\n",
+					cb->ext_name, entry->name, arg, lmax);
+			if (*end != '\0' && *end != sep)
+				xt_params->exit_err(PARAMETER_PROBLEM,
+					"%s: Argument to \"--%s\" has "
+					"unexpected characters near \"%s\".\n",
+					cb->ext_name, entry->name, end);
+		}
+		xtopt_mint_value_to_cb(cb, value);
+		++cb->nvals;
+		xtopt_mint_value_to_ptr(cb, &put, value);
+		if (*end == '\0')
+			break;
+	}
+}
+
+static void xtopt_parse_string(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	size_t z = strlen(cb->arg);
+	char *p;
+
+	if (entry->min != 0 && z < entry->min)
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"Argument must have a minimum length of "
+			"%u characters\n", entry->min);
+	if (entry->max != 0 && z > entry->max)
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"Argument must have a maximum length of "
+			"%u characters\n", entry->max);
+	if (!(entry->flags & XTOPT_PUT))
+		return;
+	if (z >= entry->size)
+		z = entry->size - 1;
+	p = XTOPT_MKPTR(cb);
+	strncpy(p, cb->arg, z);
+	p[z] = '\0';
+}
+
+static const struct tos_symbol_info {
+	unsigned char value;
+	const char *name;
+} tos_symbol_names[] = {
+	{IPTOS_LOWDELAY,    "Minimize-Delay"},
+	{IPTOS_THROUGHPUT,  "Maximize-Throughput"},
+	{IPTOS_RELIABILITY, "Maximize-Reliability"},
+	{IPTOS_MINCOST,     "Minimize-Cost"},
+	{IPTOS_NORMALSVC,   "Normal-Service"},
+	{},
+};
+
+/*
+ * tos_parse_numeric - parse a string like "15/255"
+ *
+ * @str:	input string
+ * @tvm:	(value/mask) tuple
+ * @max:	maximum allowed value (must be pow(2,some_int)-1)
+ */
+static bool tos_parse_numeric(const char *str, struct xt_option_call *cb,
+                              unsigned int max)
+{
+	unsigned int value;
+	char *end;
+
+	xtables_strtoui(str, &end, &value, 0, max);
+	cb->val.tos_value = value;
+	cb->val.tos_mask  = max;
+
+	if (*end == '/') {
+		const char *p = end + 1;
+
+		if (!xtables_strtoui(p, &end, &value, 0, max))
+			xtables_error(PARAMETER_PROBLEM, "Illegal value: \"%s\"",
+			           str);
+		cb->val.tos_mask = value;
+	}
+
+	if (*end != '\0')
+		xtables_error(PARAMETER_PROBLEM, "Illegal value: \"%s\"", str);
+	return true;
+}
+
+/**
+ * @str:	input string
+ * @tvm:	(value/mask) tuple
+ * @def_mask:	mask to force when a symbolic name is used
+ */
+static void xtopt_parse_tosmask(struct xt_option_call *cb)
+{
+	const struct tos_symbol_info *symbol;
+	char *tmp;
+
+	if (xtables_strtoui(cb->arg, &tmp, NULL, 0, UINT8_MAX)) {
+		tos_parse_numeric(cb->arg, cb, UINT8_MAX);
+		return;
+	}
+	/*
+	 * This is our way we deal with different defaults
+	 * for different revisions.
+	 */
+	cb->val.tos_mask = cb->entry->max;
+	for (symbol = tos_symbol_names; symbol->name != NULL; ++symbol)
+		if (strcasecmp(cb->arg, symbol->name) == 0) {
+			cb->val.tos_value = symbol->value;
+			return;
+		}
+
+	xtables_error(PARAMETER_PROBLEM, "Symbolic name \"%s\" is unknown",
+		      cb->arg);
+}
+
+/**
+ * Validate the input for being conformant to "mark[/mask]".
+ */
+static void xtopt_parse_markmask(struct xt_option_call *cb)
+{
+	unsigned int mark = 0, mask = ~0U;
+	char *end;
+
+	if (!xtables_strtoui(cb->arg, &end, &mark, 0, UINT32_MAX))
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: bad mark value for option \"--%s\", "
+			"or out of range.\n",
+			cb->ext_name, cb->entry->name);
+	if (*end == '/' &&
+	    !xtables_strtoui(end + 1, &end, &mask, 0, UINT32_MAX))
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: bad mask value for option \"--%s\", "
+			"or out of range.\n",
+			cb->ext_name, cb->entry->name);
+	if (*end != '\0')
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: trailing garbage after value "
+			"for option \"--%s\".\n",
+			cb->ext_name, cb->entry->name);
+	cb->val.mark = mark;
+	cb->val.mask = mask;
+}
+
+static int xtopt_sysloglvl_compare(const void *a, const void *b)
+{
+	const char *name = a;
+	const struct syslog_level *entry = b;
+
+	return strcmp(name, entry->name);
+}
+
+static void xtopt_parse_sysloglevel(struct xt_option_call *cb)
+{
+	static const struct syslog_level log_names[] = { /* must be sorted */
+		{"alert",   LOG_ALERT},
+		{"crit",    LOG_CRIT},
+		{"debug",   LOG_DEBUG},
+		{"emerg",   LOG_EMERG},
+		{"error",   LOG_ERR}, /* deprecated */
+		{"info",    LOG_INFO},
+		{"notice",  LOG_NOTICE},
+		{"panic",   LOG_EMERG}, /* deprecated */
+		{"warning", LOG_WARNING},
+	};
+	const struct syslog_level *e;
+	unsigned int num = 0;
+
+	if (!xtables_strtoui(cb->arg, NULL, &num, 0, 7)) {
+		e = bsearch(cb->arg, log_names, ARRAY_SIZE(log_names),
+			    sizeof(*log_names), xtopt_sysloglvl_compare);
+		if (e == NULL)
+			xt_params->exit_err(PARAMETER_PROBLEM,
+				"log level \"%s\" unknown\n", cb->arg);
+		num = e->level;
+	}
+	cb->val.syslog_level = num;
+	if (cb->entry->flags & XTOPT_PUT)
+		*(uint8_t *)XTOPT_MKPTR(cb) = num;
+}
+
+static void *xtables_sa_host(const void *sa, unsigned int afproto)
+{
+	if (afproto == AF_INET6)
+		return &((struct sockaddr_in6 *)sa)->sin6_addr;
+	else if (afproto == AF_INET)
+		return &((struct sockaddr_in *)sa)->sin_addr;
+	return (void *)sa;
+}
+
+static socklen_t xtables_sa_hostlen(unsigned int afproto)
+{
+	if (afproto == AF_INET6)
+		return sizeof(struct in6_addr);
+	else if (afproto == AF_INET)
+		return sizeof(struct in_addr);
+	return 0;
+}
+
+/**
+ * Accepts: a hostname (DNS), or a single inetaddr - without any mask. The
+ * result is stored in @cb->val.haddr. Additionally, @cb->val.hmask and
+ * @cb->val.hlen are set for completeness to the appropriate values.
+ */
+static void xtopt_parse_host(struct xt_option_call *cb)
+{
+	struct addrinfo hints = {.ai_family = afinfo->family};
+	unsigned int adcount = 0;
+	struct addrinfo *res, *p;
+	int ret;
+
+	ret = getaddrinfo(cb->arg, NULL, &hints, &res);
+	if (ret != 0)
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"getaddrinfo: %s\n", gai_strerror(ret));
+
+	memset(&cb->val.hmask, 0xFF, sizeof(cb->val.hmask));
+	cb->val.hlen = (afinfo->family == NFPROTO_IPV4) ? 32 : 128;
+
+	for (p = res; p != NULL; p = p->ai_next) {
+		if (adcount == 0) {
+			memset(&cb->val.haddr, 0, sizeof(cb->val.haddr));
+			memcpy(&cb->val.haddr,
+			       xtables_sa_host(p->ai_addr, p->ai_family),
+			       xtables_sa_hostlen(p->ai_family));
+			++adcount;
+			continue;
+		}
+		if (memcmp(&cb->val.haddr,
+		    xtables_sa_host(p->ai_addr, p->ai_family),
+		    xtables_sa_hostlen(p->ai_family)) != 0)
+			xt_params->exit_err(PARAMETER_PROBLEM,
+				"%s resolves to more than one address\n",
+				cb->arg);
+	}
+
+	freeaddrinfo(res);
+	if (cb->entry->flags & XTOPT_PUT)
+		/* Validation in xtables_option_metavalidate */
+		memcpy(XTOPT_MKPTR(cb), &cb->val.haddr,
+		       sizeof(cb->val.haddr));
+}
+
+/**
+ * @name:	port name, or number as a string (e.g. "http" or "80")
+ *
+ * Resolve a port name to a number. Returns the port number in integral
+ * form on success, or <0 on error. (errno will not be set.)
+ */
+static int xtables_getportbyname(const char *name)
+{
+	struct addrinfo *res = NULL, *p;
+	int ret;
+	int port = -1;
+	char *c;
+
+	ret = getaddrinfo(NULL, name, NULL, &res);
+	if (ret == EAI_SERVICE) {
+		port = strtoul(name, &c, 10);
+		if (*c == '\0' && port > 0)
+			return port;
+	}
+	if (ret != 0)
+		return -1;
+	ret = -1;
+	for (p = res; p != NULL; p = p->ai_next) {
+		if (p->ai_family == AF_INET6) {
+			ret = ((struct sockaddr_in6 *)p->ai_addr)->sin6_port;
+			break;
+		} else if (p->ai_family == AF_INET) {
+			ret = ((struct sockaddr_in *)p->ai_addr)->sin_port;
+			break;
+		}
+	}
+	freeaddrinfo(res);
+	if (ret < 0)
+		return ret;
+	return ntohs(ret);
+}
+
+/**
+ * Validate and parse a protocol specification (number or name) by use of
+ * /etc/protocols and put the result into @cb->val.protocol.
+ */
+static void xtopt_parse_protocol(struct xt_option_call *cb)
+{
+	cb->val.protocol = xtables_parse_protocol(cb->arg);
+	if (cb->entry->flags & XTOPT_PUT)
+		*(uint8_t *)XTOPT_MKPTR(cb) = cb->val.protocol;
+}
+
+/**
+ * Validate and parse a port specification and put the result into
+ * @cb->val.port.
+ */
+static void xtopt_parse_port(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	int ret;
+
+	ret = xtables_getportbyname(cb->arg);
+	if (ret < 0)
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"Port \"%s\" does not resolve to anything.\n",
+			cb->arg);
+	if (entry->flags & XTOPT_NBO)
+		ret = htons(ret);
+	cb->val.port = ret;
+	if (entry->flags & XTOPT_PUT)
+		*(uint16_t *)XTOPT_MKPTR(cb) = cb->val.port;
+}
+
+static void xtopt_parse_mport(struct xt_option_call *cb)
+{
+	static const size_t esize = sizeof(uint16_t);
+	const struct xt_option_entry *entry = cb->entry;
+	char *lo_arg, *wp_arg, *arg;
+	unsigned int maxiter;
+	int value;
+
+	wp_arg = lo_arg = strdup(cb->arg);
+	if (lo_arg == NULL)
+		xt_params->exit_err(RESOURCE_PROBLEM, "strdup");
+
+	maxiter = entry->size / esize;
+	if (maxiter == 0)
+		maxiter = 2; /* ARRAY_SIZE(cb->val.port_range) */
+	if (entry->size % esize != 0)
+		xt_params->exit_err(OTHER_PROBLEM, "%s: memory block does "
+			"not have proper size\n", __func__);
+
+	cb->val.port_range[0] = 0;
+	cb->val.port_range[1] = UINT16_MAX;
+	cb->nvals = 0;
+
+	while ((arg = strsep(&wp_arg, ":")) != NULL) {
+		if (cb->nvals == maxiter)
+			xt_params->exit_err(PARAMETER_PROBLEM, "%s: Too many "
+				"components for option \"--%s\" (max: %u)\n",
+				cb->ext_name, entry->name, maxiter);
+		if (*arg == '\0') {
+			++cb->nvals;
+			continue;
+		}
+
+		value = xtables_getportbyname(arg);
+		if (value < 0)
+			xt_params->exit_err(PARAMETER_PROBLEM,
+				"Port \"%s\" does not resolve to "
+				"anything.\n", arg);
+		if (entry->flags & XTOPT_NBO)
+			value = htons(value);
+		if (cb->nvals < ARRAY_SIZE(cb->val.port_range))
+			cb->val.port_range[cb->nvals] = value;
+		++cb->nvals;
+	}
+
+	if (cb->nvals == 1) {
+		cb->val.port_range[1] = cb->val.port_range[0];
+		++cb->nvals;
+	}
+	if (entry->flags & XTOPT_PUT)
+		memcpy(XTOPT_MKPTR(cb), cb->val.port_range, sizeof(uint16_t) *
+		       (cb->nvals <= maxiter ? cb->nvals : maxiter));
+	free(lo_arg);
+}
+
+static int xtopt_parse_mask(struct xt_option_call *cb)
+{
+	struct addrinfo hints = {.ai_family = afinfo->family,
+				 .ai_flags = AI_NUMERICHOST };
+	struct addrinfo *res;
+	int ret;
+
+	ret = getaddrinfo(cb->arg, NULL, &hints, &res);
+	if (ret != 0)
+		return 0;
+
+	memcpy(&cb->val.hmask, xtables_sa_host(res->ai_addr, res->ai_family),
+	       xtables_sa_hostlen(res->ai_family));
+
+	switch(afinfo->family) {
+	case AF_INET:
+		cb->val.hlen = xtables_ipmask_to_cidr(&cb->val.hmask.in);
+		break;
+	case AF_INET6:
+		cb->val.hlen = xtables_ip6mask_to_cidr(&cb->val.hmask.in6);
+		break;
+	}
+
+	freeaddrinfo(res);
+	return 1;
+}
+
+/**
+ * Parse an integer and ensure it is within the address family's prefix length
+ * limits. The result is stored in @cb->val.hlen.
+ */
+static void xtopt_parse_plen(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	unsigned int prefix_len = 128; /* happiness is a warm gcc */
+
+	cb->val.hlen = (afinfo->family == NFPROTO_IPV4) ? 32 : 128;
+	if (!xtables_strtoui(cb->arg, NULL, &prefix_len, 0, cb->val.hlen)) {
+		/* Is this mask expressed in full format? e.g. 255.255.255.0 */
+		if (xtopt_parse_mask(cb))
+			return;
+
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: bad value for option \"--%s\", "
+			"neither a valid network mask "
+			"nor valid CIDR (%u-%u).\n",
+			cb->ext_name, entry->name, 0, cb->val.hlen);
+	}
+	cb->val.hlen = prefix_len;
+}
+
+/**
+ * Reuse xtopt_parse_plen for testing the integer. Afterwards convert this to
+ * a bitmask, and make it available through @cb->val.hmask (hlen remains
+ * valid). If %XTOPT_PUT is used, hmask will be copied to the target area.
+ */
+static void xtopt_parse_plenmask(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	uint32_t *mask = cb->val.hmask.all;
+
+	xtopt_parse_plen(cb);
+
+	memset(mask, 0xFF, sizeof(union nf_inet_addr));
+	/* This shifting is AF-independent. */
+	if (cb->val.hlen == 0) {
+		mask[0] = mask[1] = mask[2] = mask[3] = 0;
+	} else if (cb->val.hlen <= 32) {
+		mask[0] <<= 32 - cb->val.hlen;
+		mask[1] = mask[2] = mask[3] = 0;
+	} else if (cb->val.hlen <= 64) {
+		mask[1] <<= 32 - (cb->val.hlen - 32);
+		mask[2] = mask[3] = 0;
+	} else if (cb->val.hlen <= 96) {
+		mask[2] <<= 32 - (cb->val.hlen - 64);
+		mask[3] = 0;
+	} else if (cb->val.hlen <= 128) {
+		mask[3] <<= 32 - (cb->val.hlen - 96);
+	}
+	mask[0] = htonl(mask[0]);
+	mask[1] = htonl(mask[1]);
+	mask[2] = htonl(mask[2]);
+	mask[3] = htonl(mask[3]);
+	if (entry->flags & XTOPT_PUT)
+		memcpy(XTOPT_MKPTR(cb), mask, sizeof(union nf_inet_addr));
+}
+
+static void xtopt_parse_hostmask(struct xt_option_call *cb)
+{
+	const char *orig_arg = cb->arg;
+	char *work, *p;
+
+	if (strchr(cb->arg, '/') == NULL) {
+		xtopt_parse_host(cb);
+		return;
+	}
+	work = strdup(orig_arg);
+	if (work == NULL)
+		xt_params->exit_err(PARAMETER_PROBLEM, "strdup");
+	p = strchr(work, '/'); /* by def this can't be NULL now */
+	*p++ = '\0';
+	/*
+	 * Because xtopt_parse_host and xtopt_parse_plenmask would store
+	 * different things in the same target area, XTTYPE_HOSTMASK must
+	 * disallow XTOPT_PUT, which it does by forcing its absence,
+	 * cf. not being listed in xtopt_psize.
+	 */
+	cb->arg = work;
+	xtopt_parse_host(cb);
+	cb->arg = p;
+	xtopt_parse_plenmask(cb);
+	cb->arg = orig_arg;
+}
+
+static void xtopt_parse_ethermac(struct xt_option_call *cb)
+{
+	const char *arg = cb->arg;
+	unsigned int i;
+	char *end;
+
+	for (i = 0; i < ARRAY_SIZE(cb->val.ethermac) - 1; ++i) {
+		cb->val.ethermac[i] = strtoul(arg, &end, 16);
+		if (*end != ':' || end - arg > 2)
+			goto out;
+		arg = end + 1;
+	}
+	i = ARRAY_SIZE(cb->val.ethermac) - 1;
+	cb->val.ethermac[i] = strtoul(arg, &end, 16);
+	if (*end != '\0' || end - arg > 2)
+		goto out;
+	if (cb->entry->flags & XTOPT_PUT)
+		memcpy(XTOPT_MKPTR(cb), cb->val.ethermac,
+		       sizeof(cb->val.ethermac));
+	return;
+ out:
+	xt_params->exit_err(PARAMETER_PROBLEM, "Invalid MAC address specified.");
+}
+
+static void (*const xtopt_subparse[])(struct xt_option_call *) = {
+	[XTTYPE_UINT8]       = xtopt_parse_int,
+	[XTTYPE_UINT16]      = xtopt_parse_int,
+	[XTTYPE_UINT32]      = xtopt_parse_int,
+	[XTTYPE_UINT64]      = xtopt_parse_int,
+	[XTTYPE_UINT8RC]     = xtopt_parse_mint,
+	[XTTYPE_UINT16RC]    = xtopt_parse_mint,
+	[XTTYPE_UINT32RC]    = xtopt_parse_mint,
+	[XTTYPE_UINT64RC]    = xtopt_parse_mint,
+	[XTTYPE_DOUBLE]      = xtopt_parse_float,
+	[XTTYPE_STRING]      = xtopt_parse_string,
+	[XTTYPE_TOSMASK]     = xtopt_parse_tosmask,
+	[XTTYPE_MARKMASK32]  = xtopt_parse_markmask,
+	[XTTYPE_SYSLOGLEVEL] = xtopt_parse_sysloglevel,
+	[XTTYPE_HOST]        = xtopt_parse_host,
+	[XTTYPE_HOSTMASK]    = xtopt_parse_hostmask,
+	[XTTYPE_PROTOCOL]    = xtopt_parse_protocol,
+	[XTTYPE_PORT]        = xtopt_parse_port,
+	[XTTYPE_PORTRC]      = xtopt_parse_mport,
+	[XTTYPE_PLEN]        = xtopt_parse_plen,
+	[XTTYPE_PLENMASK]    = xtopt_parse_plenmask,
+	[XTTYPE_ETHERMAC]    = xtopt_parse_ethermac,
+};
+
+/**
+ * The master option parsing routine. May be used for the ".x6_parse"
+ * function pointer in extensions if fully automatic parsing is desired.
+ * It may be also called manually from a custom x6_parse function.
+ */
+void xtables_option_parse(struct xt_option_call *cb)
+{
+	const struct xt_option_entry *entry = cb->entry;
+	unsigned int eflag = 1 << cb->entry->id;
+
+	/*
+	 * With {.id = P_FOO, .excl = P_FOO} we can have simple double-use
+	 * prevention. Though it turned out that this is too much typing (most
+	 * of the options are one-time use only), so now we also have
+	 * %XTOPT_MULTI.
+	 */
+	if ((!(entry->flags & XTOPT_MULTI) || (entry->excl & eflag)) &&
+	    cb->xflags & eflag)
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: option \"--%s\" can only be used once.\n",
+			cb->ext_name, cb->entry->name);
+	if (cb->invert && !(entry->flags & XTOPT_INVERT))
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: option \"--%s\" cannot be inverted.\n",
+			cb->ext_name, entry->name);
+	if (entry->type != XTTYPE_NONE && optarg == NULL)
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: option \"--%s\" requires an argument.\n",
+			cb->ext_name, entry->name);
+	/*
+	 * Fill in fallback value for "nvals", in case an extension (as it
+	 * happened with libxt_conntrack.2) tries to read it, despite not using
+	 * a *RC option type.
+	 */
+	cb->nvals = 1;
+	if (entry->type <= ARRAY_SIZE(xtopt_subparse) &&
+	    xtopt_subparse[entry->type] != NULL)
+		xtopt_subparse[entry->type](cb);
+	/* Exclusion with other flags tested later in finalize. */
+	cb->xflags |= 1 << entry->id;
+}
+
+/**
+ * Verifies that an extension's option map descriptor is valid, and ought to
+ * be called right after the extension has been loaded, and before option
+ * merging/xfrm.
+ */
+void xtables_option_metavalidate(const char *name,
+				 const struct xt_option_entry *entry)
+{
+	for (; entry->name != NULL; ++entry) {
+		if (entry->id >= CHAR_BIT * sizeof(unsigned int) ||
+		    entry->id >= XT_OPTION_OFFSET_SCALE)
+			xt_params->exit_err(OTHER_PROBLEM,
+				"Extension %s uses invalid ID %u\n",
+				name, entry->id);
+		if (!(entry->flags & XTOPT_PUT)) {
+			if (entry->ptroff != 0)
+				xt_params->exit_err(OTHER_PROBLEM,
+					"%s: ptroff for \"--%s\" is non-"
+					"zero but no XTOPT_PUT is specified. "
+					"Oversight?", name, entry->name);
+			continue;
+		}
+		if (entry->type >= ARRAY_SIZE(xtopt_psize) ||
+		    xtopt_psize[entry->type] == 0)
+			xt_params->exit_err(OTHER_PROBLEM,
+				"%s: entry type of option \"--%s\" cannot be "
+				"combined with XTOPT_PUT\n",
+				name, entry->name);
+		if (xtopt_psize[entry->type] != -1 &&
+		    xtopt_psize[entry->type] != entry->size)
+			xt_params->exit_err(OTHER_PROBLEM,
+				"%s: option \"--%s\" points to a memory block "
+				"of wrong size (expected %zu, got %zu)\n",
+				name, entry->name,
+				xtopt_psize[entry->type], entry->size);
+	}
+}
+
+/**
+ * Find an option entry by its id.
+ */
+static const struct xt_option_entry *
+xtables_option_lookup(const struct xt_option_entry *entry, unsigned int id)
+{
+	for (; entry->name != NULL; ++entry)
+		if (entry->id == id)
+			return entry;
+	return NULL;
+}
+
+/**
+ * @c:		getopt id (i.e. with offset)
+ * @fw:		struct ipt_entry or ip6t_entry
+ *
+ * Dispatch arguments to the appropriate parse function, based upon the
+ * extension's choice of API.
+ */
+void xtables_option_tpcall(unsigned int c, char **argv, bool invert,
+			   struct xtables_target *t, void *fw)
+{
+	struct xt_option_call cb;
+
+	if (t->x6_parse == NULL) {
+		if (t->parse != NULL)
+			t->parse(c - t->option_offset, argv, invert,
+				 &t->tflags, fw, &t->t);
+		return;
+	}
+
+	c -= t->option_offset;
+	cb.entry = xtables_option_lookup(t->x6_options, c);
+	if (cb.entry == NULL)
+		xtables_error(OTHER_PROBLEM,
+			"Extension does not know id %u\n", c);
+	cb.arg      = optarg;
+	cb.invert   = invert;
+	cb.ext_name = t->name;
+	cb.data     = t->t->data;
+	cb.xflags   = t->tflags;
+	cb.target   = &t->t;
+	cb.xt_entry = fw;
+	cb.udata    = t->udata;
+	t->x6_parse(&cb);
+	t->tflags = cb.xflags;
+}
+
+/**
+ * @c:		getopt id (i.e. with offset)
+ * @fw:		struct ipt_entry or ip6t_entry
+ *
+ * Dispatch arguments to the appropriate parse function, based upon the
+ * extension's choice of API.
+ */
+void xtables_option_mpcall(unsigned int c, char **argv, bool invert,
+			   struct xtables_match *m, void *fw)
+{
+	struct xt_option_call cb;
+
+	if (m->x6_parse == NULL) {
+		if (m->parse != NULL)
+			m->parse(c - m->option_offset, argv, invert,
+				 &m->mflags, fw, &m->m);
+		return;
+	}
+
+	c -= m->option_offset;
+	cb.entry = xtables_option_lookup(m->x6_options, c);
+	if (cb.entry == NULL)
+		xtables_error(OTHER_PROBLEM,
+			"Extension does not know id %u\n", c);
+	cb.arg      = optarg;
+	cb.invert   = invert;
+	cb.ext_name = m->name;
+	cb.data     = m->m->data;
+	cb.xflags   = m->mflags;
+	cb.match    = &m->m;
+	cb.xt_entry = fw;
+	cb.udata    = m->udata;
+	m->x6_parse(&cb);
+	m->mflags = cb.xflags;
+}
+
+/**
+ * @name:	name of extension
+ * @entry:	current option (from all ext's entries) being validated
+ * @xflags:	flags the extension has collected
+ * @i:		conflicting option (id) to test for
+ */
+static void
+xtables_option_fcheck2(const char *name, const struct xt_option_entry *entry,
+		       const struct xt_option_entry *other,
+		       unsigned int xflags)
+{
+	unsigned int ef = 1 << entry->id, of = 1 << other->id;
+
+	if (entry->also & of && !(xflags & of))
+		xt_params->exit_err(PARAMETER_PROBLEM,
+			"%s: option \"--%s\" also requires \"--%s\".\n",
+			name, entry->name, other->name);
+
+	if (!(entry->excl & of))
+		/* Use of entry does not collide with other option, good. */
+		return;
+	if ((xflags & (ef | of)) != (ef | of))
+		/* Conflicting options were not used. */
+		return;
+
+	xt_params->exit_err(PARAMETER_PROBLEM,
+		"%s: option \"--%s\" cannot be used together with \"--%s\".\n",
+		name, entry->name, other->name);
+}
+
+/**
+ * @name:	name of extension
+ * @xflags:	accumulated flags
+ * @entry:	extension's option table
+ *
+ * Check that all option constraints have been met. This effectively replaces
+ * ->final_check of the older API.
+ */
+void xtables_options_fcheck(const char *name, unsigned int xflags,
+			    const struct xt_option_entry *table)
+{
+	const struct xt_option_entry *entry, *other;
+	unsigned int i;
+
+	for (entry = table; entry->name != NULL; ++entry) {
+		if (entry->flags & XTOPT_MAND &&
+		    !(xflags & (1 << entry->id)))
+			xt_params->exit_err(PARAMETER_PROBLEM,
+				"%s: option \"--%s\" must be specified\n",
+				name, entry->name);
+		if (!(xflags & (1 << entry->id)))
+			/* Not required, not specified, thus skip. */
+			continue;
+
+		for (i = 0; i < CHAR_BIT * sizeof(entry->id); ++i) {
+			if (entry->id == i)
+				/*
+				 * Avoid conflict with self. Multi-use check
+				 * was done earlier in xtables_option_parse.
+				 */
+				continue;
+			other = xtables_option_lookup(table, i);
+			if (other == NULL)
+				continue;
+			xtables_option_fcheck2(name, entry, other, xflags);
+		}
+	}
+}
+
+/**
+ * Dispatch arguments to the appropriate final_check function, based upon the
+ * extension's choice of API.
+ */
+void xtables_option_tfcall(struct xtables_target *t)
+{
+	if (t->x6_fcheck != NULL) {
+		struct xt_fcheck_call cb;
+
+		cb.ext_name = t->name;
+		cb.data     = t->t->data;
+		cb.xflags   = t->tflags;
+		cb.udata    = t->udata;
+		t->x6_fcheck(&cb);
+	} else if (t->final_check != NULL) {
+		t->final_check(t->tflags);
+	}
+	if (t->x6_options != NULL)
+		xtables_options_fcheck(t->name, t->tflags, t->x6_options);
+}
+
+/**
+ * Dispatch arguments to the appropriate final_check function, based upon the
+ * extension's choice of API.
+ */
+void xtables_option_mfcall(struct xtables_match *m)
+{
+	if (m->x6_fcheck != NULL) {
+		struct xt_fcheck_call cb;
+
+		cb.ext_name = m->name;
+		cb.data     = m->m->data;
+		cb.xflags   = m->mflags;
+		cb.udata    = m->udata;
+		m->x6_fcheck(&cb);
+	} else if (m->final_check != NULL) {
+		m->final_check(m->mflags);
+	}
+	if (m->x6_options != NULL)
+		xtables_options_fcheck(m->name, m->mflags, m->x6_options);
+}
+
+struct xtables_lmap *xtables_lmap_init(const char *file)
+{
+	struct xtables_lmap *lmap_head = NULL, *lmap_prev = NULL, *lmap_this;
+	char buf[512];
+	FILE *fp;
+	char *cur, *nxt;
+	int id;
+
+	fp = fopen(file, "re");
+	if (fp == NULL)
+		return NULL;
+
+	while (fgets(buf, sizeof(buf), fp) != NULL) {
+		cur = buf;
+		while (isspace(*cur))
+			++cur;
+		if (*cur == '#' || *cur == '\n' || *cur == '\0')
+			continue;
+
+		/* iproute2 allows hex and dec format */
+		errno = 0;
+		id = strtoul(cur, &nxt, strncmp(cur, "0x", 2) == 0 ? 16 : 10);
+		if (nxt == cur || errno != 0)
+			continue;
+
+		/* same boundaries as in iproute2 */
+		if (id < 0 || id > 255)
+			continue;
+		cur = nxt;
+
+		if (!isspace(*cur))
+			continue;
+		while (isspace(*cur))
+			++cur;
+		if (*cur == '#' || *cur == '\n' || *cur == '\0')
+			continue;
+		nxt = cur;
+		while (*nxt != '\0' && !isspace(*nxt))
+			++nxt;
+		if (nxt == cur)
+			continue;
+		*nxt = '\0';
+
+		/* found valid data */
+		lmap_this = malloc(sizeof(*lmap_this));
+		if (lmap_this == NULL) {
+			perror("malloc");
+			goto out;
+		}
+		lmap_this->id   = id;
+		lmap_this->name = strdup(cur);
+		if (lmap_this->name == NULL) {
+			free(lmap_this);
+			goto out;
+		}
+		lmap_this->next = NULL;
+
+		if (lmap_prev != NULL)
+			lmap_prev->next = lmap_this;
+		else
+			lmap_head = lmap_this;
+		lmap_prev = lmap_this;
+	}
+
+	fclose(fp);
+	return lmap_head;
+ out:
+	fclose(fp);
+	xtables_lmap_free(lmap_head);
+	return NULL;
+}
+
+void xtables_lmap_free(struct xtables_lmap *head)
+{
+	struct xtables_lmap *next;
+
+	for (; head != NULL; head = next) {
+		next = head->next;
+		free(head->name);
+		free(head);
+	}
+}
+
+int xtables_lmap_name2id(const struct xtables_lmap *head, const char *name)
+{
+	for (; head != NULL; head = head->next)
+		if (strcmp(head->name, name) == 0)
+			return head->id;
+	return -1;
+}
+
+const char *xtables_lmap_id2name(const struct xtables_lmap *head, int id)
+{
+	for (; head != NULL; head = head->next)
+		if (head->id == id)
+			return head->name;
+	return NULL;
+}
--- iptables-1.8.x/l7-protocols/aim.pat
+++ iptables-1.8.x/l7-protocols/aim.pat
@@ -0,0 +1,27 @@
+# AIM - AOL instant messenger (OSCAR and TOC)
+# Pattern attributes: good slow notsofast
+# Protocol groups: chat proprietary
+# Wiki: http://www.protocolinfo.org/wiki/AIM
+#
+# Usually runs on port 5190
+#
+# This may also match ICQ traffic.
+# 
+# This pattern has been tested and is believed to work well.
+
+aim
+# See http://gridley.res.carleton.edu/~straitm/final (and various other places)
+# The first bit matches OSCAR signon and data commands, but not sure what
+# \x03\x0b matches, but it works apparently.
+# The next three bits match various parts of the TOC signon process.
+# The third one is the magic number "*", then 0x01 for "signon", then up to four
+# bytes ("up to" because l7-filter strips out nulls) which contain a sequence
+# number (2 bytes) the data length (2 more) and 3 nulls (which don't count), 
+# then 0x01 for the version number (not sure if there ever has been another 
+# version)
+# The fourth one is a command string, followed by some stuff, then the
+# beginning of the "roasted" password
+
+# This pattern is too slow!
+
+^(\*[\x01\x02].*\x03\x0b|\*\x01.?.?.?.?\x01)|flapon|toc_signon.*0x
--- iptables-1.8.x/l7-protocols/aimwebcontent.pat
+++ iptables-1.8.x/l7-protocols/aimwebcontent.pat
@@ -0,0 +1,9 @@
+# AIM web content - ads/news content downloaded by AOL Instant Messenger
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: chat document_retrieval proprietary
+# Wiki: http://www.protocolinfo.org/wiki/AIM
+#
+# This pattern has been tested and is believed to work well.
+
+aimwebcontent
+user-agent:aim/
--- iptables-1.8.x/l7-protocols/applejuice.pat
+++ iptables-1.8.x/l7-protocols/applejuice.pat
@@ -0,0 +1,11 @@
+# Apple Juice - P2P filesharing - http://www.applejuicenet.de
+# Pattern attributes: great veryfast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/AppleJuice
+#
+# This pattern has been tested with the Linux version (version
+# 0,29,142,229).  It matches search reqests and file transfers.
+
+applejuice
+# this pattern extracted from ipp2p, by Eicke Friedrich.
+^ajprot\x0d\x0a
--- iptables-1.8.x/l7-protocols/ares.pat
+++ iptables-1.8.x/l7-protocols/ares.pat
@@ -0,0 +1,62 @@
+# Ares - P2P filesharing - http://aresgalaxy.sf.net
+# Pattern attributes: good veryfast fast undermatch
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/Ares
+
+# This pattern catches only client-server connect messages.  This is
+# sufficient for blocking, but not for shaping, since it doesn't catch
+# the actual file transfers (see below).
+
+# Original pattern by Brandon Enright <bmenrigh at the server known as ucsd.edu>
+
+# This pattern has been tested with Ares 1.8.8.2998.
+
+ares
+# regular expression madness: "[]Z]" means ']' or 'Z'.
+^\x03[]Z].?.?\x05$
+
+# It appears that the general packet format is:
+# - Two byte little endian integer giving the data length
+# - One byte packet type
+# - data
+#
+# Login packets (TCP) have the following format:
+# - \x03\x00 (the length appears to always be 3)
+# - \x5a - The login packet type.
+#   The source code suggests that for supernodes \x5d is used instead.
+# - Three more bytes.  I don't know the meaning of these, but for me they 
+#   are always \x06\x06\x05 (in Ares 1.8.8.2998).  From the comments in IPP2P, 
+#   it seems that they are not always exactly that, but seem to always end in 
+#   \x05.
+#
+# Search packets have the following format:
+# - Two byte little endian integer giving the data length
+#   A single two letter word make this \x0a
+#   The biggest I could get it was \x4f
+# - Packet type = \x09
+# - One byte document type:
+#   - "all"      = 00
+#   - "audio"    = 01
+#   - "software" = 03
+#   - "video"    = 05
+#   - "document" = 06
+#   - "image"    = 07
+#   - "other"    = 08
+# - \x0f - I don't know what this means, but it is always this for me
+# - Two bytes of unknown meaning that change
+# - Some number search words: 
+#   - \x14 - I don't know what this means, but it is always this for me
+#   - One byte length of the first search word 
+#     Between 2 and \x14 in my tests with Ares 1.8.8.2998
+#     It ignores single letter words and truncates ones longer than \x14
+#   - Two bytes of unknown meaning that change
+#   - The search word (not null terminated)
+# This was all investigated by searching for strings in "all".  Searches
+# can also be performed in "title" and "author".  I'm not going to
+# bother to research these because I new realize that searches are done
+# on the same TCP connection as the login packets, so there is no need
+# to match them separately.
+#
+# File transfers appear to be encrypted or at least obfuscated.  (The
+# files themselves, at least, are not transmitted in the clear.) I
+# haven't found any patterns.
--- iptables-1.8.x/l7-protocols/armagetron.pat
+++ iptables-1.8.x/l7-protocols/armagetron.pat
@@ -0,0 +1,11 @@
+# Armagetron Advanced - open source Tron/snake based multiplayer game
+# Pattern attributes: good slow notsofast
+# Protocol groups: open_source game
+# Wiki: http://protocolinfo.org/wiki/Armagetron
+
+# Contributed to protocolinfo.org, possibly by joda.bot, who says "The 
+# filter matches the initial transfer of configuration data. Very early 
+# versions might not transfer the CYCLE_ Settings (before 0.2.5.x)."
+
+armagetron
+YCLC_E|CYEL
--- iptables-1.8.x/l7-protocols/battlefield1942.pat
+++ iptables-1.8.x/l7-protocols/battlefield1942.pat
@@ -0,0 +1,13 @@
+# Battlefield 1942 - An EA game
+# Pattern attributes: ok veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Battlefield_1942
+#
+# Contributed by Myles Uyema <mylesuyema AT gmail.com>
+#
+# This pattern has only been tested by one person.
+
+# tested on two original EA battlefield 1942 servers
+# matches the first two packets of joining a server
+battlefield1942
+^\x01\x11\x10\|\xf8\x02\x10\x40\x06
--- iptables-1.8.x/l7-protocols/bgp.pat
+++ iptables-1.8.x/l7-protocols/bgp.pat
@@ -0,0 +1,18 @@
+# BGP - Border Gateway Protocol - RFC 1771
+# Pattern attributes: ok veryfast fast
+# Protocol groups: networking ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/BGP
+#
+# This pattern is UNTESTED.
+
+bgp
+# "After a transport protocol connection is established, the first
+# message sent by each side is an OPEN message."
+# "If the Type of the message is OPEN, or if the Authentication Code used
+# in the OPEN message of the connection is zero, then the Marker must be
+# all ones."
+# Then the 2 byte length field, then the 1 byte type field (1 = OPEN).
+# Then the BGP version: 3 was RFC'd in 1991, 4 was RFC'd in 1995.
+# Could keep going, but that should be sufficient.
+^\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff\xff..?\x01[\x03\x04]
+
--- iptables-1.8.x/l7-protocols/bittorrent.pat
+++ iptables-1.8.x/l7-protocols/bittorrent.pat
@@ -0,0 +1,27 @@
+# Bittorrent - P2P filesharing / publishing tool - http://www.bittorrent.com
+# Pattern attributes: good slow notsofast undermatch
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/Bittorrent
+#
+# This pattern has been tested and is believed to work well.
+# It will, however, not work on bittorrent streams that are encrypted, since
+# it's impossible to match encrypted data (unless the encryption is extremely 
+# weak, like rot13 or something...).
+
+bittorrent
+
+# Does not attempt to match the HTTP download of the tracker
+# 0x13 is the length of "bittorrent protocol"
+# Second two bits match UDP wierdness
+# Next bit matches something Azureus does
+# Ditto on the next bit.  Could also match on "user-agent: azureus", but that's in the next
+# packet and perhaps this will match multiple clients.
+
+# Recently the ^ was removed from before \x13.  I think this was an accident,
+# so I have restored it.
+
+# This is not a valid GNU basic regular expression (but that's ok).
+^(\x13bittorrent protocol|azver\x01$|get /scrape\?info_hash=)|d1:ad2:id20:|\x08'7P\)[RP]
+
+# This pattern is "fast", but won't catch as much
+#^(\x13bittorrent protocol|azver\x01$|get /scrape\?info_hash=)
--- iptables-1.8.x/l7-protocols/chikka.pat
+++ iptables-1.8.x/l7-protocols/chikka.pat
@@ -0,0 +1,16 @@
+# Chikka - SMS service which can be used without phones - http://chikka.com
+# Pattern attributes: good veryfast fast superset
+# Protocol groups: proprietary chat
+# Wiki: http://www.protocolinfo.org/wiki/Chikka
+
+# Tested with Chikka Javalite on 14 Jan 2007.
+# The login and chat use the same TCP connection.
+
+# "Kamusta" means "Hello" in Tagalog, apparently, so that will probably 
+# stay the same.  I've only seen v1.2, but I've given it some leeway for 
+# past and future versions.
+
+# Chikka uses CIMD as part of the login process, see cimd.pat
+
+chikka
+^CTPv1.[123] Kamusta.*\x0d\x0a$
--- iptables-1.8.x/l7-protocols/cimd.pat
+++ iptables-1.8.x/l7-protocols/cimd.pat
@@ -0,0 +1,18 @@
+# CIMD - Computer Interface to Message Distribution, an SMSC protocol by Nokia
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: proprietary chat
+# Wiki: http://www.protocolinfo.org/wiki/CIMD
+
+# I don't know whether CIMD is ever found by itself in a TCP connection. 
+# I have only seen it myself as part of the Chikka login process, in 
+# which the second and third packets (at least) are CIMD.  So I am not 
+# using a '^' at the beginning.
+#
+# This pretty well explains the pattern:
+# http://en.wikipedia.org/w/index.php?title=CIMD&oldid=42707583
+# However, Chikka does NOT terminate the last field with a tab.
+#
+# Tested with Chikka Javalite on 14 Jan 2007.
+
+cimd
+\x02[0-4][0-9]:[0-9]+.*\x03$
--- iptables-1.8.x/l7-protocols/ciscovpn.pat
+++ iptables-1.8.x/l7-protocols/ciscovpn.pat
@@ -0,0 +1,10 @@
+# Cisco VPN - VPN client software to a Cisco VPN server
+# Pattern attributes: ok veryfast fast
+# Protocol groups: remote_access proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Cisco_VPN
+# 
+# This pattern contributed by Myles Uyema <myles AT uyema.net>
+
+ciscovpn
+^\x01\xf4\x01\xf4
+
--- iptables-1.8.x/l7-protocols/citrix.pat
+++ iptables-1.8.x/l7-protocols/citrix.pat
@@ -0,0 +1,11 @@
+# Citrix ICA - proprietary remote desktop application - http://citrix.com
+# Pattern attributes: marginal notsofast notsofast
+# Protocol groups: remote_access proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Citrix
+# 
+# This pattern is UNTESTED.
+
+# This is based on decode_citrix in dsniff 2.4.
+
+citrix
+\x32\x26\x85\x92\x58
--- iptables-1.8.x/l7-protocols/code_red.pat
+++ iptables-1.8.x/l7-protocols/code_red.pat
@@ -0,0 +1,7 @@
+# Code Red - a worm that attacks Microsoft IIS web servers
+# Pattern attributes: ok fast notsofast subset
+# Protocol groups: worm
+# Wiki: http://www.protocolinfo.org/wiki/CodeRed
+
+code_red
+/default\.ida\?NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u6858%ucbd3%u7801%u9090%u9090%u8190%u00c3%u0003%u8b00%u531b%u53ff%u0078%u0000%u00=a
--- iptables-1.8.x/l7-protocols/counterstrike-source.pat
+++ iptables-1.8.x/l7-protocols/counterstrike-source.pat
@@ -0,0 +1,41 @@
+# Counterstrike (using the new Source engine) - network game 
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Counter-Strike
+#
+# By adam.randazzoATgmail.com
+
+counterstrike-source
+^\xff\xff\xff\xff.*cstrikeCounter-Strike
+
+# These games use Steam, which is developed by Valve Software.
+#
+# This was based off of the following captured data from ethereal:
+# --Source--
+# 0000   00 11 09 2a a8 79 00 13 10 2c 3f d7 08 00 45 20  ...*.y...,?...E 
+# 0010   00 72 b9 f6 00 00 6b 11 b6 78 18 0e 04 cc c0 a8  .r....k..x......
+# 0020   01 6a 69 87 04 65 00 5e 01 ac ff ff ff ff 49 07  .ji..e.^......I.
+# 0030   54 4a 27 73 20 50 6c 61 63 65 20 6f 66 20 50 61  TJ's Place of Pa
+# 0040   69 6e 00 64 65 5f 70 69 72 61 6e 65 73 69 00 63  in.de_piranesi.c
+# 0050   73 74 72 69 6b 65 00 43 6f 75 6e 74 65 72 2d 53  strike.Counter-S
+# 0060   74 72 69 6b 65 3a 20 53 6f 75 72 63 65 00 dc 00  trike: Source...
+# 0070   08 10 06 64 77 00 00 31 2e 30 2e 30 2e 31 38 00  ...dw..1.0.0.18.
+# 0080  
+# 
+# --1.6--
+# 0000   00 11 09 2a a8 79 00 13 10 2c 3f d7 08 00 45 00  ...*.y...,?...E.
+# 0010   00 8e c4 1a 00 00 76 11 b3 85 08 09 02 fa c0 a8  ......v.........
+# 0020   01 14 69 91 04 37 00 7a c9 90 ff ff ff ff 6d 38  ..i..7.z......m8
+# 0030   2e 39 2e 32 2e 32 35 30 3a 32 37 30 32 35 00 49  .9.2.250:27025.I
+# 0040   50 20 2d 20 43 6c 61 6e 20 73 65 72 76 65 72 00  P - Clan server.
+# 0050   64 65 5f 64 75 73 74 32 00 63 73 74 72 69 6b 65  de_dust2.cstrike
+# 0060   00 43 6f 75 6e 74 65 72 2d 53 74 72 69 6b 65 00  .Counter-Strike.
+# 0070   0a 0c 2f 64 77 00 01 77 77 77 2e 63 6f 75 6e 74  ../dw..www.count
+# 0080   65 72 2d 73 74 72 69 6b 65 2e 6e 65 74 00 00 00  er-strike.net...
+# 0090   01 00 00 00 00 9e f7 0a 00 01 00 00              ............
+
+
+# Old pattern.  (Adam Randazzo says "CS 1.6 and CS: Source are the
+# only two versions that are playable on the Internet since Valve
+# disabled the WON system in favor of steam.")
+# cs .*dl.www.counter-strike.net
--- iptables-1.8.x/l7-protocols/cvs.pat
+++ iptables-1.8.x/l7-protocols/cvs.pat
@@ -0,0 +1,13 @@
+# CVS - Concurrent Versions System
+# Pattern attributes: good veryfast fast
+# Protocol groups: version_control open_source
+# Wiki: http://www.protocolinfo.org/wiki/CVS
+
+cvs
+
+# Matches pserver login.  AUTH is for actually starting the protocol
+# VERIFICATION is for authenticating without starting the protocols
+# and GSSAPI is for using security services such as kerberos.
+# http://www.loria.fr/~molli/cvs/doc/cvsclient_3.html
+
+^BEGIN (AUTH|VERIFICATION|GSSAPI) REQUEST\x0a
--- iptables-1.8.x/l7-protocols/dayofdefeat-source.pat
+++ iptables-1.8.x/l7-protocols/dayofdefeat-source.pat
@@ -0,0 +1,10 @@
+# Day of Defeat: Source - game (Half-Life 2 mod) - http://www.valvesoftware.com
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Day_of_Defeat:Source
+#
+# By Clayton Macleod <cherry twist at gmail dot com>
+
+dayofdefeat-source
+^\xff\xff\xff\xff.*dodDay of Defeat
+
--- iptables-1.8.x/l7-protocols/dhcp.pat
+++ iptables-1.8.x/l7-protocols/dhcp.pat
@@ -0,0 +1,35 @@
+# DHCP - Dynamic Host Configuration Protocol - RFC 1541
+# Pattern attributes: good veryfast fast
+# Protocol groups: networking ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/DHCP
+#
+# Usually runs on ports 67 (server) and 68 (client)
+#
+# Also matches BOOTP (Bootstrap Protocol (RFC 951)) in the case that 
+# the "vendor specific options" are used (these options were made standard
+# for DHCP).
+#
+# This pattern is lightly tested.
+
+dhcp
+^[\x01\x02][\x01- ]\x06.*c\x82sc
+
+# Let's break that down:
+#
+# (\x01|\x02) is for BOOTREQUEST or BOOTREPLY
+# Is there a demand for doing these seperately?  The Packeteer does.
+#
+# [\x01-\x20] is for any of the hardware address types listed at
+# (http://www.iana.org/assignments/arp-parameters) and hopefully faster 
+# ethernets too (100, 1000 and 10000mb) as well (do they share the 10mb 
+# number?).
+#
+# \x06 for "hardware address length = 6 bytes".  Does anyone use other lengths
+# these days?  If so, this pattern won't match it as it stands.
+#
+# .* covers the hops, xid, secs, flags, ciaddr, yiaddr, siaddr, giaddr, 
+# chaddr, sname and file fields.  While this can't really be "any number
+# of characters" long, it doesn't seem worth it to count.
+# Can we make this more specific by restricting the number of hops or seconds?
+#
+# 0x63825363 is the "magic cookie" which begins the DHCP options field.
--- iptables-1.8.x/l7-protocols/directconnect.pat
+++ iptables-1.8.x/l7-protocols/directconnect.pat
@@ -0,0 +1,13 @@
+# Direct Connect - P2P filesharing - http://www.neo-modus.com
+# Pattern attributes: good fast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Direct_Connect
+#
+# Direct Connect "hubs" listen on port 411
+# http://www.dcpp.net/wiki/
+# I've verified that this pattern can be used to limit direct connect
+# bandwidth using DC:PRO 0.2.3.149R11.
+
+directconnect
+# client-to-client handshake|client-to-hub login, hub speaking|client-to-hub login, client speaking
+^(\$mynick |\$lock |\$key )
--- iptables-1.8.x/l7-protocols/dns.pat
+++ iptables-1.8.x/l7-protocols/dns.pat
@@ -0,0 +1,62 @@
+# DNS - Domain Name System - RFC 1035
+# Pattern attributes: great slow fast
+# Protocol groups: networking ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/DNS
+
+# Thanks to Sebastien Bechet <s.bechet AT av7.net> for TLD detection
+# improvements
+
+# While RFC 2181 says "Occasionally it is assumed that the Domain Name
+# System serves only the purpose of mapping Internet host names to data,
+# and mapping Internet addresses to host names.  This is not correct, the
+# DNS is a general (if somewhat limited) hierarchical database, and can
+# store almost any kind of data, for almost any purpose.", we will assume 
+# just that, because that represents the vast majority of DNS traffic.
+
+# The packet starts with a 2 byte random ID number and 2 bytes of flags that
+# aren't easy to match on.
+
+# The first thing that is matchable is QDCOUNT, the number of queries.
+# Despite the fact that you can apparently ask for up to 65535
+# things at a time, usually you only ask for one and I doubt you ever ask for
+# zero.  Let's allow up to two, just in case (even though I can't find any 
+# situation that generates more than one).
+
+# Next comes the ANCOUNT, NSCOUNT, and ARCOUNT fields, which could be null
+# or some smallish number, not matchable except by length (up to 6)
+
+# The next matchable thing is the query address. The first byte indicates the
+# length of the first part of the address, which is limited to 63 (0x3F == '?').
+# The next byte has to be a letter (for domain names) or number (for reverse lookups).
+# Then there can be an combination of 
+# letters, digits, hyphens, and 0x01-0x3F length markers.
+# Then we check for the presence of a top-level-domain at some later point.
+# This is indicated by a 0x02-0x06 and at least two letters, followed by no
+# more than four more letters.
+# Note that this will miss a very few queries that are for a TLD alone.
+# i.e. "host museum" (195.7.77.17)
+#
+# http://www.icann.org/tlds   http://www.iana.org/cctld/cctld-whois.htm
+
+# next is the QTYPE field, which has valid values 1-16 (although this
+# could probably be restricted further since many are rare) and \x1c for
+# IPv6 (and maybe more?).  It should follow immediately after the TLD
+# (and some stripped-out nulls)
+
+# next is QCLASS, which has valid values 1-4 and 255, except 2 is never used.
+# I'm not sure if 3 and 4 are used, so I'll include them. 1=Internet 255=any
+
+# If we wanted to match queries and responses separately, there could be
+# more specifics after this for the responses.
+
+dns
+# here's a sane way of doing it
+^.?.?.?.?[\x01\x02].?.?.?.?.?.?[\x01-?][a-z0-9][\x01-?a-z]*[\x02-\x06][a-z][a-z][fglmoprstuvz]?[aeop]?(um)?[\x01-\x10\x1c][\x01\x03\x04\xFF]
+
+# This way assumes that TLDs are any alpha string 2-6 characters long.
+# If TLDs are added, this is a good fallback.
+#^.?.?.?.?[\x01\x02].?.?.?.?.?.?[\x01-?][a-z0-9][\x01-?a-z]*[\x02-\x06][a-z][a-z][a-z]?[a-z]?[a-z]?[a-z]?[\x01-\x10][\x01\x03\x04\xFF]
+
+# If you have more processing power than me, you can substitute this for
+# the [a-z][a-z][a-z]?[a-z]?[a-z]?[a-z]?
+#(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|arpa|ac|ad|ae|af|ag|ai|al|am|an|ao|aq|ar|as|at|au|aw|az|ba|bb|bd|be|bf|bg|bh|bi|bj|bm|bn|bo|br|bs|bt|bv|bw|by|bz|ca|cc|cd|cf|cg|ch|ci|ck|cl|cm|cn|co|cr|cu|cv|cx|cy|cz|de|dj|dk|dm|do|dz|ec|ee|eg|eh|er|es|et|fi|fj|fk|fm|fo|fr|ga|gd|ge|gf|gg|gh|gi|gl|gm|gn|gp|gq|gr|gs|gt|gu|gw|gy|hk|hm|hn|hr|ht|hu|id|ie|il|im|in|io|iq|ir|is|it|je|jm|jo|jp|ke|kg|kh|ki|km|kn|kp|kr|kw|ky|kz|la|lb|lc|li|lk|lr|ls|lt|lu|lv|ly|ma|mc|md|mg|mh|mk|ml|mm|mn|mo|mp|mq|mr|ms|mt|mu|mv|mw|mx|my|mz|na|nc|ne|nf|ng|ni|nl|no|np|nr|nu|nz|om|pa|pe|pf|pg|ph|pk|pl|pm|pn|pr|ps|pt|pw|py|qa|re|ro|ru|rw|sa|sb|sc|sd|se|sg|sh|si|sj|sk|sl|sm|sn|so|sr|st|sv|sy|sz|tc|td|tf|tg|th|tj|tk|tm|tn|to|tp|tr|tt|tv|tw|tz|ua|ug|uk|um|us|uy|uz|va|vc|ve|vg|vi|vn|vu|wf|ws|ye|yt|yu|za|zm|zw)
--- iptables-1.8.x/l7-protocols/doom3.pat
+++ iptables-1.8.x/l7-protocols/doom3.pat
@@ -0,0 +1,9 @@
+# Doom 3 - computer game
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Doom
+#
+# Thanks to Clayton Macleod (cherrytwist at gmail.com).
+
+doom3
+^\xff\xffchallenge
--- iptables-1.8.x/l7-protocols/edonkey.pat
+++ iptables-1.8.x/l7-protocols/edonkey.pat
@@ -0,0 +1,36 @@
+# eDonkey2000 - P2P filesharing - http://edonkey2000.com and others
+# Pattern attributes: good veryfast fast overmatch
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/EDonkey
+#
+# Tested recently (April/May 2006) with eMule 0.47a and eDonkey2000 1.4
+# and a long time ago with something else. 
+# 
+# In addition to matching what you might expect, this matches much of
+# what eMule does when you tell it to only connect to the KAD network. 
+# I don't quite know what to make of this.
+
+# Thanks to Matt Skidmore <fox AT woozle.org>
+
+edonkey
+
+# http://gd.tuwien.ac.at/opsys/linux/sf/p/pdonkey/eDonkey-protocol-0.6
+#
+# In addition to \xe3, \xc5 and \xd4, I see a lot of \xe5.
+# As of April 2006, I also see some \xe4.
+#
+# God this is a mess.  What an irritating protocol.  
+# This will match about 2% of streams with random data in them!
+# (But fortunately much fewer than 2% of streams that are other protocols.
+# You can test this with the data in ../testing/)
+
+^[\xc5\xd4\xe3-\xe5].?.?.?.?([\x01\x02\x05\x14\x15\x16\x18\x19\x1a\x1b\x1c\x20\x21\x32\x33\x34\x35\x36\x38\x40\x41\x42\x43\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f\x50\x51\x52\x53\x54\x55\x56\x57\x58[\x60\x81\x82\x90\x91\x93\x96\x97\x98\x99\x9a\x9b\x9c\x9e\xa0\xa1\xa2\xa3\xa4]|\x59................?[ -~]|\x96....$)
+
+# matches everything and too much 
+# ^(\xe3|\xc5|\xd4)
+
+# ipp2p essentially uses "\xe3....\x47", which doesn't seem at all right to me.
+
+# bandwidtharbitrator uses 
+# e0.*@.*6[a-z].*p$|e0.*@.*[a-z]6[a-z].*p0$|e.*@.*[0-9]6.*p$|emule|edonkey
+# no comments to explain what all the mush is, of course...
--- iptables-1.8.x/l7-protocols/fasttrack.pat
+++ iptables-1.8.x/l7-protocols/fasttrack.pat
@@ -0,0 +1,22 @@
+# FastTrack - P2P filesharing (Kazaa, Morpheus, iMesh, Grokster, etc)
+# Pattern attributes: good slow notsofast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Fasttrack
+#
+# Tested with Kazaa Lite Resurrection 0.0.7.6F
+#
+# This appears to match the download connections well, but not the search
+# connections (I think they are encrypted :-( ).
+
+fasttrack
+# while this is a valid http request, this will be caught because
+# the http pattern matches the response (and therefore the next packet)
+# Even so, it's best to put this match earlier in the chain.
+# http://cvs.berlios.de/cgi-bin/viewcvs.cgi/gift-fasttrack/giFT-FastTrack/PROTOCOL?rev=HEAD&content-type=text/vnd.viewcvs-markup
+
+# This pattern is kinda slow, but not too bad.
+^get (/.download/[ -~]*|/.supernode[ -~]|/.status[ -~]|/.network[ -~]*|/.files|/.hash=[0-9a-f]*/[ -~]*) http/1.1|user-agent: kazaa|x-kazaa(-username|-network|-ip|-supernodeip|-xferid|-xferuid|tag)|^give [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]?[0-9]?[0-9]?
+
+# This isn't much faster:
+#^get (/.download/.*|/.supernode.|/.status.|/.network.*|/.files|/.hash=[0-9a-f]*/.*) http/1.1|user-agent: kazaa|x-kazaa(-username|-network|-ip|-supernodeip|-xferid|-xferuid|tag)|^give [0-9][0-9][0-9][0-9][0-9][0-9][0-9][0-9]?[0-9]?[0-9]?
+
--- iptables-1.8.x/l7-protocols/finger.pat
+++ iptables-1.8.x/l7-protocols/finger.pat
@@ -0,0 +1,14 @@
+# Finger - User information server - RFC 1288
+# Pattern attributes: good slow slow undermatch overmatch
+# Protocol groups: ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/Finger
+#
+# Usually runs on port 79
+#
+# This pattern is lightly tested.
+
+finger
+# The first matches the client request, which should look like a username.
+# The second matches the usual UNIX reply (but remember that they are
+# allowed to say whatever they want)
+^[a-z][a-z0-9\-_]+|login: [\x09-\x0d -~]* name: [\x09-\x0d -~]* Directory: 
--- iptables-1.8.x/l7-protocols/freenet.pat
+++ iptables-1.8.x/l7-protocols/freenet.pat
@@ -0,0 +1,9 @@
+# Freenet - Anonymous information retrieval - http://freenetproject.org
+# Pattern attributes: poor veryfast fast
+# Protocol groups: p2p document_retrieval open_source
+# Wiki: http://www.protocolinfo.org/wiki/Freenet
+
+freenet
+# Freenet is intentionally hard to identify...
+# This is empirical, only tested on one computer, and unlikely to work anymore.
+^\x01[\x08\x09][\x03\x04]
--- iptables-1.8.x/l7-protocols/ftp.pat
+++ iptables-1.8.x/l7-protocols/ftp.pat
@@ -0,0 +1,45 @@
+# FTP - File Transfer Protocol - RFC 959
+# Pattern attributes: great notsofast fast
+# Protocol groups: document_retrieval ietf_internet_standard
+# Wiki: http://protocolinfo.org/wiki/FTP
+#
+# Usually runs on port 21.  Note that the data stream is on a dynamically
+# assigned port, which means that you will need the FTP connection 
+# tracking module in your kernel to usefully match FTP data transfers.
+# 
+# This pattern is well tested.
+#
+# Handles the first two things a server should say:
+#
+# First, the server says it's ready by sending "220".  Most servers say 
+# something after 220, even though they don't have to, and it usually 
+# includes the string "ftp" (l7-filter is case insensitive). This 
+# includes proftpd, vsftpd, wuftpd, warftpd, pureftpd, Bulletproof FTP 
+# Server, and whatever ftp.microsoft.com uses.  Almost all servers use only 
+# ASCII printable characters between the "220" and the "FTP", but non-English
+# ones might use others.
+# 
+# The next thing the server sends is a 331.  All the above servers also 
+# send something including "password" after this code.  By default, we 
+# do not match on this because it takes another packet and is more work 
+# for regexec.
+
+ftp
+# by default, we allow only ASCII
+^220[\x09-\x0d -~]*ftp
+
+# This covers UTF-8 as well 
+#^220[\x09-\x0d -~\x80-\xfd]*ftp
+
+# This allows any characters and is about 4x faster than either of the above 
+# (which are about the same as each other)
+#^220.*ftp
+
+# This is much slower
+#^220[\x09-\x0d -~]*ftp|331[\x09-\x0d -~]*password
+
+# This pattern is more precise, but takes longer to match. (3 packets vs. 1)
+#^220[\x09-\x0d -~]*\x0d\x0aUSER[\x09-\x0d -~]*\x0d\x0a331
+
+# same as above, but slightly less precise and only takes 2 packets.
+#^220[\x09-\x0d -~]*\x0d\x0aUSER[\x09-\x0d -~]*\x0d\x0a
--- iptables-1.8.x/l7-protocols/gkrellm.pat
+++ iptables-1.8.x/l7-protocols/gkrellm.pat
@@ -0,0 +1,12 @@
+# Gkrellm - a system monitor - http://gkrellm.net
+# Pattern attributes: great veryfast fast
+# Protocol groups: monitoring open_source
+# Wiki: http://www.protocolinfo.org/wiki/Gkrellm
+# 
+# This pattern has been tested and is believed to work well.
+# Since this is not anything resembling a published protocol, it may change without
+# warning in new versions of gkrellm.
+
+gkrellm
+# tested with gkrellm 2.2.7
+^gkrellm [23].[0-9].[0-9]\x0a$
--- iptables-1.8.x/l7-protocols/gnucleuslan.pat
+++ iptables-1.8.x/l7-protocols/gnucleuslan.pat
@@ -0,0 +1,9 @@
+# GnucleusLAN - LAN-only P2P filesharing
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/GnucleusLAN
+#
+# This pattern has been tested and is believed to work well.
+
+gnucleuslan
+gnuclear connect/[\x09-\x0d -~]*user-agent: gnucleus [\x09-\x0d -~]*lan:
--- iptables-1.8.x/l7-protocols/gnutella.pat
+++ iptables-1.8.x/l7-protocols/gnutella.pat
@@ -0,0 +1,33 @@
+# Gnutella - P2P filesharing
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/Gnutella
+#
+# This should match both Gnutella and "Gnutella2" ("Mike's protocol")
+# 
+# Various clients use this protocol including Mactella, Shareaza,
+# GTK-gnutella, Gnucleus, Gnotella, LimeWire, iMesh and BearShare.
+# 
+# This is tested with gtk-gnutella and Shareaza.
+
+# http://www.gnutella2.com/tiki-index.php?page=UDP%20Transceiver
+# http://rfc-gnutella.sf.net/
+# http://www.gnutella2.com/tiki-index.php?page=Gnutella2%20Specification
+# http://en.wikipedia.org/wiki/Shareaza
+
+gnutella
+
+# The first part matches UDP messages - All start with "GND", then have
+# a flag byte which is either \x00, \x01 or \x02, then two sequence bytes
+# that can be anything, then a fragment number, which must start at 1.
+# The rest matches TCP first client message or first server message (in case 
+# we can't see client messages).  Some parts of this are empirical rather than 
+# document based.  Assumes version is between 0.0 and 2.9. (usually is
+# 0.4 or 0.6).  I'm guessing at many of the user-agents.
+# The last bit is emprical and probably only matches Limewire.
+^(gnd[\x01\x02]?.?.?\x01|gnutella connect/[012]\.[0-9]\x0d\x0a|get /uri-res/n2r\?urn:sha1:|get /.*user-agent: (gtk-gnutella|bearshare|mactella|gnucleus|gnotella|limewire|imesh)|get /.*content-type: application/x-gnutella-packets|giv [0-9]*:[0-9a-f]*/|queue [0-9a-f]* [1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?:[1-9][0-9]?[0-9]?[0-9]?|gnutella.*content-type: application/x-gnutella|...................?lime)
+
+# Needlessly precise, at the expense of time
+#^(gnd[\x01\x02]?.?.?\x01|gnutella connect/[012]\.[0-9]\x0d\x0a|get /uri-res/n2r\?urn:sha1:|get /[\x09-\x0d -~]*user-agent: (gtk-gnutella|bearshare|mactella|gnucleus|gnotella|limewire|imesh)|get /[\x09-\x0d -~]*content-type: application/x-gnutella-packets|giv [0-9]*:[0-9a-f]*/|queue [0-9a-f]* [1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?\.[1-9][0-9]?[0-9]?:[1-9][0-9]?[0-9]?[0-9]?|gnutella[\x09-\x0d -~]*content-type: application/x-gnutella|..................lime)
+
+
--- iptables-1.8.x/l7-protocols/gopher.pat
+++ iptables-1.8.x/l7-protocols/gopher.pat
@@ -0,0 +1,24 @@
+# Gopher - A precursor to HTTP - RFC 1436
+# Pattern attributes: good slow notsofast undermatch
+# Protocol groups: document_retrieval obsolete ietf_rfc_documented
+# Wiki: http://www.protocolinfo.org/wiki/Gopher
+#
+# Gopher servers usually run on TCP port 70.
+#
+# This pattern is lightly tested using gopher.dna.affrc.go.jp .
+
+gopher
+# This matches the server's response, but naturally only if it is a
+# directory listing, not if it is sending a file, because then the data 
+# is totally arbitrary.
+
+# Matches the client saying "list what you have", then the server
+# response: one of the file type characters, any printable characters, a
+# tab, any printable characters, a tab, something that looks like a
+# domain name, a tab, and then a number which could be the start of a
+# port number.
+
+# "0About internet Gopher\tStuff:About us\trawBits.micro.umn.edu\t70"
+# "\r7search by keywords on protein data using wais\twaissrc:/protein_all/protein\tgopher.dna.affrc.go.jp\t70"
+
+^[\x09-\x0d]*[1-9,+tgi][\x09-\x0d -~]*\x09[\x09-\x0d -~]*\x09[a-z0-9.]*\.[a-z][a-z].?.?\x09[1-9]
--- iptables-1.8.x/l7-protocols/h323.pat
+++ iptables-1.8.x/l7-protocols/h323.pat
@@ -0,0 +1,35 @@
+# H.323 - Voice over IP.
+# Pattern attributes: ok veryfast fast
+# Protocol groups: voip itu-t_standard
+# Wiki: http://www.protocolinfo.org/wiki/H.323
+#
+# This pattern is written without knowledge of the principles of H.323.
+# It has only been tested with gnomemeeting and may not work for other
+# clients. 
+#
+# Also, it has been reported that:
+# "the pattern ... match[es] only first H.323 stream (conntrack for H.323 was 
+# enabled).  Also the major chunk of traffic was of RTP which went untracked."
+#
+# Also, it may very well match other things that use TPKT and
+# Q.931. 
+
+# Note that to take full advantage of this pattern, you will need to
+# have connection tracking of H.323 support in your kernel.  This
+# support is not in the stock kernel.  A patch can be found at
+# http://netfilter.org
+
+h323
+# TPKT format: http://www.ietf.org/rfc/rfc1006.txt
+# \x03 = TPKT version.  It was 3 in May 1987 and gnomemeeting still uses 3.
+# ..? = null reserved byte and packet length field.
+# Q.931 format: http://www.freesoft.org/CIE/Topics/126.htm
+# \x08  = Q.931
+# . = length of call reference
+# The next byte was: \x18 = message sent from originating side.
+# But based on experimentation, it seems that just . is better. 
+# .?.?.?.?.?.?.?.?.?.?.?.?.?.?.? = call reference (0-15 bytes (0 for nulls))
+# \x05 = setup message
+#
+# Yup, it doesn't actually include any H.323 protocol information.
+^\x03..?\x08...?.?.?.?.?.?.?.?.?.?.?.?.?.?.?\x05
--- iptables-1.8.x/l7-protocols/halflife2-deathmatch.pat
+++ iptables-1.8.x/l7-protocols/halflife2-deathmatch.pat
@@ -0,0 +1,9 @@
+# Half-Life 2 Deathmatch - popular computer game
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Half-Life
+# 
+# By Clayton Macleod <cherrytwist TA gmail.com>
+
+halflife2-deathmatch
+^\xff\xff\xff\xff.*hl2mpDeathmatch
--- iptables-1.8.x/l7-protocols/hddtemp.pat
+++ iptables-1.8.x/l7-protocols/hddtemp.pat
@@ -0,0 +1,13 @@
+# hddtemp - Hard drive temperature reporting
+# Pattern attributes: great veryfast fast
+# Protocol groups: monitoring open_source
+# Wiki: http://www.protocolinfo.org/wiki/HDDtemp
+# 
+# Usually runs on port 7634
+#
+# You're a silly person if you use this pattern.
+#
+# This pattern has been tested and is believed to work well.
+
+hddtemp
+^\|/dev/[a-z][a-z][a-z]\|[0-9a-z]*\|[0-9][0-9]\|[cfk]\|
--- iptables-1.8.x/l7-protocols/http.pat
+++ iptables-1.8.x/l7-protocols/http.pat
@@ -0,0 +1,27 @@
+# HTTP - HyperText Transfer Protocol - RFC 2616
+# Pattern attributes: great slow notsofast superset
+# Protocol groups: document_retrieval ietf_draft_standard
+# Wiki: http://protocolinfo.org/wiki/HTTP
+#
+# Usually runs on port 80
+#
+# This pattern has been tested and is believed to work well.
+#
+# this intentionally catches the response from the server rather than
+# the request so that other protocols which use http (like kazaa) can be
+# caught based on specific http requests regardless of the ordering of
+# filters... also matches posts
+
+# Sites that serve really long cookies may break this by pushing the
+# server response too far away from the beginning of the connection. To
+# fix this, increase the kernel's data buffer length.
+
+http
+# Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF (rfc 2616)
+# As specified in rfc 2616 a status code is preceeded and followed by a
+# space. 
+http/(0\.9|1\.0|1\.1) [1-5][0-9][0-9] [\x09-\x0d -~]*(connection:|content-type:|content-length:|date:)|post [\x09-\x0d -~]* http/[01]\.[019]
+# A slightly faster version that might be good enough:
+#http/(0\.9|1\.0|1\.1) [1-5][0-9][0-9]|post [\x09-\x0d -~]* http/[01]\.[019]
+# old pattern(s):
+#(http[\x09-\x0d -~]*(200 ok|302 |304 )[\x09-\x0d -~]*(connection:|content-type:|content-length:))|^(post [\x09-\x0d -~]* http/)
--- iptables-1.8.x/l7-protocols/http-rtsp.pat
+++ iptables-1.8.x/l7-protocols/http-rtsp.pat
@@ -0,0 +1,15 @@
+# RTSP in HTTP - RTSP tunneled within HTTP
+# Pattern attributes: ok notsofast notsofast subset
+# Protocol groups: streaming_audio streaming_video ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/RTSP
+#
+# Apple's documentation on what Quicktime does:
+# http://developer.apple.com/quicktime/icefloe/dispatch028.html
+# This is what the first part of the pattern is about
+#
+# The second part is based on the example in RFC 2326.  For this part to
+# work, this pattern MUST be earlier in the iptables rules chain than
+# HTTP.  Otherwise, the stream will be identified as HTTP.
+
+http-rtsp
+^(get[\x09-\x0d -~]* Accept: application/x-rtsp-tunnelled|http/(0\.9|1\.0|1\.1) [1-5][0-9][0-9] [\x09-\x0d -~]*a=control:rtsp://)
--- iptables-1.8.x/l7-protocols/ident.pat
+++ iptables-1.8.x/l7-protocols/ident.pat
@@ -0,0 +1,14 @@
+# Ident - Identification Protocol - RFC 1413
+# Pattern attributes: good fast fast
+# Protocol groups: networking ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/Ident
+#
+# Usually runs on port 113
+#
+# This pattern is believed to work.
+
+ident
+# "number , numberCRLF" possibly without the CR and/or LF.
+# ^$ is appropriate because the first packet should never have anything
+# else in it.
+^[1-9][0-9]?[0-9]?[0-9]?[0-9]?[\x09-\x0d]*,[\x09-\x0d]*[1-9][0-9]?[0-9]?[0-9]?[0-9]?(\x0d\x0a|[\x0d\x0a])?$
--- iptables-1.8.x/l7-protocols/imap.pat
+++ iptables-1.8.x/l7-protocols/imap.pat
@@ -0,0 +1,13 @@
+# IMAP - Internet Message Access Protocol (A common e-mail protocol)
+# Pattern attributes: great veryfast fast
+# Protocol groups: mail ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/IMAP
+#
+# This matches IMAP4 (RFC 3501) and probably IMAP2 (RFC 1176)
+#
+# This pattern has been tested and is believed to work well.
+# 
+# This matches the IMAP welcome message or a noop command (which for 
+# some unknown reason can happen at the start of a connection?)  
+imap
+^(\* ok|a[0-9]+ noop)
--- iptables-1.8.x/l7-protocols/imesh.pat
+++ iptables-1.8.x/l7-protocols/imesh.pat
@@ -0,0 +1,14 @@
+# iMesh - the native protocol of iMesh, a P2P application - http://imesh.com
+# Pattern attributes: ok notsofast notsofast
+# Protocol groups: p2p
+# Wiki:   http://protocolinfo.org/wiki/iMesh
+#
+# depending on the version of iMesh (the program), it can also use fasttrack,
+# gnutella and edonkey in addition to iMesh (the protocol).
+
+imesh
+# The first branch matches the login
+# The second branch matches the main non-download connection (searches, etc)
+# The third branch matches downloads of "premium" content
+# The fourth branch matches peer downloads.
+^(post[\x09-\x0d -~]*<PasswordHash>................................</PasswordHash><ClientVer>|\x34\x80?\x0d?\xfc\xff\x04|get[\x09-\x0d -~]*Host: imsh\.download-prod\.musicnet\.com|\x02[\x01\x02]\x83.*\x02[\x01\x02]\x83)
--- iptables-1.8.x/l7-protocols/ipp.pat
+++ iptables-1.8.x/l7-protocols/ipp.pat
@@ -0,0 +1,11 @@
+# IP printing - a new standard for UNIX printing - RFC 2911
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: printer ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/IPP
+#
+# This pattern has been tested and is believed to work well.
+
+ipp
+# It's unlikely that anything else has this string, but I think we could
+# do a bit better...
+ipp://
--- iptables-1.8.x/l7-protocols/irc.pat
+++ iptables-1.8.x/l7-protocols/irc.pat
@@ -0,0 +1,19 @@
+# IRC - Internet Relay Chat - RFC 1459
+# Pattern attributes: great veryfast fast
+# Protocol groups: chat ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/IRC
+#
+# Usually runs on port 6666 or 6667
+# Note that chat traffic runs on these ports, but IRC-DCC traffic (which
+# can use much more bandwidth) uses a dynamically assigned port, so you 
+# must have the IRC connection tracking module in your kernel to classify
+# this.
+#
+# This pattern has been tested and is believed to work well.
+
+irc
+# First thing that happens is that the client sends NICK and USER, in 
+# either order.  This allows MIRC color codes (\x02-\x0d instead of
+# \x09-\x0d).
+^(nick[\x09-\x0d -~]*user[\x09-\x0d -~]*:|user[\x09-\x0d -~]*:[\x02-\x0d -~]*nick[\x09-\x0d -~]*\x0d\x0a)
+
--- iptables-1.8.x/l7-protocols/jabber.pat
+++ iptables-1.8.x/l7-protocols/jabber.pat
@@ -0,0 +1,23 @@
+# Jabber (XMPP) - open instant messenger protocol - RFC 3920 - http://jabber.org
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: chat ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/Jabber
+#
+# This pattern has been tested with Gaim and Gabber.  It is only tested 
+# with non-SSL mode Jabber with no proxies.
+
+# Thanks to Jan Hudec for some improvements.
+
+# Jabber seems to take a long time to set up a connection.  I'm
+# connecting with Gabber 0.8.8 to 12jabber.org and the first 8 packets
+# is this:
+# <stream:stream to='12jabber.com' xmlns='jabber:client'
+# xmlns:stream='http://etherx.jabber.org/streams'><?xml
+# version='1.0'?><stream:stream
+# xmlns:stream='http://etherx.jabber.org/streams' id='3f73e951'
+# xmlns='jabber:client' from='12jabber.com'>
+#
+# No mention of my username or password yet, you'll note.
+
+jabber
+<stream:stream[\x09-\x0d ][ -~]*[\x09-\x0d ]xmlns=['"]jabber
--- iptables-1.8.x/l7-protocols/mohaa.pat
+++ iptables-1.8.x/l7-protocols/mohaa.pat
@@ -0,0 +1,10 @@
+# Medal of Honor Allied Assault - an Electronic Arts game
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Medal_of_Honor_Allied_Assault
+#
+# This pattern is written and tested by Krzysztof Maciejewski.
+
+mohaa
+^\xff\xff\xff\xffgetstatus\x0a
+
--- iptables-1.8.x/l7-protocols/msnmessenger.pat
+++ iptables-1.8.x/l7-protocols/msnmessenger.pat
@@ -0,0 +1,27 @@
+# MSN Messenger - Microsoft Network chat client
+# Pattern attributes: good slow notsofast
+# Protocol groups: chat proprietary
+# Wiki: http://www.protocolinfo.org/wiki/MSN_Messenger
+#
+# Usually uses TCP port 1863
+# http://www.hypothetic.org/docs/msn/index.php
+# http://msnpiki.msnfanatic.com/
+#
+# This pattern has been tested and is believed to work well.
+
+msnmessenger
+
+# First branch: login
+#   ver: allow versions up to 99.
+#   I've never seen a cvr other than cvr0.  Maybe this will be trouble later?
+#   Can't anchor at the beginning because sometimes this is encapsulated in
+#   HTTP.  But either way, the first packet ends like this.
+# Second/Third branches: accepting/sending a message
+#   I will assume that these can also be encapsulated in HTTP, although I have
+#   not checked.  Example of each direction:
+#   ANS 1 quadong@hotmail.com 1139803431.29427 17522047
+#   USR 1 quadong@hotmail.com 530423708.968145.366138
+
+# Branches are written entirely separately for better performance.
+ver [0-9]+ msnp[1-9][0-9]? [\x09-\x0d -~]*cvr0\x0d\x0a$|usr 1 [!-~]+ [0-9. ]+\x0d\x0a$|ans 1 [!-~]+ [0-9. ]+\x0d\x0a$
+
--- iptables-1.8.x/l7-protocols/mute.pat
+++ iptables-1.8.x/l7-protocols/mute.pat
@@ -0,0 +1,10 @@
+# MUTE - P2P filesharing - http://mute-net.sourceforge.net
+# Pattern attributes: marginal veryfast fast
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/MUTE
+#
+# This pattern is lightly tested.  I don't know for sure that it will 
+# match the actual file transfers.
+
+mute
+^(Public|AES)Key: [0-9a-f]*\x0aEnd(Public|AES)Key\x0a$
--- iptables-1.8.x/l7-protocols/napster.pat
+++ iptables-1.8.x/l7-protocols/napster.pat
@@ -0,0 +1,23 @@
+# Napster - P2P filesharing
+# Pattern attributes: good fast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Napster
+#
+# All my tests show that this pattern is fast, but one user has reported that
+# it is slow.  Your milage may vary.
+# 
+# Should work for any Napster offspring, like OpenNAP.
+# (Yes, people still use this!)
+# Matches both searches and downloads.
+#
+# http://opennap.sourceforge.net/napster.txt
+#
+# This pattern has been tested and is believed to work well.
+
+napster
+# (client-server: length, assumed to be less than 256, login or new user login, 
+# username, password, port, client ID, link-type |
+# client-client: 1, firewalled or not, username, filename) 
+# Assumes that filenames are well-behaved ASCII strings.  I have found
+# one case where this assumptions fails (filename had \x99 in it).
+^(.[\x02\x06][!-~]+ [!-~]+ [0-9][0-9]?[0-9]?[0-9]?[0-9]? "[\x09-\x0d -~]+" ([0-9]|10)|1(send|get)[!-~]+ "[\x09-\x0d -~]+")
--- iptables-1.8.x/l7-protocols/nbns.pat
+++ iptables-1.8.x/l7-protocols/nbns.pat
@@ -0,0 +1,19 @@
+# NBNS - NetBIOS name service
+# Pattern attributes: good slow notsofast
+# Protocol groups: networking proprietary
+# Wiki: http://www.protocolinfo.org/wiki/NBNS
+#
+# This pattern has been tested and is believed to work well.
+#
+# name query
+# \x01\x10 means name query
+#
+# registration NB
+# (\x10 or )\x10 means registration
+#
+# release NB (merged with registration)
+# 0\x10 means release
+
+nbns
+# This is not a valid basic GNU regular expression.
+\x01\x10\x01|\)\x10\x01\x01|0\x10\x01
--- iptables-1.8.x/l7-protocols/ncp.pat
+++ iptables-1.8.x/l7-protocols/ncp.pat
@@ -0,0 +1,22 @@
+# NCP - Novell Core Protocol
+# Pattern attributes: good veryfast fast
+# Protocol groups: networking proprietary
+# Wiki: http://www.protocolinfo.org/wiki/NCP
+#
+# This pattern has been tested and is believed to work well.
+
+# ncp request
+# dmdt means Request
+#  *any length
+#
+#  *any reply buffer size
+# "" means service request
+#  | \x17\x17 means create a service connection
+#  | uu means destroy service connection
+
+# ncp reply
+# tncp means reply
+# 33 means service reply
+
+ncp
+^(dmdt.*\x01.*(""|\x11\x11|uu)|tncp.*33)
--- iptables-1.8.x/l7-protocols/nimda.pat
+++ iptables-1.8.x/l7-protocols/nimda.pat
@@ -0,0 +1,7 @@
+# Nimda - a worm that attacks Microsoft IIS web servers, and MORE!
+# Pattern attributes: ok notsofast notsofast subset
+# Protocol groups: worm
+# Wiki: http://www.protocolinfo.org/wiki/Nimda
+
+nimda
+GET (/scripts/root\.exe\?/c\+dir|/MSADC/root\.exe\?/c\+dir|/c/winnt/system32/cmd\.exe\?/c\+dir|/d/winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.%5c\.\./winnt/system32/cmd\.exe\?/c\+dir|/_vti_bin/\.\.%5c\.\./\.\.%5c\.\./\.\.%5c\.\./winnt/system32/cmd\.exe\?/c\+dir|/_mem_bin/\.\.%5c\.\./\.\.%5c\.\./\.\.%5c\.\./winnt/system32/cmd\.exe\?/c\+dir|/msadc/\.\.%5c\.\./\.\.%5c\.\./\.\.%5c/\.\.\xc1\x1c\.\./\.\.\xc1\x1c\.\./\.\.\xc1\x1c\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.\xc1\x1c\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.\xc0/\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.\xc0\xaf\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.\xc1\x9c\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.%35c\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.%35c\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.%5c\.\./winnt/system32/cmd\.exe\?/c\+dir|/scripts/\.\.%2f\.\./winnt/system32/cmd\.exe\?/c\+dir)
--- iptables-1.8.x/l7-protocols/nntp.pat
+++ iptables-1.8.x/l7-protocols/nntp.pat
@@ -0,0 +1,20 @@
+# NNTP - Network News Transfer Protocol - RFCs 977 and 2980
+# Pattern attributes: good veryfast fast
+# Protocol groups: ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/NNTP
+#
+# usually runs on port 119
+
+# This pattern is tested and is believed to work well (but could use
+# more testing).
+
+nntp
+# matches authorized login
+# OR 
+# matches unauthorized login if the server says "news" after 200/201
+# (Half of the 2 servers I tested did :-), but they both required authorization
+# so it's quite possible that this pattern will miss some nntp traffic.)
+^(20[01][\x09-\x0d -~]*AUTHINFO USER|20[01][\x09-\x0d -~]*news)
+
+# same thing, slightly more accurate, but 100+ times slower
+#^20[01][\x09-\x0d -~]*\x0d\x0a[\x09-\x0d -~]*AUTHINFO USER|20[01][\x09-\x0d -~]*news
--- iptables-1.8.x/l7-protocols/not_commit/exe.pat
+++ iptables-1.8.x/l7-protocols/not_commit/exe.pat
@@ -0,0 +1,19 @@
+# Executable - Microsoft PE file format.  
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: file
+
+# Thanks to Brandon Enright [bmenrighATucsd.edu]
+
+# This pattern doesn't techincally match the PE file format but rather the
+# MZ stub program Microsoft uses for backwards compatibility with DOS.
+# That means this will correctly match DOS executables too.
+
+exe
+# There are two different stubs used depending on the compiler/packer.
+# Numerous NULL bytes have been stripped from this pattern.
+
+# This pattern may be more efficient:
+# \x4d\x5a\x90\x03\x04|\x4d\x5a\x50\x02\x04
+
+# This is easier to understand:
+\x4d\x5a(\x90\x03|\x50\x02)\x04
--- iptables-1.8.x/l7-protocols/not_commit/flash.pat
+++ iptables-1.8.x/l7-protocols/not_commit/flash.pat
@@ -0,0 +1,17 @@
+# Flash - Macromedia Flash.  
+# Pattern attributes: good slow notsofast subset
+# Protocol groups: file
+
+# Thanks to Brandon Enright {bmenrigh AT ucsd.edu} and chinalantian at 
+# 126 dot com
+
+# Macromedia spec:
+# http://download.macromedia.com/pub/flash/flash_file_format_specification.pdf
+# See also:
+# http://www.digitalpreservation.gov/formats/fdd/fdd000130.shtml
+# http://osflash.org/flv
+
+flash
+# FWS = uncompressed, CWS = compressed, next byte is version number
+# FLV = video 
+[FC]WS[\x01-\x09]|FLV\x01\x05\x09
--- iptables-1.8.x/l7-protocols/not_commit/gif.pat
+++ iptables-1.8.x/l7-protocols/not_commit/gif.pat
@@ -0,0 +1,7 @@
+# GIF - Popular Image format.  
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: file
+
+gif
+# drawn from /usr/share/magic
+GIF8(7|9)a
--- iptables-1.8.x/l7-protocols/not_commit/html.pat
+++ iptables-1.8.x/l7-protocols/not_commit/html.pat
@@ -0,0 +1,10 @@
+# (X)HTML - (Extensible) Hypertext Markup Language - http://w3.org
+# Pattern attributes: good fast notsofast subset
+# Protocol groups: file
+# 
+# This pattern has been tested and is believe to work well.
+
+# this should match any (X)HTML document from any version that conforms
+# even vaugly to the standards.
+html
+<html.*><head>
--- iptables-1.8.x/l7-protocols/not_commit/jpeg.pat
+++ iptables-1.8.x/l7-protocols/not_commit/jpeg.pat
@@ -0,0 +1,7 @@
+# JPEG - Joint Picture Expert Group image format.  
+# Pattern attributes: ok fast notsofast subset
+# Protocol groups: file
+
+jpeg
+# drawn from /usr/share/magic
+\xff\xd8
--- iptables-1.8.x/l7-protocols/not_commit/mp3.pat
+++ iptables-1.8.x/l7-protocols/not_commit/mp3.pat
@@ -0,0 +1,10 @@
+# MP3 - Moving Picture Experts Group Audio Layer III
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: file
+
+# By LanTian (chinalantian at 126 d.t com)
+
+# Only matches the standard MP3 form, non-standard files might not be matched.
+
+mp3
+\x49\x44\x33\x03
--- iptables-1.8.x/l7-protocols/not_commit/ogg.pat
+++ iptables-1.8.x/l7-protocols/not_commit/ogg.pat
@@ -0,0 +1,6 @@
+# Ogg - Ogg Vorbis music format (not any ogg file, just vorbis)
+# Pattern attributes: ok notsofast notsofast subset
+# Protocol groups: file
+
+ogg
+oggs.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?.?\x01vorbis
--- iptables-1.8.x/l7-protocols/not_commit/pdf.pat
+++ iptables-1.8.x/l7-protocols/not_commit/pdf.pat
@@ -0,0 +1,10 @@
+# PDF - Portable Document Format - Postscript-like format by Adobe
+# Pattern attributes: good fast notsofast subset
+# Protocol groups: file
+# 
+# This pattern has been tested and is believe to work well.
+
+# Matches PDF versions 1.0 - 1.6 (not sure if 1.6 exists yet, but it probably 
+# will.
+pdf
+%PDF-1\.[0123456]
--- iptables-1.8.x/l7-protocols/not_commit/perl.pat
+++ iptables-1.8.x/l7-protocols/not_commit/perl.pat
@@ -0,0 +1,6 @@
+# Perl - A scripting language by Larry Wall.
+# Pattern attributes: good fast notsofast subset
+# Protocol groups: file
+
+perl
+\#! ?/(usr/(local/)?)?bin/perl
--- iptables-1.8.x/l7-protocols/not_commit/postscript.pat
+++ iptables-1.8.x/l7-protocols/not_commit/postscript.pat
@@ -0,0 +1,6 @@
+# Postscript - Printing Language
+# Pattern attributes: good fast notsofast subset
+# Protocol groups: file
+
+postscript
+%!ps
--- iptables-1.8.x/l7-protocols/not_commit/rar.pat
+++ iptables-1.8.x/l7-protocols/not_commit/rar.pat
@@ -0,0 +1,6 @@
+# RAR - The WinRAR archive format  
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: file
+
+rar
+rar\x21\x1a\x07
--- iptables-1.8.x/l7-protocols/not_commit/rpm.pat
+++ iptables-1.8.x/l7-protocols/not_commit/rpm.pat
@@ -0,0 +1,6 @@
+# RPM - Redhat Package Management packages
+# Pattern attributes: good fast notsofast subset
+# Protocol groups: file
+
+rpm
+\xed\xab\xee\xdb.?.?.?.?[1-7]
--- iptables-1.8.x/l7-protocols/not_commit/rtf.pat
+++ iptables-1.8.x/l7-protocols/not_commit/rtf.pat
@@ -0,0 +1,7 @@
+# RTF - Rich Text Format - an open document format
+# Pattern attributes: good fast notsofast subset
+# Protocol groups: file
+
+rtf
+\{\\rtf[12]
+
--- iptables-1.8.x/l7-protocols/not_commit/tar.pat
+++ iptables-1.8.x/l7-protocols/not_commit/tar.pat
@@ -0,0 +1,11 @@
+# Tar - tape archive.  Standard UNIX file archiver, not just for tapes.
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: file
+
+tar
+# /usr/share/magic
+## POSIX tar archives
+#257     string          ustar\0         POSIX tar archive
+#257     string          ustar\040\040\0 GNU tar archive
+# this is pretty general.  It's not a dictionary word, but still...
+ustar
--- iptables-1.8.x/l7-protocols/not_commit/zip.pat
+++ iptables-1.8.x/l7-protocols/not_commit/zip.pat
@@ -0,0 +1,6 @@
+# ZIP - (PK|Win)Zip archive format  
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: file
+
+zip
+pk\x03\x04\x14
--- iptables-1.8.x/l7-protocols/ntp.pat
+++ iptables-1.8.x/l7-protocols/ntp.pat
@@ -0,0 +1,16 @@
+# (S)NTP - (Simple) Network Time Protocol - RFCs 1305 and 2030
+# Pattern attributes: good fast fast overmatch 
+# Protocol groups: time_synchronization ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/NTP
+#
+# This pattern is tested and is believed to work.
+
+# client|server
+# Requires the server's timestamp to be in the present or future (of 2005).
+# Tested with ntpdate on Linux.
+# Assumes version 2, 3 or 4.
+
+# Note that ntp packets are always 48 bytes, so you should match on that too.
+
+ntp
+^([\x13\x1b\x23\xd3\xdb\xe3]|[\x14\x1c$].......?.?.?.?.?.?.?.?.?[\xc6-\xff])
--- iptables-1.8.x/l7-protocols/openft.pat
+++ iptables-1.8.x/l7-protocols/openft.pat
@@ -0,0 +1,12 @@
+# OpenFT - P2P filesharing (implemented in giFT library)
+# Pattern attributes: good fast notsofast
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/OpenFT
+
+# Ben Efros <ben AT xgendev.com> says:
+# "This pattern identifies openFT P2P transfers fine.  openFT is part of giFT
+# and is a pretty large p2p network. I would describe this pattern as pretty 
+# weak, but it works for the giFT-based clients I've used."
+
+openft
+x-openftalias: [-)(0-9a-z ~.]
--- iptables-1.8.x/l7-protocols/pop3.pat
+++ iptables-1.8.x/l7-protocols/pop3.pat
@@ -0,0 +1,49 @@
+# POP3 - Post Office Protocol version 3 (popular e-mail protocol) - RFC 1939
+# Pattern attributes: great veryfast fast
+# Protocol groups: mail ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/POP
+#
+# This pattern has been tested somewhat.
+
+# this is a difficult protocol to match because of the relative lack of 
+# distinguishing information.  Read on.
+pop3
+
+# this the most conservative pattern.  It should definitely work.
+#^(\+ok|-err)
+
+# this pattern assumes that the server says _something_ after +ok or -err
+# I think this is probably the way to go.
+^(\+ok |-err )
+
+# more that 90% of servers seem to say "pop" after "+ok", but not all.
+#^(\+ok .*pop)
+
+# Here's another tack. I think this is my second favorite.
+#^(\+ok [\x09-\x0d -~]*(ready|hello|pop|starting)|-err [\x09-\x0d -~]*(invalid|unknown|unimplemented|unrecognized|command))
+
+# this matches the server saying "you have N messages that are M bytes",
+# which the client probably asks for early in the session (not tested)
+#\+ok [0-9]+ [0-9]+
+
+# some sample servers:
+# RFC example:        +OK POP3 server ready <1896.697170952@dbc.mtview.ca.us>
+# mail.dreamhost.com: +OK Hello there.
+# pop.carleton.edu:   +OK POP3D(*) Server PMDFV6.2.2 at Fri, 12 Sep 2003 19:28:10 -0500 (CDT) (APOP disabled)
+# mail.earthlink.net: +OK NGPopper vEL_4_38 at earthlink.net ready <25509.1063412951@falcon>
+# *.email.umn.edu:    +OK Cubic Circle's v1.22 1998/04/11 POP3 ready <7d1e0000da67623f@aquamarine.tc.umn.edu>
+# mail.yale.edu:      +OK POP3 pantheon-po01 v2002.81 server ready
+# mail.gustavus.edu:  +OK POP3 solen v2001.78 server ready
+# mail.reed.edu:      +OK POP3 letra.reed.edu v2002.81 server ready
+# mail.bowdoin.edu:   +OK mail.bowdoin.edu POP3 service (iPlanet Messaging Server 5.2 HotFix 1.15 (built Apr 28 2003))
+# pop.colby.edu:      +OK Qpopper (version 4.0.5) at basalt starting.
+# mail.mac.com:       +OK Netscape Messaging Multiplexor ready
+
+# various error strings:
+#-ERR Invalid command.
+#-ERR invalid command
+#-ERR unimplemented
+#-ERR Invalid command, try one of: USER name, PASS string, QUIT
+#-ERR Unknown AUTHORIZATION state command
+#-ERR Unrecognized command
+#-ERR Unknown command: "sadf'".
--- iptables-1.8.x/l7-protocols/qq.pat
+++ iptables-1.8.x/l7-protocols/qq.pat
@@ -0,0 +1,18 @@
+# Tencent QQ Protocol - Chinese instant messenger protocol - http://www.qq.com
+# Pattern attributes: good fast fast
+# Protocol groups: chat
+# Wiki: http://www.protocolinfo.org/wiki/QQ
+#
+# Over six million people use QQ in China, according to wsgtrsys.
+# 
+# This pattern has been tested and is believed to work well.
+#
+# QQ uses three (two?) methods to connect to server(s?).
+# one is udp, and another is tcp
+# udp protocol: the first byte is 02 and last byte is 03
+# tcp protocol: the second byte is 02 and last byte is 03
+# pattern written by www.routerclub.com wsgtrsys
+
+qq
+^.?\x02.+\x03$
+
--- iptables-1.8.x/l7-protocols/quake-halflife.pat
+++ iptables-1.8.x/l7-protocols/quake-halflife.pat
@@ -0,0 +1,26 @@
+# HL1, Quake, CS - Half Life 1 engine games (HL 1, Quake 2/3/World, Counterstrike 1.6, etc.)
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Half-Life http://www.protocolinfo.org/wiki/Counter-Strike http://www.protocolinfo.org/wiki/Day_of_Defeat
+#
+# Contributed by Laurens Blankers <laurens AT blankersfamily.com>, who says:
+#
+# This pattern has been tested with QuakeWorld (2.30), Quake 2 (3.20), 
+# Quake 3 (1.32), and Half-life (1.1.1.0). But may also work on other
+# games based on the Quake engine.
+#
+# Clayton Macleod <cherrytwist A gmail.com> says:
+# [This should match] Counter-Strike v1.6, [...] the slightly updated
+# Counter-Strike: Condition Zero, and the game Day Of Defeat, Team
+# Fortress Classic, Deathmatch Classic, Ricochet, Half-Life [1] Deathmatch,
+# and I imagine all the other 3rd party mods that also use this engine
+# will match that pattern.
+
+quake-halflife
+# All quake (like) protocols start with 4x 0xFF.  Then the client either
+# issues getinfo or getchallenge.
+^\xff\xff\xff\xffget(info|challenge)
+
+# A previous quake pattern allowed the connection to start with only 2 bytes
+# of 0xFF.  This doesn't seem to ever happen, but we should keep an eye out
+# for it.
--- iptables-1.8.x/l7-protocols/radmin.pat
+++ iptables-1.8.x/l7-protocols/radmin.pat
@@ -0,0 +1,16 @@
+# Famatech Remote Administrator - remote desktop for MS Windows
+# Pattern attributes: ok veryfast fast
+# Protocol groups: remote_access proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Radmin
+#
+# This pattern has been verified with Radmin v1.1 and v3.0beta on Win2000/XP
+# It has only been tested between a single pair of computers.
+
+# The first packet of every TCP stream appears to be either one of:
+#
+# 01 00 00 00  01 00 00 00  08 08
+# 01 00 00 00  01 00 00 00  1b 1b
+
+radmin
+^\x01\x01(\x08\x08|\x1b\x1b)$
+
--- iptables-1.8.x/l7-protocols/rdp.pat
+++ iptables-1.8.x/l7-protocols/rdp.pat
@@ -0,0 +1,19 @@
+# RDP - Remote Desktop Protocol (used in Windows Terminal Services)
+# Pattern attributes: ok notsofast notsofast
+# Protocol groups: remote_access proprietary
+# Wiki: http://www.protocolinfo.org/wiki/RDP
+#
+# This pattern was submitted by Michael Leong.  It has been tested under the 
+# following conditions: "WinXP Pro with all the patches, rdesktop server 
+# running on port 7000 instead of 3389 --> WinXP Pro Remote Desktop Client."
+# Also tested is WinXP to Win 2000 Server.
+
+# At least one other person has reported it to work as well.
+
+rdp
+rdpdr.*cliprdr.*rdpsnd
+
+# Old pattern, submitted by Daniel Weatherford.
+# rdpdr.*cliprdp.*rdpsnd 
+
+
--- iptables-1.8.x/l7-protocols/replaytv-ivs.pat
+++ iptables-1.8.x/l7-protocols/replaytv-ivs.pat
@@ -0,0 +1,10 @@
+# ReplayTV Internet Video Sharing - Digital Video Recorder - http://replaytv.com
+# Pattern attributes: good veryfast fast
+# Protocol groups: 
+# Wiki: http://www.protocolinfo.org/wiki/ReplayTV
+#
+# Pattern by jm 409 at hot mail dot com, who says that this one "worked best".
+
+replaytv-ivs
+^(get /ivs-IVSGetFileChunk|http/(0\.9|1\.0|1\.1) [1-5][0-9][0-9] [\x09-\x0d -~]*\x23\x23\x23\x23\x23REPLAY_CHUNK_START\x23\x23\x23\x23\x23)
+
--- iptables-1.8.x/l7-protocols/rtp.pat
+++ iptables-1.8.x/l7-protocols/rtp.pat
@@ -0,0 +1,40 @@
+# RTP - Real-time Transport Protocol - RFC 3550
+# Pattern attributes: marginal overmatch undermatch veryfast fast
+# Protocol groups: streaming_video ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/RTP
+#
+# RTP headers are *very* short and compact.  They have almost nothing in 
+# them that can be matched by l7-filter.  If you want to match them 
+# along with their associated SIP packets, I think the best way might be 
+# to set up some iptables rules that watch for SIP packets and then also 
+# match any other UDP packets that are going between the same two IP 
+# addresses.
+#
+# However, I will attempt a pattern anyway.  This is UNTESTED!
+# 
+# I think we can count on the first bit being 1 and the second bit being 
+# 0 (meaning protocol version 2). The next two bits could go either way, 
+# but in the example I've seen, they are zero, so I'll assume they are 
+# usually zero.  The next four bits are a count of "contributing source 
+# identifiers".  I'm not sure how big that could be, but in the example 
+# I've seen, they're zero, so I'll assume they're usually zero. So that 
+# gives us ^\x80.  The marker bit that comes next is probably zero for 
+# the first packet, although that's not a sure thing.  Next is the 
+# payload type, 7 bits that might usually only take a few values, but 
+# maybe not. In the example I've seen, it's zero, which (with a zero 
+# marker bit) means it looks to l7-filter like it's not there at all.  
+# The rest of the header is random numbers (sequence number, timestamp, 
+# synchronization source identifier), so that's no help at all.
+#
+# I think the best we could do is to watch to see if several \x80 bytes 
+# come in with a small number of bytes between them.  This makes all the 
+# above assumptions and also assumes that the first packet has no 
+# payload and not too much trailing gargage.  So this will definitely not
+# work all the time.  It clearly also might match other stuff.
+
+rtp
+^\x80......?.?.?.?.?.?.?.?.?.?.?.?.?\x80
+
+# Might also try this.  It's a bit slower (one packet and not too much extra
+# regexec load) and a bit more accurate:
+#^\x80......?.?.?.?.?.?.?.?.?.?.?.?.?\x80.*\x80
--- iptables-1.8.x/l7-protocols/rtsp.pat
+++ iptables-1.8.x/l7-protocols/rtsp.pat
@@ -0,0 +1,14 @@
+# RTSP - Real Time Streaming Protocol - http://www.rtsp.org - RFC 2326
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: streaming_video ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/RTSP
+#
+# usually runs on port 554
+#
+# To take full advantage of this pattern, please see the RTSP connection 
+# tracking patch to the Linux kernel referenced at the above site.
+#
+# This pattern has been tested and is believed to work well.
+
+rtsp
+rtsp/1.0 200 ok
--- iptables-1.8.x/l7-protocols/shoutcast.pat
+++ iptables-1.8.x/l7-protocols/shoutcast.pat
@@ -0,0 +1,26 @@
+# Shoutcast and Icecast - streaming audio
+# Pattern attributes: good slow notsofast
+# Protocol groups: streaming_audio
+# Wiki: http://www.protocolinfo.org/wiki/Icecast
+#
+# usually runs on port 80
+#
+# Original pattern contributed by Deepak Seshadri <dseshadri AT 
+# broadbandmaritime.com> who says "The difference between [Shoutcast and 
+# Icecast] is not clearly mentioned anywhere. According to this 
+# document, my pattern would filter JUST shoutcast packets."
+#
+# Should now match both Shoutcast and Icecast.  Tested with Winamp (in 
+# 2005) and Totem using streams at dir.xiph.org (in Nov 2007).
+#
+# http://sander.vanzoest.com/talks/2002/audio_and_apache/
+# http://forums.radiotoolbox.com/viewtopic.php?t=74
+# http://www.icecast.org
+
+shoutcast
+# The first branch looks for an HTTP request that looks like it is asking for
+# a SHOUTcast stream.  The second branch looks for the server's reply.  However,
+# some (newer?) servers answer with "http/1.0 200 OK", not "ICY 200 OK", so
+# this will not work.
+# This pattern was discovered using Ethereal.
+^get /.*icy-metadata:1|icy [1-5][0-9][0-9] [\x09-\x0d -~]*(content-type:audio|icy-)
--- iptables-1.8.x/l7-protocols/sip.pat
+++ iptables-1.8.x/l7-protocols/sip.pat
@@ -0,0 +1,18 @@
+# SIP - Session Initiation Protocol - Internet telephony - RFC 3261
+# Pattern attributes: ok fast fast
+# Protocol groups: voip ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/SIP
+#
+# This pattern has been tested with the Ubiquity SIP user agent.
+#
+# Thanks to Ankit Desai for this pattern.
+#
+# SIP typically uses port 5060.
+#
+# This pattern is based on SIP request format as per RFC 3261. I'm not
+# sure about the version part. The RFC doesn't say anything about it, so
+# I have allowed version ranging from 0.x to 2.x.
+
+#Request-Line  =  Method SP Request-URI SP SIP-Version CRLF
+sip
+^(invite|register|cancel) sip[\x09-\x0d -~]*sip/[0-2]\.[0-9]
--- iptables-1.8.x/l7-protocols/skypeout.pat
+++ iptables-1.8.x/l7-protocols/skypeout.pat
@@ -0,0 +1,49 @@
+# Skype to phone - UDP voice call (program to POTS phone) - http://skype.com
+# Pattern attributes: ok slow notsofast overmatch
+# Protocol groups: voip p2p proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Skype
+
+# Thanks to Myles Uyema, mylesuyema AT gmail.com
+
+# Taken using Ethereal traces of Windows Skype v1.2.037, same in v1.2.0.18_API
+#
+# Skype will attempt to use the same UDP port for all its connections as
+# configured in its options.  However, this is a random port by default.
+# Skype has some preference for ports 80 and 443.
+#
+# Example sessions:
+#
+#SkypeOut <USA phone number>
+#c6 5c bf 41 8e 8d d6 d2 08 <-- this is sometimes as short as 1 byte and 
+#c6 5c bf 41 8e 8d d6 d2 08 <-- sometimes as long as 9 (or more?)
+#00 6b 2c f5 87 f1 06
+#00 6b 2c f5 87 f1 06
+#00 6b 2c f5 36 ea 85
+#00 6b 2c f5 36 ea 85
+#00 6b 2c f5 57 27 d4
+#00 6b 2c f5 57 27 d4
+#00 6b 2c f5 43 5b 00
+#00 6b 2c f5 43 5b 00
+#
+#SkypeOut <USA phone number>
+#7e 4f e5 b8
+#7e 4f e5 b8
+#00 6b 88 61 80 52 93
+#00 6b 88 61 80 52 93
+#00 6b 88 61 1a 09 e9
+#00 6b 88 61 1a 09 e9
+#00 6b 88 61 47 43 c4
+#00 6b 88 61 47 43 c4
+
+skypeout
+
+# Scary.  Our regular expressions suck.  This is a prime candidate for 
+# some sort of a scheme to support two different regular expressions 
+# when there's a major difference between what the two libraries allow.  
+# For the Henry Spencer library, there's not much that can be done 
+# except requiring that we see the same byte twice.
+
+# This matches about %4 of random streams and 13% of printable random streams
+
+# This is slow, but not as bad as you might think.
+^(\x01.?.?.?.?.?.?.?.?\x01|\x02.?.?.?.?.?.?.?.?\x02|\x03.?.?.?.?.?.?.?.?\x03|\x04.?.?.?.?.?.?.?.?\x04|\x05.?.?.?.?.?.?.?.?\x05|\x06.?.?.?.?.?.?.?.?\x06|\x07.?.?.?.?.?.?.?.?\x07|\x08.?.?.?.?.?.?.?.?\x08|\x09.?.?.?.?.?.?.?.?\x09|\x0a.?.?.?.?.?.?.?.?\x0a|\x0b.?.?.?.?.?.?.?.?\x0b|\x0c.?.?.?.?.?.?.?.?\x0c|\x0d.?.?.?.?.?.?.?.?\x0d|\x0e.?.?.?.?.?.?.?.?\x0e|\x0f.?.?.?.?.?.?.?.?\x0f|\x10.?.?.?.?.?.?.?.?\x10|\x11.?.?.?.?.?.?.?.?\x11|\x12.?.?.?.?.?.?.?.?\x12|\x13.?.?.?.?.?.?.?.?\x13|\x14.?.?.?.?.?.?.?.?\x14|\x15.?.?.?.?.?.?.?.?\x15|\x16.?.?.?.?.?.?.?.?\x16|\x17.?.?.?.?.?.?.?.?\x17|\x18.?.?.?.?.?.?.?.?\x18|\x19.?.?.?.?.?.?.?.?\x19|\x1a.?.?.?.?.?.?.?.?\x1a|\x1b.?.?.?.?.?.?.?.?\x1b|\x1c.?.?.?.?.?.?.?.?\x1c|\x1d.?.?.?.?.?.?.?.?\x1d|\x1e.?.?.?.?.?.?.?.?\x1e|\x1f.?.?.?.?.?.?.?.?\x1f|\x20.?.?.?.?.?.?.?.?\x20|\x21.?.?.?.?.?.?.?.?\x21|\x22.?.?.?.?.?.?.?.?\x22|\x23.?.?.?.?.?.?.?.?\x23|\$.?.?.?.?.?.?.?.?\$|\x25.?.?.?.?.?.?.?.?\x25|\x26.?.?.?.?.?.?.?.?\x26|\x27.?.?.?.?.?.?.?.?\x27|\(.?.?.?.?.?.?.?.?\(|\).?.?.?.?.?.?.?.?\)|\*.?.?.?.?.?.?.?.?\*|\+.?.?.?.?.?.?.?.?\+|\x2c.?.?.?.?.?.?.?.?\x2c|\x2d.?.?.?.?.?.?.?.?\x2d|\..?.?.?.?.?.?.?.?\.|\x2f.?.?.?.?.?.?.?.?\x2f|\x30.?.?.?.?.?.?.?.?\x30|\x31.?.?.?.?.?.?.?.?\x31|\x32.?.?.?.?.?.?.?.?\x32|\x33.?.?.?.?.?.?.?.?\x33|\x34.?.?.?.?.?.?.?.?\x34|\x35.?.?.?.?.?.?.?.?\x35|\x36.?.?.?.?.?.?.?.?\x36|\x37.?.?.?.?.?.?.?.?\x37|\x38.?.?.?.?.?.?.?.?\x38|\x39.?.?.?.?.?.?.?.?\x39|\x3a.?.?.?.?.?.?.?.?\x3a|\x3b.?.?.?.?.?.?.?.?\x3b|\x3c.?.?.?.?.?.?.?.?\x3c|\x3d.?.?.?.?.?.?.?.?\x3d|\x3e.?.?.?.?.?.?.?.?\x3e|\?.?.?.?.?.?.?.?.?\?|\x40.?.?.?.?.?.?.?.?\x40|\x41.?.?.?.?.?.?.?.?\x41|\x42.?.?.?.?.?.?.?.?\x42|\x43.?.?.?.?.?.?.?.?\x43|\x44.?.?.?.?.?.?.?.?\x44|\x45.?.?.?.?.?.?.?.?\x45|\x46.?.?.?.?.?.?.?.?\x46|\x47.?.?.?.?.?.?.?.?\x47|\x48.?.?.?.?.?.?.?.?\x48|\x49.?.?.?.?.?.?.?.?\x49|\x4a.?.?.?.?.?.?.?.?\x4a|\x4b.?.?.?.?.?.?.?.?\x4b|\x4c.?.?.?.?.?.?.?.?\x4c|\x4d.?.?.?.?.?.?.?.?\x4d|\x4e.?.?.?.?.?.?.?.?\x4e|\x4f.?.?.?.?.?.?.?.?\x4f|\x50.?.?.?.?.?.?.?.?\x50|\x51.?.?.?.?.?.?.?.?\x51|\x52.?.?.?.?.?.?.?.?\x52|\x53.?.?.?.?.?.?.?.?\x53|\x54.?.?.?.?.?.?.?.?\x54|\x55.?.?.?.?.?.?.?.?\x55|\x56.?.?.?.?.?.?.?.?\x56|\x57.?.?.?.?.?.?.?.?\x57|\x58.?.?.?.?.?.?.?.?\x58|\x59.?.?.?.?.?.?.?.?\x59|\x5a.?.?.?.?.?.?.?.?\x5a|\[.?.?.?.?.?.?.?.?\[|\\.?.?.?.?.?.?.?.?\\|\].?.?.?.?.?.?.?.?\]|\^.?.?.?.?.?.?.?.?\^|\x5f.?.?.?.?.?.?.?.?\x5f|\x60.?.?.?.?.?.?.?.?\x60|\x61.?.?.?.?.?.?.?.?\x61|\x62.?.?.?.?.?.?.?.?\x62|\x63.?.?.?.?.?.?.?.?\x63|\x64.?.?.?.?.?.?.?.?\x64|\x65.?.?.?.?.?.?.?.?\x65|\x66.?.?.?.?.?.?.?.?\x66|\x67.?.?.?.?.?.?.?.?\x67|\x68.?.?.?.?.?.?.?.?\x68|\x69.?.?.?.?.?.?.?.?\x69|\x6a.?.?.?.?.?.?.?.?\x6a|\x6b.?.?.?.?.?.?.?.?\x6b|\x6c.?.?.?.?.?.?.?.?\x6c|\x6d.?.?.?.?.?.?.?.?\x6d|\x6e.?.?.?.?.?.?.?.?\x6e|\x6f.?.?.?.?.?.?.?.?\x6f|\x70.?.?.?.?.?.?.?.?\x70|\x71.?.?.?.?.?.?.?.?\x71|\x72.?.?.?.?.?.?.?.?\x72|\x73.?.?.?.?.?.?.?.?\x73|\x74.?.?.?.?.?.?.?.?\x74|\x75.?.?.?.?.?.?.?.?\x75|\x76.?.?.?.?.?.?.?.?\x76|\x77.?.?.?.?.?.?.?.?\x77|\x78.?.?.?.?.?.?.?.?\x78|\x79.?.?.?.?.?.?.?.?\x79|\x7a.?.?.?.?.?.?.?.?\x7a|\{.?.?.?.?.?.?.?.?\{|\|.?.?.?.?.?.?.?.?\||\}.?.?.?.?.?.?.?.?\}|\x7e.?.?.?.?.?.?.?.?\x7e|\x7f.?.?.?.?.?.?.?.?\x7f|\x80.?.?.?.?.?.?.?.?\x80|\x81.?.?.?.?.?.?.?.?\x81|\x82.?.?.?.?.?.?.?.?\x82|\x83.?.?.?.?.?.?.?.?\x83|\x84.?.?.?.?.?.?.?.?\x84|\x85.?.?.?.?.?.?.?.?\x85|\x86.?.?.?.?.?.?.?.?\x86|\x87.?.?.?.?.?.?.?.?\x87|\x88.?.?.?.?.?.?.?.?\x88|\x89.?.?.?.?.?.?.?.?\x89|\x8a.?.?.?.?.?.?.?.?\x8a|\x8b.?.?.?.?.?.?.?.?\x8b|\x8c.?.?.?.?.?.?.?.?\x8c|\x8d.?.?.?.?.?.?.?.?\x8d|\x8e.?.?.?.?.?.?.?.?\x8e|\x8f.?.?.?.?.?.?.?.?\x8f|\x90.?.?.?.?.?.?.?.?\x90|\x91.?.?.?.?.?.?.?.?\x91|\x92.?.?.?.?.?.?.?.?\x92|\x93.?.?.?.?.?.?.?.?\x93|\x94.?.?.?.?.?.?.?.?\x94|\x95.?.?.?.?.?.?.?.?\x95|\x96.?.?.?.?.?.?.?.?\x96|\x97.?.?.?.?.?.?.?.?\x97|\x98.?.?.?.?.?.?.?.?\x98|\x99.?.?.?.?.?.?.?.?\x99|\x9a.?.?.?.?.?.?.?.?\x9a|\x9b.?.?.?.?.?.?.?.?\x9b|\x9c.?.?.?.?.?.?.?.?\x9c|\x9d.?.?.?.?.?.?.?.?\x9d|\x9e.?.?.?.?.?.?.?.?\x9e|\x9f.?.?.?.?.?.?.?.?\x9f|\xa0.?.?.?.?.?.?.?.?\xa0|\xa1.?.?.?.?.?.?.?.?\xa1|\xa2.?.?.?.?.?.?.?.?\xa2|\xa3.?.?.?.?.?.?.?.?\xa3|\xa4.?.?.?.?.?.?.?.?\xa4|\xa5.?.?.?.?.?.?.?.?\xa5|\xa6.?.?.?.?.?.?.?.?\xa6|\xa7.?.?.?.?.?.?.?.?\xa7|\xa8.?.?.?.?.?.?.?.?\xa8|\xa9.?.?.?.?.?.?.?.?\xa9|\xaa.?.?.?.?.?.?.?.?\xaa|\xab.?.?.?.?.?.?.?.?\xab|\xac.?.?.?.?.?.?.?.?\xac|\xad.?.?.?.?.?.?.?.?\xad|\xae.?.?.?.?.?.?.?.?\xae|\xaf.?.?.?.?.?.?.?.?\xaf|\xb0.?.?.?.?.?.?.?.?\xb0|\xb1.?.?.?.?.?.?.?.?\xb1|\xb2.?.?.?.?.?.?.?.?\xb2|\xb3.?.?.?.?.?.?.?.?\xb3|\xb4.?.?.?.?.?.?.?.?\xb4|\xb5.?.?.?.?.?.?.?.?\xb5|\xb6.?.?.?.?.?.?.?.?\xb6|\xb7.?.?.?.?.?.?.?.?\xb7|\xb8.?.?.?.?.?.?.?.?\xb8|\xb9.?.?.?.?.?.?.?.?\xb9|\xba.?.?.?.?.?.?.?.?\xba|\xbb.?.?.?.?.?.?.?.?\xbb|\xbc.?.?.?.?.?.?.?.?\xbc|\xbd.?.?.?.?.?.?.?.?\xbd|\xbe.?.?.?.?.?.?.?.?\xbe|\xbf.?.?.?.?.?.?.?.?\xbf|\xc0.?.?.?.?.?.?.?.?\xc0|\xc1.?.?.?.?.?.?.?.?\xc1|\xc2.?.?.?.?.?.?.?.?\xc2|\xc3.?.?.?.?.?.?.?.?\xc3|\xc4.?.?.?.?.?.?.?.?\xc4|\xc5.?.?.?.?.?.?.?.?\xc5|\xc6.?.?.?.?.?.?.?.?\xc6|\xc7.?.?.?.?.?.?.?.?\xc7|\xc8.?.?.?.?.?.?.?.?\xc8|\xc9.?.?.?.?.?.?.?.?\xc9|\xca.?.?.?.?.?.?.?.?\xca|\xcb.?.?.?.?.?.?.?.?\xcb|\xcc.?.?.?.?.?.?.?.?\xcc|\xcd.?.?.?.?.?.?.?.?\xcd|\xce.?.?.?.?.?.?.?.?\xce|\xcf.?.?.?.?.?.?.?.?\xcf|\xd0.?.?.?.?.?.?.?.?\xd0|\xd1.?.?.?.?.?.?.?.?\xd1|\xd2.?.?.?.?.?.?.?.?\xd2|\xd3.?.?.?.?.?.?.?.?\xd3|\xd4.?.?.?.?.?.?.?.?\xd4|\xd5.?.?.?.?.?.?.?.?\xd5|\xd6.?.?.?.?.?.?.?.?\xd6|\xd7.?.?.?.?.?.?.?.?\xd7|\xd8.?.?.?.?.?.?.?.?\xd8|\xd9.?.?.?.?.?.?.?.?\xd9|\xda.?.?.?.?.?.?.?.?\xda|\xdb.?.?.?.?.?.?.?.?\xdb|\xdc.?.?.?.?.?.?.?.?\xdc|\xdd.?.?.?.?.?.?.?.?\xdd|\xde.?.?.?.?.?.?.?.?\xde|\xdf.?.?.?.?.?.?.?.?\xdf|\xe0.?.?.?.?.?.?.?.?\xe0|\xe1.?.?.?.?.?.?.?.?\xe1|\xe2.?.?.?.?.?.?.?.?\xe2|\xe3.?.?.?.?.?.?.?.?\xe3|\xe4.?.?.?.?.?.?.?.?\xe4|\xe5.?.?.?.?.?.?.?.?\xe5|\xe6.?.?.?.?.?.?.?.?\xe6|\xe7.?.?.?.?.?.?.?.?\xe7|\xe8.?.?.?.?.?.?.?.?\xe8|\xe9.?.?.?.?.?.?.?.?\xe9|\xea.?.?.?.?.?.?.?.?\xea|\xeb.?.?.?.?.?.?.?.?\xeb|\xec.?.?.?.?.?.?.?.?\xec|\xed.?.?.?.?.?.?.?.?\xed|\xee.?.?.?.?.?.?.?.?\xee|\xef.?.?.?.?.?.?.?.?\xef|\xf0.?.?.?.?.?.?.?.?\xf0|\xf1.?.?.?.?.?.?.?.?\xf1|\xf2.?.?.?.?.?.?.?.?\xf2|\xf3.?.?.?.?.?.?.?.?\xf3|\xf4.?.?.?.?.?.?.?.?\xf4|\xf5.?.?.?.?.?.?.?.?\xf5|\xf6.?.?.?.?.?.?.?.?\xf6|\xf7.?.?.?.?.?.?.?.?\xf7|\xf8.?.?.?.?.?.?.?.?\xf8|\xf9.?.?.?.?.?.?.?.?\xf9|\xfa.?.?.?.?.?.?.?.?\xfa|\xfb.?.?.?.?.?.?.?.?\xfb|\xfc.?.?.?.?.?.?.?.?\xfc|\xfd.?.?.?.?.?.?.?.?\xfd|\xfe.?.?.?.?.?.?.?.?\xfe|\xff.?.?.?.?.?.?.?.?\xff)
--- iptables-1.8.x/l7-protocols/skypetoskype.pat
+++ iptables-1.8.x/l7-protocols/skypetoskype.pat
@@ -0,0 +1,13 @@
+# Skype to Skype - UDP voice call (program to program) - http://skype.com
+# Pattern attributes: ok veryfast fast overmatch
+# Protocol groups: voip p2p proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Skype
+
+# This matches at least some of the general chatter that occurs when the
+# user isn't doing anything as well as actual calls.
+# Thanks to Myles Uyema, mylesuyema AT gmail.com
+
+skypetoskype
+# require at least 16 bytes (my limited tests always get at least 18)
+^..\x02.............
+
--- iptables-1.8.x/l7-protocols/smb.pat
+++ iptables-1.8.x/l7-protocols/smb.pat
@@ -0,0 +1,18 @@
+# Samba/SMB - Server Message Block - Microsoft Windows filesharing
+# Pattern attributes: good fast notsofast
+# Protocol groups: document_retrieval networking proprietary
+# Wiki: http://www.protocolinfo.org/wiki/SMB
+#
+# "This protocol is sometimes also referred to as the Common Internet File 
+# System (CIFS), LanManager or NetBIOS protocol." -- "man samba"
+#
+# Actually, SMB is a higher level protocol than NetBIOS.  However, the 
+# NetBIOS header is only 4 bytes: not much to match on.
+#
+# http://www.ubiqx.org/cifs/SMB.html
+#
+# This pattern is lightly tested.
+
+smb
+# matches a NEGOTIATE PROTOCOL or TRANSACTION REQUEST command
+\xffsmb[\x72\x25]
--- iptables-1.8.x/l7-protocols/smtp.pat
+++ iptables-1.8.x/l7-protocols/smtp.pat
@@ -0,0 +1,39 @@
+# SMTP - Simple Mail Transfer Protocol - RFC 2821 (See also RFC 1869)
+# Pattern attributes: great notsofast fast
+# Protocol groups: mail ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/SMTP
+#
+# usually runs on port 25
+# 
+# This pattern has been tested and is believed to work well.
+
+# As usual, no text is required after "220", but all known servers have some
+# there.  It (almost?) always has string "smtp" in it.  The RFC examples
+# does not, so we match those too, just in case anyone has copied them 
+# literally.
+#
+# Some examples:
+# 220 mail.stalker.com ESMTP CommuniGate Pro 4.1.3
+# 220 mail.vieodata.com ESMTP Merak 6.1.0; Mon, 15 Sep 2003 13:48:11 -0400
+# 220 mail.ut.caldera.com ESMTP
+# 220 persephone.pmail.gen.nz ESMTP server ready.
+# 220 smtp1.superb.net ESMTP
+# 220 mail.kerio.com Kerio MailServer 5.6.7 ESMTP ready
+# 220-mail.deerfield.com ESMTP VisNetic.MailServer.v6.0.9.0; Mon, 15 Sep 2003 13:4
+# 220 altn.com ESMTP MDaemon 6.8.5; Mon, 15 Sep 2003 12:46:42 -0500
+# 220 X1 NT-ESMTP Server ipsmin0165atl2.interland.net (IMail 6.06 73062-3)
+# 220 mail.icewarp.com ESMTP Merak 6.1.1; Mon, 15 Sep 2003 19:43:23 +0200
+# 220-mail.email-scan.com ESMTP
+# 220 smaug.dreamhost.com ESMTP
+# 220 kona.carleton.edu -- Server ESMTP (PMDF V6.2#30648)
+# 220 letra.reed.edu ESMTP Sendmail 8.12.9/8.12.9; Mon, 15 Sep 2003 10:35:57 -0700 (PDT)
+# 220-swan.mail.pas.earthlink.net ESMTP Exim 3.33 #1 Mon, 15 Sep 2003 10:32:15 -0700
+# 
+# RFC examples:
+# 220 xyz.com Simple Mail Transfer Service Ready (RFC example)
+# 220 dbc.mtview.ca.us SMTP service ready
+
+smtp
+^220[\x09-\x0d -~]* (e?smtp|simple mail)
+userspace pattern=^220[\x09-\x0d -~]* (E?SMTP|[Ss]imple [Mm]ail)
+userspace flags=REG_NOSUB REG_EXTENDED
--- iptables-1.8.x/l7-protocols/snmp.pat
+++ iptables-1.8.x/l7-protocols/snmp.pat
@@ -0,0 +1,18 @@
+# SNMP - Simple Network Management Protocol - RFC 1157
+# Pattern attributes: good veryfast fast superset
+# Protocol groups: networking ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/SNMP
+#
+# Usually runs on UDP ports 161 (monitoring) and 162 (traps).
+#
+# These filters match SNMPv1 packets without fail, and are made as
+# specific as possible not to match any ASN.1 encoded protocols. However
+# these could still be matched by other protocols that use ASN.1 encoding
+
+# Contributed by Goli SriSairam <goli_sai AT yahoo.com>
+
+# This pattern has been tested and is believed to work well.
+
+# All SNMPv1 traffic.  See snmp-mon.pat and snmp-trap.pat for details.
+snmp
+^\x02\x01\x04.+([\xa0-\xa3]\x02[\x01-\x04].?.?.?.?\x02\x01.?\x02\x01.?\x30|\xa4\x06.+\x40\x04.?.?.?.?\x02\x01.?\x02\x01.?\x43)
--- iptables-1.8.x/l7-protocols/socks.pat
+++ iptables-1.8.x/l7-protocols/socks.pat
@@ -0,0 +1,31 @@
+# SOCKS Version 5 - Firewall traversal protocol - RFC 1928
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: networking ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/SOCKS
+#
+# Usually runs on port 1080
+# Also useful: http://www.iana.org/assignments/socks-methods
+#
+# We have had two reports that this pattern works.
+
+# method request, no private methods	\x05[\x01-\x08]*
+# method reply, assumes sucess		\x05[\x01-\x08]?
+# method dependent sub-negotiation	.*
+# request, ipv4 only			\x05[\x01-\x03][\x01\x03].*
+# reply					\x05[\x01-\x08]?[\x01\x03].*
+
+# username/password method
+# u/p request, assuming reasonable usernames and passwords
+# \x05[\x02-\x10][a-z][a-z0-9\-]*[\x05-\x20][!-~]*
+# server reply
+# \x05
+
+# GSSAPI method
+# client initial token 		\x01\x01\x02.*
+# server reply			\x01\x01\x02.*
+
+# any other method  .* (all methods boil down to this until we have information
+# about all the commonly used ones)
+
+socks
+\x05[\x01-\x08]*\x05[\x01-\x08]?.*\x05[\x01-\x03][\x01\x03].*\x05[\x01-\x08]?[\x01\x03]
--- iptables-1.8.x/l7-protocols/soribada.pat
+++ iptables-1.8.x/l7-protocols/soribada.pat
@@ -0,0 +1,50 @@
+# Soribada - A Korean P2P filesharing program/protocol - http://www.soribada.com
+# Pattern attributes: good slow notsofast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Soribada
+
+# I am told that there are three versions of this protocol, the first no
+# longer being used.  That would probably explain why incoming searches
+# have two different formats...
+
+# There are three parts to Soribada protocal:
+# 1: Ping/Pong to establish a relationship on the net (UDP with 2 useful bytes)
+# 2: Searching (in two formats) (UDP with two short easy to match starts)
+# 3: Download requests/transfers (TCP with an obvious first packet)
+
+# 1 -- Pings/Pongs:
+# Requester send 2 bytes and a 6 byte response is sent back.
+# \x10 for the first byte and \x14-\x16 for the second.
+# The response is the first byte (\x10) and the second byte incremented
+# by 1 (\x15-\x17).
+# No further communication happens between the hosts except for searches.
+# A regex match: ^\x10[\x14-\x16]\x10[\x15-\x17].?.?.?.?$
+# First Packet ---^^^^^^^^^^^^^^^
+# Second Packet -----------------^^^^^^^^^^^^^^^^^^^^^^^
+
+# 2 -- Search requests:
+# All searches are totally stateless and are only responded to if the user
+# actually has the file.
+# Both format start with a \x01 byte, have 3 "random bytes" and then 3 bytes
+# corasponding to one of two formats.
+# Format 1 is \x51\x3a\+ and format 2 is \x51\x32\x3a
+# A regex match: ^\x01.?.?.?(\x51\x3a\+|\x51\x32\x3a)
+
+# 3 -- Download requests:
+# All downloads start with "GETMP3\x0d\x0aFilename"
+# A regex match: ^GETMP3\x0d\x0aFilename
+
+soribada
+
+# This will match the second packet of two.
+# ^\x10[\x14-\x16]\x10[\x15-\x17].?.?.?.?$
+
+# Again, matching this is the end of the comunication.
+# ^\x01.?.?.?(\x51\x3a\+|\x51\x32\x3a)
+
+# This is the start of the transfer and an easy match
+#^GETMP3\x0d\x0aFilename
+
+# This will match everything including the udp packet portions
+^GETMP3\x0d\x0aFilename|^\x01.?.?.?(\x51\x3a\+|\x51\x32\x3a)|^\x10[\x14-\x16]\x10[\x15-\x17].?.?.?.?$
+
--- iptables-1.8.x/l7-protocols/soulseek.pat
+++ iptables-1.8.x/l7-protocols/soulseek.pat
@@ -0,0 +1,16 @@
+# Soulseek - P2P filesharing - http://slsknet.org
+# Pattern attributes: good fast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Soulseek
+#
+# All my tests show that this pattern is fast, but one user has reported that
+# it is slow.  Your milage may vary.
+
+# This has been tested and works for "pierce firewall" commands and file
+# transfers.  It does *not* match all the various sorts of chatter that go on, 
+# such as searches, pings and whatnot.
+
+soulseek
+# (Pierce firewall: in theory the token could be 4 bytes, but the last two 
+# seem to always be zero.|download: Peer Init)
+^(\x05..?|.\x01.[ -~]+\x01F..?.?.?.?.?.?.?)$
--- iptables-1.8.x/l7-protocols/ssdp.pat
+++ iptables-1.8.x/l7-protocols/ssdp.pat
@@ -0,0 +1,20 @@
+# SSDP - Simple Service Discovery Protocol - easy discovery of network devices
+# Pattern attributes: good slow notsofast
+# Protocol groups: networking ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/SSDP
+
+# This pattern was tested only by listening to a Linksys WRT54G. However,
+# I expect it works in general given the simplicity of the protocol.
+
+# SSDP packets should _always_ be sent to the multicast address
+# 239.255.255.250, making this pattern irrelevant.  (Moreover, SSDP
+# packets should be resitricted to local networks that have plenty of
+# bandwidth.)  However, Microsoft, as usual, has other ideas, so maybe
+# it could be useful.  Can't hurt, anyway. :-)
+#
+# http://www.upnp.org/download/draft_cai_ssdp_v1_03.txt
+# http://msdn.microsoft.com/library/default.asp?url=/library/en-us/randz/protocol/ssdp.asp
+
+ssdp
+^notify[\x09-\x0d ]\*[\x09-\x0d ]http/1\.1[\x09-\x0d -~]*ssdp:(alive|byebye)|^m-search[\x09-\x0d ]\*[\x09-\x0d ]http/1\.1[\x09-\x0d -~]*ssdp:discover
+
--- iptables-1.8.x/l7-protocols/ssh.pat
+++ iptables-1.8.x/l7-protocols/ssh.pat
@@ -0,0 +1,16 @@
+# SSH - Secure SHell
+# Pattern attributes: great veryfast fast
+# Protocol groups: remote_access secure ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/SSH
+#
+# usually runs on port 22
+#
+# http://www.ietf.org/internet-drafts/draft-ietf-secsh-transport-22.txt
+#
+# This pattern has been tested and is believed to work well.
+
+ssh
+^ssh-[12]\.[0-9]
+
+# old pattern:
+# (diffie-hellman-group-exchange-sha1|diffie-hellman-group1-sha1.ssh-rsa|ssh-dssfaes128-cbc|3des-cbc|blowfish-cbc|cast128-cbc|arcfour|aes192-cbc|aes256-cbc|rijndael-cbc@lysator.liu.sefaes128-cbc|3des-cbc|blowfish-cbc|cast128-cbc|arcfour|aes192-cbc|aes256-cbc|rijndael-cbc@lysator.liu.seuhmac-md5|hmac-sha1|hmac-ripemd160)+
--- iptables-1.8.x/l7-protocols/ssl.pat
+++ iptables-1.8.x/l7-protocols/ssl.pat
@@ -0,0 +1,15 @@
+# SSL and TLS - Secure Socket Layer / Transport Layer Security - RFC 2246
+# Pattern attributes: good notsofast fast superset
+# Protocol groups: secure ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/SSL
+#
+# Usually runs on port 443
+#
+# This is a superset of validcertssl.  For it to match, it must be first.
+# 
+# This pattern has been tested and is believed to work well.
+
+ssl
+# Server Hello with certificate | Client Hello
+# This allows SSL 3.X, which includes TLS 1.0, known internally as SSL 3.1
+^(.?.?\x16\x03.*\x16\x03|.?.?\x01\x03\x01?.*\x0b)
--- iptables-1.8.x/l7-protocols/subspace.pat
+++ iptables-1.8.x/l7-protocols/subspace.pat
@@ -0,0 +1,20 @@
+# Subspace - 2D asteroids-style space game - http://sscentral.com
+# Pattern attributes: marginal veryfast fast
+# Protocol groups: game
+# Wiki: http://www.protocolinfo.org/wiki/Subspace
+#
+# By Myles Uyema <mylesuyema AT gmail.com>
+#
+# This pattern matches the initial 2 packets of the client-server
+# 'handshake' when joining a Zone.
+#
+# The first packet is an 8 byte UDP payload sent from client
+# 0x00 0x01 0x?? 0x?? 0x?? 0x?? 0x11
+# The next packet is a 12 byte UDP response from server
+# 0x00 0x10 0x?? 0x?? 0x?? 0x?? 0x?? 0x?? 0x?? 0x?? 0x01 0x00
+#
+# l7-filter strips out the null bytes, leaving me with this pattern
+
+subspace
+^\x01....\x11\x10........\x01$
+
--- iptables-1.8.x/l7-protocols/subversion.pat
+++ iptables-1.8.x/l7-protocols/subversion.pat
@@ -0,0 +1,12 @@
+# Subversion - a version control system
+# Pattern attributes: ok veryfast fast
+# Protocol groups: version_control open_source
+# Wiki: http://www.protocolinfo.org/wiki/Subversion
+#
+# This pattern is UNTESTED.  (But it seems straightforward enough...)
+#
+# Subversion uses TCP port 3690 by default.
+
+subversion
+# This is not a valid basic GNU regular expression.
+^\( success \( 1 2 \(
--- iptables-1.8.x/l7-protocols/teamfortress2.pat
+++ iptables-1.8.x/l7-protocols/teamfortress2.pat
@@ -0,0 +1,10 @@
+# Team Fortress 2 - network game - http://www.valvesoftware.com
+# Pattern attributes: good veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Team_Fortress
+#
+# Credits: Clayton Macleod <cherry twist at gmail dot com>
+#          Jan Engelhardt <jengelh at computergmbh dot de>
+
+teamfortress2
+^\xff\xff\xff\xff.....*tfTeam Fortress
--- iptables-1.8.x/l7-protocols/teamspeak.pat
+++ iptables-1.8.x/l7-protocols/teamspeak.pat
@@ -0,0 +1,14 @@
+# TeamSpeak - VoIP application - http://goteamspeak.com
+# Pattern attributes: good veryfast fast
+# Protocol groups: voip proprietary
+# Wiki: http://www.protocolinfo.org/wiki/TeamSpeak
+#
+# This pattern has been tested by Matthew Strait and verified by packet
+# traces by at least two other people.  The meaning of f4b303 is not
+# known, but it seems to appear in all first packets.  This pattern only
+# matches the actual UDP voice traffic, not the TeamSpeak web interface
+# or "TCP query".
+
+teamspeak
+^\xf4\xbe\x03.*teamspeak
+
--- iptables-1.8.x/l7-protocols/telnet.pat
+++ iptables-1.8.x/l7-protocols/telnet.pat
@@ -0,0 +1,15 @@
+# Telnet - Insecure remote login - RFC 854
+# Pattern attributes: good veryfast fast
+# Protocol groups: remote_access obsolete ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/Telnet
+#
+# Usually runs on port 23
+#
+# This pattern is lightly tested.
+
+telnet
+# Matches at least three IAC (Do|Will|Don't|Won't) commands in a row.  
+# My telnet client sends 9 when I connect, so this should be fine.
+# This pattern could fail on a unchatty connection or it could be 
+# matched by something non-telnet spewing a lot of stuff in the fb-ff range.
+^\xff[\xfb-\xfe].\xff[\xfb-\xfe].\xff[\xfb-\xfe]
--- iptables-1.8.x/l7-protocols/thecircle.pat
+++ iptables-1.8.x/l7-protocols/thecircle.pat
@@ -0,0 +1,11 @@
+# The Circle - P2P application - http://thecircle.org.au
+# Pattern attributes: ok veryfast fast
+# Protocol groups: p2p open_source
+# Wiki: http://www.protocolinfo.org/wiki/The_Circle
+
+# This is tested with The Circle 0.41c on Linux.
+# It likely misses some stuff.  Notably, I wasn't able to test it on any 
+# large downloads, because no one is sharing anything!
+
+thecircle
+^t\x03ni.?[\x01-\x06]?t[\x01-\x05]s[\x0a\x0b](glob|who are you$|query data)
--- iptables-1.8.x/l7-protocols/tor.pat
+++ iptables-1.8.x/l7-protocols/tor.pat
@@ -0,0 +1,16 @@
+# Tor - The Onion Router - used for anonymization - http://tor.eff.org
+# Pattern attributes: good notsofast notsofast
+# Protocol groups: networking
+# Wiki: http://protocolinfo.org/wiki/Tor
+#
+# This pattern has been tested and is believed to work well.
+#
+# It matches on the second packet.  I have no idea how the protocol
+# works, but this matches every stream I have made using Tor 0.1.0.16 as
+# a client on Linux.
+#
+# It does NOT attempt to match the HTTP request that fetches the list of
+# Tor servers.
+
+tor
+TOR1.*<identity>
--- iptables-1.8.x/l7-protocols/tsp.pat
+++ iptables-1.8.x/l7-protocols/tsp.pat
@@ -0,0 +1,13 @@
+# TSP - Berkely UNIX Time Synchronization Protocol
+# Pattern attributes: good veryfast fast overmatch
+# Protocol groups: time_synchronization open_source
+# Wiki: http://www.protocolinfo.org/wiki/TSP
+#
+# http://ftp.svbug.com/ftp/pub/manuals/pdf/smm.22.timed.pdf
+# http://docs.freebsd.org/44doc/smm/12.timed/paper.pdf
+# 
+# This pattern is barely tested.
+
+tsp
+# type, version (1), sequence number, 8 type specific bytes, machine name
+^[\x01-\x13\x16-$]\x01.?.?.?.?.?.?.?.?.?.?[ -~]+
--- iptables-1.8.x/l7-protocols/untested/100bao.pat
+++ iptables-1.8.x/l7-protocols/untested/100bao.pat
@@ -0,0 +1,11 @@
+# 100bao - a Chinese P2P protocol/program - http://www.100bao.com
+# Pattern attributes: ok veryfast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/100Bao
+#
+# Pattern written by www.routerclub.com's wsgtrsys.
+# The author of this pattern says it works, but this is unconfirmed. 
+
+100bao
+^\x01\x01\x05\x0a
+
--- iptables-1.8.x/l7-protocols/untested/battlefield2142.pat
+++ iptables-1.8.x/l7-protocols/untested/battlefield2142.pat
@@ -0,0 +1,13 @@
+# Battlefield 2142 - An EA game.
+# Pattern attributes: ok fast fast
+# Protocol groups: proprietary game 
+# Wiki: http://protocolinfo.org/wiki/Battlefield_2142
+
+# Submitted by Telsin.  Not confirmed.
+
+battlefield2142
+# gameplay|account-login|server browsing/information
+# Can't put a ^ on the last branch: it fails to match if you do.
+# This branch seems to matter very rarely, though
+^(\x11\x20\x01\x90\x50\x64\x10|\xfe\xfd.?.?.?\x18|[\x01\\].?battlefield2)
+
--- iptables-1.8.x/l7-protocols/untested/battlefield2.pat
+++ iptables-1.8.x/l7-protocols/untested/battlefield2.pat
@@ -0,0 +1,25 @@
+# Battlefield 2 - An EA game.
+# Pattern attributes: ok slow notsofast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Battlefield_2
+#
+# This pattern is unconfirmed except implicitly by a comment on protocolinfo.
+
+battlefield2
+# gameplay|account-login|server browsing/information
+# See http://protocolinfo.org/wiki/Battlefield_2
+# Can we put a ^ on the last branch?  If so, nosofast --> veryfast
+
+# 193.85.217.35 on protocolinfo says:
+# The first part of the pattern, \x11\x20\x01\xa0\x98\x11, has to be 
+# modified for different version of Battlefield 2. The gameplay part of 
+# pattern for BF2 v1.4 is \x11\x20\x01\x30\xb9\x10\x11, and for BF2 
+# v1.41 is \x11\x20\x01\x50\xb9\x10\x11
+#
+# Rather than put all of those in, I've just gone with "...?" in the 
+# middle.
+
+^(\x11\x20\x01...?\x11|\xfe\xfd.?.?.?.?.?.?(\x14\x01\x06|\xff\xff\xff))|[]\x01].?battlefield2
+
+# Pattern prior to 193.85.217.35's comment on protocolinfo:
+#^(\x11\x20\x01\xa0\x98\x11|\xfe\xfd.?.?.?.?.?.?(\x14\x01\x06|\xff\xff\xff))|[]\x01].?battlefield2
--- iptables-1.8.x/l7-protocols/untested/biff.pat
+++ iptables-1.8.x/l7-protocols/untested/biff.pat
@@ -0,0 +1,15 @@
+# Biff - new mail notification 
+# Pattern attributes: good veryfast fast undermatch overmatch
+# Protocol groups: mail
+# Wiki: http://www.protocolinfo.org/wiki/Biff
+#
+# Usually runs on port 512
+#
+# This pattern is completely untested.
+
+biff
+# This is a rare case where we will specify a $ (end of line), since
+# this is the entirety of the communication.
+# something that looks like a username, an @, a number.
+# won't catch usernames that have strange characters in them.
+^[a-z][a-z0-9]+@[1-9][0-9]+$
--- iptables-1.8.x/l7-protocols/untested/goboogy.pat
+++ iptables-1.8.x/l7-protocols/untested/goboogy.pat
@@ -0,0 +1,12 @@
+# GoBoogy - a Korean P2P protocol
+# Pattern attributes: marginal slow notsofast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/GoBoogy
+# 
+# This pattern is untested and likely does not work in all cases!
+#
+# By Adam Przybyla, modified by Matthew Strait.  Possibly lifted from 
+# Josh Ballard (oofle.com).
+
+goboogy
+<peerplat>|^get /getfilebyhash\.cgi\?|^get /queue_register\.cgi\?|^get /getupdowninfo\.cgi\?
--- iptables-1.8.x/l7-protocols/untested/hotline.pat
+++ iptables-1.8.x/l7-protocols/untested/hotline.pat
@@ -0,0 +1,11 @@
+# Hotline - An old P2P filesharing protocol
+# Pattern attributes: marginal fast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Hotline
+# 
+# This pattern is untested!
+#
+# This is lifted from http://oofle.com/filesharing.php?app=hotline
+
+hotline
+^....................TRTPHOTL\x01\x02
--- iptables-1.8.x/l7-protocols/untested/kugoo.pat
+++ iptables-1.8.x/l7-protocols/untested/kugoo.pat
@@ -0,0 +1,14 @@
+# KuGoo - a Chinese P2P program - http://www.kugoo.com
+# Pattern attributes: ok veryfast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/KuGoo
+#
+# The author of this pattern says it works, but this is unconfirmed.
+# Written by www.routerclub.com wsgtrsys.
+#
+# LanTian submitted \x64.+\x74\x47\x50\x37 for "KuGoo2", but adding as 
+# another branch makes the pattern REALLY slow.  If it could have a ^, that'd
+# be ok (still veryfast/fast).  Waiting to hear.
+
+kugoo
+^(\x31..\x8e|\x64.+\x74\x47\x50\x37)
--- iptables-1.8.x/l7-protocols/untested/live365.pat
+++ iptables-1.8.x/l7-protocols/untested/live365.pat
@@ -0,0 +1,14 @@
+# live365 - An Internet radio site - http://live365.com
+# Pattern attributes: marginal notsofast notsofast
+# Protocol groups: streaming_audio
+# Wiki: http://www.protocolinfo.org/wiki/Live365
+#
+# This pattern was "contributed" (taken with permission) by the bandwidth 
+# arbitrator project (www.bandwidtharbitrator.com).
+#
+# This pattern is unconfirmed.
+
+live365
+# FIXME: what's going on here?
+membername.*session.*player
+
--- iptables-1.8.x/l7-protocols/untested/liveforspeed.pat
+++ iptables-1.8.x/l7-protocols/untested/liveforspeed.pat
@@ -0,0 +1,12 @@
+# Live For Speed - A racing game.
+# Pattern attributes: poor veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Live_For_Speed
+#
+# This pattern was submitted to protocolinfo.org by 80.55.238.74 with no
+# explanation.  It is unconfirmed.
+
+# Live For Speed S2 Alpha 0.5 X10
+liveforspeed
+^..\x05\x58\x0a\x1d\x03
+# The same guy came by the next day and deleted the \x03 without comment...
--- iptables-1.8.x/l7-protocols/untested/lpd.pat
+++ iptables-1.8.x/l7-protocols/untested/lpd.pat
@@ -0,0 +1,17 @@
+# LPD - Line Printer Daemon Protocol (old-style UNIX printing) - RFC 1179
+# Pattern attributes: ok fast fast
+# Protocol groups: printer ietf_rfc_documented
+# Wiki: http://www.protocolinfo.org/wiki/LPD
+#
+# This pattern is untested.
+
+lpd
+# print waiting jobs:  ^\x01[!-~]+\x0a$
+# receive a print job: ^\x02[!-~]+\x0a.[\x01\x02\x03][\x01-\x0a -~]*\x0a$
+# Send queue state:    ^[\x03\x04][!-~]+[\x09-\x0d]+[a-z][\x09-\x0d -~]*\x0a$
+# Remove jobs:         ^\x05[!-~]+[\x09-\x0d]+([a-z][!-~]*[\x09-\x0d]+[1-9][0-9]?[0-9]?|root[\x09-\x0d]+[!-~]+).*\x0a$
+
+# This pattern looks like it might match random data once in a while, but 
+# testing shows that this is not the case.
+
+^(\x01[!-~]+|\x02[!-~]+\x0a.[\x01\x02\x03][\x01-\x0a -~]*|[\x03\x04][!-~]+[\x09-\x0d]+[a-z][\x09-\x0d -~]*|\x05[!-~]+[\x09-\x0d]+([a-z][!-~]*[\x09-\x0d]+[1-9][0-9]?[0-9]?|root[\x09-\x0d]+[!-~]+).*)\x0a$
--- iptables-1.8.x/l7-protocols/untested/msn-filetransfer.pat
+++ iptables-1.8.x/l7-protocols/untested/msn-filetransfer.pat
@@ -0,0 +1,29 @@
+# MSN file transfers - MSN (Micosoft Network) Messenger file transfers (MSNFTP and MSNSLP)
+# Pattern attributes: good veryfast fast
+# Protocol groups: chat document_retrieval proprietary
+# Wiki: http://www.protocolinfo.org/wiki/MSN_Messenger
+#
+# http://www.hypothetic.org/docs/msn/client/file_transfer.php
+
+# NOTE!  This pattern does not catch the modern type of MSN filetransfers
+# because they use the same TCP connection as the chat itself.  See 
+# ../example_traffic/msn_chat_and_file_transfer.txt for a demonstration.
+
+# This pattern has been tested and seems to work well.  It, does,
+# however, require more testing with various versions of the official
+# MSN client as well as with clones such as Trillian, Miranda, Gaim,
+# etc.  If you are using a MSN clone and this pattern DOES work for you,
+# please, also let us know.
+
+# First part matches the older MSNFTP: A MSN filetransfer is a normal
+# MSN connection except that the protocol is MSNFTP. Some clients
+# (especially Trillian) send other protocol versions besides MSNFTP
+# which should be matched by the [ -~]*.
+
+# Second part matches newer MSNSLP: 
+# http://msnpiki.msnfanatic.com/index.php/MSNC:MSNSLP
+# This part is untested.
+
+msn-filetransfer
+^(ver [ -~]*msnftp\x0d\x0aver msnftp\x0d\x0ausr|method msnmsgr:)
+
--- iptables-1.8.x/l7-protocols/untested/netbios.pat
+++ iptables-1.8.x/l7-protocols/untested/netbios.pat
@@ -0,0 +1,28 @@
+# NetBIOS - Network Basic Input Output System
+# Pattern attributes: marginal notsofast notsofast
+# Protocol groups: networking ietf_internet_standard proprietary
+# Wiki: http://www.protocolinfo.org/wiki/NetBIOS
+#
+# As mentioned in smb.pat:
+#
+# "This protocol is sometimes also referred to as the Common Internet File 
+# System (CIFS), LanManager or NetBIOS protocol." -- "man samba"
+#
+# Actually, SMB is a higher level protocol than NetBIOS.  However, the 
+# NetBIOS header is only 4 bytes: not much to match on.
+#
+# http://www.ubiqx.org/cifs/SMB.html
+# See also RFCs 1001 and 1002.
+#
+# This pattern attempts to match the (Session layer) NetBIOS Session request. 
+# If sucessful, you may be able to match NetBIOS several packets earlier 
+# than if you just waited for the easier-to-match SMB header.
+#
+# This pattern is untested.
+
+netbios
+# session request byte, three bytes of flags and length.  Then 
+# there should be a big mess of letters between A and P which represent
+# the NetBIOS names of the involved computers (with a null between them).  
+# (40ish here, damn this regexp implementation and its lack of {40,})
+\x81.?.?.[A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P][A-P]
--- iptables-1.8.x/l7-protocols/untested/pcanywhere.pat
+++ iptables-1.8.x/l7-protocols/untested/pcanywhere.pat
@@ -0,0 +1,11 @@
+# pcAnywhere - Symantec remote access program
+# Pattern attributes: marginal veryfast fast
+# Protocol groups: remote_access proprietary
+# Wiki: http://www.protocolinfo.org/wiki/PcAnywhere
+
+# This is completely untested!
+# See http://www.unixwiz.net/tools/pcascan.txt
+
+pcanywhere
+# I think this only matches queries and not the bulk of the traffic!
+^(nq|st)$
--- iptables-1.8.x/l7-protocols/untested/poco.pat
+++ iptables-1.8.x/l7-protocols/untested/poco.pat
@@ -0,0 +1,11 @@
+# POCO and PP365 - Chinese P2P filesharing - http://pp365.com http://poco.cn
+# Pattern attributes: ok veryfast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Poco
+#
+# The author of this pattern says it works, but this is unconfirmed.
+# Written by www.routerclub.com wsgtrsys.
+
+poco
+^\x80\x94\x0a\x01....\x1f\x9e
+
--- iptables-1.8.x/l7-protocols/untested/quake1.pat
+++ iptables-1.8.x/l7-protocols/untested/quake1.pat
@@ -0,0 +1,18 @@
+# Quake 1 - A popular computer game.
+# Pattern attributes: marginal veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Quake
+#
+# This pattern is untested and unconfirmed.
+
+# Info taken from http://www.gamers.org/dEngine/quake/QDP/qnp.html,
+# which says that it "is incomplete, inaccurate and only applies to
+# versions 0.91, 0.92, 1.00 and 1.01 of QUAKE"
+
+quake1
+# Connection request: 80 00 00 0c 01 51 55 41 4b 45 00 03
+# \x80 = control packet.
+# \x0c = packet length
+# \x01 = CCREQ_CONNECT
+# \x03 = protocol version (3 == 0.91, 0.92, 1.00, 1.01)
+^\x80\x0c\x01quake\x03
--- iptables-1.8.x/l7-protocols/untested/rlogin.pat
+++ iptables-1.8.x/l7-protocols/untested/rlogin.pat
@@ -0,0 +1,18 @@
+# rlogin - remote login - RFC 1282
+# Pattern attributes: ok veryfast fast
+# Protocol groups: remote_access ietf_rfc_documented
+# Wiki: http://www.protocolinfo.org/wiki/Rlogin
+#
+# usually runs on port 443
+#
+# This pattern is untested.
+
+rlogin
+# At least three characters (user name, user name, terminal type), 
+# the first of which could be the first character of a user name, a
+# slash, then a terminal speed.  (Assumes that usernames and terminal
+# types are alphanumeric only.  I'm sure there are usernames like
+# "straitm-47" out there, but it's not common.) All terminal speeds 
+# I know of end in two zeros and are between 3 and 6 digits long.
+# This pattern is uncomfortably general.
+^[a-z][a-z0-9][a-z0-9]+/[1-9][0-9]?[0-9]?[0-9]?00
--- iptables-1.8.x/l7-protocols/untested/stun.pat
+++ iptables-1.8.x/l7-protocols/untested/stun.pat
@@ -0,0 +1,45 @@
+# STUN - Simple Traversal of UDP Through NAT - RFC 3489
+# Pattern attributes: ok veryfast fast
+# Protocol groups: networking ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/STUN
+#
+# This pattern is untested as far as I know.
+
+# Wikipedia says: "The STUN server is contacted on UDP port 3478,
+# however the server will hint clients to perform tests on alternate IP
+# and port number too (STUN servers have two IP addresses). The RFC
+# states that this port and IP are arbitrary."
+
+stun
+# \x01 is a Binding Request.  \x02 is a Shared Secret Request. Binding
+# Requests are, experimentally, exactly 20 Bytes with three NULL Bytes. 
+# The first NULL is part of the two byte message type field.  The other
+# two give the message length, zero.  I'm guessing that Shared Secret
+# Requests are similar, but I have not checked.  Please read the RFC and
+# do experiments to find out.  All other message types are responses,
+# and so don't matter.
+#
+# The .? allows one of the Message Transaction ID Bytes to be \x00.  If
+# two are \x00, it will fail.  This will happen 0.37% of the time, since
+# the Message Transaction ID is supposed to be random.  If this is
+# unacceptable to you, add another ? to reduce this to 0.020%, but be
+# aware of the increased possibility of false positives.
+^[\x01\x02]................?$
+
+# From my post to the mailing list:
+# http://sourceforge.net/mailarchive/message.php?msg_id=36787107
+# 
+# This is a rather permissive pattern, but you can make it a little better 
+# by combining it with another iptables rule that checks that the packet 
+# data is exactly 20 Bytes.  Of course, the second packet is longer, so 
+# maybe that introduces more complications than benefits.
+# 
+# If you're willing to wait until the second packet to make the 
+# identification, you could use this:
+# 
+# ^\x01................?\x01\x01
+# 
+# or if the Message Length is always \x24 (I'm not sure it is from your 
+# single example):
+# 
+# ^\x01................?\x01\x01\x24
--- iptables-1.8.x/l7-protocols/untested/tesla.pat
+++ iptables-1.8.x/l7-protocols/untested/tesla.pat
@@ -0,0 +1,14 @@
+# Tesla Advanced Communication - P2P filesharing (?)
+# Pattern attributes: marginal slow notsofast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Tesla
+#
+# This pattern is untested!
+
+# This is lifted from http://oofle.com/filesharing.php?app=tesla
+# There is no explaination of what these numbers mean.
+# The above page says that the first string is found only in TCP packets
+# and the second only in UDP.
+
+tesla
+\x03\x9a\x89\x22\x31\x31\x31\.\x30\x30\x20\x42\x65\x74\x61\x20|\xe2\x3c\x69\x1e\x1c\xe9
--- iptables-1.8.x/l7-protocols/untested/tftp.pat
+++ iptables-1.8.x/l7-protocols/untested/tftp.pat
@@ -0,0 +1,20 @@
+# TFTP - Trivial File Transfer Protocol - used for bootstrapping - RFC 1350
+# Pattern attributes: marginal veryfast fast
+# Protocol groups: document_retrieval ietf_internet_standard
+# Wiki: http://www.protocolinfo.org/wiki/TFTP
+#
+# usually runs on port 69
+# 
+# This pattern is unconfirmed. 
+
+tftp
+# The first packet from the initiating host should either be a Read Request 
+# or a Write Request.  In the other direction, it should be data packet with 
+# block number one or an ACK with block number zero.  We only attempt to match
+# the initiating host's packets, because the only identifying features of 
+# the responses to them are two byte sequences (which isn't specific enough).
+# (\x01|\x02) = Read Request or Write Request
+# [ -~]* = the file name
+# the rest = netascii|octet|mail (case insensitivity done by the kernel)
+
+^(\x01|\x02)[ -~]*(netascii|octet|mail)
--- iptables-1.8.x/l7-protocols/untested/unknown.pat
+++ iptables-1.8.x/l7-protocols/untested/unknown.pat
@@ -0,0 +1,7 @@
+# Unknown - Dummy pattern for old unmatched connections.
+
+unknown
+# This pattern is ignored by the kernel.  It sees that the "protocol" is
+# "unknown" and always returns unmatched for connections that are still
+# being tested.
+.
--- iptables-1.8.x/l7-protocols/untested/unset.pat
+++ iptables-1.8.x/l7-protocols/untested/unset.pat
@@ -0,0 +1,8 @@
+# Unset - Dummy pattern for unmatched connections that are still being tested
+
+unset
+# This pattern is ignored by the kernel.  It sees that the "protocol" is
+# "testing" and always returns matched for connections that are still
+# being tested.
+# NOT YET IMPLEMENTED.
+.
--- iptables-1.8.x/l7-protocols/untested/uucp.pat
+++ iptables-1.8.x/l7-protocols/untested/uucp.pat
@@ -0,0 +1,11 @@
+# UUCP - Unix to Unix Copy
+# Pattern attributes: ok veryfast fast
+# Protocol groups: document_retrieval obsolete
+# Wiki: http://www.protocolinfo.org/wiki/UUCP
+
+# This is completely untested!  (I don't know how to use UUCP...)
+
+# See http://docs.freebsd.org/info/uucp/uucp.info.The_Initial_Handshake.html
+
+uucp
+^\x10here=
--- iptables-1.8.x/l7-protocols/untested/zmaap.pat
+++ iptables-1.8.x/l7-protocols/untested/zmaap.pat
@@ -0,0 +1,17 @@
+# ZMAAP - Zeroconf Multicast Address Allocation Protocol
+# Pattern attributes: ok veryfast fast
+# Protocol groups: networking ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/ZMAAP
+#
+# http://files.zeroconf.org/draft-ietf-zeroconf-zmaap-02.txt
+# (Note that this reference is an Internet-Draft, and therefore must
+# be considered a work in progress.)
+#
+# This pattern is untested!
+
+zmaap
+# - 4 byte magic number.
+# - 1 byte version. Allow 1 & 2, even though only version 1 currently exists.
+# - 1 byte message type,which is either 0 or 1
+# - 1 byte address family.  L7-filter only works in IPv4, so this is 1.
+^\x1b\xd7\x3b\x48[\x01\x02]\x01?\x01
--- iptables-1.8.x/l7-protocols/validcertssl.pat
+++ iptables-1.8.x/l7-protocols/validcertssl.pat
@@ -0,0 +1,24 @@
+# Valid Cert. SSL - Valid certificate SSL 
+# Pattern attributes: good notsofast notsofast subset
+# Protocol groups: secure ietf_proposed_standard
+# Wiki: http://www.protocolinfo.org/wiki/SSL
+
+# This matches anything claiming to use a valid certificate from a well 
+# known certificate authority.
+#
+# This is a subset of ssl, so it needs to come first to match.
+#
+# Note that opening a website that has a valid certificate will 
+# open one connection that matches this and many ssl connections that
+# only match the ssl pattern.  Thus, this pattern may not be very useful.
+#
+# This pattern is believed match only the above, but may not match all
+# of it.
+#
+# the certificate authority info is sent in quasi plain text, if it matches 
+# a well known certificate authority then we will assume it is a 
+# web/imaps/etc server. Other ssl may be good too, but it should fall under 
+# a different rule
+
+validcertssl
+^(.?.?\x16\x03.*\x16\x03|.?.?\x01\x03\x01?.*\x0b).*(thawte|equifax secure|rsa data security, inc|verisign, inc|gte cybertrust root|entrust\.net limited)
--- iptables-1.8.x/l7-protocols/ventrilo.pat
+++ iptables-1.8.x/l7-protocols/ventrilo.pat
@@ -0,0 +1,17 @@
+# Ventrilo - VoIP - http://ventrilo.com
+# Pattern attributes: good fast fast
+# Protocol groups: voip proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Ventrilo
+#
+# I have tested this with Ventrilo client 2.3.0 on Windows talking to
+# Ventrilo server 2.3.1 (the public version) on Linux.  I've done this
+# both within a LAN and over the Internet.  In one test, I tried
+# monkeying around with the server settings to see if I could break the
+# pattern, and I couldn't.  However, you can't change the port number in
+# the public server. 
+#
+# It has also been tested by one other person in an unknown configuration.
+
+ventrilo
+^..?v\$\xcf
+
--- iptables-1.8.x/l7-protocols/vnc.pat
+++ iptables-1.8.x/l7-protocols/vnc.pat
@@ -0,0 +1,22 @@
+# VNC - Virtual Network Computing.  Also known as RFB - Remote Frame Buffer
+# Pattern attributes: great veryfast fast
+# Protocol groups: remote_access
+# Wiki: http://www.protocolinfo.org/wiki/VNC
+#
+# http://www.realvnc.com/documentation.html
+# 
+# This pattern has been verified with vnc v3.3.7 on WinXP and Linux
+#
+# Thanks to Trevor Paskett <tpaskett AT cymphonix.com> for this pattern.
+
+vnc
+# Assumes single digit major and minor version numbers 
+# This message should be all alone in the first packet, so ^$ is appropriate
+^rfb 00[1-9]\.00[0-9]\x0a$
+
+# This is a more restrictive version which assumes the version numbers
+# are ones actually in existance at the time of this writing, i.e. 3.3,
+# 3.7 and 3.8 (with some clients wrongly reporting 3.5).  It should be
+# slightly faster, but probably not worth the extra maintenance. 
+# ^rfb 003\.00[3578]\x0a$
+
--- iptables-1.8.x/l7-protocols/whois.pat
+++ iptables-1.8.x/l7-protocols/whois.pat
@@ -0,0 +1,13 @@
+# Whois - query/response system, usually used for domain name info - RFC 3912
+# Pattern attributes: good notsofast notsofast overmatch
+# Protocol groups: networking ietf_draft_standard
+# Wiki: http://www.protocolinfo.org/wiki/Whois
+#
+# Usually runs on TCP port 43
+# 
+# This pattern has been tested and is believed to work well.
+
+whois
+# Matches the query.  Assumes only that it is printable ASCII without wierd
+# whitespace.
+^[ !-~]+\x0d\x0a$
--- iptables-1.8.x/l7-protocols/worldofwarcraft.pat
+++ iptables-1.8.x/l7-protocols/worldofwarcraft.pat
@@ -0,0 +1,65 @@
+# World of Warcraft - popular network game - http://blizzard.com/
+# Pattern attributes: ok veryfast fast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/World_of_Warcraft
+
+worldofwarcraft
+^\x06\xec\x01
+
+# Quoth the author of this pattern, Weisskopf Beat <weisb AT bfh.ch>:
+
+# I have written a pattern for wow (tested with versions 1.8.3 and
+# 1.8.4, german edition). It does not match the login as i think this is
+# uncritical, but i have added the necessary info later on. So only the
+# actual in-game traffic is matched.
+#
+# I hope the pattern is specific enough, otherwise one may add some
+# bytes from the response.
+#
+# some captured info:
+#
+# login:
+#
+# 0000:  00 02 28 00 57 6F 57 00 01 08 03 C7 12 36 38 78  ..(.WoW......68x
+# 0010:  00 6E 69 57 00 45 44 65 64 3C 00 00 00 C0 A8 01  .niW.EDed<......
+# 0020:  22 0A 42 57 45 49 53 53 4B 4F 50 46              ".BWEISSKOPF
+#
+# 0000:  00 02 28 00 57 6F 57 00 01 08 03 C7 12 36 38 78  ..(.WoW......68x
+# 0010:  00 6E 69 57 00 45 44 65 64 3C 00 00 00 C0 A8 01  .niW.EDed<......
+# 0020:  22 0A 42 57 45 49 53 53 4B 4F 50 46              ".BWEISSKOPF
+#
+# server asking:
+#
+# #1
+# 0000:  00 06 EC 01 04 49 C5 33                          .....I.3
+#
+# #2
+# 0000:  00 06 EC 01 C3 A8 6E 63                          ......nc
+#
+# client response
+# #1
+# 0000:  00 A4 ED 01 00 00 C7 12 00 00 00 00 00 00 42 57  ..............BW
+# 0010:  45 49 53 53 4B 4F 50 46 00 EB 35 DC 89 5A CA 6D  EISSKOPF..5..Z.m
+# 0020:  17 95 DE 5B 74 6E 1E 5D 23 73 C6 8F 27 9F 11 12  ...[tn.]#s..'...
+# 0030:  BB 21 01 00 00 78 9C 75 CC 41 0A 83 50 0C 84 E1  .!...x.u.A..P...
+# 0040:  E7 3D 7A 19 75 25 D4 4D AB EB 12 5E A2 0C 8D 51  .=z.u%.M...^...Q
+# 0050:  D2 57 04 4F DF 2E 2D A4 B3 FD 86 3F A5 EF 1A C5  .W.O..-....?....
+# 0060:  71 90 F3 A3 7E E7 82 D5 C6 2E 55 CB 7E B9 FE 58  q...~.....U.~..X
+# 0070:  43 A5 A8 4C 10 E5 1E 86 85 B6 E8 04 63 D8 1C 06  C..L........c...
+# 0080:  5A A7 A9 84 D2 D9 6B 93 1C 5B 4F D9 D7 50 6E 04  Z.....k..[O..Pn.
+# 0090:  0E 61 20 15 8B 6B 83 13 CB FD 09 D5 7F 0C 13 3F  .a ..k.........?
+# 00A0:  DB 07 B4 EA 54 F8                                ....T.
+#
+# #2
+# 0000:  00 A4 ED 01 00 00 C7 12 00 00 00 00 00 00 42 57  ..............BW
+# 0010:  45 49 53 53 4B 4F 50 46 00 38 4C B5 95 C3 AD 25  EISSKOPF.8L....%
+# 0020:  CB 73 48 BD 82 FC 99 63 59 AC BF F3 D0 C6 8D AB  .sH....cY.......
+# 0030:  3D 21 01 00 00 78 9C 75 CC 41 0A 83 50 0C 84 E1  =!...x.u.A..P...
+# 0040:  E7 3D 7A 19 75 25 D4 4D AB EB 12 5E A2 0C 8D 51  .=z.u%.M...^...Q
+# 0050:  D2 57 04 4F DF 2E 2D A4 B3 FD 86 3F A5 EF 1A C5  .W.O..-....?....
+# 0060:  71 90 F3 A3 7E E7 82 D5 C6 2E 55 CB 7E B9 FE 58  q...~.....U.~..X
+# 0070:  43 A5 A8 4C 10 E5 1E 86 85 B6 E8 04 63 D8 1C 06  C..L........c...
+# 0080:  5A A7 A9 84 D2 D9 6B 93 1C 5B 4F D9 D7 50 6E 04  Z.....k..[O..Pn.
+# 0090:  0E 61 20 15 8B 6B 83 13 CB FD 09 D5 7F 0C 13 3F  .a ..k.........?
+# 00A0:  DB 07 B4 EA 54 F8                                ....T.
+
--- iptables-1.8.x/l7-protocols/x11.pat
+++ iptables-1.8.x/l7-protocols/x11.pat
@@ -0,0 +1,22 @@
+# X Windows Version 11 - Networked GUI system used in most Unices
+# Pattern attributes: good notsofast fast
+# Protocol groups: remote_access x_consortium_standard
+# Wiki: http://www.protocolinfo.org/wiki/X11
+#
+# It is common for X to be tunneled through SSH.  Then obviously this pattern
+# will not catch it.
+#
+# Specification: http://www.msu.edu/~huntharo/xwin/docs/xwindows/PROTO.pdf
+# Usually runs on port 6000 (6001 for the second server on a host, etc)
+#
+# This pattern has been tested.
+
+x11
+# 'l' = little-endian.  'B' = big endian
+# ".?" is for the unused byte that comes next.  If it's a null, it won't appear.
+# \x0b = protocol-major-version 11.
+# For some reason, protocol-minor-version is 0, not 6, so can't match it.
+# This pattern is too general. 
+^[lb].?\x0b
+userspace pattern=^[lB].?\x0b
+userspace flags=REG_NOSUB
--- iptables-1.8.x/l7-protocols/xboxlive.pat
+++ iptables-1.8.x/l7-protocols/xboxlive.pat
@@ -0,0 +1,40 @@
+# XBox Live - Console gaming
+# pattern attributes: marginal slow notsofast
+# Protocol groups: game proprietary
+# Wiki: http://www.protocolinfo.org/wiki/XBox_Live
+#
+# This may match all XBox traffic, or may only match Halo 2 traffic.  
+# We don't know yet.
+#
+# Thanks to Myles Uyema <mylesuyema AT gmail DOT com>, who says:
+#
+# Analyzing packet traces using Ethereal, the Xbox typically connects
+# to remote users using UDP port 3074.  The first frame is typically
+# a 156 byte UDP payload.  I've only scrutinized the first 20 or so bytes.
+#
+# Each line below represents the first frame between my Xbox and a remote
+# player's IP address playing Halo2 on Xbox Live.
+#
+# 00 00 00 00 00 58 80 00 00 00 00 00 82 31 9e a8 05 0f c5 62 00 f3 96 08
+# 00 00 00 00 00 58 80 00 00 00 00 00 82 31 9e a8 0f 0f c5 62 00 f3 97 09
+# 00 00 00 00 00 58 80 00 00 00 00 00 82 31 9e a8 05 0f c5 62 00 f3 95 07
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 87 ea 59 aa 11 ff 89 00 f3 bc 07
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 87 ea 59 aa 11 ff 89 00 f3 be 09
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 87 ea 59 aa 11 ff 89 00 f3 bf 0a
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 87 ea 59 aa 11 ff 89 00 f3 bd 08
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 87 ea 59 aa 11 ff 89 00 f3 ba 05
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 87 ea 59 aa 11 ff 89 00 f3 bb 06
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 7f dd 14 f2 8e a3 a1 00 f3 ca 06
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 7f dd 14 f2 8e a3 a1 00 f3 cc 08
+# 00 00 00 00 00 58 80 00 00 00 00 00 81 7f dd 14 f2 8e a3 a1 00 f3 c9 05
+# 00 00 00 00 00 58 80 00 00 00 00 00 8b ca 5b c0 d8 9c f8 c3 00 f3 d4 0a
+# 00 00 00 00 00 58 80 00 00 00 00 00 8b ca 5b c0 d8 9c f3 c3 00 f3 d1 07
+# 00 00 00 00 00 58 80 00 00 00 00 00 8b ca 5b c0 d8 9c f8 c3 00 f3 d2 08
+# 00 00 00 00 00 58 80 00 00 00 00 00 8b ca 5b c0 d8 9c f8 c3 00 f3 cf 05
+# 00 00 00 00 06 58 4e 00 00 00 e6 d9 6e ab 65 0d 63 9f 02 00 00 02 80 dd
+# 00 00 00 00 06 58 4e 00 00 00 46 e2 95 74 cd f9 bc 3d 00 00 00 00 8b ca
+# 00 00 00 00 06 58 4e 00 00 00 cf ce 3b 5c f5 f2 49 9a 00 00 00 00 8b ca
+# 00 00 00 00 06 58 4e 00 00 00 a9 c0 ac c5 16 e5 c9 92 00 00 00 00 8b ca
+
+xboxlive
+^\x58\x80........\xf3|^\x06\x58\x4e
--- iptables-1.8.x/l7-protocols/xunlei.pat
+++ iptables-1.8.x/l7-protocols/xunlei.pat
@@ -0,0 +1,14 @@
+# Xunlei - Chinese P2P filesharing - http://xunlei.com
+# Pattern attributes: good veryfast fast
+# Protocol groups: p2p
+# Wiki: http://www.protocolinfo.org/wiki/Xunlei
+#
+# This has been tested by three people.  It definitely catches some
+# streams. 
+#
+# Written by wsgtrsys of www.routerclub.com.  Improved by VeNoMouS.
+# Improved more by wsgtrsys and platinum of bbs.chinaunix.net.
+
+xunlei
+^[()]...?.?.?(reg|get|query)
+
--- iptables-1.8.x/l7-protocols/yahoo.pat
+++ iptables-1.8.x/l7-protocols/yahoo.pat
@@ -0,0 +1,26 @@
+# Yahoo messenger - an instant messenger protocol - http://yahoo.com
+# Pattern attributes: good fast fast
+# Protocol groups: chat proprietary
+# Wiki: http://www.protocolinfo.org/wiki/Yahoo_Messenger
+#
+# Usually runs on port 5050 
+#
+# This pattern has been tested and is believed to work well. 
+
+yahoo
+# http://www.venkydude.com/articles/yahoo.htm says: 
+# All Yahoo commands start with YMSG.  
+# (Well... http://ethereal.com/faq.html#q5.32 suggests that YPNS and YHOO
+# are also possible, so let's allow those)
+# The next 7 bytes contain command (packet?) length and version information
+# which we won't currently try to match.
+# L means "YAHOO_SERVICE_VERIFY" according to Ethereal
+# W means "encryption challenge command" (YAHOO_SERVICE_AUTH)
+# T means "login command" (YAHOO_SERVICE_AUTHRESP)
+# (there are others, i.e. 0x01 "coming online", 0x02 "going offline",
+# 0x04 "changing status to available", 0x06 "user message", but W and T
+# should appear in the first few packets.)
+# 0xC080 is the standard argument separator, it should appear not long
+# after the "type of command" byte.
+
+^(ymsg|ypns|yhoo).?.?.?.?.?.?.?[lwt].*\xc0\x80
--- iptables-1.8.x/include/linux/netfilter/xt_IMQ.h
+++ iptables-1.8.x/include/linux/netfilter/xt_IMQ.h
@@ -0,0 +1,9 @@
+#ifndef _XT_IMQ_H
+#define _XT_IMQ_H
+
+struct xt_imq_info {
+	unsigned int todev; /* target imq device */
+};
+
+#endif /* _XT_IMQ_H */
+
