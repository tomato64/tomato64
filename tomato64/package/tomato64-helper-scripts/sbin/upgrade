#!/bin/sh

. /usr/sbin/nvram_ops

if [ $# -eq 0 ]; then
	echo "missing .tzst file argument"
	exit
fi

mount -o remount,rw,async,nobarrier /
result=$?
if [ "$result" -ne 0 ]; then
	printf 'error code "%d", unable to mount the filesystem as read/write' "$result"
	exit
fi

# Define directories to clean
CLEANUP_DIRS="/bin /sbin /lib /libexec /usr/bin /usr/sbin /usr/lib /usr/libexec /usr/share /boot /rom /www"

# Create list of files on disk BEFORE extraction (excluding /lib/modules/*)
DISK_FILES=$(mktemp)
for dir in $CLEANUP_DIRS; do
	if [ -d "$dir" ]; then
		find "$dir" \( -type f -o -type l \) ! -path "*/modules/*"
	fi
done | sed 's|^/||' | sort > "$DISK_FILES"

# Extract archive and output list to file
ARCHIVE_LIST=$(mktemp)
tar --warning=no-timestamp -I "zstd -f" -xvf $1 -C / 2>&1 > "$ARCHIVE_LIST"
result=$?

if [ "$result" -ne 0 ]; then
	printf 'error code "%d" returned during extraction' "$result"
	rm -f "$ARCHIVE_LIST" "$DISK_FILES"
	exit
fi

# Filter archive list to CLEANUP_DIRS, remove leading ./, and exclude directories
ARCHIVE_FILTERED=$(mktemp)
for dir in $CLEANUP_DIRS; do
	# Remove leading / from dir for pattern matching
	dirpattern="${dir#/}"
	grep "^\./${dirpattern}/" "$ARCHIVE_LIST"
done | grep -v "/modules/" | grep -v '/$' | sed 's|^\./||' | sort > "$ARCHIVE_FILTERED"

# Find files in DISK_FILES but not in ARCHIVE_FILTERED using comm
TO_DELETE=$(mktemp)
comm -23 "$DISK_FILES" "$ARCHIVE_FILTERED" > "$TO_DELETE"

# Delete files that weren't in the archive
while read -r filepath; do
	[ -n "$filepath" ] && rm -f "/$filepath" 2>/dev/null
done < "$TO_DELETE"

# Remove empty directories
for dir in $CLEANUP_DIRS; do
	if [ -d "$dir" ]; then
		find "$dir" -mindepth 1 -type d -empty -delete 2>/dev/null
	fi
done

# x86_64
if [ -f /boot/bzImage ] && [ "$(NG "t_model_name")" == "x86_64" ]; then
	kernel=`file -bL /boot/bzImage  | sed 's/.*version //;s/ .*//'`
	for dir in /lib/modules/*; do
		[ "$dir" = "/lib/modules/$kernel" ] && continue
		rm -rf "$dir"
	done
	printf "image successfully flashed\n"
fi

# GL-MT6000
if [ -f /boot/glinet_gl-mt6000-kernel.bin ] && [ "$(NG "t_model_name")" == "GL.iNet GL-MT6000" ]; then

	export EMMC_KERNEL_BLOCKS=$(($(dd if=/boot/glinet_gl-mt6000-kernel.bin of=/dev/mmcblk0p6 bs=512 2>&1 | grep "records out" | cut -d' ' -f1)))

	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel write' "$result"
		exit
	fi

	dd if=/dev/zero of=/dev/mmcblk0p6 bs=512 seek=$EMMC_KERNEL_BLOCKS count=8 >/dev/null 2>&1

	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel padding write' "$result"
		exit
	fi

	kernel=$(strings /boot/glinet_gl-mt6000-kernel.bin | grep -i "Linux-" | awk '{print $3}' | sed "s/.*-//")
	for dir in /lib/modules/*; do
		[ "$dir" = "/lib/modules/$kernel" ] && continue
		rm -rf "$dir"
	done
	printf "image successfully flashed\n"
fi

# BPI-R3
if [ -f /boot/tomato64-bananapi_bpi-r3-sysupgrade.itb ] && [ "$(NG "t_model_name")" == "Banana Pi BPI-R3" ]; then

	export EMMC_KERNEL_BLOCKS=$(($(dd if=/boot/tomato64-bananapi_bpi-r3-sysupgrade.itb of=/dev/mmcblk0p5 bs=512 2>&1 | grep "records out" | cut -d' ' -f1)))

	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel write' "$result"
		exit
	fi

	dd if=/dev/zero of=/dev/mmcblk0p5 bs=512 seek=$EMMC_KERNEL_BLOCKS count=8 >/dev/null 2>&1

	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel padding write' "$result"
		exit
	fi

	kernel=$(strings /boot/tomato64-bananapi_bpi-r3-sysupgrade.itb | grep -i "Linux-" | awk '{print $3}' | sed "s/.*-//")
	for dir in /lib/modules/*; do
		[ "$dir" = "/lib/modules/$kernel" ] && continue
		rm -rf "$dir"
	done
	printf "image successfully flashed\n"
fi

# BPI-R3 Mini
if [ -f /boot/tomato64-bpi-r3-mini-sysupgrade.itb ] && [ "$(NG "t_model_name")" == "Banana Pi BPI-R3 Mini" ]; then

	export EMMC_KERNEL_BLOCKS=$(($(dd if=/boot/tomato64-bpi-r3-mini-sysupgrade.itb of=/dev/mmcblk0p4 bs=512 2>&1 | grep "records out" | cut -d' ' -f1)))

	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel write' "$result"
		exit
	fi

	dd if=/dev/zero of=/dev/mmcblk0p4 bs=512 seek=$EMMC_KERNEL_BLOCKS count=8 >/dev/null 2>&1

	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel padding write' "$result"
		exit
	fi

	kernel=$(strings /boot/tomato64-bpi-r3-mini-sysupgrade.itb | grep -i "Linux-" | awk '{print $3}' | sed "s/.*-//")
	for dir in /lib/modules/*; do
		[ "$dir" = "/lib/modules/$kernel" ] && continue
		rm -rf "$dir"
	done
	printf "image successfully flashed\n"
fi

# Raspberry PI 4-B
if [ -f /boot/bcm2711-rpi-4-b.dtb ] && [ "$(NG "t_model_name")" == "Raspberry Pi 4 Model B" ]; then
	mount -t vfat /dev/mmcblk0p1 /mnt
	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during mounting boot partition' "$result"
		exit
	fi
	cp -ar /boot/* /mnt
	sync
	umount /mnt

	kernel=$(strings /boot/Image |grep -m 1 "Linux version " | awk '{print $3}')
	for dir in /lib/modules/*; do
		[ "$dir" = "/lib/modules/$kernel" ] && continue
		rm -rf "$dir"
	done
	printf "image successfully flashed\n"
fi

# NanoPi R6S
if [ -f /boot/friendlyarm_nanopi-r6s-kernel.bin ] && [ "$(NG "t_model_name")" == "FriendlyElec NanoPi R6S" ]; then
	ROOT_DEV=$(findmnt -n -o SOURCE /)
	BOOT_DISK=$(echo "$ROOT_DEV" | sed 's|/dev/||; s|p[0-9]*$||')

	# Update kernel partition (p1) - ext4 filesystem containing kernel.img and boot.scr
	MOUNT_POINT=$(mktemp -d)
	mount -t ext4 /dev/${BOOT_DISK}p1 "$MOUNT_POINT"
	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during mounting kernel partition' "$result"
		rmdir "$MOUNT_POINT"
		exit
	fi
	cp /boot/friendlyarm_nanopi-r6s-kernel.bin "$MOUNT_POINT/kernel.img"
	result=$?
	if [ "$result" -ne 0 ]; then
		printf 'error code "%d" returned during kernel copy' "$result"
		umount "$MOUNT_POINT"
		rmdir "$MOUNT_POINT"
		exit
	fi
	sync
	umount "$MOUNT_POINT"
	rmdir "$MOUNT_POINT"

	# Clean old kernel modules
	kernel=$(strings /boot/friendlyarm_nanopi-r6s-kernel.bin | grep -m 1 "Linux version " | awk '{print $3}')
	for dir in /lib/modules/*; do
		[ "$dir" = "/lib/modules/$kernel" ] && continue
		rm -rf "$dir"
	done
	printf "image successfully flashed\n"
fi

sync
