#!/bin/sh
export PATH=/bin:/usr/bin:/sbin:/usr/sbin:/home/root
#
# Copyright (C) 2015 shibby
#
# changes/fixes: 2018 - 2026 by pedro
# https://freshtomato.org/
#


. nvram_ops

PID=$$
PIDFILE="/var/run/mwwatchdog.pid"
IPLISTFILE="/tmp/mwwatchdog.iplist"
IPLIST=""
MWAN=$(NG mwan_num)
MWANTABLE="wan"
LOGI="logger -t mwwatchdog[$PID]"
LOGE="logger -p ERROR -t mwwatchdog[$PID]"
LOGW="logger -p WARN -t mwwatchdog[$PID]"
LOGD=$([ "$(NG mwwatchdog_debug)" -gt 0 ] 2>/dev/null && echo "logger -p DEBUG -t mwwatchdog[$PID]" || echo "echo")


i=1
while [ $i -le $MWAN ]; do
	[ "$i" -gt 1 ] && MWANTABLE="$MWANTABLE wan$i"
	i=$((i+1))
done

timeout() {
	local cmd_pid sleep_pid retval
	(shift; "$@") &
	cmd_pid=$!
	(sleep "$1"; kill "$cmd_pid" 2>/dev/null) &
	sleep_pid=$!
	wait "$cmd_pid"
	retval=$?
	kill "$sleep_pid" 2>/dev/null
	return "$retval"
}

findHost() {
	local host ip dst hostlist
	dst=$(NG mwan_ckdst)
	hostlist=$(echo "$dst" | sed 's/,/ /g')

	IPLIST=""
	for host in $hostlist; do
		if echo "$host" | grep -Eo '((([a-zA-Z]{1,2})|([0-9]{1,2})|([a-zA-Z0-9]{1,2})|([a-zA-Z0-9][a-zA-Z0-9-]{1,61}[a-zA-Z0-9]))\.)+[a-zA-Z]{2,6}' >/dev/null 2>&1; then
			# resolve domain name
			ip=$(nslookup "$host" 2>/dev/null | tail -n +5 | grep -v '::' | awk '{print $3}' | tail -1)
			IPLIST="${IPLIST} $ip"
		else
			# treat as IP address
			IPLIST="${IPLIST} $host"
		fi
	done

	# write result because we're in subshell
	echo "$IPLIST" > "$IPLISTFILE"
}

dhcpFix() {
	dhcpc-release "$1"
	sleep 1
	dhcpc-renew "$1"
}

ifconfigChk() {
	# check if interface has valid IP address
	ret_ifchk=$(ifconfig "$IFACE" 2>/dev/null | grep inet | grep -Eo '((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)' | grep -v '0.0.0.0' | wc -l)
	[ "$ret_ifchk" -eq 0 ] && ret_ifchk=0 || ret_ifchk=1
}

mwwatchdogRun() {
	for PREFIX in $MWANTABLE; do
		IFACE=$(NG "$PREFIX"_iface)
		ISPPPD=$([ -f /tmp/ppp/pppd$PREFIX ] && echo 1 || echo 0)
		WEIGHT=$(NG "$PREFIX"_weight)
		METHOD=$(NG "$PREFIX"_ckmtd)
		PROTO=$(NG "$PREFIX"_proto)
		DEMAND=$(NG "$PREFIX"_ppp_demand)
		RESULT=0
		PREFIX_MWAN=$PREFIX
		PREFIX_LOG="WAN$(echo "$PREFIX"0 | cut -c 4- | tr '234' '123' | cut -c 1)"
		STATE_FILE="/var/lib/misc/${PREFIX}_state"
		local ret_ifchk

		[ "$(NG "$PREFIX"_ck_pause)" -eq 1 ] && {
			$LOGD "MWWatchdog paused for $PREFIX_LOG - skipping ..."
			continue
		}

		[ "$PROTO" != "disabled" ] && {
			[ "$(NG mwan_debug)" -gt 0 ] && {
				ISUP=$(wanuptime "$PREFIX")
				ISGW=$(ip route | grep "$IFACE" | grep -v link | wc -l)
				$LOGD "prefix=$PREFIX_LOG, iface=$IFACE, uptime=$ISUP, ISGW=$ISGW, WEIGHT=$WEIGHT"
			}

			[ "$PROTO" = "dhcp" ] && {
				ifconfigChk
				[ "$ret_ifchk" -eq 0 ] && dhcpFix "$PREFIX" && sleep 3
			}

			[ "$PROTO" != "lte" ] && {
				ifconfigChk
				[ "$ret_ifchk" -eq 0 ] && {
					$LOGD "$PREFIX doesn't have an IP address. Skipping..."
					echo "0" > "$STATE_FILE"
					continue
				}
			}

			# check if interface exists before accessing /sys (safety)
			[ ! -d "/sys/class/net/$IFACE" ] && {
				$LOGD "interface $IFACE does not exist in sysfs. Skipping..."
				echo "0" > "$STATE_FILE"
				continue
			}

			DEFAULT_ROUTE_FRAGMENT=$(ip route | grep default | cut -d' ' -f2-)
			GATEWAY_FRAGMENT="via $(NG "$PREFIX"_gateway)"
			[ "$ISPPPD" -eq 1 ] && GATEWAY_FRAGMENT=""

			# add routes
			for IP in $IPLIST; do
				[ -n "$DEFAULT_ROUTE_FRAGMENT" ] && {
					ROUTE_EXEC="ip route add $IP $DEFAULT_ROUTE_FRAGMENT"
					$LOGD $ROUTE_EXEC
					$ROUTE_EXEC &>/dev/null
				}
				ROUTE_EXEC="ip route add $IP dev $IFACE $GATEWAY_FRAGMENT metric 50000"
				$LOGD $ROUTE_EXEC
				$ROUTE_EXEC &>/dev/null
			done

			$LOGD "start test for: $IFACE ..."
			case "$METHOD" in
				1) ckping ;;
				2) cktracert ;;
# BBT-BEGIN
				*) ckcurl ;;
# BBT-END
			esac

			# remove routes
			for IP in $IPLIST; do
				[ -n "$DEFAULT_ROUTE_FRAGMENT" ] && {
					ROUTE_EXEC="ip route del $IP $DEFAULT_ROUTE_FRAGMENT"
					$LOGD $ROUTE_EXEC
					$ROUTE_EXEC &>/dev/null
				}
				ROUTE_EXEC="ip route del $IP dev $IFACE $GATEWAY_FRAGMENT metric 50000"
				$LOGD $ROUTE_EXEC
				$ROUTE_EXEC &>/dev/null
			done

			# handle WAN down
			if [ "$RESULT" -eq 0 ]; then
				[ "$PROTO" = "lte" ] && {
					$LOGI "Connection $PREFIX_LOG DOWN - Reconnecting ..."
					echo "0" > "$STATE_FILE"
					switch4g "$PREFIX"
				} || {
					[ "$PREFIX" == "wan" -a "$MWAN" -gt 1 ] && PREFIX_MWAN="wan1" # "wan" means restart all WANs, but we only want restart one

					if [ "$(NG action_service)" == "wan-restart" -o "$(NG action_service)" == $PREFIX_MWAN"-restart" -o "$(NG action_service)" == "wan-restart-c" -o "$(NG action_service)" == $PREFIX_MWAN"-restart-c" ]; then
						$LOGI "Connection $PREFIX_LOG DOWN - Reconnect is already in progress ..."
					else
						echo "0" > "$STATE_FILE"

						if [ "$PROTO" == "pppoe" -o "$PROTO" == "pptp" -o "$PROTO" == "l2tp" -o "$PROTO" == "ppp3g" ] && [ "$DEMAND" -eq 1 -a "$ISPPPD" -eq 0 ]; then
							$LOGI "Killing orphaned connect-on-demand listen process ..."
							LISTEN_PID=$(ps | grep '[l]isten' | grep "$PREFIX" | awk '{print $1}' | head -1)
							if [ -n "$LISTEN_PID" ]; then
								kill -9 "$LISTEN_PID" 2>/dev/null
								$LOGI "Killed $LISTEN_PID"
							else
								$LOGI "Connect-on-demand listen not running"
							fi

							$LOGI "Connection $PREFIX_LOG DOWN - Reconnecting ..."
							service "$PREFIX_MWAN" restart
						else
							$LOGI "Connection $PREFIX_LOG DOWN - Reconnect will be handled by another process ..."
						fi
					fi
				}
			else
				# handle WAN up
				[ "$PROTO" == "dhcp" -a "$(cat "$STATE_FILE" 2>/dev/null || echo 1 )" -eq 0 ] && dhcpFix "$PREFIX" # connected + DHCP + previous status - disconnected? release/renew
				$LOGD "Connection $PREFIX_LOG is functioning"
				echo "1" > "$STATE_FILE"
			fi
		}
	done
}

cktracert() {
	local RXBYTES1 RXBYTES2 IP
	# minimum bytes indicating working WAN
	local RXBYTES_MIN_DIFF=$(NG mwan_diff)
	# ensure minimum sensible value
	[ -z "$RXBYTES_MIN_DIFF" ] || [ "$RXBYTES_MIN_DIFF" -lt 100 ] && RXBYTES_MIN_DIFF=100
	# double the value for connections other than LTE and PPP3G
	[ "$PROTO" != "lte" -a "$PROTO" != "ppp3g" ] && RXBYTES_MIN_DIFF=$((RXBYTES_MIN_DIFF*2))

	for IP in $IPLIST; do
		# fallback to 0 on read failure + debug log
		RXBYTES1=$(cat /sys/class/net/$IFACE/statistics/rx_bytes 2>/dev/null || echo 0)
		RXBYTES1=${RXBYTES1:-0}
		[ "$RXBYTES1" = "0" ] && $LOGD "failed to read initial rx_bytes for $IFACE (using 0)"

		traceroute -i "$IFACE" -n -w 1 -m 10 -q 1 -z 1 "$IP" 2>/dev/null
		sleep 1

		RXBYTES2=$(cat /sys/class/net/$IFACE/statistics/rx_bytes 2>/dev/null || echo 0)
		RXBYTES2=${RXBYTES2:-0}
		[ "$RXBYTES2" = "0" ] && $LOGD "failed to read final rx_bytes for $IFACE (using 0)"

		# simple wrap-around handling (for 32-bit counters)
		if [ "$RXBYTES2" -ge "$RXBYTES1" ]; then
			if [ "$((RXBYTES2 - RXBYTES1))" -gt "$RXBYTES_MIN_DIFF" ]; then
				RESULT=1; break
			fi
		else
			# possible wrap-around
			if [ "$((RXBYTES2 + 4294967296 - RXBYTES1))" -gt "$RXBYTES_MIN_DIFF" ]; then
				RESULT=1; break
			fi
		fi
	done

	[ "$RESULT" -gt 0 ] && $LOGD "tracert test result for: $IFACE - OK [transfer: $((RXBYTES2-RXBYTES1))]" || $LOGD "tracert test result for: $IFACE - FAILED! [transfer: $((RXBYTES2-RXBYTES1))]"
}

ckping() {
	local IP i=0

	for IP in $IPLIST; do
		i=$((i+1))
		# 0 means 100% loss - no packages received
		ping -c $((i+1)) -A -W $((i+2)) -q -I "$IFACE" "$IP" >/dev/null 2>&1 && RESULT=$((RESULT+1))
		[ "$RESULT" -gt 0 ] && break
	done

	[ "$RESULT" -gt 0 ] && $LOGD "ping test result for: $IFACE - OK" || $LOGD "ping test result for: $IFACE - FAILED!"
}

# BBT-BEGIN
ckcurl() {
	local IP i=0 target

	for IP in $IPLIST; do
		i=$((i+1))
		# add http:// prefix for better HTTP compatibility; add --max-time and --location
		target="$IP"
		echo "$IP" | grep -qE '^([0-9]{1,3}\.){3}[0-9]{1,3}$' && target="http://$IP"

		curl "$target" --interface "$IFACE" --connect-timeout $((i+3)) --max-time $((i+5)) -ksfIL -o /dev/null 2>/dev/null && RESULT=$((RESULT+1))
		[ "$RESULT" -gt 0 ] && break
		sleep $i
	done

	[ "$RESULT" -gt 0 ] && $LOGD "curl test result for: $IFACE - OK" || $LOGD "curl test result for: $IFACE - FAILED!"
}
# BBT-END

mwwatchdogAdd() {
	local CKTIME=$(NG mwan_cktime)
	local MINS=$((CKTIME/60))

	[ "$MINS" -gt 0 ] && { cru l | grep -q mwwatchdogJob || cru a mwwatchdogJob "*/$MINS * * * * /usr/sbin/mwwatchdog"; }
}

mwwatchdogDel() {
	cru l | grep -q mwwatchdogJob && cru d mwwatchdogJob
}

mwanJob() {
	cru l | grep -q mwanJob && cru d mwanJob || cru a mwanJob "*/1 * * * * /usr/sbin/mwwatchdog alive"
}

mwanAlive() {
	[ "$MWAN" -gt 1 ] && {
		ps | grep -q '[m]wanroute' && $LOGD "mwanroute is running" || {
			$LOGW "mwanroute not found, trying to recover it"
			nohup mwanroute >/dev/null 2>&1 &
		}
	}
}

checkPid() {
	local PIDNO

	if [ -f "$PIDFILE" ]; then
		PIDNO=$(cat "$PIDFILE")
		if kill -0 "$PIDNO" 2>/dev/null; then
			$LOGW "another process in action - exiting ..."
			exit 0
		fi
	fi

	echo $PID > $PIDFILE || {
		$LOGE "could not create PID file"
		exit 0
	}
}

checkPidSwitch() {
	local SPREFIX

	for SPREFIX in $MWANTABLE; do
		if [ -f "/var/run/switch3g_$SPREFIX.pid" ]; then
			if ! ps | grep -q '[s]witch3g'; then
				# PID file exists but process doesn't
				rm "/var/run/switch3g_$SPREFIX.pid" 2>/dev/null
			else
				$LOGW "switch3g ($SPREFIX) script in action - exiting ..."
				rm -f "$PIDFILE" 2>/dev/null
				exit 0
			fi
		fi

		if [ -f "/var/run/switch4g_$SPREFIX.pid" ]; then
			if ! ps | grep -q '[s]witch4g'; then
				# PID file exists but process doesn't
				rm "/var/run/switch4g_$SPREFIX.pid" 2>/dev/null
			else
				$LOGW "switch4g ($SPREFIX) script in action - exiting ..."
				rm -f "$PIDFILE" 2>/dev/null
				exit 0
			fi
		fi
	done
}


###################################################


case "$1" in
	add)
		mwwatchdogAdd
		mwanJob
		;;
	del)
		mwwatchdogDel
		;;
	alive)
		mwanAlive
		;;
	*)
		if [ "$(NG g_upgrade)" != "1" ] && [ "$(NG g_reboot)" != "1" ]; then
			checkPid
			checkPidSwitch
			mwanJob

			# run with a 10 sec timeout to not hang
			timeout 10 findHost
			[ -f "$IPLISTFILE" ] && IPLIST=$(cat "$IPLISTFILE")
			[ -z "$IPLIST" ] && IPLIST="$(NG wan_checker)" # Resilient IP if the list is empty

			# filter out DNS IPs from the list
			BADIPLIST=""
			for IP in $IPLIST; do
				nvram show 2>/dev/null | grep -E '^wan.?_dns=' | cut -f2 -d= | tr '\n' ' ' | grep -Fq "$IP" && BADIPLIST="${BADIPLIST} $IP"
			done

			# remove bad IPs from IPLIST
			if [ -n "$BADIPLIST" ]; then
				IPLIST=$(echo "$IPLIST" | tr ' ' '\n' | grep -vFf <(echo "$BADIPLIST" | tr ' ' '\n') | tr '\n' ' ' | sed 's/ $//')
			fi

			mwwatchdogRun
			[ -f "$IPLISTFILE" ] && rm "$IPLISTFILE"
		fi
		;;
esac

rm -f "$PIDFILE" 2>/dev/null
