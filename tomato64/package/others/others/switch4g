#!/bin/sh
export PATH=/bin:/usr/bin:/sbin:/usr/sbin:/home/root
#
# Copyright (C) 2015 shibby
#
# - changes/fixes
# - add support for rndis protocol
# Copyright (C) 2018 - 2025 by pedro
# https://freshtomato.org/
#


. nvram_ops

PREFIX="$1"

PID=$$
PIDFILE="/var/run/switch4g_$PREFIX.pid"
READYFILE="/tmp/switch4g_$PREFIX.ready"
DIAGSFILE="/tmp/switch4g_$PREFIX.diags"
STATEFILE="/var/lib/misc/$PREFIX_state"
PATHDIAG="/sys/bus/usb/devices"
PATHWAN="/sys/class/net"
MODE=$(NG "$PREFIX"_proto)
COUNT_KILL=0
LOGI="logger -t switch4g[$PID]"
LOGE="logger -p ERROR -t switch4g[$PID]"
LOGW="logger -p WARN -t switch4g[$PID]"


[ -z "$PREFIX" ] && {
	echo "usage: $0 INTERFACE [connect|disconnect|signal|reset]"
	exit 0
}

[ "$MODE" != "lte" ] && exit 0


getSpeedText() {
	case "$1" in
		00)     echo "Auto" ;;
		03)     echo "4G only" ;;
		02)     echo "3G only" ;;
		0302)   echo "4G/3G only" ;;
		030201) echo "4G/3G/2G" ;;
		*)      echo "unknown" ;;
	esac
}

getRoamText() {
	case "$1" in
		0) echo "Disabled" ;;
		1) echo "Supported" ;;
		2) echo "No change" ;;
		3) echo "Roam only" ;;
		*) echo "unknown" ;;
	esac
}

getBandText() {
	case "$1" in
		80000)            echo "B20 (800 MHz)" ;;
		80)               echo "B8 (900 MHz)" ;;
		4)                echo "B3 (1800 MHz)" ;;
		1)                echo "B1 (2100 MHz)" ;;
		40)               echo "B7 (2600 MHz)" ;;
		7FFFFFFFFFFFFFFF) echo "All supported" ;;
		*)                echo "unknown" ;;
	esac
}

connect() {
	MTYPE=$(NG "$PREFIX"_modem_type)
	DEVNR=$(NG "$PREFIX"_modem_dev)
	APN=$(NG "$PREFIX"_modem_apn)
	SPEED=$(NG "$PREFIX"_modem_speed)
	BAND=$(NG "$PREFIX"_modem_band)
	ROAMING=$(NG "$PREFIX"_modem_roam)
	IFA=$(NG "$PREFIX"_ifname)
	local DEVALL SYSCFGEX CGPADDR TXTLOG MODESPEED MODEROAM MODEBAND CONNECTED=0 COUNT=1 DONE=0 i
	local SPEEDTXT ROAMTXT BANDTXT RESSPEED RSPEEDTXT RESROAM RROAMTXT RESBAND RBANDTXT

	# check if DIAG interface required for certain modem types
	case "$MTYPE" in
		non-hilink|huawei-non-hilink|hw-ether|qmi_wwan)
			[ -n "$DEVNR" ] || wayOut "4G MODEM - DIAG interface not found: connection terminated!"
		;;
	esac

	$LOGI "4G MODEM - connecting ..."

	# non-hilink/1st type
	if [ "$MTYPE" = "non-hilink" ] || [ "$MTYPE" = "huawei-non-hilink" ] || [ "$MTYPE" = "hw-ether" ]; then
		SPEEDTXT=$(getSpeedText "$SPEED")
		ROAMTXT=$(getRoamText "$ROAMING")
		BANDTXT=$(getBandText "$BAND")

		# Build device list to try (primary and secondary DIAG interfaces)
		DEVALL="$DEVNR $(cat "$DIAGSFILE" | sed "s~"$DEVNR"~~")"
		DEVALL="$DEVALL $DEVALL $DEVALL" # try 3x on every interface

		while [ "$CONNECTED" -eq 0 ]; do
			for i in $DEVALL; do
				# disconnect first
				MODE="AT^NDISDUP=1,0" gcom -d "$i" -s /etc/gcom/setmode.gcom >/dev/null
				sleep 2

				# check for current network type
				SYSCFGEX=$(MODE="AT^SYSCFGEX?" gcom -d "$i" -s /etc/gcom/setverbose.gcom)
				RESSPEED=$(echo "$SYSCFGEX" | grep SYSCFGEX | grep '"' | cut -d '"' -f2)
				RESROAM=$(echo "$SYSCFGEX" | grep SYSCFGEX | grep ',' | cut -d ',' -f3)
				RESBAND=$(echo "$SYSCFGEX" | grep SYSCFGEX | grep ',' | cut -d ',' -f5 | tr -d '\r')

				RSPEEDTXT=$(getSpeedText "$RESSPEED")
				RROAMTXT=$(getRoamText "$RESROAM")
				RBANDTXT=$(getBandText "$RESBAND")

				# build log message and determine if config change needed
				TXTLOG="Network type is '$RSPEEDTXT'."
				MODESPEED=$RESSPEED
				MODEROAM=$RESROAM
				MODEBAND=$RESBAND

				[ "$SPEED" != "$RESSPEED" ] && {
					TXTLOG="Network type changed: was '$RSPEEDTXT', now '$SPEEDTXT'."
					MODESPEED=$SPEED
				}

				TXTLOG="$TXTLOG Roaming is '$RROAMTXT'."
				[ "$ROAMING" != "$RESROAM" ] && {
					TXTLOG="$TXTLOG Roaming changed: was '$RROAMTXT', now '$ROAMTXT'."
					MODEROAM=$ROAMING
				}

				TXTLOG="$TXTLOG Band is '$RBANDTXT'"
				[ "$SPEED" = "03" ] && [ "$BAND" != "$RESBAND" ] && {
					TXTLOG="$TXTLOG Band changed: was '$RBANDTXT', now '$BANDTXT'"
					MODEBAND=$BAND
				}

				$LOGI "4G MODEM - $TXTLOG (device $i)"

				# apply configuration changes if needed
				if [ "$SPEED" != "$RESSPEED" ] || [ "$ROAMING" != "$RESROAM" ] || ([ "$SPEED" = "03" ] && [ "$BAND" != "$RESBAND" ]) ; then
					MODE="AT^SYSCFGEX=\"$MODESPEED\",3fffffff,$MODEROAM,4,$MODEBAND,," gcom -d "$i" -s /etc/gcom/setverbose.gcom >/dev/null
					sleep 3
				fi

				# connect
				MODE="AT^NDISDUP=1,1,\"$APN\"" gcom -d "$i" -s /etc/gcom/setverbose.gcom >/dev/null
				sleep 2

				CGPADDR=$(MODE="AT+CGPADDR=1" gcom -d "$i" -s /etc/gcom/setverbose.gcom)

				if [ "$(echo "$CGPADDR" | grep "+CGPADDR:" | wc -l)" -eq 1 ]; then
					$LOGI "4G MODEM - connected (device $i) ..."
					CONNECTED=1
					[ "$(NG "$PREFIX"_modem_dev)" != "$i" ] && {
						NS "$PREFIX"_modem_dev="$i"
						NC
					}
					break
				else
					$LOGI "4G MODEM - connection failed (device $i) [$COUNT] ..."
					COUNT=$((COUNT+1))
					sleep 3
				fi
			done

			# still not connected?
			if [ "$CONNECTED" -eq 0 ]; then
				disconnect
				if [ "$(NG mwan_cktime)" -gt 0 ]; then
					modemReset
					mwwatchdog add
					wayOut "4G MODEM - connection failed: mwwatchdog enabled"
				else
					mwwatchdog del
					wayOut "4G MODEM - connection failed: process terminated!"
				fi
			fi
		done

	# non-hilink/2nd type
	elif [ "$MTYPE" = "qmi_wwan" ]; then
		local DATAFORMAT TIMEOUT=30 TIMECOUNT=0 CONNSTAT REGISTRATION_STATE=""
		# for feature use
		local AUTOCONNECT="" PROFILE="" AUTH="" USERNAME="" PASSWORD=""

		case "$SPEED" in
		     00)   SPEEDTXT="all" ;;
		     03)   SPEEDTXT="lte" ;;
		     02)   SPEEDTXT="umts,cdma" ;;
		     0302) SPEEDTXT="lte,umts,cdma" ;;
		     030201) SPEEDTXT="lte,umts,cdma,gsm" ;;
		     *)    SPEEDTXT="all" ;;
		esac

		case "$ROAMING" in
		     0)  ROAMTXT="off"  ;;
		     1)  ROAMTXT="any"  ;;
		     3)  ROAMTXT="only" ;;
		     *)  ROAMTXT="any"  ;;
		esac

		# devices need timeout, otherwise they hang
		sleep 6

		# try to clear previous autoconnect state
		uqmiCall "-t 1000 --stop-network 0xffffffff --autoconnect"
		uqmiCall "-t 1000 --set-ip-family ipv6 --stop-network 0xffffffff --autoconnect"

		# go online
		uqmiCall "-t 1000 --set-device-operating-mode online"

		# set IP format
		uqmiCall "-t 1000 --set-data-format 802.3"
		uqmiCall "-t 1000 --wda-set-data-format 802.3"
		DATAFORMAT=$(uqmiCall "-t 1000 --wda-get-data-format")

		if [ "$DATAFORMAT" = '"raw-ip"' ]; then
			[ -f $PATHWAN/$IFA/qmi/raw_ip ] || wayOut "Device only supports raw-ip mode but is missing this required driver attribute: $PATHWAN/$IFA/qmi/raw_ip"

			$LOGI "4G MODEM - device does not support 802.3 mode. Informing driver of raw-ip only for $IFA ..."
			echo "Y" > $PATHWAN/$IFA/qmi/raw_ip
		fi

		uqmiCall "-t 1000 --sync"
		uqmiCall "-t 20000 --network-register"

		# set network type (all,lte,umts,cdma,td-scdma)
		uqmiCall "-t 1000 --set-network-modes $SPEEDTXT"
		$LOGI "4G MODEM - network type is set to '$SPEEDTXT'"
		sleep 3

		# scan network to not rely on registration-timeout after RAT change
		uqmiCall "--network-scan"
		sleep 3

		# set roaming
		uqmiCall "-t 1000 --set-network-roaming $ROAMTXT"
		$LOGI "4G MODEM - roaming is set to '$ROAMTXT'"

		$LOGI "4G MODEM - waiting for network registration ..."
		sleep 5

		while true; do
			REGISTRATION_STATE=$(echo "$(uqmiCall "-t 1000 --get-serving-system")" | grep -o '"registration":"[^"]*"' | cut -d'"' -f4)

			[ "$REGISTRATION_STATE" = "registered" ] && break

			if [ "$REGISTRATION_STATE" = "searching" ] || [ "$REGISTRATION_STATE" = "not_registered" ]; then
				if [ "$TIMECOUNT" -lt "$TIMEOUT" ]; then
					[ "$REGISTRATION_STATE" = "searching" ] || {
						$LOGI "4G MODEM - device stopped network registration. Restart network registration"
						uqmiCall "-t 20000 --network-register"
					}
					TIMECOUNT=$((TIMECOUNT+1))
					sleep 1
					continue
				fi
				wayOut "4G MODEM - network registration failed, registration timeout reached"
			else
				# REGISTRATION_STATE is 'registration_denied' or 'unknown' or ''
				wayOut "4G MODEM - network registration failed (reason: '$REGISTRATION_STATE')"
			fi
		done

		$LOGI "4G MODEM - starting network $IFA"

		# get client id for wds
		CLID=$(uqmiCall "-t 1000 --get-client-id wds")

		[ $? -ne 0 ] && wayOut "4G MODEM - unable to obtain client ID!"

		NS "$PREFIX"_modem_clid="$CLID"
		$LOGI "4G MODEM - got new client ID: $CLID"

		# only IPv4 for now
		uqmiCall "-t 5000 --set-client-id wds,$CLID --set-ip-family ipv4"

		while [ "$CONNECTED" -eq 0 ]; do
			if [ "$COUNT" -lt 6 ]; then
				# connect
				PDH=$(uqmiCall "-t 5000 --set-client-id wds,$CLID --start-network" 1)

				case $PDH in
				     ''|*[!0-9]*)
						$LOGW "4G MODEM - connection failed: (device $DEVNR) session ID: $PDH [$COUNT] ..."
						COUNT=$((COUNT+1))
						sleep 5
					;;
				     *)
						$LOGI "4G MODEM - connected (device $DEVNR) session ID: $PDH"
						NS "$PREFIX"_modem_pdh="$PDH"
						CONNECTED=1
						break
					;;
				esac
			else
				# checked 5 times but still not connected?
				uqmiCall "-t 5000 --set-client-id wds,$CLID --release-client-id wds"

				if [ "$(NG mwan_cktime)" -gt 0 ]; then
					modemReset
					mwwatchdog add
					wayOut "4G MODEM - connection failed: mwwatchdog enabled"
				else
					mwwatchdog del
					wayOut "4G MODEM - connection failed: process terminated!"
				fi
			fi
		done

		# check data connection state
		CONNSTAT=$(uqmiCall "-t 1000 --get-data-status")
		[ "$CONNSTAT" = '"connected"' ] || {
			uqmiCall "-t 5000 --set-client-id wds,$CLID --release-client-id wds"

			if [ "$(NG mwan_cktime)" -gt 0 ]; then
				modemReset
				mwwatchdog add
				wayOut "4G MODEM - no data link: mwwatchdog enabled"
			else
				mwwatchdog del
				wayOut "4G MODEM - no data link: process terminated!"
			fi
		}
	fi
	# endif (non-hilink/type)

	COUNT=1

	while [ "$DONE" -eq 0 ] && [ "$COUNT" -lt 6 ]; do
		dhcpc-release $PREFIX
		sleep 1
		dhcpc-renew $PREFIX
		sleep 1

		# is IF up?
		if ifconfig "$IFA" &>/dev/null; then
			# IF has an IP address assigned?
			if ifconfig "$IFA" | grep -q 'inet addr'; then
				$LOGI "4G MODEM - WAN IFACE configured ($IFA)"
				DONE=1
				break
			else
				# TODO: IP is up only every 2nd attempt - temporary fix
				dhcpc-release $PREFIX
				sleep 1
				dhcpc-renew $PREFIX
			fi
		else
			$LOGI "4G MODEM - WAN IFACE not ready ($IFA) [$COUNT] ..."
			COUNT=$((COUNT+1))
			sleep 2
		fi
	done

	[ "$DONE" -eq 0 ] && {
		if [ "$(NG mwan_cktime)" -gt 0 ]; then
			mwwatchdog add
			wayOut "4G MODEM - WAN IFACE failed: mwwatchdog enabled"
		else
			mwwatchdog del
			wayOut "4G MODEM - WAN IFACE failed: connection process terminated!"
		fi
	}

	echo "1" > $STATEFILE
	mwwatchdog add
}

disconnect() {
	MTYPE=$(NG "$PREFIX"_modem_type)
	DEVNR=$(NG "$PREFIX"_modem_dev)
	CLID=$(NG "$PREFIX"_modem_clid)
	PDH=$(NG "$PREFIX"_modem_pdh)
	local DEVALL j

	$LOGI "4G MODEM - disconnecting ..."
	mwwatchdog del
	dhcpc-release $PREFIX

	case "$MTYPE" in
		non-hilink|huawei-non-hilink|hw-ether)
			DEVALL="$DEVNR $(cat "$DIAGSFILE" | sed "s~"$DEVNR"~~")"

			for j in $DEVALL; do # on every interface
				MODE="AT^NDISDUP=1,0" gcom -d "$j" -s /etc/gcom/setmode.gcom >/dev/null
				sleep 2
			done
		;;
		qmi_wwan)
			[ -n "$CLID" ] || return
			uqmiCall "-t 5000 --set-client-id wds,$CLID --stop-network 0xffffffff --autoconnect"

			[ -n "$PDH" ] && uqmiCall "-t 5000 --set-client-id wds,$CLID --stop-network $PDH"

			uqmiCall "-t 5000 --set-client-id wds,$CLID --release-client-id wds"
			NS "$PREFIX"_modem_pdh=""
			NS "$PREFIX"_modem_clid=""

			$LOGI "4G MODEM - release Client ID: $CLID"
		;;
	esac

	$LOGI "4G MODEM - disconnected"
}

switchMode() {
	VENDOR="" PRODUCT="" MTYPE="" MODULE="" DEVICENAME="" SWITCHED=0 # global
# BCMARM-BEGIN
	MODULES="qmi_wwan cdc_ether huawei_cdc_ncm cdc_ncm rndis_host"
# BCMARM-END
# BCMARMNO-BEGIN
	MODULES="qmi_wwan cdc_ether huawei_ether cdc_ncm rndis_host"
# BCMARMNO-END

	# first remove modules
	for MODULE in $MODULES; do
		modprobe -r $MODULE
	done

	$LOGI "4G MODEM - detecting ..."

	switchMe

	[ "$SWITCHED" -eq 0 ] && $LOGI "4G MODEM - not found in USB_ModeSwitch database, already switched? Loading modules..."
}

switchMe() {
	local COUNT=1 DVDP=0 PATHDEV SWITCH DEVICES IFN_BEFORE DV DP DB DG

	# detect modem
	DEVICES=$(lsusb | awk '{print $6}')

	for SWITCH in $DEVICES; do
		[ "$(ls /etc/usb_modeswitch.d/"$SWITCH" 2>/dev/null | wc -l)" -eq 1 ] && {
			# search for devicename & other data
			for DEVICENAME in $(ls "$PATHDIAG"/ | grep -v ":" | grep "-"); do
				PATHDEV="$PATHDIAG/$DEVICENAME"
				[ -f $PATHDEV/idVendor ] && [ -f $PATHDEV/idProduct ] && [ -f $PATHDEV/uevent ] || continue # skip

				DV=$(cat "$PATHDEV"/idVendor 2>/dev/null)			# vendor
				DP=$(cat "$PATHDEV"/idProduct 2>/dev/null)			# product
				DB=$(grep -s ^BUSNUM "$PATHDEV"/uevent | cut -d "=" -f2)	# BUSNUM
				DG=$(grep -s ^DEVNUM "$PATHDEV"/uevent | cut -d "=" -f2)	# DEVNUM

				[ "$DV" = "$(echo "$SWITCH" | cut -d ":" -f1)" ] && [ "$DP" = "$(echo "$SWITCH" | cut -d ":" -f2)" ] && { # self
					DVDP=1
					break
				}
			done

			[ "$DVDP" -eq 1 ] && {
				# in some cases it needs more time
				COUNT=1
				while [ "$COUNT" -lt 10 ]; do
					sleep 1
					[ -s $PATHDEV/bNumInterfaces ] && {
						IFN_BEFORE=$(cat "$PATHDEV"/bNumInterfaces)
						break
					}
					COUNT=$((COUNT+1))
				done

				$LOGI "4G MODEM FOUND - $SWITCH: switching ..."

				/usr/sbin/usb_modeswitch -Q -c /etc/usb_modeswitch.d/$SWITCH -v $DV -p $DP -b $DB -g $DG

				# need few seconds before modem will be detected once again after switch
				COUNT=1
				while [ "$COUNT" -lt 20 ]; do
					sleep 1
					[ -s $PATHDEV/bNumInterfaces ] && {
						[ "$(cat "$PATHDEV"/bNumInterfaces)" -gt "$IFN_BEFORE" ] && break
					}
					COUNT=$((COUNT+1))
				done
				sleep 1

				VENDOR=$(cat /etc/usb_modeswitch.d/"$SWITCH" | grep TargetVendor | cut -d "=" -f2 | cut -d "x" -f2)
				[ -z "$VENDOR" ] && VENDOR=$(cat "$PATHDEV"/idVendor 2>/dev/null)

				PRODUCT=$(cat "$PATHDEV"/idProduct 2>/dev/null)
				[ -n "$PRODUCT" ] && {
					$LOGI "4G MODEM - ready: $VENDOR:$PRODUCT"
					SWITCHED=1
					break
				}
			}
		}
	done
}

searchWAN() {
	# search WAN interface (usbX, ethX, wwanX)
	WAN="" WANS="" # global
	local FOUND=0 MODULE

	for MODULE in $MODULES; do
		modprobe $MODULE
		sleep 1

		# check if interface is up
		for WAN in $(ls $PATHWAN/ | grep -e eth -e usb -e wwan); do
			[ -f $PATHWAN/$WAN/uevent ] && [ -f $PATHWAN/$WAN/device/uevent ] || continue

			# check if interface has our MODULE
			[ "$(grep -s ^DRIVER $PATHWAN/$WAN/device/uevent | cut -d "=" -f2)" = "$MODULE" ] && {
				WANS="$WANS $WAN:$(ls $PATHWAN/$WAN/device/ | grep usb | cut -d ":" -f2)"
				$LOGI "4G MODEM - found WAN(s): $WANS"
				FOUND=1
			}
		done
		[ "$FOUND" -eq 1 ] && break

		$LOGI "4G MODEM - WAN ($MODULE) not found ..."
		modprobe -r $MODULE
		sleep 1
	done

	if [ "$FOUND" -eq 1 ]; then
		findType # MODULE --> MTYPE

		NS "$PREFIX"_ifname="$WAN"
		NS "$PREFIX"_modem_type="$MTYPE"
		$LOGI "4G MODEM - WAN ($MTYPE) found: using $MODULE module and $WAN as WAN"
	else
		if [ "$(NG mwan_cktime)" -gt 0 ]; then
			mwwatchdog add
			wayOut "4G MODEM - WAN not found: mwwatchdog enabled"
		else
			mwwatchdog del
			wayOut "4G MODEM - WAN not found: connection process terminated!"
		fi
	fi
}

isDiag() {
	TTYS=$(ls -d $PATHDIAG/$DEVICENAME/${DEVICENAME}*/tty?* 2>/dev/null | sed -e "s/.*\\/\\//.*/g" -e "s/.*\\//\\/dev\\//g" | tr "\n" " " | sed -e "s/  */ /g" -e "s,^ *,,; s, *$,,")
}

searchDiag() {
	DEVNR=""
	local TTYS="" UQMIRET="" UQMIPID=""
	local PATHDEV WAN IFACE TTY

	[ -z "$DEVICENAME" ] && DEVICENAME=$(ls -d $PATHWAN/$WAN/device/driver/*[0-9-:\.] 2>/dev/null | tr "\n" " " | sed -e "s/.*\\/\\//.*/g" -e "s/.*\\///g" -e "s/:.*//g")
	[ -z "$VENDOR" ] && VENDOR=$(cat "$PATHDIAG"/"$DEVICENAME"/idVendor 2>/dev/null)
	[ -z "$PRODUCT" ] && PRODUCT=$(cat "$PATHDIAG"/"$DEVICENAME"/idProduct 2>/dev/null)

	case "$MTYPE" in
		non-hilink|huawei-non-hilink|hw-ether)
			isDiag # --> TTYS

			if [ -z "$TTYS" ]; then
				if [ "$(lsmod | grep usbserial | wc -l)" -gt 0 ] && [ -n "$VENDOR" ] && [ -n "$PRODUCT" ]; then
					$LOGI "4G MODEM - add ($VENDOR:$PRODUCT) to already loaded usbserial module"
					echo "$VENDOR $PRODUCT" > /sys/bus/usb-serial/drivers/generic/new_id
				elif [ -n "$VENDOR" ] && [ -n "$PRODUCT" ]; then
					$LOGI "4G MODEM - loading usbserial module ($VENDOR:$PRODUCT)"
					insmod usbserial vendor=0x$VENDOR product=0x$PRODUCT
				else
					# VENDOR/PRODUCT unknown, so try for every possible device...
					for DEVICENAME in $(ls "$PATHDIAG"/ | grep -v ":" | grep "-"); do
						PATHDEV="$PATHDIAG/$DEVICENAME"
						[ -f $PATHDEV/idVendor ] && [ -f $PATHDEV/idProduct ] && [ -f $PATHDEV/uevent ] || continue # skip

						VENDOR=$(cat "$PATHDEV"/idVendor 2>/dev/null)	# vendor
						PRODUCT=$(cat "$PATHDEV"/idProduct 2>/dev/null)	# product
						$LOGI "4G MODEM - try to load usbserial module ($VENDOR:$PRODUCT) for device $DEVICENAME ..."

						modprobe -r usbserial
						insmod usbserial vendor=0x$VENDOR product=0x$PRODUCT
						sleep 1
						isDiag # --> TTYS
						[ -n "$TTYS" ] && {
							# found
							$LOGI "4G MODEM - found: using usbserial module"
							break
						}
					done
				fi
				sleep 1

				isDiag # --> TTYS
			fi

			if [ -n "$TTYS" ]; then
				$LOGI "4G MODEM - ready: DIAG(s) found ($TTYS)"
				echo $TTYS > $DIAGSFILE
				DEVNR=$(echo "$TTYS" | cut -d " " -f1)
				NS "$PREFIX"_modem_dev="$DEVNR"
				NS "$PREFIX"_modem_devicename="$DEVICENAME"
			fi
		;;
		qmi_wwan)
			TTYS=$(ls -d $PATHDIAG/$DEVICENAME/${DEVICENAME}*/usb:cdc-wdm?* 2>/dev/null | sed -e "s/.*\\/\\//.*/g" -e "s/.*://g")

			if [ -n "$TTYS" ]; then
				$LOGI "4G MODEM - DIAG(s) found ($TTYS)"

				for TTY in $TTYS; do
					DEVNR="/dev/$TTY"
					uqmiCall "-t 3000 --get-capabilities" 2 # in a background
					sleep 2

					UQMIPID=$(ps | grep [g]et-capabilities | awk '{print $1}')
					# hangs?
					if [ -n "$UQMIPID" ]; then
						kill -9 $UQMIPID
						sleep 2
						DEVNR=""
					# it works
					else
						# check which WWAN is the working one (if more than one diag is found)
						for WAN in $WANS; do
							IFACE=$(echo $WAN | cut -d ":" -f1)
							[ "/dev/$(echo $WAN | cut -d ":" -f2)" = "$DEVNR" ] && {
								$LOGI "4G MODEM - setting/updating WAN: $IFACE"
								NS "$PREFIX"_ifname="$IFACE"
							}
						done

						# final check
						UQMIRET=$(uqmiCall "-t 3000 --get-capabilities")
						case "$UQMIRET" in
						     *data_service*) break ;;
						esac
					fi
				done

				TTYS=""
				if [ -n "$DEVNR" ]; then
					TTYS="$DEVNR"
					echo $TTYS > $DIAGSFILE
					$LOGI "4G MODEM - ready: working DIAG is ($TTYS)"
					NS "$PREFIX"_modem_dev="$TTYS"
					NS "$PREFIX"_modem_devicename="$DEVICENAME"
				fi
			fi
		;;
	esac

	if [ -z "$TTYS" ]; then
		if [ "$(NG mwan_cktime)" -gt 0 ]; then
			mwwatchdog add
			modemReset
			wayOut "4G MODEM - DIAG(s) not found: mwwatchdog enabled"
		else
			mwwatchdog del
			wayOut "4G MODEM - DIAG(s) not found: connection process terminated!"
		fi
	fi
}

findType() {
	case "$MODULE" in
		cdc_ether)        MTYPE="hilink" ;;
		cdc_ncm)          MTYPE="non-hilink" ;;
		huawei_cdc_ncm)   MTYPE="huawei-non-hilink" ;;
		huawei_ether)     MTYPE="hw-ether" ;;
		qmi_wwan)         MTYPE="qmi_wwan" ;;
		rndis_host)       MTYPE="rndis_host" ;;
		*)                MTYPE="unknown" ;;
	esac
}

modemReset() {
	# TODO: reset should also be performed if the connection fails X times at any given time
	local DNAME=$(NG "$PREFIX"_modem_devicename)

	$LOGI "4G MODEM - resetting the modem $DNAME ..."

	rm -f $READYFILE &>/dev/null

	echo 0 > "$PATHDIAG"/"$DNAME"/authorized
	sleep 1
	echo 1 > "$PATHDIAG"/"$DNAME"/authorized
}

setPIN() {
	local PIN=$(NG "$PREFIX"_modem_pin)
	local IS_DONE=0 COUNT=1 PIN_STATUS PIN_VERIFY_TRIES PIN_EXT_STATUS=0 PINVAL STATUS

	$LOGI "4G MODEM - waiting for SIM initialization"

	[ -n "$DEVNR" ] || wayOut "4G MODEM - DIAG interface not found!"

	case "$MTYPE" in
		non-hilink|huawei-non-hilink|hw-ether)
			MODE="AT+CFUN=1" gcom -d "$DEVNR" -s /etc/gcom/setverbose.gcom >/dev/null  # set as online mode (default value)
			STATUS=$(MODE="AT^CPIN?" gcom -d "$DEVNR" -s /etc/gcom/setverbose.gcom) # extended PIN status (ie. Huawei modems)
			if [ -z "$(echo "$STATUS" | grep OK)" ] || [ -n "$(echo "$STATUS" | grep ERR)" ]; then # error?
				COUNT=1
				while [ "$COUNT" -lt 4 ]; do # try 3 times
					STATUS=$(MODE="AT+CPIN?" gcom -d "$DEVNR" -s /etc/gcom/setverbose.gcom) # std PIN status

					if [ -z "$(echo "$STATUS" | grep OK)" ] || [ -n "$(echo "$STATUS" | grep ERR)" ]; then # error?
						COUNT=$((COUNT+1))
						sleep 1
					else
						break
					fi
				done
				[ -n "$PIN" ] && [ "$COUNT" -ge 3 ] && wayOut "4G MODEM - Error reading SIM status!"

				PIN_STATUS=$(echo "$STATUS" | grep CPIN: | cut -d ":" -f2 | awk '{$1=$1};1')
			else
				PIN_EXT_STATUS=1
				PIN_STATUS=$(echo "$STATUS" | grep CPIN: | cut -d ":" -f2 | awk '{$1=$1};1' | cut -d "," -f1)
				PIN_VERIFY_TRIES=$(echo "$STATUS" | grep CPIN: | cut -d "," -f4)
			fi

			# verify pin
			case "$PIN_STATUS" in
				"READY" | $'READY\r')
					$LOGI "4G MODEM - PIN verification is not required"
					IS_DONE=1
				;;
				"SIM PUK")
					wayOut "4G MODEM - SIM locked PUK required"
				;;
				"SIM PIN" | "SIM PIN2")
					[ "$PIN_EXT_STATUS" -eq 1 ] && [ "$PIN_VERIFY_TRIES" -lt 3 ] && wayOut "4G MODEM - PIN verify count value is $PIN_VERIFY_TRIES this is below the limit of 3"
					if [ -n "$PIN" ]; then
						PINVAL=$(MODE="AT+CPIN=\"$PIN\"" gcom -d "$DEVNR" -s /etc/gcom/setverbose.gcom)
						[ -z "$(echo "$PINVAL" | grep OK)" ] || [ -n "$(echo "$PINVAL" | grep ERR)" ] && wayOut "4G MODEM - Unable to verify PIN"
						IS_DONE=1
					else
						wayOut "4G MODEM - PIN not specified but required"
					fi
				;;
				*)
					wayOut "4G MODEM - PIN status failed (${PIN_STATUS:-sim_not_present})"
				;;
			esac
		;;
		qmi_wwan)
			# timeout 3s for first call to avoid hanging uqmi
			uqmiCall "-t 3000 --get-pin-status"

			while uqmiCall "-t 1000 --get-pin-status" | grep '"UIM uninitialized"'; do
				[ -n "$DEVNR" ] || wayOut "4G MODEM - DIAG interface not found!"

				if [ "$COUNT" -lt 30 ]; then
					COUNT=$((COUNT+1))
					sleep 1
				else
					wayOut "4G MODEM - SIM not initialized!"
				fi
			done

			# check if UIM application is stuck in illegal state
			COUNT=1
			while true; do
				STATUS=$(uqmiCall "-t 2000 --uim-get-sim-state" | cut -d "," -f2 | cut -d ":" -f2 | tr -d '"')

				# SIM card is either completely absent or state is labeled as illegal
				# try to power-cycle the SIM card to recover from this state
				if [ -z "$STATUS" ] || [ "$STATUS" = "illegal" ]; then
					$LOGI "4G MODEM - SIM in illegal state: Power-cycling SIM"

					# try to reset SIM application
					uqmiCall "-t 1000 --uim-power-off --uim-slot 1"
					sleep 3
					uqmiCall "-t 1000 --uim-power-on --uim-slot 1"

					if [ "$COUNT" -lt 10 ]; then
						COUNT=$((COUNT+1))
						sleep 5
						continue
					fi

					# recovery failed
					wayOut "4G MODEM - SIM recovery failed!"
				else
					break
				fi
			done

			# verify pin
			if uqmiCall "-t 1000 --uim-get-sim-state" | grep -q '"Not supported"\|"Invalid QMI command"' && uqmiCall "-t 1000 --get-pin-status" | grep -q '"Not supported"\|"Invalid QMI command"'; then
				[ -n "$PIN" ] && {
					uqmiCall "-t 1000 --verify-pin1 $PIN" || uqmiCall "-t 1000 --uim-verify-pin1 $PIN" || wayOut "4G MODEM - Unable to verify PIN!"
					IS_DONE=1
				}
			else
				STATUS=$(uqmiCall "-t 1000 --get-pin-status")
				PIN_STATUS=$(echo "$STATUS" | cut -d "," -f1 | cut -d ":" -f2 | tr -d '"')
				PIN_VERIFY_TRIES=$(echo "$STATUS" | cut -d "," -f2 | cut -d ":" -f2)

				[ -z "$PIN_STATUS" ] && {
					STATUS=$(uqmiCall "-t 1000 --uim-get-sim-state")
					PIN_STATUS=$(echo "$STATUS" | cut -d "," -f3 | cut -d ":" -f2 | tr -d '"')
					PIN_VERIFY_TRIES=$(echo "$STATUS" | cut -d "," -f4 | cut -d ":" -f2)
				}

				case "$PIN_STATUS" in
					disabled)
						$LOGI "4G MODEM - PIN verification is disabled"
						IS_DONE=1
					;;
					blocked)
						wayOut "4G MODEM - SIM locked PUK required"
					;;
					not_verified)
						[ "$PIN_VERIFY_TRIES" -lt 3 ] && wayOut "4G MODEM - PIN verify count value is $PIN_VERIFY_TRIES this is below the limit of 3"
						if [ -n "$PIN" ]; then
							uqmiCall "-t 1000 --verify-pin1 $PIN" || uqmiCall "-t 1000 --uim-verify-pin1 $PIN" || wayOut "4G MODEM - Unable to verify PIN"
							IS_DONE=1
						else
							wayOut "4G MODEM - PIN not specified but required"
						fi
					;;
					verified)
						$LOGI "4G MODEM - PIN already verified"
						IS_DONE=1
					;;
					*)
						wayOut "4G MODEM - PIN status failed (${PIN_STATUS:-sim_not_present})"
					;;
				esac
			fi
		;;
	esac

	if [ "$IS_DONE" -ne 1 ]; then
		mwwatchdog del
		wayOut "4G MODEM - SIM locked: connection process terminated!"
	else
		$LOGI "4G MODEM - SIM ready"
	fi
}

uqmiCall() {
	# for now, it's the only way to prevent uqmi hangups on two different calls at the same time and on the same device: https://forum.openwrt.org/viewtopic.php?id=63559
	# OPTION: 1 - connect, 2 - background, no option - normal use
	local COUNT=1 COMMAND="$1" OPTION="$2"
	[ -z "$OPTION" ] && OPTION=0

	# wait for other uqmi process(es) to exit...
	while [ "$COUNT" -lt 10 ]; do
		ps | grep [u]qmi || {
			if [ "$OPTION" -eq 1 ]; then
				uqmi -s -d "$DEVNR" $COMMAND \
					${APN:+--apn "$APN"} \
					${PROFILE:+--profile $PROFILE} \
					${AUTH:+--auth-type $AUTH} \
					${USERNAME:+--username $USERNAME} \
					${PASSWORD:+--password $PASSWORD} \
					${AUTOCONNECT:+--autoconnect}
				return
			elif [ "$OPTION" -eq 2 ]; then
				uqmi -s -d "$DEVNR" $COMMAND 1>/dev/null &
				return
			else
				uqmi -s -d "$DEVNR" $COMMAND
				return
			fi
		}
		COUNT=$((COUNT+1))
		sleep 1
	done

	# after 10 seconds, kill process(es) (only one try per running script)
	if [ "$COUNT_KILL" -eq 0 ]; then
		uqmiKill $COMMAND $OPTION
	else
		wayOut "4G MODEM - uqmi hangs again: exiting!"
	fi
}

uqmiKill() {
	local C="$1" O="$2" UQMIPID="" i

	UQMIPID=$(ps | grep [u]qmi | awk '{print $1}')
	if [ -n "$UQMIPID" ]; then
		for i in $UQMIPID; do
			$LOGW "4G MODEM - found another uqmi process (PID: $i), killing ..."
			kill -9 $UQMIPID
			sleep 2
		done

		# try once again
		COUNT_KILL=1
		uqmiCall $C $O
	fi
}

checkPid() {
	local PRIORITY="$1" PIDNO

	if [ -f "$PIDFILE" ]; then
		PIDNO=$(cat "$PIDFILE")
		if kill -0 "$PIDNO" 2>/dev/null; then
			$LOGW "4G MODEM - another process in action - exiting"
			exit 0
		fi
	fi

	[ "$PRIORITY" -eq 0 ] && return

	echo $PID > $PIDFILE || {
		$LOGE "4G MODEM - could not create PID file"
		exit 0
	}
}

wayOut() {
	$LOGE "${1:-4 Modem - exiting}"
	rm -f $READYFILE 2>/dev/null
	rm -f $PIDFILE 2>/dev/null
	exit 0
}


###################################################


case "$2" in
	connect)
		checkPid 1
		connect
	;;
	disconnect)
		checkPid 0
		disconnect
	;;
	reset)
		checkPid 0
		modemReset
	;;
	signal)
		wwansignal $PREFIX
		exit
	;;
	*)
		checkPid 1

		# modem not yet detected
		[ ! -f $READYFILE ] && {
			switchMode
			searchWAN

			# only for non-hilink
			case "$MTYPE" in
				non-hilink|huawei-non-hilink|hw-ether|qmi_wwan)
					searchDiag
					setPIN
				;;
			esac
		}

		connect
	;;
esac

rm -f $PIDFILE 2>/dev/null
