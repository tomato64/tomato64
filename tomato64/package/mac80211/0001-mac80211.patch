From ab6468650282964e833771a0daf65859275364e1 Mon Sep 17 00:00:00 2001
From: lancethepants <lancethepants@gmail.com>
Date: Fri, 6 Sep 2024 09:22:45 -0600
Subject: [PATCH] mac80211

---
 Kconfig.local                                 | 111 ---
 Kconfig.sources                               |   5 -
 Makefile                                      | 115 +--
 Makefile.kernel                               |   4 -
 Makefile.real                                 |  29 +-
 .../linux/bcma/bcma_driver_chipcommon.h       |  10 +
 backport-include/linux/iommu.h                |  23 +
 backport-include/linux/list.h                 |   2 +-
 backport-include/linux/of_net.h               |  26 -
 backport-include/linux/random.h               |   2 +-
 backport-include/net/dropreason.h             |   3 +-
 compat/main.c                                 |  25 -
 compat_version                                |   1 +
 drivers/net/wireless/ath/Kconfig              |   5 +-
 drivers/net/wireless/ath/Makefile             |   2 +-
 drivers/net/wireless/ath/ath.h                |   7 -
 drivers/net/wireless/ath/ath10k/Kconfig       |  12 +
 drivers/net/wireless/ath/ath10k/Makefile      |   3 +-
 drivers/net/wireless/ath/ath10k/core.c        |  45 +
 drivers/net/wireless/ath/ath10k/core.h        |  12 +
 drivers/net/wireless/ath/ath10k/htt.h         |   4 +
 drivers/net/wireless/ath/ath10k/hw.h          |   1 +
 drivers/net/wireless/ath/ath10k/leds.c        |  90 ++
 drivers/net/wireless/ath/ath10k/leds.h        |  34 +
 drivers/net/wireless/ath/ath10k/mac.c         |  66 +-
 drivers/net/wireless/ath/ath10k/pci.c         |  16 +
 drivers/net/wireless/ath/ath10k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath10k/wmi-ops.h     |  32 +
 drivers/net/wireless/ath/ath10k/wmi-tlv.c     |   2 +
 drivers/net/wireless/ath/ath10k/wmi.c         |  54 ++
 drivers/net/wireless/ath/ath10k/wmi.h         |  35 +
 drivers/net/wireless/ath/ath11k/Kconfig       |  13 +-
 drivers/net/wireless/ath/ath11k/Makefile      |   2 +-
 drivers/net/wireless/ath/ath11k/core.c        |  33 +-
 drivers/net/wireless/ath/ath11k/mac.c         |   1 +
 drivers/net/wireless/ath/ath11k/mhi.c         |  49 +-
 drivers/net/wireless/ath/ath11k/mhi.h         |   3 +
 drivers/net/wireless/ath/ath11k/pci.c         |   9 +-
 drivers/net/wireless/ath/ath11k/reg.c         | 201 +----
 drivers/net/wireless/ath/ath11k/reg.h         |   2 +-
 drivers/net/wireless/ath/ath11k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath5k/ath5k.h        |   1 +
 drivers/net/wireless/ath/ath5k/base.c         |   8 +-
 drivers/net/wireless/ath/ath5k/debug.c        |  93 ++
 drivers/net/wireless/ath/ath5k/dma.c          |   8 +
 drivers/net/wireless/ath/ath5k/initvals.c     |   6 +
 drivers/net/wireless/ath/ath5k/mac80211-ops.c |   9 +-
 drivers/net/wireless/ath/ath5k/pci.c          |  28 +-
 drivers/net/wireless/ath/ath5k/reset.c        |   2 +
 drivers/net/wireless/ath/regd.c               |  72 +-
 drivers/net/wireless/ath/regd_common.h        |   3 +
 drivers/net/wireless/broadcom/b43/Kconfig     |  14 +-
 drivers/net/wireless/broadcom/b43/Makefile    |   2 +-
 drivers/net/wireless/broadcom/b43/b43.h       |   3 +
 drivers/net/wireless/broadcom/b43/dma.h       |   2 +-
 drivers/net/wireless/broadcom/b43/main.c      |  86 +-
 drivers/net/wireless/broadcom/b43/pio.h       |  34 +-
 .../net/wireless/broadcom/b43legacy/Kconfig   |   8 +-
 .../net/wireless/broadcom/b43legacy/main.c    |   4 +-
 .../net/wireless/broadcom/brcm80211/Kconfig   |   4 +-
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    |  36 +
 .../broadcom/brcm80211/brcmfmac/common.c      |   4 +
 .../wireless/broadcom/brcm80211/brcmfmac/of.c |  32 +
 .../broadcom/brcm80211/brcmfmac/usb.c         |   4 +
 .../broadcom/brcm80211/brcmsmac/channel.c     |  19 +-
 drivers/net/wireless/intel/iwlwifi/mvm/tt.c   |  10 +
 drivers/net/wireless/marvell/libertas/cfg.c   |   4 +
 drivers/net/wireless/marvell/libertas/main.c  |   1 +
 drivers/net/wireless/marvell/mwifiex/cmdevt.c |  96 ++-
 drivers/net/wireless/marvell/mwifiex/decl.h   |   4 +-
 drivers/net/wireless/marvell/mwifiex/main.h   |   2 +
 .../wireless/marvell/mwifiex/sta_cmdresp.c    |   5 +-
 .../net/wireless/marvell/mwifiex/uap_cmd.c    |   3 +-
 drivers/net/wireless/marvell/mwl8k.c          |   5 +-
 drivers/net/wireless/mediatek/mt7601u/usb.h   |   2 +-
 drivers/net/wireless/ralink/rt2x00/Kconfig    |  23 +-
 drivers/net/wireless/ralink/rt2x00/Makefile   |   1 +
 drivers/net/wireless/ralink/rt2x00/rt2800.h   |   5 +
 .../net/wireless/ralink/rt2x00/rt2800lib.c    | 373 ++++----
 .../net/wireless/ralink/rt2x00/rt2800lib.h    |  24 +
 .../net/wireless/ralink/rt2x00/rt2800pci.c    |   7 +
 .../net/wireless/ralink/rt2x00/rt2800soc.c    |  52 +-
 .../net/wireless/ralink/rt2x00/rt2800usb.c    |   7 +
 drivers/net/wireless/ralink/rt2x00/rt2x00.h   |   9 +
 .../net/wireless/ralink/rt2x00/rt2x00dev.c    |  34 +-
 .../net/wireless/ralink/rt2x00/rt2x00eeprom.c | 208 +++++
 .../net/wireless/ralink/rt2x00/rt2x00leds.c   |   3 +
 .../net/wireless/ralink/rt2x00/rt2x00soc.c    |  16 +
 .../net/wireless/ralink/rt2x00/rt2x00soc.h    |   9 +
 drivers/net/wireless/virtual/mac80211_hwsim.c |  74 +-
 drivers/net/wireless/virtual/mac80211_hwsim.h |   4 +
 drivers/staging/rtl8723bs/Kconfig             |   1 -
 include/linux/ath5k_platform.h                |  30 +
 include/linux/bcma/bcma.h                     | 489 -----------
 include/linux/bcma/bcma_driver_arm_c9.h       |  16 -
 include/linux/bcma/bcma_driver_chipcommon.h   | 722 ----------------
 include/linux/bcma/bcma_driver_gmac_cmn.h     |  95 ---
 include/linux/bcma/bcma_driver_mips.h         |  45 -
 include/linux/bcma/bcma_driver_pci.h          | 264 ------
 include/linux/bcma/bcma_driver_pcie2.h        | 159 ----
 include/linux/bcma/bcma_regs.h                | 104 ---
 include/linux/bcma/bcma_soc.h                 |  17 -
 include/linux/mhi.h                           | 801 ------------------
 include/linux/rt2x00_platform.h               |  23 +
 include/linux/ssb/ssb.h                       | 682 ---------------
 include/linux/ssb/ssb_driver_chipcommon.h     | 672 ---------------
 include/linux/ssb/ssb_driver_extif.h          | 258 ------
 include/linux/ssb/ssb_driver_gige.h           | 194 -----
 include/linux/ssb/ssb_driver_mips.h           |  71 --
 include/linux/ssb/ssb_driver_pci.h            | 131 ---
 include/linux/ssb/ssb_embedded.h              |  19 -
 include/linux/ssb/ssb_regs.h                  | 687 ---------------
 include/net/cfg80211.h                        |  60 +-
 include/net/mac80211.h                        |   8 +-
 include/uapi/linux/nl80211.h                  |  65 ++
 kconf/Makefile                                |   6 +-
 kconf/conf.c                                  |  46 +-
 kconf/confdata.c                              |   4 +-
 local-symbols                                 |  50 +-
 local-symbols.orig                            | 475 +++++++++++
 net/mac80211/cfg.c                            |  15 +-
 net/mac80211/chan.c                           | 215 +++--
 net/mac80211/debugfs.c                        |  13 +-
 net/mac80211/ibss.c                           |   2 +-
 net/mac80211/ieee80211_i.h                    |   9 +-
 net/mac80211/iface.c                          |  10 +-
 net/mac80211/main.c                           |  69 +-
 net/mac80211/rc80211_minstrel_ht.c            |  75 +-
 net/mac80211/rc80211_minstrel_ht.h            |   2 +-
 net/mac80211/sta_info.c                       |  29 +-
 net/mac80211/sta_info.h                       |   3 +-
 net/mac80211/status.c                         |   5 +-
 net/mac80211/tx.c                             |  63 +-
 net/mac80211/util.c                           | 147 ++--
 net/mac80211/wpa.c                            |  12 +-
 net/wireless/ap.c                             |   6 +-
 net/wireless/chan.c                           |  45 +
 net/wireless/core.c                           |  15 -
 net/wireless/core.h                           |   2 +
 net/wireless/mlme.c                           |   7 +-
 net/wireless/nl80211.c                        | 212 +++--
 net/wireless/rdev-ops.h                       |  12 +
 net/wireless/reg.c                            |   3 +
 net/wireless/sysfs.c                          |  31 +-
 net/wireless/util.c                           |  68 +-
 145 files changed, 3208 insertions(+), 6612 deletions(-)
 create mode 100644 backport-include/linux/bcma/bcma_driver_chipcommon.h
 create mode 100644 backport-include/linux/iommu.h
 delete mode 100644 backport-include/linux/of_net.h
 create mode 100644 compat_version
 create mode 100644 drivers/net/wireless/ath/ath10k/leds.c
 create mode 100644 drivers/net/wireless/ath/ath10k/leds.h
 create mode 100644 drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
 create mode 100644 include/linux/ath5k_platform.h
 delete mode 100644 include/linux/bcma/bcma.h
 delete mode 100644 include/linux/bcma/bcma_driver_arm_c9.h
 delete mode 100644 include/linux/bcma/bcma_driver_chipcommon.h
 delete mode 100644 include/linux/bcma/bcma_driver_gmac_cmn.h
 delete mode 100644 include/linux/bcma/bcma_driver_mips.h
 delete mode 100644 include/linux/bcma/bcma_driver_pci.h
 delete mode 100644 include/linux/bcma/bcma_driver_pcie2.h
 delete mode 100644 include/linux/bcma/bcma_regs.h
 delete mode 100644 include/linux/bcma/bcma_soc.h
 delete mode 100644 include/linux/mhi.h
 create mode 100644 include/linux/rt2x00_platform.h
 delete mode 100644 include/linux/ssb/ssb.h
 delete mode 100644 include/linux/ssb/ssb_driver_chipcommon.h
 delete mode 100644 include/linux/ssb/ssb_driver_extif.h
 delete mode 100644 include/linux/ssb/ssb_driver_gige.h
 delete mode 100644 include/linux/ssb/ssb_driver_mips.h
 delete mode 100644 include/linux/ssb/ssb_driver_pci.h
 delete mode 100644 include/linux/ssb/ssb_embedded.h
 delete mode 100644 include/linux/ssb/ssb_regs.h
 create mode 100644 local-symbols.orig

diff --git a/Kconfig.local b/Kconfig.local
index c5cfed5..78bac06 100644
--- a/Kconfig.local
+++ b/Kconfig.local
@@ -1417,117 +1417,6 @@ config BACKPORTED_USB_NET_AQC111
 config BACKPORTED_USB_RTL8153_ECM
 	tristate
 	default USB_RTL8153_ECM
-config BACKPORTED_SSB_POSSIBLE
-	tristate
-	default SSB_POSSIBLE
-config BACKPORTED_SSB
-	tristate
-	default SSB
-config BACKPORTED_SSB_SPROM
-	tristate
-	default SSB_SPROM
-config BACKPORTED_SSB_BLOCKIO
-	tristate
-	default SSB_BLOCKIO
-config BACKPORTED_SSB_PCIHOST_POSSIBLE
-	tristate
-	default SSB_PCIHOST_POSSIBLE
-config BACKPORTED_SSB_PCIHOST
-	tristate
-	default SSB_PCIHOST
-config BACKPORTED_SSB_B43_PCI_BRIDGE
-	tristate
-	default SSB_B43_PCI_BRIDGE
-config BACKPORTED_SSB_PCMCIAHOST_POSSIBLE
-	tristate
-	default SSB_PCMCIAHOST_POSSIBLE
-config BACKPORTED_SSB_PCMCIAHOST
-	tristate
-	default SSB_PCMCIAHOST
-config BACKPORTED_SSB_SDIOHOST_POSSIBLE
-	tristate
-	default SSB_SDIOHOST_POSSIBLE
-config BACKPORTED_SSB_SDIOHOST
-	tristate
-	default SSB_SDIOHOST
-config BACKPORTED_SSB_HOST_SOC
-	tristate
-	default SSB_HOST_SOC
-config BACKPORTED_SSB_SERIAL
-	tristate
-	default SSB_SERIAL
-config BACKPORTED_SSB_DRIVER_PCICORE_POSSIBLE
-	tristate
-	default SSB_DRIVER_PCICORE_POSSIBLE
-config BACKPORTED_SSB_DRIVER_PCICORE
-	tristate
-	default SSB_DRIVER_PCICORE
-config BACKPORTED_SSB_PCICORE_HOSTMODE
-	tristate
-	default SSB_PCICORE_HOSTMODE
-config BACKPORTED_SSB_DRIVER_MIPS
-	tristate
-	default SSB_DRIVER_MIPS
-config BACKPORTED_SSB_SFLASH
-	tristate
-	default SSB_SFLASH
-config BACKPORTED_SSB_EMBEDDED
-	tristate
-	default SSB_EMBEDDED
-config BACKPORTED_SSB_DRIVER_EXTIF
-	tristate
-	default SSB_DRIVER_EXTIF
-config BACKPORTED_SSB_DRIVER_GIGE
-	tristate
-	default SSB_DRIVER_GIGE
-config BACKPORTED_SSB_DRIVER_GPIO
-	tristate
-	default SSB_DRIVER_GPIO
-config BACKPORTED_BCMA_POSSIBLE
-	tristate
-	default BCMA_POSSIBLE
-config BACKPORTED_BCMA
-	tristate
-	default BCMA
-config BACKPORTED_BCMA_BLOCKIO
-	tristate
-	default BCMA_BLOCKIO
-config BACKPORTED_BCMA_HOST_PCI_POSSIBLE
-	tristate
-	default BCMA_HOST_PCI_POSSIBLE
-config BACKPORTED_BCMA_HOST_PCI
-	tristate
-	default BCMA_HOST_PCI
-config BACKPORTED_BCMA_HOST_SOC
-	tristate
-	default BCMA_HOST_SOC
-config BACKPORTED_BCMA_DRIVER_PCI
-	tristate
-	default BCMA_DRIVER_PCI
-config BACKPORTED_BCMA_DRIVER_PCI_HOSTMODE
-	tristate
-	default BCMA_DRIVER_PCI_HOSTMODE
-config BACKPORTED_BCMA_DRIVER_MIPS
-	tristate
-	default BCMA_DRIVER_MIPS
-config BACKPORTED_BCMA_PFLASH
-	tristate
-	default BCMA_PFLASH
-config BACKPORTED_BCMA_SFLASH
-	tristate
-	default BCMA_SFLASH
-config BACKPORTED_BCMA_NFLASH
-	tristate
-	default BCMA_NFLASH
-config BACKPORTED_BCMA_DRIVER_GMAC_CMN
-	tristate
-	default BCMA_DRIVER_GMAC_CMN
-config BACKPORTED_BCMA_DRIVER_GPIO
-	tristate
-	default BCMA_DRIVER_GPIO
-config BACKPORTED_BCMA_DEBUG
-	tristate
-	default BCMA_DEBUG
 config BACKPORTED_USB_ACM
 	tristate
 	default USB_ACM
diff --git a/Kconfig.sources b/Kconfig.sources
index 2ea4d8a..d74affd 100644
--- a/Kconfig.sources
+++ b/Kconfig.sources
@@ -4,15 +4,10 @@ source "$BACKPORT_DIR/compat/Kconfig"
 # these are copied from the kernel
 source "$BACKPORT_DIR/net/wireless/Kconfig"
 source "$BACKPORT_DIR/net/mac80211/Kconfig"
-source "$BACKPORT_DIR/net/qrtr/Kconfig"
-source "$BACKPORT_DIR/drivers/bus/mhi/Kconfig"
 source "$BACKPORT_DIR/drivers/soc/qcom/Kconfig"
 source "$BACKPORT_DIR/drivers/net/wireless/Kconfig"
 source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
 
-source "$BACKPORT_DIR/drivers/ssb/Kconfig"
-source "$BACKPORT_DIR/drivers/bcma/Kconfig"
-
 source "$BACKPORT_DIR/drivers/usb/class/Kconfig"
 
 source "$BACKPORT_DIR/drivers/staging/Kconfig"
diff --git a/Makefile b/Makefile
index 548d813..989faff 100644
--- a/Makefile
+++ b/Makefile
@@ -2,10 +2,10 @@
 # Makefile for the output source package
 #
 
-ifeq ($(KERNELRELEASE),)
+ifeq ($(KERNELVERSION),)
 
 MAKEFLAGS += --no-print-directory
-SHELL := /bin/bash
+SHELL := /usr/bin/env bash
 BACKPORT_DIR := $(shell pwd)
 
 KMODDIR ?= updates
@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
 KERNEL_CONFIG := $(KLIB_BUILD)/.config
 KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
 CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
 
 export KLIB KLIB_BUILD BACKPORT_DIR KMODDIR KMODPATH_ARG
 
@@ -36,7 +37,8 @@ mrproper:
 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
 	@rm -f backport-include/backport/autoconf.h
 
-.DEFAULT:
+.SILENT: $(STAMP_KERNEL_CONFIG)
+$(STAMP_KERNEL_CONFIG):
 	@set -e ; test -f local-symbols || (						\
 	echo "/--------------"								;\
 	echo "| You shouldn't run make in the backports tree, but only in"		;\
@@ -60,57 +62,62 @@ mrproper:
 	echo "| (that isn't currently running.)"					;\
 	echo "\\--"									;\
 	false)
-	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
-	then 										\
-		echo -n "Generating local configuration database from kernel ..."	;\
-		grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
-			while read l ; do						\
-				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-					continue					;\
-				fi							;\
-				l=$${l:7}						;\
-				n=$${l%%=*}						;\
-				v=$${l#*=}						;\
-				if [ "$$v" = "m" ] ; then				\
-					echo config $$n					;\
-					echo '    tristate' 				;\
-				elif [ "$$v" = "y" ] ; then				\
-					echo config $$n					;\
-					echo '    bool'					;\
-				else							\
-					continue					;\
-				fi							;\
-				echo "    default $$v"					;\
-				echo ""							;\
-			done								\
-		) > Kconfig.kernel							;\
-		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
-			kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
-		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-		test "$$kver" != ""							;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
-		kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
-		print=0									;\
-		for v in $$kvers ; do							\
-			if [ "$$print" = "1" ] ; then					\
-				echo config KERNEL_$$(echo $$v | tr . _)	;\
-				echo "    def_bool y"					;\
-			fi								;\
-			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-		done > Kconfig.versions							;\
-		# RHEL as well, sadly we need to grep for it				;\
-		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-			echo "    def_bool y"						;\
-		done >> Kconfig.versions						;\
-		echo " done."								;\
-	fi										;\
-	echo "$(CONFIG_MD5)" > .kernel_config_md5
+	@rm -f .kernel_config_md5_*
+	@touch $@
+
+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) local-symbols
+	@printf "Generating local configuration database from kernel ..."
+	@grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
+		while read l ; do						\
+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
+				continue					;\
+			fi							;\
+			l=$${l:7}						;\
+			n=$${l%%=*}						;\
+			v=$${l#*=}						;\
+			if [ "$$v" = "m" ] ; then				\
+				echo config $$n					;\
+				echo '    tristate' 				;\
+			elif [ "$$v" = "y" ] ; then				\
+				echo config $$n					;\
+				echo '    bool'					;\
+			else							\
+				continue					;\
+			fi							;\
+			echo "    default $$v"					;\
+			echo ""							;\
+		done								\
+	) > $@
+	@echo " done."
+
+Kconfig.versions: Kconfig.kernel
+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
+		kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
+	test "$$kver" != ""							;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
+	kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
+	print=0									;\
+	for v in $$kvers ; do							\
+		if [ "$$print" = "1" ] ; then					\
+			echo config KERNEL_$$(echo $$v | tr . _)	;\
+			echo "    def_bool y"					;\
+		fi								;\
+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
+	done > Kconfig.versions							;\
+	# RHEL as well, sadly we need to grep for it				;\
+	RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
+		echo "    def_bool y"						;\
+	done >> $@
+
+.DEFAULT:
+	@$(MAKE) Kconfig.versions
 	@$(MAKE) -f Makefile.real "$@"
 
 .PHONY: defconfig-help
diff --git a/Makefile.kernel b/Makefile.kernel
index 155e1ff..495c1c3 100644
--- a/Makefile.kernel
+++ b/Makefile.kernel
@@ -38,12 +38,8 @@ obj-y += compat/
 
 obj-$(CPTCFG_CFG80211) += net/wireless/
 obj-$(CPTCFG_MAC80211) += net/mac80211/
-obj-$(CPTCFG_QRTR) += net/qrtr/
 obj-$(CPTCFG_QCOM_QMI_HELPERS) += drivers/soc/qcom/
-obj-$(CPTCFG_MHI_BUS) += drivers/bus/mhi/
 obj-$(CPTCFG_WLAN) += drivers/net/wireless/
-obj-$(CPTCFG_SSB) += drivers/ssb/
-obj-$(CPTCFG_BCMA) += drivers/bcma/
 obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
 
 obj-$(CPTCFG_USB_WDM) += drivers/usb/class/
diff --git a/Makefile.real b/Makefile.real
index 6550802..971a543 100644
--- a/Makefile.real
+++ b/Makefile.real
@@ -6,6 +6,18 @@ else
 export BACKPORTS_GIT_TRACKER_DEF=
 endif
 
+ifneq ($(LLVM),)
+ifneq ($(filter %/,$(LLVM)),)
+LLVM_PREFIX := $(LLVM)
+else ifneq ($(filter -%,$(LLVM)),)
+LLVM_SUFFIX := $(LLVM)
+endif
+
+HOSTCC	= $(LLVM_PREFIX)clang$(LLVM_SUFFIX)
+else
+HOSTCC	= gcc
+endif
+
 # disable built-in rules for this file
 .SUFFIXES:
 
@@ -24,21 +36,21 @@ listnewconfig oldaskconfig oldconfig \
 silentoldconfig olddefconfig oldnoconfig \
 allnoconfig allyesconfig allmodconfig \
 alldefconfig randconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --$@ Kconfig
 
 .PHONY: usedefconfig
 usedefconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --defconfig=defconfig Kconfig
 
 .PHONY: savedefconfig
 savedefconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --savedefconfig=defconfig Kconfig
 
 defconfig-%::
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --defconfig=defconfigs/$(@:defconfig-%=%) Kconfig
 
 .config:
@@ -59,7 +71,7 @@ defconfig-%::
 
 backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 	@$(MAKE) oldconfig
-	@echo -n "Building backport-include/backport/autoconf.h ..."
+	@printf "Building backport-include/backport/autoconf.h ..."
 	@grep -f local-symbols .config | (				\
 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
@@ -80,7 +92,12 @@ backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 			esac						;\
 		done							;\
 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
-	) > backport-include/backport/autoconf.h
+	) > $@.new
+	@if cmp -s $@ $@.new; then \
+		rm -f $@.new; \
+	else \
+		mv $@.new $@; \
+	fi
 	@echo " done."
 
 .PHONY: modules
diff --git a/backport-include/linux/bcma/bcma_driver_chipcommon.h b/backport-include/linux/bcma/bcma_driver_chipcommon.h
new file mode 100644
index 0000000..42e028b
--- /dev/null
+++ b/backport-include/linux/bcma/bcma_driver_chipcommon.h
@@ -0,0 +1,10 @@
+#ifndef __BACKPORT_BCMA_DRIVER_CHIPCOMMON_H
+#define __BACKPORT_BCMA_DRIVER_CHIPCOMMON_H
+
+#include_next <linux/bcma/bcma_driver_chipcommon.h>
+
+#ifndef BCMA_CC_SROM_CONTROL_OTP_PRESENT
+#define BCMA_CC_SROM_CONTROL_OTP_PRESENT 0x00000020
+#endif
+
+#endif
diff --git a/backport-include/linux/iommu.h b/backport-include/linux/iommu.h
new file mode 100644
index 0000000..1c1e877
--- /dev/null
+++ b/backport-include/linux/iommu.h
@@ -0,0 +1,23 @@
+#ifndef __BACKPORT_LINUX_IOMMU_H
+#define __BACKPORT_LINUX_IOMMU_H
+
+#include_next <linux/iommu.h>
+#include <linux/version.h>
+
+#if LINUX_VERSION_IS_LESS(6,3,0)
+
+static inline int LINUX_BACKPORT(iommu_map)(struct iommu_domain *domain,
+					    unsigned long iova,
+					    phys_addr_t paddr, size_t size,
+					    int prot, gfp_t gfp)
+{
+	if (gfp == GFP_ATOMIC)
+		return iommu_map_atomic(domain, iova, paddr, size, prot);
+
+	return iommu_map(domain, iova, paddr, size, prot);
+}
+#define iommu_map LINUX_BACKPORT(iommu_map)
+
+#endif /* < 6.3 */
+
+#endif
diff --git a/backport-include/linux/list.h b/backport-include/linux/list.h
index 78367e9..a948c22 100644
--- a/backport-include/linux/list.h
+++ b/backport-include/linux/list.h
@@ -3,7 +3,7 @@
 #include_next <linux/list.h>
 #include <linux/version.h>
 
-#if LINUX_VERSION_IS_LESS(6,3,0)
+#if 0 /* OpenWrt backports list_count_nodes() on its own */
 /**
  * list_count_nodes - count nodes in the list
  * @head:	the head for your list.
diff --git a/backport-include/linux/of_net.h b/backport-include/linux/of_net.h
deleted file mode 100644
index 9b9276f..0000000
--- a/backport-include/linux/of_net.h
+++ /dev/null
@@ -1,26 +0,0 @@
-#ifndef _BP_OF_NET_H
-#define _BP_OF_NET_H
-#include_next <linux/of_net.h>
-#include <linux/version.h>
-#include <linux/etherdevice.h>
-
-/* The behavior of of_get_mac_address() changed in kernel 5.2, it now
- * returns an error code and not NULL in case of an error.
- */
-#if LINUX_VERSION_IS_LESS(5,13,0)
-static inline int backport_of_get_mac_address(struct device_node *np, u8 *mac_out)
-{
-	const void *mac = of_get_mac_address(np);
-
-	if (!mac)
-		return -ENODEV;
-	if (IS_ERR(mac))
-		return PTR_ERR(mac);
-	ether_addr_copy(mac_out, mac);
-	
-	return 0;
-}
-#define of_get_mac_address LINUX_BACKPORT(of_get_mac_address)
-#endif /* < 5.2 */
-
-#endif /* _BP_OF_NET_H */
diff --git a/backport-include/linux/random.h b/backport-include/linux/random.h
index 51bb17d..ca206c4 100644
--- a/backport-include/linux/random.h
+++ b/backport-include/linux/random.h
@@ -15,7 +15,7 @@ static inline u16 get_random_u16(void)
 }
 #endif
 
-#if LINUX_VERSION_IS_LESS(6,2,0)
+#if LINUX_VERSION_IS_LESS(6,1,4)
 static inline u32 __get_random_u32_below(u32 ceil)
 {
 	/*
diff --git a/backport-include/net/dropreason.h b/backport-include/net/dropreason.h
index ec74e71..ab6a632 100644
--- a/backport-include/net/dropreason.h
+++ b/backport-include/net/dropreason.h
@@ -3,10 +3,9 @@
 
 #include <linux/version.h>
 
+#include <net/dropreason-core.h>
 #if LINUX_VERSION_IS_GEQ(6,0,0)
 #include_next <net/dropreason.h>
-#else
-#include <net/dropreason-core.h>
 #endif
 
 #if LINUX_VERSION_IS_LESS(6,4,0)
diff --git a/compat/main.c b/compat/main.c
index d4f3340..651ab63 100644
--- a/compat/main.c
+++ b/compat/main.c
@@ -19,31 +19,6 @@ MODULE_LICENSE("GPL");
 #error "You need a CPTCFG_VERSION"
 #endif
 
-static char *backported_kernel_name = CPTCFG_KERNEL_NAME;
-
-module_param(backported_kernel_name, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_name,
-		 "The kernel tree name that was used for this backport (" CPTCFG_KERNEL_NAME ")");
-
-#ifdef BACKPORTS_GIT_TRACKED
-static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
-module_param(backports_tracker_id, charp, 0400);
-MODULE_PARM_DESC(backports_tracker_id,
-		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
-#else
-static char *backported_kernel_version = CPTCFG_KERNEL_VERSION;
-static char *backports_version = CPTCFG_VERSION;
-
-module_param(backported_kernel_version, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_version,
-		 "The kernel version that was used for this backport (" CPTCFG_KERNEL_VERSION ")");
-
-module_param(backports_version, charp, 0400);
-MODULE_PARM_DESC(backports_version,
-		 "The git version of the backports tree used to generate this backport (" CPTCFG_VERSION ")");
-
-#endif
-
 void backport_dependency_symbol(void)
 {
 }
diff --git a/compat_version b/compat_version
new file mode 100644
index 0000000..6804cfd
--- /dev/null
+++ b/compat_version
@@ -0,0 +1 @@
+compat-wireless-6.9.9-1-r27299-66559946ac
diff --git a/drivers/net/wireless/ath/Kconfig b/drivers/net/wireless/ath/Kconfig
index 9ef8d46..bd576b4 100644
--- a/drivers/net/wireless/ath/Kconfig
+++ b/drivers/net/wireless/ath/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: ISC
 config ATH_COMMON
-	tristate
+	tristate "ath.ko"
 	depends on m
 
 config WLAN_VENDOR_ATH
@@ -24,6 +24,9 @@ config WLAN_VENDOR_ATH
 
 if WLAN_VENDOR_ATH
 
+config ATH_USER_REGD
+	bool "Do not enforce EEPROM regulatory restrictions"
+
 config ATH_DEBUG
 	bool "Atheros wireless debugging"
 	help
diff --git a/drivers/net/wireless/ath/Makefile b/drivers/net/wireless/ath/Makefile
index 7432d87..adea25c 100644
--- a/drivers/net/wireless/ath/Makefile
+++ b/drivers/net/wireless/ath/Makefile
@@ -16,10 +16,10 @@ ath-objs :=	main.o \
 		regd.o \
 		hw.o \
 		key.o \
+		debug.o \
 		dfs_pattern_detector.o \
 		dfs_pri_detector.o
 
-ath-$(CPTCFG_ATH_DEBUG) += debug.o
 ath-$(CPTCFG_ATH_TRACEPOINTS) += trace.o
 
 CFLAGS_trace.o := -I$(src)
diff --git a/drivers/net/wireless/ath/ath.h b/drivers/net/wireless/ath/ath.h
index 1bfd992..eb63efd 100644
--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -321,14 +321,7 @@ void _ath_dbg(struct ath_common *common, enum ATH_DEBUG dbg_mask,
 #endif /* CPTCFG_ATH_DEBUG */
 
 /** Returns string describing opmode, or NULL if unknown mode. */
-#ifdef CPTCFG_ATH_DEBUG
 const char *ath_opmode_to_string(enum nl80211_iftype opmode);
-#else
-static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
-{
-	return "UNKNOWN";
-}
-#endif
 
 extern const char *ath_bus_type_strings[];
 static inline const char *ath_bus_type_to_string(enum ath_bus_type bustype)
diff --git a/drivers/net/wireless/ath/ath10k/Kconfig b/drivers/net/wireless/ath/ath10k/Kconfig
index 42fe42e..d8f919c 100644
--- a/drivers/net/wireless/ath/ath10k/Kconfig
+++ b/drivers/net/wireless/ath/ath10k/Kconfig
@@ -73,6 +73,12 @@ config ATH10K_DEBUGFS
 
 	  If unsure, say Y to make it easier to debug problems.
 
+config ATH10K_LEDS
+	bool
+	depends on ATH10K
+	depends on LEDS_CLASS=y || LEDS_CLASS=MAC80211
+	default y
+
 config ATH10K_SPECTRAL
 	bool "Atheros ath10k spectral scan support"
 	depends on ATH10K_DEBUGFS
@@ -88,6 +94,12 @@ config ATH10K_TRACING
 	help
 	  Select this to ath10k use tracing infrastructure.
 
+config ATH10K_THERMAL
+	bool "Atheros ath10k thermal monitoring support"
+	depends on THERMAL
+	---help---
+	  Select this to ath10k use hwmon for thermal measurement.
+
 config ATH10K_DFS_CERTIFIED
 	bool "Atheros DFS support for certified platforms"
 	depends on ATH10K && CFG80211_CERTIFICATION_ONUS
diff --git a/drivers/net/wireless/ath/ath10k/Makefile b/drivers/net/wireless/ath/ath10k/Makefile
index 24d846a..e040d84 100644
--- a/drivers/net/wireless/ath/ath10k/Makefile
+++ b/drivers/net/wireless/ath/ath10k/Makefile
@@ -18,7 +18,8 @@ ath10k_core-y += mac.o \
 ath10k_core-$(CPTCFG_ATH10K_SPECTRAL) += spectral.o
 ath10k_core-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath10k_core-$(CPTCFG_ATH10K_TRACING) += trace.o
-ath10k_core-$(CONFIG_THERMAL) += thermal.o
+ath10k_core-$(CPTCFG_ATH10K_THERMAL) += thermal.o
+ath10k_core-$(CPTCFG_ATH10K_LEDS) += leds.o
 ath10k_core-$(CPTCFG_MAC80211_DEBUGFS) += debugfs_sta.o
 ath10k_core-$(CONFIG_PM) += wow.o
 ath10k_core-$(CONFIG_DEV_COREDUMP) += coredump.o
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index fa5e2e6..26534f4 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/firmware.h>
 #include <linux/of.h>
+#include <linux/of_net.h>
 #include <linux/property.h>
 #include <linux/dmi.h>
 #include <linux/ctype.h>
@@ -27,6 +28,7 @@
 #include "testmode.h"
 #include "wmi-ops.h"
 #include "coredump.h"
+#include "leds.h"
 
 unsigned int ath10k_debug_mask;
 EXPORT_SYMBOL(ath10k_debug_mask);
@@ -68,6 +70,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca988x hw2.0",
 		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 1,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
@@ -109,6 +112,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca988x hw2.0 ubiquiti",
 		.patch_load_addr = QCA988X_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 0,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
@@ -151,6 +155,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca9887 hw1.0",
 		.patch_load_addr = QCA9887_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 1,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_ALL,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
@@ -193,6 +198,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca6174 hw3.2 sdio",
 		.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,
 		.uart_pin = 19,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -230,6 +236,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca6164 hw2.1",
 		.patch_load_addr = QCA6174_HW_2_1_PATCH_LOAD_ADDR,
 		.uart_pin = 6,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -271,6 +278,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca6174 hw2.1",
 		.patch_load_addr = QCA6174_HW_2_1_PATCH_LOAD_ADDR,
 		.uart_pin = 6,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -312,6 +320,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca6174 hw3.0",
 		.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,
 		.uart_pin = 6,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -353,6 +362,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca6174 hw3.2",
 		.patch_load_addr = QCA6174_HW_3_0_PATCH_LOAD_ADDR,
 		.uart_pin = 6,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -398,6 +408,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca99x0 hw2.0",
 		.patch_load_addr = QCA99X0_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 17,
 		.otp_exe_param = 0x00000700,
 		.continuous_frag_desc = true,
 		.cck_rate_map_rev2 = true,
@@ -445,6 +456,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca9984/qca9994 hw1.0",
 		.patch_load_addr = QCA9984_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 17,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
 		.otp_exe_param = 0x00000700,
 		.continuous_frag_desc = true,
@@ -499,6 +511,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca9888 hw2.0",
 		.patch_load_addr = QCA9888_HW_2_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 17,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
 		.otp_exe_param = 0x00000700,
 		.continuous_frag_desc = true,
@@ -550,6 +563,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca9377 hw1.0",
 		.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 6,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -591,6 +605,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca9377 hw1.1",
 		.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 6,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -634,6 +649,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca9377 hw1.1 sdio",
 		.patch_load_addr = QCA9377_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 19,
+		.led_pin = 0,
 		.otp_exe_param = 0,
 		.channel_counters_freq_hz = 88000,
 		.max_probe_resp_desc_thres = 0,
@@ -668,6 +684,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.name = "qca4019 hw1.0",
 		.patch_load_addr = QCA4019_HW_1_0_PATCH_LOAD_ADDR,
 		.uart_pin = 7,
+		.led_pin = 0,
 		.cc_wraparound_type = ATH10K_HW_CC_WRAP_SHIFTED_EACH,
 		.otp_exe_param = 0x0010000,
 		.continuous_frag_desc = true,
@@ -714,6 +731,7 @@ static const struct ath10k_hw_params ath10k_hw_params_list[] = {
 		.dev_id = 0,
 		.bus = ATH10K_BUS_SNOC,
 		.name = "wcn3990 hw1.0",
+		.led_pin = 0,
 		.continuous_frag_desc = true,
 		.tx_chain_mask = 0x7,
 		.rx_chain_mask = 0x7,
@@ -3242,6 +3260,10 @@ int ath10k_core_start(struct ath10k *ar, enum ath10k_firmware_mode mode,
 		goto err_hif_stop;
 	}
 
+	status = ath10k_leds_start(ar);
+	if (status)
+		goto err_hif_stop;
+
 	return 0;
 
 err_hif_stop:
@@ -3408,6 +3430,8 @@ static int ath10k_core_probe_fw(struct ath10k *ar)
 
 	device_get_mac_address(ar->dev, ar->mac_addr);
 
+	of_get_mac_address(ar->dev->of_node, ar->mac_addr);
+
 	ret = ath10k_core_init_firmware_features(ar);
 	if (ret) {
 		ath10k_err(ar, "fatal problem with firmware features: %d\n",
@@ -3500,9 +3524,18 @@ static void ath10k_core_register_work(struct work_struct *work)
 		goto err_spectral_destroy;
 	}
 
+	status = ath10k_leds_register(ar);
+	if (status) {
+		ath10k_err(ar, "could not register leds: %d\n",
+			   status);
+		goto err_thermal_unregister;
+	}
+
 	set_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags);
 	return;
 
+err_thermal_unregister:
+	ath10k_thermal_unregister(ar);
 err_spectral_destroy:
 	ath10k_spectral_destroy(ar);
 err_debug_destroy:
@@ -3527,6 +3560,16 @@ int ath10k_core_register(struct ath10k *ar,
 
 	queue_work(ar->workqueue, &ar->register_work);
 
+	/* OpenWrt requires all PHYs to be initialized to create the
+	 * configuration files during bootup. ath10k violates this
+	 * because it delays the creation of the PHY to a not well defined
+	 * point in the future.
+	 *
+	 * Forcing the work to be done immediately works around this problem
+	 * but may also delay the boot when firmware images cannot be found.
+	 */
+	flush_workqueue(ar->workqueue);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath10k_core_register);
@@ -3538,6 +3581,8 @@ void ath10k_core_unregister(struct ath10k *ar)
 	if (!test_bit(ATH10K_FLAG_CORE_REGISTERED, &ar->dev_flags))
 		return;
 
+	ath10k_leds_unregister(ar);
+
 	ath10k_thermal_unregister(ar);
 	/* Stop spectral before unregistering from mac80211 to remove the
 	 * relayfs debugfs file cleanly. Otherwise the parent debugfs tree
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index 2435291..8546f2f 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -15,6 +15,7 @@
 #include <linux/pci.h>
 #include <linux/uuid.h>
 #include <linux/time.h>
+#include <linux/leds.h>
 
 #include "htt.h"
 #include "htc.h"
@@ -1256,6 +1257,13 @@ struct ath10k {
 		bool utf_monitor;
 	} testmode;
 
+	struct {
+		struct gpio_led wifi_led;
+		struct led_classdev cdev;
+		char label[48];
+		u32 gpio_state_pin;
+	} leds;
+
 	struct {
 		/* protected by data_lock */
 		u32 rx_crc_err_drop;
@@ -1305,6 +1313,10 @@ struct ath10k {
 	s32 tx_power_2g_limit;
 	s32 tx_power_5g_limit;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	const char *led_default_trigger;
+#endif
+
 	/* must be last */
 	u8 drv_priv[] __aligned(sizeof(void *));
 };
diff --git a/drivers/net/wireless/ath/ath10k/htt.h b/drivers/net/wireless/ath/ath10k/htt.h
index 603f6de..bea1d16 100644
--- a/drivers/net/wireless/ath/ath10k/htt.h
+++ b/drivers/net/wireless/ath/ath10k/htt.h
@@ -236,7 +236,11 @@ enum htt_rx_ring_flags {
 };
 
 #define HTT_RX_RING_SIZE_MIN 128
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 #define HTT_RX_RING_SIZE_MAX 2048
+#else
+#define HTT_RX_RING_SIZE_MAX 512
+#endif
 #define HTT_RX_RING_SIZE HTT_RX_RING_SIZE_MAX
 #define HTT_RX_RING_FILL_LEVEL (((HTT_RX_RING_SIZE) / 2) - 1)
 #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
diff --git a/drivers/net/wireless/ath/ath10k/hw.h b/drivers/net/wireless/ath/ath10k/hw.h
index 0140fe7..50fb32f 100644
--- a/drivers/net/wireless/ath/ath10k/hw.h
+++ b/drivers/net/wireless/ath/ath10k/hw.h
@@ -521,6 +521,7 @@ struct ath10k_hw_params {
 	const char *name;
 	u32 patch_load_addr;
 	int uart_pin;
+	int led_pin;
 	u32 otp_exe_param;
 
 	/* Type of hw cycle counter wraparound logic, for more info
diff --git a/drivers/net/wireless/ath/ath10k/leds.c b/drivers/net/wireless/ath/ath10k/leds.c
new file mode 100644
index 0000000..b82033b
--- /dev/null
+++ b/drivers/net/wireless/ath/ath10k/leds.c
@@ -0,0 +1,90 @@
+// SPDX-License-Identifier: ISC
+/*
+ * Copyright (c) 2005-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
+ * Copyright (c) 2018 Sebastian Gottschall <s.gottschall@dd-wrt.com>
+ * Copyright (c) 2018 The Linux Foundation. All rights reserved.
+ */
+
+#include <linux/leds.h>
+
+#include "core.h"
+#include "wmi.h"
+#include "wmi-ops.h"
+
+#include "leds.h"
+
+static int ath10k_leds_set_brightness_blocking(struct led_classdev *led_cdev,
+					       enum led_brightness brightness)
+{
+	struct ath10k *ar = container_of(led_cdev, struct ath10k,
+					 leds.cdev);
+	struct gpio_led *led = &ar->leds.wifi_led;
+
+	mutex_lock(&ar->conf_mutex);
+
+	if (ar->state != ATH10K_STATE_ON)
+		goto out;
+
+	ar->leds.gpio_state_pin = (brightness != LED_OFF) ^ led->active_low;
+	ath10k_wmi_gpio_output(ar, led->gpio, ar->leds.gpio_state_pin);
+
+out:
+	mutex_unlock(&ar->conf_mutex);
+
+	return 0;
+}
+
+int ath10k_leds_start(struct ath10k *ar)
+{
+	if (ar->hw_params.led_pin == 0)
+		/* leds not supported */
+		return 0;
+
+	/* under some circumstances, the gpio pin gets reconfigured
+	 * to default state by the firmware, so we need to
+	 * reconfigure it this behaviour has only ben seen on
+	 * QCA9984 and QCA99XX devices so far
+	 */
+	ath10k_wmi_gpio_config(ar, ar->hw_params.led_pin, 0,
+			       WMI_GPIO_PULL_NONE, WMI_GPIO_INTTYPE_DISABLE);
+	ath10k_wmi_gpio_output(ar, ar->hw_params.led_pin, 1);
+
+	return 0;
+}
+
+int ath10k_leds_register(struct ath10k *ar)
+{
+	int ret;
+
+	if (ar->hw_params.led_pin == 0)
+		/* leds not supported */
+		return 0;
+
+	snprintf(ar->leds.label, sizeof(ar->leds.label), "ath10k-%s",
+		 wiphy_name(ar->hw->wiphy));
+	ar->leds.wifi_led.active_low = 1;
+	ar->leds.wifi_led.gpio = ar->hw_params.led_pin;
+	ar->leds.wifi_led.name = ar->leds.label;
+	ar->leds.wifi_led.default_state = LEDS_GPIO_DEFSTATE_KEEP;
+
+	ar->leds.cdev.name = ar->leds.label;
+	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
+	ar->leds.cdev.default_trigger = ar->led_default_trigger;
+
+	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void ath10k_leds_unregister(struct ath10k *ar)
+{
+	if (ar->hw_params.led_pin == 0)
+		/* leds not supported */
+		return;
+
+	led_classdev_unregister(&ar->leds.cdev);
+}
+
diff --git a/drivers/net/wireless/ath/ath10k/leds.h b/drivers/net/wireless/ath/ath10k/leds.h
new file mode 100644
index 0000000..09dd759
--- /dev/null
+++ b/drivers/net/wireless/ath/ath10k/leds.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: ISC */
+/*
+ * Copyright (c) 2005-2011 Atheros Communications Inc.
+ * Copyright (c) 2011-2017 Qualcomm Atheros, Inc.
+ * Copyright (c) 2018 Sebastian Gottschall <s.gottschall@dd-wrt.com>
+ * Copyright (c) 2018 The Linux Foundation. All rights reserved.
+ */
+
+#ifndef _LEDS_H_
+#define _LEDS_H_
+
+#include "core.h"
+
+#ifdef CPTCFG_ATH10K_LEDS
+void ath10k_leds_unregister(struct ath10k *ar);
+int ath10k_leds_start(struct ath10k *ar);
+int ath10k_leds_register(struct ath10k *ar);
+#else
+static inline void ath10k_leds_unregister(struct ath10k *ar)
+{
+}
+
+static inline int ath10k_leds_start(struct ath10k *ar)
+{
+	return 0;
+}
+
+static inline int ath10k_leds_register(struct ath10k *ar)
+{
+	return 0;
+}
+
+#endif
+#endif /* _LEDS_H_ */
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index ec43216..f179dff 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -25,6 +25,7 @@
 #include "wmi-tlv.h"
 #include "wmi-ops.h"
 #include "wow.h"
+#include "leds.h"
 
 /*********/
 /* Rates */
@@ -1021,6 +1022,40 @@ static inline int ath10k_vdev_setup_sync(struct ath10k *ar)
 	return ar->last_wmi_vdev_start_status;
 }
 
+static u32 ath10k_get_max_antenna_gain(struct ath10k *ar,
+				       u32 ch_max_antenna_gain)
+{
+	u32 max_antenna_gain;
+
+	if (ar->dfs_detector && ar->dfs_detector->region == NL80211_DFS_FCC) {
+		/* FCC allows maximum antenna gain of 6 dBi. 15.247(b)(4):
+		 *
+		 * > (4) The conducted output power limit
+		 * > specified in paragraph (b) of this section
+		 * > is based on the use of antennas
+		 * > with directional gains that do not exceed
+		 * > 6 dBi. Except as shown in paragraph
+		 * > (c) of this section, if transmitting
+		 * > antennas of directional gain greater
+		 * > than 6 dBi are used, the conducted
+		 * > output power from the intentional radiator
+		 * > shall be reduced below the stated
+		 * > values in paragraphs (b)(1), (b)(2),
+		 * > and (b)(3) of this section, as appropriate,
+		 * > by the amount in dB that the
+		 * > directional gain of the antenna exceeds
+		 * > 6 dBi.
+		 *
+		 * https://www.gpo.gov/fdsys/pkg/CFR-2013-title47-vol1/pdf/CFR-2013-title47-vol1-sec15-247.pdf
+		 */
+		max_antenna_gain = 6;
+	} else {
+		max_antenna_gain = 0;
+	}
+
+	return max(ch_max_antenna_gain, max_antenna_gain);
+}
+
 static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 {
 	struct cfg80211_chan_def *chandef = NULL;
@@ -1053,7 +1088,8 @@ static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 	arg.channel.min_power = 0;
 	arg.channel.max_power = channel->max_power * 2;
 	arg.channel.max_reg_power = channel->max_reg_power * 2;
-	arg.channel.max_antenna_gain = channel->max_antenna_gain;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 
 	reinit_completion(&ar->vdev_setup_done);
 	reinit_completion(&ar->vdev_delete_done);
@@ -1499,7 +1535,8 @@ static int ath10k_vdev_start_restart(struct ath10k_vif *arvif,
 	arg.channel.min_power = 0;
 	arg.channel.max_power = chandef->chan->max_power * 2;
 	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
-	arg.channel.max_antenna_gain = chandef->chan->max_antenna_gain;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+					chandef->chan->max_antenna_gain);
 
 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		arg.ssid = arvif->u.ap.ssid;
@@ -3430,7 +3467,8 @@ static int ath10k_update_channel_list(struct ath10k *ar)
 			ch->min_power = 0;
 			ch->max_power = channel->max_power * 2;
 			ch->max_reg_power = channel->max_reg_power * 2;
-			ch->max_antenna_gain = channel->max_antenna_gain;
+			ch->max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 			ch->reg_class_id = 0; /* FIXME */
 
 			/* FIXME: why use only legacy modes, why not any
@@ -9918,6 +9956,21 @@ static int ath10k_mac_init_rd(struct ath10k *ar)
 	return 0;
 }
 
+#ifdef CPTCFG_MAC80211_LEDS
+static const struct ieee80211_tpt_blink ath10k_tpt_blink[] = {
+	{ .throughput = 0 * 1024, .blink_time = 334 },
+	{ .throughput = 1 * 1024, .blink_time = 260 },
+	{ .throughput = 2 * 1024, .blink_time = 220 },
+	{ .throughput = 5 * 1024, .blink_time = 190 },
+	{ .throughput = 10 * 1024, .blink_time = 170 },
+	{ .throughput = 25 * 1024, .blink_time = 150 },
+	{ .throughput = 54 * 1024, .blink_time = 130 },
+	{ .throughput = 120 * 1024, .blink_time = 110 },
+	{ .throughput = 265 * 1024, .blink_time = 80 },
+	{ .throughput = 586 * 1024, .blink_time = 50 },
+};
+#endif
+
 int ath10k_mac_register(struct ath10k *ar)
 {
 	static const u32 cipher_suites[] = {
@@ -10036,7 +10089,6 @@ int ath10k_mac_register(struct ath10k *ar)
 	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
 	ieee80211_hw_set(ar->hw, QUEUE_CONTROL);
 	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
-	ieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);
 
 	if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))
 		ieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);
@@ -10280,6 +10332,12 @@ int ath10k_mac_register(struct ath10k *ar)
 
 	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	ar->led_default_trigger = ieee80211_create_tpt_led_trigger(ar->hw,
+		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath10k_tpt_blink,
+		ARRAY_SIZE(ath10k_tpt_blink));
+#endif
+
 	ret = ieee80211_register_hw(ar->hw);
 	if (ret) {
 		ath10k_err(ar, "failed to register ieee80211: %d\n", ret);
diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
index d7ac5ae..c7e8e90 100644
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -132,7 +132,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 512,
+#else
+		.dest_nentries = 128,
+#endif
 		.recv_cb = ath10k_pci_htt_htc_rx_cb,
 	},
 
@@ -141,7 +145,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 128,
+#else
+		.dest_nentries = 64,
+#endif
 		.recv_cb = ath10k_pci_htc_rx_cb,
 	},
 
@@ -168,7 +176,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 512,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 512,
+#else
+		.dest_nentries = 128,
+#endif
 		.recv_cb = ath10k_pci_htt_rx_cb,
 	},
 
@@ -193,7 +205,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 128,
+#else
+		.dest_nentries = 96,
+#endif
 		.recv_cb = ath10k_pci_pktlog_rx_cb,
 	},
 
diff --git a/drivers/net/wireless/ath/ath10k/thermal.h b/drivers/net/wireless/ath/ath10k/thermal.h
index 1f4de9f..fcfa3c2 100644
--- a/drivers/net/wireless/ath/ath10k/thermal.h
+++ b/drivers/net/wireless/ath/ath10k/thermal.h
@@ -25,7 +25,7 @@ struct ath10k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH10K_THERMAL)
 int ath10k_thermal_register(struct ath10k *ar);
 void ath10k_thermal_unregister(struct ath10k *ar);
 void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
diff --git a/drivers/net/wireless/ath/ath10k/wmi-ops.h b/drivers/net/wireless/ath/ath10k/wmi-ops.h
index aa57d80..f3f6b59 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-ops.h
+++ b/drivers/net/wireless/ath/ath10k/wmi-ops.h
@@ -226,7 +226,10 @@ struct wmi_ops {
 			 const struct wmi_bb_timing_cfg_arg *arg);
 	struct sk_buff *(*gen_per_peer_per_tid_cfg)(struct ath10k *ar,
 						    const struct wmi_per_peer_per_tid_cfg_arg *arg);
+	struct sk_buff *(*gen_gpio_config)(struct ath10k *ar, u32 gpio_num,
+					   u32 input, u32 pull_type, u32 intr_mode);
 
+	struct sk_buff *(*gen_gpio_output)(struct ath10k *ar, u32 gpio_num, u32 set);
 };
 
 int ath10k_wmi_cmd_send(struct ath10k *ar, struct sk_buff *skb, u32 cmd_id);
@@ -1122,6 +1125,35 @@ ath10k_wmi_force_fw_hang(struct ath10k *ar,
 	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->force_fw_hang_cmdid);
 }
 
+static inline int ath10k_wmi_gpio_config(struct ath10k *ar, u32 gpio_num,
+					 u32 input, u32 pull_type, u32 intr_mode)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_gpio_config)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_gpio_config(ar, gpio_num, input, pull_type, intr_mode);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_config_cmdid);
+}
+
+static inline int ath10k_wmi_gpio_output(struct ath10k *ar, u32 gpio_num, u32 set)
+{
+	struct sk_buff *skb;
+
+	if (!ar->wmi.ops->gen_gpio_config)
+		return -EOPNOTSUPP;
+
+	skb = ar->wmi.ops->gen_gpio_output(ar, gpio_num, set);
+	if (IS_ERR(skb))
+		return PTR_ERR(skb);
+
+	return ath10k_wmi_cmd_send(ar, skb, ar->wmi.cmd->gpio_output_cmdid);
+}
+
 static inline int
 ath10k_wmi_dbglog_cfg(struct ath10k *ar, u64 module_enable, u32 log_level)
 {
diff --git a/drivers/net/wireless/ath/ath10k/wmi-tlv.c b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
index aed97fd..dbaf26d 100644
--- a/drivers/net/wireless/ath/ath10k/wmi-tlv.c
+++ b/drivers/net/wireless/ath/ath10k/wmi-tlv.c
@@ -4606,6 +4606,8 @@ static const struct wmi_ops wmi_tlv_ops = {
 	.gen_echo = ath10k_wmi_tlv_op_gen_echo,
 	.gen_vdev_spectral_conf = ath10k_wmi_tlv_op_gen_vdev_spectral_conf,
 	.gen_vdev_spectral_enable = ath10k_wmi_tlv_op_gen_vdev_spectral_enable,
+	/* .gen_gpio_config not implemented */
+	/* .gen_gpio_output not implemented */
 };
 
 static const struct wmi_peer_flags_map wmi_tlv_peer_flags_map = {
diff --git a/drivers/net/wireless/ath/ath10k/wmi.c b/drivers/net/wireless/ath/ath10k/wmi.c
index 5d80988..6b428b4 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.c
+++ b/drivers/net/wireless/ath/ath10k/wmi.c
@@ -7493,6 +7493,49 @@ ath10k_wmi_op_gen_peer_set_param(struct ath10k *ar, u32 vdev_id,
 	return skb;
 }
 
+static struct sk_buff *ath10k_wmi_op_gen_gpio_config(struct ath10k *ar,
+						     u32 gpio_num, u32 input,
+						     u32 pull_type, u32 intr_mode)
+{
+	struct wmi_gpio_config_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_gpio_config_cmd *)skb->data;
+	cmd->pull_type = __cpu_to_le32(pull_type);
+	cmd->gpio_num = __cpu_to_le32(gpio_num);
+	cmd->input = __cpu_to_le32(input);
+	cmd->intr_mode = __cpu_to_le32(intr_mode);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_config gpio_num 0x%08x input 0x%08x pull_type 0x%08x intr_mode 0x%08x\n",
+		   gpio_num, input, pull_type, intr_mode);
+
+	return skb;
+}
+
+static struct sk_buff *ath10k_wmi_op_gen_gpio_output(struct ath10k *ar,
+						     u32 gpio_num, u32 set)
+{
+	struct wmi_gpio_output_cmd *cmd;
+	struct sk_buff *skb;
+
+	skb = ath10k_wmi_alloc_skb(ar, sizeof(*cmd));
+	if (!skb)
+		return ERR_PTR(-ENOMEM);
+
+	cmd = (struct wmi_gpio_output_cmd *)skb->data;
+	cmd->gpio_num = __cpu_to_le32(gpio_num);
+	cmd->set = __cpu_to_le32(set);
+
+	ath10k_dbg(ar, ATH10K_DBG_WMI, "wmi gpio_output gpio_num 0x%08x set 0x%08x\n",
+		   gpio_num, set);
+
+	return skb;
+}
+
 static struct sk_buff *
 ath10k_wmi_op_gen_set_psmode(struct ath10k *ar, u32 vdev_id,
 			     enum wmi_sta_ps_mode psmode)
@@ -9157,6 +9200,9 @@ static const struct wmi_ops wmi_ops = {
 	.fw_stats_fill = ath10k_wmi_main_op_fw_stats_fill,
 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
 	.gen_echo = ath10k_wmi_op_gen_echo,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
+
 	/* .gen_bcn_tmpl not implemented */
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
@@ -9227,6 +9273,8 @@ static const struct wmi_ops wmi_10_1_ops = {
 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
 	.gen_echo = ath10k_wmi_op_gen_echo,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_bcn_tmpl not implemented */
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
@@ -9299,6 +9347,8 @@ static const struct wmi_ops wmi_10_2_ops = {
 	.gen_delba_send = ath10k_wmi_op_gen_delba_send,
 	.fw_stats_fill = ath10k_wmi_10x_op_fw_stats_fill,
 	.get_vdev_subtype = ath10k_wmi_op_get_vdev_subtype,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_pdev_enable_adaptive_cca not implemented */
 };
 
@@ -9370,6 +9420,8 @@ static const struct wmi_ops wmi_10_2_4_ops = {
 		ath10k_wmi_op_gen_pdev_enable_adaptive_cca,
 	.get_vdev_subtype = ath10k_wmi_10_2_4_op_get_vdev_subtype,
 	.gen_bb_timing = ath10k_wmi_10_2_4_op_gen_bb_timing,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 	/* .gen_bcn_tmpl not implemented */
 	/* .gen_prb_tmpl not implemented */
 	/* .gen_p2p_go_bcn_ie not implemented */
@@ -9451,6 +9503,8 @@ static const struct wmi_ops wmi_10_4_ops = {
 	.gen_pdev_bss_chan_info_req = ath10k_wmi_10_2_op_gen_pdev_bss_chan_info,
 	.gen_echo = ath10k_wmi_op_gen_echo,
 	.gen_pdev_get_tpc_config = ath10k_wmi_10_2_4_op_gen_pdev_get_tpc_config,
+	.gen_gpio_config = ath10k_wmi_op_gen_gpio_config,
+	.gen_gpio_output = ath10k_wmi_op_gen_gpio_output,
 };
 
 int ath10k_wmi_attach(struct ath10k *ar)
diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h
index 2379501..09d0245 100644
--- a/drivers/net/wireless/ath/ath10k/wmi.h
+++ b/drivers/net/wireless/ath/ath10k/wmi.h
@@ -3034,6 +3034,41 @@ enum wmi_10_4_feature_mask {
 
 };
 
+/* WMI_GPIO_CPTCFG_CMDID */
+enum {
+	WMI_GPIO_PULL_NONE,
+	WMI_GPIO_PULL_UP,
+	WMI_GPIO_PULL_DOWN,
+};
+
+enum {
+	WMI_GPIO_INTTYPE_DISABLE,
+	WMI_GPIO_INTTYPE_RISING_EDGE,
+	WMI_GPIO_INTTYPE_FALLING_EDGE,
+	WMI_GPIO_INTTYPE_BOTH_EDGE,
+	WMI_GPIO_INTTYPE_LEVEL_LOW,
+	WMI_GPIO_INTTYPE_LEVEL_HIGH
+};
+
+/* WMI_GPIO_CPTCFG_CMDID */
+struct wmi_gpio_config_cmd {
+	__le32 gpio_num;             /* GPIO number to be setup */
+	__le32 input;                /* 0 - Output/ 1 - Input */
+	__le32 pull_type;            /* Pull type defined above */
+	__le32 intr_mode;            /* Interrupt mode defined above (Input) */
+} __packed;
+
+/* WMI_GPIO_OUTPUT_CMDID */
+struct wmi_gpio_output_cmd {
+	__le32 gpio_num;    /* GPIO number to be setup */
+	__le32 set;         /* Set the GPIO pin*/
+} __packed;
+
+/* WMI_GPIO_INPUT_EVENTID */
+struct wmi_gpio_input_event {
+	__le32 gpio_num;    /* GPIO number which changed state */
+} __packed;
+
 struct wmi_ext_resource_config_10_4_cmd {
 	/* contains enum wmi_host_platform_type */
 	__le32 host_platform_config;
diff --git a/drivers/net/wireless/ath/ath11k/Kconfig b/drivers/net/wireless/ath/ath11k/Kconfig
index 7430aaf..2258c11 100644
--- a/drivers/net/wireless/ath/ath11k/Kconfig
+++ b/drivers/net/wireless/ath/ath11k/Kconfig
@@ -25,9 +25,9 @@ config ATH11K_PCI
 	tristate "Atheros ath11k PCI support"
 	depends on m
 	depends on ATH11K && PCI
-	select MHI_BUS
-	select QRTR
-	select QRTR_MHI
+	depends on MHI_BUS
+	depends on QRTR
+	depends on QRTR_MHI
 	help
 	  This module adds support for PCIE bus
 
@@ -61,3 +61,10 @@ config ATH11K_SPECTRAL
 	  Enable ath11k spectral scan support
 
 	  Say Y to enable access to the FFT/spectral data via debugfs.
+
+config ATH11K_THERMAL
+	bool "ath11k thermal sensors and throttling support"
+	depends on ATH11K
+	depends on THERMAL
+	help
+	  Enable ath11k thermal sensors and throttling support.
diff --git a/drivers/net/wireless/ath/ath11k/Makefile b/drivers/net/wireless/ath/ath11k/Makefile
index 8386be2..776f6ba 100644
--- a/drivers/net/wireless/ath/ath11k/Makefile
+++ b/drivers/net/wireless/ath/ath11k/Makefile
@@ -23,7 +23,7 @@ ath11k-y += core.o \
 ath11k-$(CPTCFG_ATH11K_DEBUGFS) += debugfs.o debugfs_htt_stats.o debugfs_sta.o
 ath11k-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath11k-$(CPTCFG_ATH11K_TRACING) += trace.o
-ath11k-$(CONFIG_THERMAL) += thermal.o
+ath11k-$(CPTCFG_ATH11K_THERMAL) += thermal.o
 ath11k-$(CPTCFG_ATH11K_SPECTRAL) += spectral.o
 ath11k-$(CONFIG_PM) += wow.o
 
diff --git a/drivers/net/wireless/ath/ath11k/core.c b/drivers/net/wireless/ath/ath11k/core.c
index 5d07585..25e72b1 100644
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -37,7 +37,7 @@ bool ath11k_ftm_mode;
 module_param_named(ftm_mode, ath11k_ftm_mode, bool, 0444);
 MODULE_PARM_DESC(ftm_mode, "Boots up in factory test mode");
 
-static const struct ath11k_hw_params ath11k_hw_params[] = {
+static struct ath11k_hw_params ath11k_hw_params[] = {
 	{
 		.hw_rev = ATH11K_HW_IPQ8074,
 		.name = "ipq8074 hw2.0",
@@ -170,8 +170,8 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.supports_shadow_regs = false,
 		.idle_ps = false,
 		.supports_sta_ps = false,
-		.coldboot_cal_mm = true,
-		.coldboot_cal_ftm = true,
+		.coldboot_cal_mm = false,
+		.coldboot_cal_ftm = false,
 		.cbcal_restart_fw = true,
 		.fw_mem_mode = 0,
 		.num_vdevs = 16 + 1,
@@ -2138,7 +2138,8 @@ static void ath11k_core_reset(struct work_struct *work)
 static int ath11k_init_hw_params(struct ath11k_base *ab)
 {
 	const struct ath11k_hw_params *hw_params = NULL;
-	int i;
+	u32 fw_mem_mode;
+	int i, ret;
 
 	for (i = 0; i < ARRAY_SIZE(ath11k_hw_params); i++) {
 		hw_params = &ath11k_hw_params[i];
@@ -2154,7 +2155,31 @@ static int ath11k_init_hw_params(struct ath11k_base *ab)
 
 	ab->hw_params = *hw_params;
 
+	ret = of_property_read_u32(ab->dev->of_node,
+				   "qcom,ath11k-fw-memory-mode",
+				   &fw_mem_mode);
+	if (!ret) {
+		if (fw_mem_mode == 0) {
+			ab->hw_params.fw_mem_mode = 0;
+			ab->hw_params.num_vdevs = 16 + 1;
+			ab->hw_params.num_peers = 512;
+		}
+		else if (fw_mem_mode == 1) {
+			ab->hw_params.fw_mem_mode = 1;
+			ab->hw_params.num_vdevs = 8;
+			ab->hw_params.num_peers = 128;
+		} else if (fw_mem_mode == 2) {
+			ab->hw_params.fw_mem_mode = 2;
+			ab->hw_params.num_vdevs = 8;
+			ab->hw_params.num_peers = 128;
+			ab->hw_params.coldboot_cal_mm = false;
+			ab->hw_params.coldboot_cal_ftm = false;
+		} else
+			ath11k_info(ab, "Unsupported FW memory mode: %u\n", fw_mem_mode);
+	}
+
 	ath11k_info(ab, "%s\n", ab->hw_params.name);
+	ath11k_info(ab, "FW memory mode: %d\n", ab->hw_params.fw_mem_mode);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index d261a6c..e547006 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -10034,6 +10034,7 @@ static int __ath11k_mac_register(struct ath11k *ar)
 	if (ret)
 		goto err;
 
+	wiphy_read_of_freq_limits(ar->hw->wiphy);
 	ath11k_mac_setup_ht_vht_cap(ar, cap, &ht_cap);
 	ath11k_mac_setup_he_cap(ar, cap);
 
diff --git a/drivers/net/wireless/ath/ath11k/mhi.c b/drivers/net/wireless/ath/ath11k/mhi.c
index d52491b..56da100 100644
--- a/drivers/net/wireless/ath/ath11k/mhi.c
+++ b/drivers/net/wireless/ath/ath11k/mhi.c
@@ -239,6 +239,34 @@ static void ath11k_mhi_op_runtime_put(struct mhi_controller *mhi_cntrl)
 {
 }
 
+static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
+				  void __iomem *addr,
+				  u32 *out)
+{
+	*out = readl(addr);
+
+	return 0;
+}
+
+static void ath11k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,
+				    void __iomem *addr,
+				    u32 val)
+{
+	writel(val, addr);
+}
+
+static void ath11k_mhi_qrtr_instance_set(struct mhi_controller *mhi_cntrl)
+{
+	struct ath11k_base *ab = dev_get_drvdata(mhi_cntrl->cntrl_dev);
+
+	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
+		ath11k_mhi_op_write_reg(mhi_cntrl,
+					mhi_cntrl->bhi + BHI_ERRDBG2,
+					FIELD_PREP(QRTR_INSTANCE_MASK,
+					ab->qmi.service_ins_id - ab->hw_params.qmi_service_ins_id));
+	}
+}
+
 static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
 {
 	switch (reason) {
@@ -260,6 +288,8 @@ static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
 		return "MHI_CB_FATAL_ERROR";
 	case MHI_CB_BW_REQ:
 		return "MHI_CB_BW_REQ";
+	case MHI_CB_EE_SBL_MODE:
+		return "MHI_CB_EE_SBL_MODE";
 	default:
 		return "UNKNOWN";
 	}
@@ -282,27 +312,14 @@ static void ath11k_mhi_op_status_cb(struct mhi_controller *mhi_cntrl,
 		if (!(test_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags)))
 			queue_work(ab->workqueue_aux, &ab->reset_work);
 		break;
+	case MHI_CB_EE_SBL_MODE:
+		ath11k_mhi_qrtr_instance_set(mhi_cntrl);
+		break;
 	default:
 		break;
 	}
 }
 
-static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
-				  void __iomem *addr,
-				  u32 *out)
-{
-	*out = readl(addr);
-
-	return 0;
-}
-
-static void ath11k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,
-				    void __iomem *addr,
-				    u32 val)
-{
-	writel(val, addr);
-}
-
 static int ath11k_mhi_read_addr_from_dt(struct mhi_controller *mhi_ctrl)
 {
 	struct device_node *np;
diff --git a/drivers/net/wireless/ath/ath11k/mhi.h b/drivers/net/wireless/ath/ath11k/mhi.h
index f81fba2..c9638b5 100644
--- a/drivers/net/wireless/ath/ath11k/mhi.h
+++ b/drivers/net/wireless/ath/ath11k/mhi.h
@@ -17,6 +17,9 @@
 #define MHICTRL					0x38
 #define MHICTRL_RESET_MASK			0x2
 
+#define BHI_ERRDBG2				0x38
+#define QRTR_INSTANCE_MASK			GENMASK(7, 0)
+
 int ath11k_mhi_start(struct ath11k_pci *ar_pci);
 void ath11k_mhi_stop(struct ath11k_pci *ar_pci);
 int ath11k_mhi_register(struct ath11k_pci *ar_pci);
diff --git a/drivers/net/wireless/ath/ath11k/pci.c b/drivers/net/wireless/ath/ath11k/pci.c
index 548e41b..e5474e6 100644
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -374,13 +374,20 @@ static void ath11k_pci_sw_reset(struct ath11k_base *ab, bool power_on)
 static void ath11k_pci_init_qmi_ce_config(struct ath11k_base *ab)
 {
 	struct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;
+	struct ath11k_pci *ab_pci = ath11k_pci_priv(ab);
+	struct pci_bus *bus = ab_pci->pdev->bus;
 
 	cfg->tgt_ce = ab->hw_params.target_ce_config;
 	cfg->tgt_ce_len = ab->hw_params.target_ce_count;
 
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
-	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+
+	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
+		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id +
+		(((pci_domain_nr(bus) & 0xF) << 4) | (bus->number & 0xF));
+	} else
+		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
 
 	ath11k_ce_get_shadow_config(ab, &cfg->shadow_reg_v2,
 				    &cfg->shadow_reg_v2_len);
diff --git a/drivers/net/wireless/ath/ath11k/reg.c b/drivers/net/wireless/ath/ath11k/reg.c
index a739b4f..6dc33b1 100644
--- a/drivers/net/wireless/ath/ath11k/reg.c
+++ b/drivers/net/wireless/ath/ath11k/reg.c
@@ -363,134 +363,6 @@ static u32 ath11k_map_fw_phy_flags(u32 phy_flags)
 	return flags;
 }
 
-static bool
-ath11k_reg_can_intersect(struct ieee80211_reg_rule *rule1,
-			 struct ieee80211_reg_rule *rule2)
-{
-	u32 start_freq1, end_freq1;
-	u32 start_freq2, end_freq2;
-
-	start_freq1 = rule1->freq_range.start_freq_khz;
-	start_freq2 = rule2->freq_range.start_freq_khz;
-
-	end_freq1 = rule1->freq_range.end_freq_khz;
-	end_freq2 = rule2->freq_range.end_freq_khz;
-
-	if ((start_freq1 >= start_freq2 &&
-	     start_freq1 < end_freq2) ||
-	    (start_freq2 > start_freq1 &&
-	     start_freq2 < end_freq1))
-		return true;
-
-	/* TODO: Should we restrict intersection feasibility
-	 *  based on min bandwidth of the intersected region also,
-	 *  say the intersected rule should have a  min bandwidth
-	 * of 20MHz?
-	 */
-
-	return false;
-}
-
-static void ath11k_reg_intersect_rules(struct ieee80211_reg_rule *rule1,
-				       struct ieee80211_reg_rule *rule2,
-				       struct ieee80211_reg_rule *new_rule)
-{
-	u32 start_freq1, end_freq1;
-	u32 start_freq2, end_freq2;
-	u32 freq_diff, max_bw;
-
-	start_freq1 = rule1->freq_range.start_freq_khz;
-	start_freq2 = rule2->freq_range.start_freq_khz;
-
-	end_freq1 = rule1->freq_range.end_freq_khz;
-	end_freq2 = rule2->freq_range.end_freq_khz;
-
-	new_rule->freq_range.start_freq_khz = max_t(u32, start_freq1,
-						    start_freq2);
-	new_rule->freq_range.end_freq_khz = min_t(u32, end_freq1, end_freq2);
-
-	freq_diff = new_rule->freq_range.end_freq_khz -
-			new_rule->freq_range.start_freq_khz;
-	max_bw = min_t(u32, rule1->freq_range.max_bandwidth_khz,
-		       rule2->freq_range.max_bandwidth_khz);
-	new_rule->freq_range.max_bandwidth_khz = min_t(u32, max_bw, freq_diff);
-
-	new_rule->power_rule.max_antenna_gain =
-		min_t(u32, rule1->power_rule.max_antenna_gain,
-		      rule2->power_rule.max_antenna_gain);
-
-	new_rule->power_rule.max_eirp = min_t(u32, rule1->power_rule.max_eirp,
-					      rule2->power_rule.max_eirp);
-
-	/* Use the flags of both the rules */
-	new_rule->flags = rule1->flags | rule2->flags;
-
-	if ((rule1->flags & NL80211_RRF_PSD) && (rule2->flags & NL80211_RRF_PSD))
-		new_rule->psd = min_t(s8, rule1->psd, rule2->psd);
-	else
-		new_rule->flags &= ~NL80211_RRF_PSD;
-
-	/* To be safe, lts use the max cac timeout of both rules */
-	new_rule->dfs_cac_ms = max_t(u32, rule1->dfs_cac_ms,
-				     rule2->dfs_cac_ms);
-}
-
-static struct ieee80211_regdomain *
-ath11k_regd_intersect(struct ieee80211_regdomain *default_regd,
-		      struct ieee80211_regdomain *curr_regd)
-{
-	u8 num_old_regd_rules, num_curr_regd_rules, num_new_regd_rules;
-	struct ieee80211_reg_rule *old_rule, *curr_rule, *new_rule;
-	struct ieee80211_regdomain *new_regd = NULL;
-	u8 i, j, k;
-
-	num_old_regd_rules = default_regd->n_reg_rules;
-	num_curr_regd_rules = curr_regd->n_reg_rules;
-	num_new_regd_rules = 0;
-
-	/* Find the number of intersecting rules to allocate new regd memory */
-	for (i = 0; i < num_old_regd_rules; i++) {
-		old_rule = default_regd->reg_rules + i;
-		for (j = 0; j < num_curr_regd_rules; j++) {
-			curr_rule = curr_regd->reg_rules + j;
-
-			if (ath11k_reg_can_intersect(old_rule, curr_rule))
-				num_new_regd_rules++;
-		}
-	}
-
-	if (!num_new_regd_rules)
-		return NULL;
-
-	new_regd = kzalloc(sizeof(*new_regd) + (num_new_regd_rules *
-			sizeof(struct ieee80211_reg_rule)),
-			GFP_ATOMIC);
-
-	if (!new_regd)
-		return NULL;
-
-	/* We set the new country and dfs region directly and only trim
-	 * the freq, power, antenna gain by intersecting with the
-	 * default regdomain. Also MAX of the dfs cac timeout is selected.
-	 */
-	new_regd->n_reg_rules = num_new_regd_rules;
-	memcpy(new_regd->alpha2, curr_regd->alpha2, sizeof(new_regd->alpha2));
-	new_regd->dfs_region = curr_regd->dfs_region;
-	new_rule = new_regd->reg_rules;
-
-	for (i = 0, k = 0; i < num_old_regd_rules; i++) {
-		old_rule = default_regd->reg_rules + i;
-		for (j = 0; j < num_curr_regd_rules; j++) {
-			curr_rule = curr_regd->reg_rules + j;
-
-			if (ath11k_reg_can_intersect(old_rule, curr_rule))
-				ath11k_reg_intersect_rules(old_rule, curr_rule,
-							   (new_rule + k++));
-		}
-	}
-	return new_regd;
-}
-
 static const char *
 ath11k_reg_get_regdom_str(enum nl80211_dfs_regions dfs_region)
 {
@@ -641,11 +513,11 @@ ath11k_reg_ap_pwr_convert(enum ieee80211_ap_reg_power power_type)
 
 struct ieee80211_regdomain *
 ath11k_reg_build_regd(struct ath11k_base *ab,
-		      struct cur_regulatory_info *reg_info, bool intersect,
+		      struct cur_regulatory_info *reg_info,
 		      enum wmi_vdev_type vdev_type,
 		      enum ieee80211_ap_reg_power power_type)
 {
-	struct ieee80211_regdomain *tmp_regd, *default_regd, *new_regd = NULL;
+	struct ieee80211_regdomain *new_regd = NULL;
 	struct cur_reg_rule *reg_rule, *reg_rule_6ghz;
 	u8 i = 0, j = 0, k = 0;
 	u8 num_rules;
@@ -688,26 +560,26 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 	}
 
 	if (!num_rules)
-		goto ret;
+		return new_regd;
 
 	/* Add max additional rules to accommodate weather radar band */
 	if (reg_info->dfs_region == ATH11K_DFS_REG_ETSI)
 		num_rules += 2;
 
-	tmp_regd =  kzalloc(sizeof(*tmp_regd) +
+	new_regd =  kzalloc(sizeof(*new_regd) +
 			(num_rules * sizeof(struct ieee80211_reg_rule)),
 			GFP_ATOMIC);
-	if (!tmp_regd)
-		goto ret;
+	if (!new_regd)
+		return new_regd;
 
-	memcpy(tmp_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
+	memcpy(new_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
 	memcpy(alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
 	alpha2[2] = '\0';
-	tmp_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
+	new_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
 
 	ath11k_dbg(ab, ATH11K_DBG_REG,
 		   "Country %s, CFG Regdomain %s FW Regdomain %d, num_reg_rules %d\n",
-		   alpha2, ath11k_reg_get_regdom_str(tmp_regd->dfs_region),
+		   alpha2, ath11k_reg_get_regdom_str(new_regd->dfs_region),
 		   reg_info->dfs_region, num_rules);
 	/* Update reg_rules[] below. Firmware is expected to
 	 * send these rules in order(2 GHz rules first and then 5 GHz)
@@ -746,7 +618,7 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 		flags |= ath11k_map_fw_reg_flags(reg_rule->flags);
 		flags |= ath11k_map_fw_phy_flags(reg_info->phybitmap);
 
-		ath11k_reg_update_rule(tmp_regd->reg_rules + i,
+		ath11k_reg_update_rule(new_regd->reg_rules + i,
 				       reg_rule->start_freq,
 				       reg_rule->end_freq, max_bw,
 				       reg_rule->ant_gain, reg_rule->reg_power,
@@ -761,7 +633,7 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 		    reg_info->dfs_region == ATH11K_DFS_REG_ETSI &&
 		    (reg_rule->end_freq > ETSI_WEATHER_RADAR_BAND_LOW &&
 		    reg_rule->start_freq < ETSI_WEATHER_RADAR_BAND_HIGH)){
-			ath11k_reg_update_weather_radar_band(ab, tmp_regd,
+			ath11k_reg_update_weather_radar_band(ab, new_regd,
 							     reg_rule, &i,
 							     flags, max_bw);
 			continue;
@@ -772,51 +644,23 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d) (%d, %d)\n",
 				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
 				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-				   tmp_regd->reg_rules[i].dfs_cac_ms, flags,
+				   new_regd->reg_rules[i].dfs_cac_ms, flags,
 				   reg_rule->psd_flag, reg_rule->psd_eirp);
 		} else {
 			ath11k_dbg(ab, ATH11K_DBG_REG,
 				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\n",
 				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
 				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-				   tmp_regd->reg_rules[i].dfs_cac_ms,
+				   new_regd->reg_rules[i].dfs_cac_ms,
 				   flags);
 		}
 	}
 
-	tmp_regd->n_reg_rules = i;
-
-	if (intersect) {
-		default_regd = ab->default_regd[reg_info->phy_id];
+	new_regd->n_reg_rules = i;
 
-		/* Get a new regd by intersecting the received regd with
-		 * our default regd.
-		 */
-		new_regd = ath11k_regd_intersect(default_regd, tmp_regd);
-		kfree(tmp_regd);
-		if (!new_regd) {
-			ath11k_warn(ab, "Unable to create intersected regdomain\n");
-			goto ret;
-		}
-	} else {
-		new_regd = tmp_regd;
-	}
-
-ret:
 	return new_regd;
 }
 
-static bool ath11k_reg_is_world_alpha(char *alpha)
-{
-	if (alpha[0] == '0' && alpha[1] == '0')
-		return true;
-
-	if (alpha[0] == 'n' && alpha[1] == 'a')
-		return true;
-
-	return false;
-}
-
 static enum wmi_vdev_type ath11k_reg_get_ar_vdev_type(struct ath11k *ar)
 {
 	struct ath11k_vif *arvif;
@@ -839,7 +683,6 @@ int ath11k_reg_handle_chan_list(struct ath11k_base *ab,
 				enum ieee80211_ap_reg_power power_type)
 {
 	struct ieee80211_regdomain *regd;
-	bool intersect = false;
 	int pdev_idx;
 	struct ath11k *ar;
 	enum wmi_vdev_type vdev_type;
@@ -891,24 +734,14 @@ int ath11k_reg_handle_chan_list(struct ath11k_base *ab,
 		    (char *)reg_info->alpha2, 2))
 		goto retfail;
 
-	/* Intersect new rules with default regd if a new country setting was
-	 * requested, i.e a default regd was already set during initialization
-	 * and the regd coming from this event has a valid country info.
-	 */
-	if (ab->default_regd[pdev_idx] &&
-	    !ath11k_reg_is_world_alpha((char *)
-		ab->default_regd[pdev_idx]->alpha2) &&
-	    !ath11k_reg_is_world_alpha((char *)reg_info->alpha2))
-		intersect = true;
-
 	ar = ab->pdevs[pdev_idx].ar;
 	vdev_type = ath11k_reg_get_ar_vdev_type(ar);
 
 	ath11k_dbg(ab, ATH11K_DBG_WMI,
-		   "wmi handle chan list power type %d vdev type %d intersect %d\n",
-		   power_type, vdev_type, intersect);
+		   "wmi handle chan list power type %d vdev type %d\n",
+		   power_type, vdev_type);
 
-	regd = ath11k_reg_build_regd(ab, reg_info, intersect, vdev_type, power_type);
+	regd = ath11k_reg_build_regd(ab, reg_info, vdev_type, power_type);
 	if (!regd) {
 		ath11k_warn(ab, "failed to build regd from reg_info\n");
 		goto fallback;
diff --git a/drivers/net/wireless/ath/ath11k/reg.h b/drivers/net/wireless/ath/ath11k/reg.h
index 64edb79..63938e5 100644
--- a/drivers/net/wireless/ath/ath11k/reg.h
+++ b/drivers/net/wireless/ath/ath11k/reg.h
@@ -35,7 +35,7 @@ void ath11k_reg_free(struct ath11k_base *ab);
 void ath11k_regd_update_work(struct work_struct *work);
 struct ieee80211_regdomain *
 ath11k_reg_build_regd(struct ath11k_base *ab,
-		      struct cur_regulatory_info *reg_info, bool intersect,
+		      struct cur_regulatory_info *reg_info,
 		      enum wmi_vdev_type vdev_type,
 		      enum ieee80211_ap_reg_power power_type);
 int ath11k_regd_update(struct ath11k *ar);
diff --git a/drivers/net/wireless/ath/ath11k/thermal.h b/drivers/net/wireless/ath/ath11k/thermal.h
index cdaf4e0..be102bc 100644
--- a/drivers/net/wireless/ath/ath11k/thermal.h
+++ b/drivers/net/wireless/ath/ath11k/thermal.h
@@ -26,7 +26,7 @@ struct ath11k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH11K_THERMAL)
 int ath11k_thermal_register(struct ath11k_base *ab);
 void ath11k_thermal_unregister(struct ath11k_base *ab);
 int ath11k_thermal_set_throttling(struct ath11k *ar, u32 throttle_state);
diff --git a/drivers/net/wireless/ath/ath5k/ath5k.h b/drivers/net/wireless/ath/ath5k/ath5k.h
index 308a429..0e6d184 100644
--- a/drivers/net/wireless/ath/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
@@ -1372,6 +1372,7 @@ struct ath5k_hw {
 	u8			ah_coverage_class;
 	bool			ah_ack_bitrate_high;
 	u8			ah_bwmode;
+	u8			ah_bwmode_debug;
 	bool			ah_short_slot;
 
 	/* Antenna Control */
diff --git a/drivers/net/wireless/ath/ath5k/base.c b/drivers/net/wireless/ath/ath5k/base.c
index 7ec5d9a..1a500ab 100644
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -465,6 +465,9 @@ ath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef)
 		return -EINVAL;
 	}
 
+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
+		ah->ah_bwmode = ah->ah_bwmode_debug;
+
 	/*
 	 * To switch channels clear any pending DMA operations;
 	 * wait long enough for the RX fifo to drain, reset the
@@ -2009,7 +2012,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
 	}
 
 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
-			ah->num_mesh_vifs > 1) ||
+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
 		u64 tsf = ath5k_hw_get_tsf64(ah);
 		u32 tsftu = TSF_TO_TU(tsf);
@@ -2095,7 +2098,7 @@ ath5k_beacon_update_timers(struct ath5k_hw *ah, u64 bc_tsf)
 
 	intval = ah->bintval & AR5K_BEACON_PERIOD;
 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
-		+ ah->num_mesh_vifs > 1) {
+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
 		if (intval < 15)
 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
@@ -2561,6 +2564,7 @@ static const struct ieee80211_iface_limit if_limits[] = {
 				 BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
 				 BIT(NL80211_IFTYPE_AP) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 static const struct ieee80211_iface_combination if_comb = {
diff --git a/drivers/net/wireless/ath/ath5k/debug.c b/drivers/net/wireless/ath/ath5k/debug.c
index ec13051..239d789 100644
--- a/drivers/net/wireless/ath/ath5k/debug.c
+++ b/drivers/net/wireless/ath/ath5k/debug.c
@@ -803,6 +803,97 @@ static const struct file_operations fops_ani = {
 	.llseek = default_llseek,
 };
 
+/* debugfs: bwmode */
+
+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[15];
+	unsigned int len = 0;
+
+	int cur_ah_bwmode = ah->ah_bwmode_debug;
+
+#define print_selected(MODE, LABEL) \
+	if (cur_ah_bwmode == MODE) \
+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
+	else \
+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
+	len += snprintf(buf+len, sizeof(buf)-len, " ");
+
+	print_selected(AR5K_BWMODE_5MHZ, "5");
+	print_selected(AR5K_BWMODE_10MHZ, "10");
+	print_selected(AR5K_BWMODE_DEFAULT, "20");
+	print_selected(AR5K_BWMODE_40MHZ, "40");
+#undef print_selected
+
+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_bwmode(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[3];
+	int bw = 20;
+	int tobwmode = AR5K_BWMODE_DEFAULT;
+
+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+		return -EFAULT;
+
+	/* TODO: Add check for active interface */
+
+	if(strncmp(buf, "5", 1) == 0 ) {
+		tobwmode = AR5K_BWMODE_5MHZ;
+		bw = 5;
+	} else if ( strncmp(buf, "10", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_10MHZ;
+		bw = 10;
+	} else if ( strncmp(buf, "20", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_DEFAULT;
+		bw = 20;
+	} else if ( strncmp(buf, "40", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_40MHZ;
+		bw = 40;
+	} else
+		return -EINVAL;
+
+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
+		bw, tobwmode);
+
+	switch (ah->ah_radio) {
+	/* TODO: only define radios that actually support 5/10mhz channels */
+	case AR5K_RF5413:
+	case AR5K_RF5110:
+	case AR5K_RF5111:
+	case AR5K_RF5112:
+	case AR5K_RF2413:
+	case AR5K_RF2316:
+	case AR5K_RF2317:
+	case AR5K_RF2425:
+		if(ah->ah_bwmode_debug != tobwmode) {
+			mutex_lock(&ah->lock);
+			ah->ah_bwmode = tobwmode;
+			ah->ah_bwmode_debug = tobwmode;
+			mutex_unlock(&ah->lock);
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return count;
+}
+
+static const struct file_operations fops_bwmode = {
+	.read = read_file_bwmode,
+	.write = write_file_bwmode,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 /* debugfs: queues etc */
 
@@ -995,6 +1086,8 @@ ath5k_debug_init_device(struct ath5k_hw *ah)
 	debugfs_create_file("queue", 0600, phydir, ah, &fops_queue);
 	debugfs_create_bool("32khz_clock", 0600, phydir,
 			    &ah->ah_use_32khz_clock);
+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
+			    &fops_bwmode);
 }
 
 /* functions used in other places */
diff --git a/drivers/net/wireless/ath/ath5k/dma.c b/drivers/net/wireless/ath/ath5k/dma.c
index d9e376e..db06ff8 100644
--- a/drivers/net/wireless/ath/ath5k/dma.c
+++ b/drivers/net/wireless/ath/ath5k/dma.c
@@ -854,10 +854,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
 	 * guess we can tweak it and see how it goes ;-)
 	 */
 	if (ah->ah_version != AR5K_AR5210) {
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
+#else
+		/* WAR for AR71xx PCI bug */
+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
+#endif
 	}
 
 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/drivers/net/wireless/ath/ath5k/initvals.c b/drivers/net/wireless/ath/ath5k/initvals.c
index ee1c2fa..122fe1c 100644
--- a/drivers/net/wireless/ath/ath5k/initvals.c
+++ b/drivers/net/wireless/ath/ath5k/initvals.c
@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini[] = {
 	{ AR5K_IMR,		0 },
 	{ AR5K_IER,		AR5K_IER_DISABLE },
 	{ AR5K_BSR,		0, AR5K_INI_READ },
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
+#else
+	/* WAR for AR71xx PCI bug */
+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
+#endif
 	{ AR5K_CFG,		AR5K_INIT_CFG },
 	{ AR5K_TOPS,		8 },
 	{ AR5K_RXNOFRM,		8 },
diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
index eea4bda..67efda7 100644
--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		goto end;
 	}
 
-	/* Don't allow other interfaces if one ad-hoc is configured.
-	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
-	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
-	 * for the IBSS, but this breaks with additional AP or STA interfaces
-	 * at the moment. */
-	if (ah->num_adhoc_vifs ||
-	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
+	/* Don't allow more than one ad-hoc interface */
+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
 		ret = -ELNRNG;
 		goto end;
diff --git a/drivers/net/wireless/ath/ath5k/pci.c b/drivers/net/wireless/ath/ath5k/pci.c
index b51fce5..2aae4de 100644
--- a/drivers/net/wireless/ath/ath5k/pci.c
+++ b/drivers/net/wireless/ath/ath5k/pci.c
@@ -20,6 +20,7 @@
 #include <linux/pci.h>
 #include <linux/etherdevice.h>
 #include <linux/module.h>
+#include <linux/ath5k_platform.h>
 #include "../ath.h"
 #include "ath5k.h"
 #include "debug.h"
@@ -46,6 +47,8 @@ static const struct pci_device_id ath5k_pci_id_table[] = {
 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
+	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
+	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
 	{ 0 }
 };
@@ -71,7 +74,7 @@ static void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)
 }
 
 /*
- * Read from eeprom
+ * Read from eeprom or platform_data
  */
 static bool
 ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
@@ -79,6 +82,19 @@ ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
 	struct ath5k_hw *ah = common->ah;
 	u32 status, timeout;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS)
+			return false;
+
+		*data = pdata->eeprom_data[offset];
+		return true;
+	}
+
 	/*
 	 * Initialize EEPROM access
 	 */
@@ -122,6 +138,16 @@ static int ath5k_pci_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)
 	u16 data;
 	int octet;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->macaddr) {
+		memcpy(mac, pdata->macaddr, ETH_ALEN);
+		return 0;
+	}
+
 	AR5K_EEPROM_READ(0x20, data);
 
 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/drivers/net/wireless/ath/ath5k/reset.c b/drivers/net/wireless/ath/ath5k/reset.c
index 9fdb528..eabf225 100644
--- a/drivers/net/wireless/ath/ath5k/reset.c
+++ b/drivers/net/wireless/ath/ath5k/reset.c
@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	tsf_lo = 0;
 	mode = 0;
 
+#if 0
 	/*
 	 * Sanity check for fast flag
 	 * Fast channel change only available
@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	 */
 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
 	(ah->ah_radio != AR5K_RF5413))
+#endif
 		fast = false;
 
 	/* Disable sleep clock operation
diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 2afdebf..3ba9fc3 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -24,6 +24,7 @@
 #include "regd_common.h"
 
 static int __ath_regd_init(struct ath_regulatory *reg);
+static struct reg_dmn_pair_mapping *ath_get_regpair(int regdmn);
 
 /*
  * This is a set of common rules used by our world regulatory domains.
@@ -43,7 +44,8 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 #define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
@@ -61,64 +63,79 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 #define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
 				ATH_5GHZ_5725_5850
 
+#define REGD_RULES(...) \
+	.reg_rules = { __VA_ARGS__ }, \
+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
+
 /* Can be used for:
  * 0x60, 0x61, 0x62 */
 static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
-	.n_reg_rules = 5,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_ALL,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x63 and 0x65 */
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x64 only */
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x66 and 0x69 */
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
+{
+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
+}
+
+static bool is_default_regd(struct ath_regulatory *reg)
+{
+	return ath_regd_get_eepromRD(reg) == CTRY_DEFAULT;
+}
+
 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
+
 	if (IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;
 
+	if (is_default_regd(reg))
+		return true;
+
 	switch (reg->country_code) {
 	case CTRY_UNITED_STATES:
 	case CTRY_JAPAN1:
@@ -188,6 +205,8 @@ static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 
 static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
 	if (!IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
 	if (!dynamic_country_user_possible(reg))
@@ -202,11 +221,6 @@ static inline bool is_wwr_sku(u16 regd)
 		(regd == WORLD));
 }
 
-static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
-{
-	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
-}
-
 bool ath_is_world_regd(struct ath_regulatory *reg)
 {
 	return is_wwr_sku(ath_regd_get_eepromRD(reg));
@@ -345,6 +359,9 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
@@ -379,6 +396,9 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 {
 	struct ieee80211_supported_band *sband;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
@@ -408,6 +428,9 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;
 
@@ -640,6 +663,13 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
+
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return 0;
+
+	if (is_default_regd(reg))
+		return 0;
+
 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
 				   REGULATORY_CUSTOM_REG;
 
diff --git a/drivers/net/wireless/ath/regd_common.h b/drivers/net/wireless/ath/regd_common.h
index cdb1e9a..2574f80 100644
--- a/drivers/net/wireless/ath/regd_common.h
+++ b/drivers/net/wireless/ath/regd_common.h
@@ -32,6 +32,7 @@ enum EnumRd {
 	FCC2_WORLD = 0x21,
 	FCC2_ETSIC = 0x22,
 	FCC6_WORLD = 0x23,
+	FCC3_FCCA_2 = 0x2A,
 	FRANCE_RES = 0x31,
 	FCC3_FCCA = 0x3A,
 	FCC3_WORLD = 0x3B,
@@ -173,6 +174,7 @@ static struct reg_dmn_pair_mapping regDomainPairs[] = {
 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC3_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
@@ -486,6 +488,7 @@ static struct country_code_to_enum_rd allCountries[] = {
 	{CTRY_UAE, NULL1_WORLD, "AE"},
 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
 	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
 	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
 	/* This "PS" is for US public safety actually... to support this we
diff --git a/drivers/net/wireless/broadcom/b43/Kconfig b/drivers/net/wireless/broadcom/b43/Kconfig
index 2e196b5..5f008b4 100644
--- a/drivers/net/wireless/broadcom/b43/Kconfig
+++ b/drivers/net/wireless/broadcom/b43/Kconfig
@@ -63,21 +63,21 @@ endchoice
 config B43_PCI_AUTOSELECT
 	bool
 	depends on B43 && SSB_PCIHOST_POSSIBLE
-	select SSB_PCIHOST
-	select SSB_B43_PCI_BRIDGE
+	depends on SSB_PCIHOST
+	depends on SSB_B43_PCI_BRIDGE
 	default y
 
 # Auto-select SSB PCICORE driver, if possible
 config B43_PCICORE_AUTOSELECT
 	bool
 	depends on B43 && SSB_DRIVER_PCICORE_POSSIBLE
-	select SSB_DRIVER_PCICORE
+	depends on SSB_DRIVER_PCICORE
 	default y
 
 config B43_SDIO
 	bool "Broadcom 43xx SDIO device support"
 	depends on B43 && B43_SSB && SSB_SDIOHOST_POSSIBLE
-	select SSB_SDIOHOST
+	depends on SSB_SDIOHOST
 	help
 	  Broadcom 43xx device support for Soft-MAC SDIO devices.
 
@@ -96,13 +96,13 @@ config B43_SDIO
 config B43_BCMA_PIO
 	bool
 	depends on B43 && B43_BCMA
-	select BCMA_BLOCKIO
+	depends on BCMA_BLOCKIO
 	default y
 
 config B43_PIO
-	bool
+	bool "Broadcom 43xx PIO support"
 	depends on B43 && B43_SSB
-	select SSB_BLOCKIO
+	depends on SSB_BLOCKIO
 	default y
 
 config B43_PHY_G
diff --git a/drivers/net/wireless/broadcom/b43/Makefile b/drivers/net/wireless/broadcom/b43/Makefile
index f20b692..48589b5 100644
--- a/drivers/net/wireless/broadcom/b43/Makefile
+++ b/drivers/net/wireless/broadcom/b43/Makefile
@@ -18,7 +18,7 @@ b43-$(CPTCFG_B43_PHY_AC)	+= phy_ac.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= dma.o
-b43-y				+= pio.o
+b43-$(CPTCFG_B43_PIO)		+= pio.o
 b43-y				+= rfkill.o
 b43-y				+= ppr.o
 b43-$(CPTCFG_B43_LEDS)		+= leds.o
diff --git a/drivers/net/wireless/broadcom/b43/b43.h b/drivers/net/wireless/broadcom/b43/b43.h
index 0e4ea13..946cfe5 100644
--- a/drivers/net/wireless/broadcom/b43/b43.h
+++ b/drivers/net/wireless/broadcom/b43/b43.h
@@ -840,6 +840,9 @@ struct b43_wldev {
 	bool qos_enabled;		/* TRUE, if QoS is used. */
 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
 	bool use_pio;			/* TRUE if next init should use PIO */
+	int gpiomask;			/* GPIO LED mask as a module parameter */
+	int rx_antenna;			/* Used RX antenna (B43_ANTENNAxxx) */
+	int tx_antenna;			/* Used TX antenna (B43_ANTENNAxxx) */
 
 	/* PHY/Radio device. */
 	struct b43_phy phy;
diff --git a/drivers/net/wireless/broadcom/b43/dma.h b/drivers/net/wireless/broadcom/b43/dma.h
index dfebc64..ec72414 100644
--- a/drivers/net/wireless/broadcom/b43/dma.h
+++ b/drivers/net/wireless/broadcom/b43/dma.h
@@ -170,7 +170,7 @@ struct b43_dmadesc_generic {
 
 /* DMA engine tuning knobs */
 #define B43_TXRING_SLOTS		256
-#define B43_RXRING_SLOTS		256
+#define B43_RXRING_SLOTS		32
 #define B43_DMA0_RX_FW598_BUFSIZE	(B43_DMA0_RX_FW598_FO + IEEE80211_MAX_FRAME_LEN)
 #define B43_DMA0_RX_FW351_BUFSIZE	(B43_DMA0_RX_FW351_FO + IEEE80211_MAX_FRAME_LEN)
 
diff --git a/drivers/net/wireless/broadcom/b43/main.c b/drivers/net/wireless/broadcom/b43/main.c
index c2e0a05..76d2a87 100644
--- a/drivers/net/wireless/broadcom/b43/main.c
+++ b/drivers/net/wireless/broadcom/b43/main.c
@@ -72,6 +72,11 @@ MODULE_FIRMWARE("b43/ucode40.fw");
 MODULE_FIRMWARE("b43/ucode42.fw");
 MODULE_FIRMWARE("b43/ucode9.fw");
 
+static int modparam_gpiomask = 0x000F;
+module_param_named(gpiomask, modparam_gpiomask, int, 0444);
+MODULE_PARM_DESC(gpiomask,
+         "GPIO mask for LED control (default 0x000F)");
+
 static int modparam_bad_frames_preempt;
 module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
 MODULE_PARM_DESC(bad_frames_preempt,
@@ -109,7 +114,7 @@ static int b43_modparam_pio;
 module_param_named(pio, b43_modparam_pio, int, 0644);
 MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
 
-static int modparam_allhwsupport = !IS_ENABLED(CPTCFG_BRCMSMAC);
+static int modparam_allhwsupport = 1;
 module_param_named(allhwsupport, modparam_allhwsupport, int, 0444);
 MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
 
@@ -1638,7 +1643,7 @@ static void b43_write_beacon_template(struct b43_wldev *dev,
 				  len, ram_offset, shm_size_offset, rate);
 
 	/* Write the PHY TX control parameters. */
-	antenna = B43_ANTENNA_DEFAULT;
+	antenna = dev->tx_antenna;
 	antenna = b43_antenna_to_phyctl(antenna);
 	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
 	/* We can't send beacons with short preamble. Would get PHY errors. */
@@ -1996,10 +2001,12 @@ static void b43_do_interrupt_thread(struct b43_wldev *dev)
 			dma_reason[0], dma_reason[1],
 			dma_reason[2], dma_reason[3],
 			dma_reason[4], dma_reason[5]);
+#ifdef CPTCFG_B43_PIO
 		b43err(dev->wl, "This device does not support DMA "
 			       "on your system. It will now be switched to PIO.\n");
 		/* Fall back to PIO transfers if we get fatal DMA errors! */
 		dev->use_pio = true;
+#endif
 		b43_controller_restart(dev, "DMA error");
 		return;
 	}
@@ -2854,7 +2861,7 @@ static struct ssb_device *b43_ssb_gpio_dev(struct b43_wldev *dev)
 {
 	struct ssb_bus *bus = dev->dev->sdev->bus;
 
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
+#ifdef CONFIG_SSB_DRIVER_PCICORE
 	return (bus->chipco.dev ? bus->chipco.dev : bus->pcicore.dev);
 #else
 	return bus->chipco.dev;
@@ -2870,16 +2877,24 @@ static int b43_gpio_init(struct b43_wldev *dev)
 	u32 mask, set;
 
 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
-	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
+	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
 
 	mask = 0x0000001F;
-	set = 0x0000000F;
+	set = modparam_gpiomask;
 	if (dev->dev->chip_id == 0x4301) {
 		mask |= 0x0060;
 		set |= 0x0060;
 	} else if (dev->dev->chip_id == 0x5354) {
 		/* Don't allow overtaking buttons GPIOs */
 		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
+	} else if (dev->dev->chip_id == BCMA_CHIP_ID_BCM4716 || 
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM47162 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5356 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5357 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM53572) {
+		/* just use gpio 0 and 1 for 2.4 GHz wifi led */
+		set &= 0x3;
+		mask &= 0x3;
 	}
 
 	if (0 /* FIXME: conditional unknown */ ) {
@@ -3278,8 +3293,8 @@ static int b43_chip_init(struct b43_wldev *dev)
 
 	/* Select the antennae */
 	if (phy->ops->set_rx_antenna)
-		phy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);
-	b43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);
+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
 
 	if (phy->type == B43_PHYTYPE_B) {
 		value16 = b43_read16(dev, 0x005E);
@@ -3981,7 +3996,6 @@ static int b43_op_config(struct ieee80211_hw *hw, u32 changed)
 	struct b43_wldev *dev = wl->current_dev;
 	struct b43_phy *phy = &dev->phy;
 	struct ieee80211_conf *conf = &hw->conf;
-	int antenna;
 	int err = 0;
 
 	mutex_lock(&wl->mutex);
@@ -4024,11 +4038,9 @@ static int b43_op_config(struct ieee80211_hw *hw, u32 changed)
 	}
 
 	/* Antennas for RX and management frame TX. */
-	antenna = B43_ANTENNA_DEFAULT;
-	b43_mgmtframe_txantenna(dev, antenna);
-	antenna = B43_ANTENNA_DEFAULT;
+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
 	if (phy->ops->set_rx_antenna)
-		phy->ops->set_rx_antenna(dev, antenna);
+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
 
 	if (wl->radio_enabled != phy->radio_on) {
 		if (wl->radio_enabled) {
@@ -4873,7 +4885,7 @@ static int b43_wireless_core_init(struct b43_wldev *dev)
 	}
 	if (sprom->boardflags_lo & B43_BFL_XTAL_NOSLOW)
 		hf |= B43_HF_DSCRQ; /* Disable slowclock requests from ucode. */
-#if defined(CPTCFG_B43_SSB) && defined(CPTCFG_SSB_DRIVER_PCICORE)
+#if defined(CPTCFG_B43_SSB) && defined(CONFIG_SSB_DRIVER_PCICORE)
 	if (dev->dev->bus_type == B43_BUS_SSB &&
 	    dev->dev->sdev->bus->bustype == SSB_BUSTYPE_PCI &&
 	    dev->dev->sdev->bus->pcicore.dev->id.revision <= 10)
@@ -5171,6 +5183,47 @@ static int b43_op_get_survey(struct ieee80211_hw *hw, int idx,
 	return 0;
 }
 
+static int b43_op_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev = wl->current_dev;
+
+	if (tx_ant == 1 && rx_ant == 1) {
+		dev->tx_antenna = B43_ANTENNA0;
+		dev->rx_antenna = B43_ANTENNA0;
+	}
+	else if (tx_ant == 2 && rx_ant == 2) {
+		dev->tx_antenna = B43_ANTENNA1;
+		dev->rx_antenna = B43_ANTENNA1;
+	}
+	else if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3) {
+		dev->tx_antenna = B43_ANTENNA_DEFAULT;
+		dev->rx_antenna = B43_ANTENNA_DEFAULT;
+	}
+	else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int b43_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev = wl->current_dev;
+
+	switch (dev->tx_antenna) {
+	case B43_ANTENNA0:
+		*tx_ant = 1; *rx_ant = 1; break;
+	case B43_ANTENNA1:
+		*tx_ant = 2; *rx_ant = 2; break;
+	case B43_ANTENNA_DEFAULT:
+		*tx_ant = 3; *rx_ant = 3; break;
+	}
+	return 0;
+}
+
 static const struct ieee80211_ops b43_hw_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -5197,6 +5250,8 @@ static const struct ieee80211_ops b43_hw_ops = {
 	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
 	.get_survey		= b43_op_get_survey,
 	.rfkill_poll		= b43_rfkill_poll,
+	.set_antenna		= b43_op_set_antenna,
+	.get_antenna		= b43_op_get_antenna,
 };
 
 /* Hard-reset the chip. Do not call this directly.
@@ -5498,6 +5553,8 @@ static int b43_one_core_attach(struct b43_bus_dev *dev, struct b43_wl *wl)
 	if (!wldev)
 		goto out;
 
+	wldev->rx_antenna = B43_ANTENNA_DEFAULT;
+	wldev->tx_antenna = B43_ANTENNA_DEFAULT;
 	wldev->use_pio = b43_modparam_pio;
 	wldev->dev = dev;
 	wldev->wl = wl;
@@ -5589,6 +5646,9 @@ static struct b43_wl *b43_wireless_init(struct b43_bus_dev *dev)
 
 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
 
+	hw->wiphy->available_antennas_rx = 0x3;
+	hw->wiphy->available_antennas_tx = 0x3;
+
 	wl->hw_registered = false;
 	hw->max_rates = 2;
 	SET_IEEE80211_DEV(hw, dev->dev);
diff --git a/drivers/net/wireless/broadcom/b43/pio.h b/drivers/net/wireless/broadcom/b43/pio.h
index ffbfec6..a3742b7 100644
--- a/drivers/net/wireless/broadcom/b43/pio.h
+++ b/drivers/net/wireless/broadcom/b43/pio.h
@@ -151,7 +151,7 @@ static inline void b43_piorx_write32(struct b43_pio_rxqueue *q,
 	b43_write32(q->dev, q->mmio_base + offset, value);
 }
 
-
+#ifdef CPTCFG_B43_PIO
 int b43_pio_init(struct b43_wldev *dev);
 void b43_pio_free(struct b43_wldev *dev);
 
@@ -162,5 +162,37 @@ void b43_pio_rx(struct b43_pio_rxqueue *q);
 
 void b43_pio_tx_suspend(struct b43_wldev *dev);
 void b43_pio_tx_resume(struct b43_wldev *dev);
+#else
+static inline int b43_pio_init(struct b43_wldev *dev)
+{
+	return 0;
+}
+
+static inline void b43_pio_free(struct b43_wldev *dev)
+{
+}
+
+static inline int b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static inline void b43_pio_handle_txstatus(struct b43_wldev *dev,
+					   const struct b43_txstatus *status)
+{
+}
+
+static inline void b43_pio_rx(struct b43_pio_rxqueue *q)
+{
+}
+
+static inline void b43_pio_tx_suspend(struct b43_wldev *dev)
+{
+}
+
+static inline void b43_pio_tx_resume(struct b43_wldev *dev)
+{
+}
+#endif /* CPTCFG_B43_PIO */
 
 #endif /* B43_PIO_H_ */
diff --git a/drivers/net/wireless/broadcom/b43legacy/Kconfig b/drivers/net/wireless/broadcom/b43legacy/Kconfig
index 6ba7eb7..b924f63 100644
--- a/drivers/net/wireless/broadcom/b43legacy/Kconfig
+++ b/drivers/net/wireless/broadcom/b43legacy/Kconfig
@@ -3,7 +3,7 @@ config B43LEGACY
 	tristate "Broadcom 43xx-legacy wireless support (mac80211 stack)"
 	depends on m
 	depends on SSB_POSSIBLE && MAC80211 && HAS_DMA
-	select SSB
+	depends on SSB
 	depends on FW_LOADER
 	help
 	  b43legacy is a driver for 802.11b devices from Broadcom (BCM4301 and
@@ -25,15 +25,15 @@ config B43LEGACY
 config B43LEGACY_PCI_AUTOSELECT
 	bool
 	depends on B43LEGACY && SSB_PCIHOST_POSSIBLE
-	select SSB_PCIHOST
-	select SSB_B43_PCI_BRIDGE
+	depends on SSB_PCIHOST
+	depends on SSB_B43_PCI_BRIDGE
 	default y
 
 # Auto-select SSB PCICORE driver, if possible
 config B43LEGACY_PCICORE_AUTOSELECT
 	bool
 	depends on B43LEGACY && SSB_DRIVER_PCICORE_POSSIBLE
-	select SSB_DRIVER_PCICORE
+	depends on SSB_DRIVER_PCICORE
 	default y
 
 # LED support
diff --git a/drivers/net/wireless/broadcom/b43legacy/main.c b/drivers/net/wireless/broadcom/b43legacy/main.c
index edd91ff..0222f63 100644
--- a/drivers/net/wireless/broadcom/b43legacy/main.c
+++ b/drivers/net/wireless/broadcom/b43legacy/main.c
@@ -1907,7 +1907,7 @@ static int b43legacy_gpio_init(struct b43legacy_wldev *dev)
 	if (dev->dev->id.revision >= 2)
 		mask  |= 0x0010; /* FIXME: This is redundant. */
 
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
+#ifdef CONFIG_SSB_DRIVER_PCICORE
 	pcidev = bus->pcicore.dev;
 #endif
 	gpiodev = bus->chipco.dev ? : pcidev;
@@ -1926,7 +1926,7 @@ static void b43legacy_gpio_cleanup(struct b43legacy_wldev *dev)
 	struct ssb_bus *bus = dev->dev->bus;
 	struct ssb_device *gpiodev, *pcidev = NULL;
 
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
+#ifdef CONFIG_SSB_DRIVER_PCICORE
 	pcidev = bus->pcicore.dev;
 #endif
 	gpiodev = bus->chipco.dev ? : pcidev;
diff --git a/drivers/net/wireless/broadcom/brcm80211/Kconfig b/drivers/net/wireless/broadcom/brcm80211/Kconfig
index 400dc88..597a4c3 100644
--- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
+++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config BRCMUTIL
-	tristate
+	tristate "Broadcom 802.11 driver utility functions"
 	depends on m
 
 config BRCMSMAC
@@ -8,7 +8,7 @@ config BRCMSMAC
 	depends on m
 	depends on MAC80211
 	depends on BCMA_POSSIBLE
-	select BCMA
+	depends on BCMA
 	select BRCMUTIL
 	depends on FW_LOADER
 	depends on CORDIC
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index b99aa66..221d17a 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -980,8 +980,36 @@ static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
 	struct brcmf_pub *drvr = cfg->pub;
 	struct wireless_dev *wdev;
+	struct net_device *dev;
 	int err;
 
+	/*
+	 * There is a bug with in-firmware BSS management. When adding virtual
+	 * interface brcmfmac first tells firmware to create new BSS and then
+	 * it creates new struct net_device.
+	 *
+	 * If creating/registering netdev(ice) fails, BSS remains in some bugged
+	 * state. It conflicts with existing BSSes by overtaking their auth
+	 * requests.
+	 *
+	 * It results in one BSS (addresss X) sending beacons and another BSS
+	 * (address Y) replying to authentication requests. This makes interface
+	 * unusable as AP.
+	 *
+	 * To workaround this bug we may try to guess if register_netdev(ice)
+	 * will fail. The most obvious case is using interface name that already
+	 * exists. This is actually quite likely with brcmfmac & some user space
+	 * scripts as brcmfmac doesn't allow deleting virtual interfaces.
+	 * So this bug can be triggered even by something trivial like:
+	 * iw dev wlan0 delete
+	 * iw phy phy0 interface add wlan0 type __ap
+	 */
+	dev = dev_get_by_name(&init_net, name);
+	if (dev) {
+		dev_put(dev);
+		return ERR_PTR(-ENFILE);
+	}
+
 	brcmf_dbg(TRACE, "enter: %s type %d\n", name, type);
 	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
 	if (err) {
@@ -3285,6 +3313,10 @@ brcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
 	 * preference in cfg struct to apply this to
 	 * FW later while initializing the dongle
 	 */
+#if defined(CONFIG_ARCH_BCM2835)
+	brcmf_dbg(INFO, "power management disabled\n");
+	enabled = false;
+#endif
 	cfg->pwr_save = enabled;
 	if (!check_vif_up(ifp->vif)) {
 
@@ -7947,6 +7979,7 @@ static s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char alpha2[2],
 	return 0;
 }
 
+#if !defined(CONFIG_ARCH_BCM2835)
 static int
 brcmf_parse_dump_obss(char *buf, struct brcmf_dump_survey *survey)
 {
@@ -8169,6 +8202,7 @@ exit:
 		brcmf_set_mpc(ifp, 1);
 	return err;
 }
+#endif /* CONFIG_ARCH_BCM2835 */
 
 static void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,
 					struct regulatory_request *req)
@@ -8321,8 +8355,10 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))
 		ops->set_rekey_data = brcmf_cfg80211_set_rekey_data;
 #endif
+#if !defined(CONFIG_ARCH_BCM2835)
 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_DUMP_OBSS))
 		ops->dump_survey = brcmf_cfg80211_dump_survey;
+#endif /* CONFIG_ARCH_BCM2835 */
 
 	err = wiphy_register(wiphy);
 	if (err < 0) {
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
index dff464d..d051555 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
@@ -59,7 +59,11 @@ static int brcmf_fcmode;
 module_param_named(fcmode, brcmf_fcmode, int, 0);
 MODULE_PARM_DESC(fcmode, "Mode of firmware signalled flow control");
 
+#if defined(CONFIG_ARCH_BCM2835)
+static int brcmf_roamoff = 1;
+#else
 static int brcmf_roamoff;
+#endif
 module_param_named(roamoff, brcmf_roamoff, int, 0400);
 MODULE_PARM_DESC(roamoff, "Do not use internal roaming engine");
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
index e406e11..bfee039 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
@@ -65,6 +65,36 @@ static int brcmf_of_get_country_codes(struct device *dev,
 	return 0;
 }
 
+/* TODO: FIXME: Use DT */
+static void brcmf_of_probe_cc(struct device *dev,
+			      struct brcmf_mp_device *settings)
+{
+	static struct brcmfmac_pd_cc_entry netgear_r8000_cc_ent[] = {
+		{ "JP", "JP", 78 },
+		{ "US", "Q2", 86 },
+	};
+	struct brcmfmac_pd_cc_entry *cc_ent = NULL;
+	int table_size = 0;
+
+	if (of_machine_is_compatible("netgear,r8000")) {
+		cc_ent = netgear_r8000_cc_ent;
+		table_size = ARRAY_SIZE(netgear_r8000_cc_ent);
+	}
+
+	if (cc_ent && table_size) {
+		struct brcmfmac_pd_cc *cc;
+		size_t memsize;
+
+		memsize = table_size * sizeof(struct brcmfmac_pd_cc_entry);
+		cc = devm_kzalloc(dev, sizeof(*cc) + memsize, GFP_KERNEL);
+		if (!cc)
+			return;
+		cc->table_size = table_size;
+		memcpy(cc->table, cc_ent, memsize);
+		settings->country_codes = cc;
+	}
+}
+
 void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
 		    struct brcmf_mp_device *settings)
 {
@@ -113,6 +143,8 @@ void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
 		of_node_put(root);
 	}
 
+	brcmf_of_probe_cc(dev, settings);
+
 	if (!np || !of_device_is_compatible(np, "brcm,bcm4329-fmac"))
 		return;
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
index 0ccf735..dc61984 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
@@ -1581,7 +1581,11 @@ static int brcmf_usb_reset_device(struct device *dev, void *notused)
 
 void brcmf_usb_exit(void)
 {
+#if LINUX_VERSION_IS_GEQ(6,8,0)
 	struct device_driver *drv = &brcmf_usbdrvr.driver;
+#else
+	struct device_driver *drv = &brcmf_usbdrvr.drvwrap.driver;
+#endif
 	int ret;
 
 	brcmf_dbg(USB, "Enter\n");
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
index f6962e5..7746f1f 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
@@ -58,19 +58,12 @@
 				 (((c) < 149) ? 3 : 4))))
 
 #define BRCM_2GHZ_2412_2462	REG_RULE(2412-10, 2462+10, 40, 0, 19, 0)
-#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, \
-					 NL80211_RRF_NO_IR)
-
-#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, \
-					 NL80211_RRF_DFS | \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, \
-					 NL80211_RRF_DFS | \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, \
-					 NL80211_RRF_NO_IR)
+#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, 0)
+
+#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, 0)
 
 static const struct ieee80211_regdomain brcms_regdom_x2 = {
 	.n_reg_rules = 6,
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
index 61a4638..2dffa4a 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
@@ -689,13 +689,23 @@ static void iwl_mvm_thermal_zone_register(struct iwl_mvm *mvm)
 	for (i = 0 ; i < IWL_MAX_DTS_TRIPS; i++) {
 		mvm->tz_device.trips[i].temperature = THERMAL_TEMP_INVALID;
 		mvm->tz_device.trips[i].type = THERMAL_TRIP_PASSIVE;
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 		mvm->tz_device.trips[i].flags = THERMAL_TRIP_FLAG_RW_TEMP;
+#endif
 	}
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 	mvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,
 							mvm->tz_device.trips,
 							IWL_MAX_DTS_TRIPS,
 							mvm, &tzone_ops,
 							NULL, 0, 0);
+#else
+	mvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,
+							mvm->tz_device.trips,
+							IWL_MAX_DTS_TRIPS, 0,
+							mvm, &tzone_ops,
+							NULL, 0, 0);
+#endif
 	if (IS_ERR(mvm->tz_device.tzone)) {
 		IWL_DEBUG_TEMP(mvm,
 			       "Failed to register to thermal zone (err = %ld)\n",
diff --git a/drivers/net/wireless/marvell/libertas/cfg.c b/drivers/net/wireless/marvell/libertas/cfg.c
index b700c21..5a37686 100644
--- a/drivers/net/wireless/marvell/libertas/cfg.c
+++ b/drivers/net/wireless/marvell/libertas/cfg.c
@@ -2101,6 +2101,8 @@ struct wireless_dev *lbs_cfg_alloc(struct device *dev)
 		goto err_wiphy_new;
 	}
 
+	set_wiphy_dev(wdev->wiphy, dev);
+
 	return wdev;
 
  err_wiphy_new:
@@ -2176,6 +2178,8 @@ int lbs_cfg_register(struct lbs_private *priv)
 	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
 	wdev->wiphy->reg_notifier = lbs_reg_notifier;
 
+	memcpy(wdev->wiphy->perm_addr, priv->current_addr, ETH_ALEN);
+
 	ret = wiphy_register(wdev->wiphy);
 	if (ret < 0)
 		pr_err("cannot register wiphy device\n");
diff --git a/drivers/net/wireless/marvell/libertas/main.c b/drivers/net/wireless/marvell/libertas/main.c
index 78e8b5a..b56a495 100644
--- a/drivers/net/wireless/marvell/libertas/main.c
+++ b/drivers/net/wireless/marvell/libertas/main.c
@@ -935,6 +935,7 @@ struct lbs_private *lbs_add_card(void *card, struct device *dmdev)
 		goto err_adapter;
 	}
 
+	dev_net_set(dev, wiphy_net(wdev->wiphy));
 	dev->ieee80211_ptr = wdev;
 	dev->ml_priv = priv;
 	SET_NETDEV_DEV(dev, dmdev);
diff --git a/drivers/net/wireless/marvell/mwifiex/cmdevt.c b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
index 9eff29a..e7129c3 100644
--- a/drivers/net/wireless/marvell/mwifiex/cmdevt.c
+++ b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
@@ -16,6 +16,85 @@
 
 static void mwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter);
 
+const char *
+mwifiex_cmd_to_str(u16 command)
+{
+	switch (command) {
+	case HostCmd_CMD_GET_HW_SPEC:			return "GET_HW_SPEC";
+	case HostCmd_CMD_802_11_SCAN:			return "SCAN";
+	case HostCmd_CMD_802_11_GET_LOG:		return "GET_LOG";
+	case HostCmd_CMD_MAC_MULTICAST_ADR:		return "MAC_MULTICAST_ADR";
+	case HostCmd_CMD_802_11_EEPROM_ACCESS:		return "EEPROM_ACCESS";
+	case HostCmd_CMD_802_11_ASSOCIATE:		return "ASSOCIATE";
+	case HostCmd_CMD_802_11_SNMP_MIB:		return "SNMP_MIB";
+	case HostCmd_CMD_MAC_REG_ACCESS:		return "MAC_REG_ACCESS";
+	case HostCmd_CMD_BBP_REG_ACCESS:		return "BBP_REG_ACCESS";
+	case HostCmd_CMD_RF_REG_ACCESS:			return "RF_REG_ACCESS";
+	case HostCmd_CMD_PMIC_REG_ACCESS:		return "PMIC_REG_ACCESS";
+	case HostCmd_CMD_RF_TX_PWR:			return "RF_TX_PWR";
+	case HostCmd_CMD_RF_ANTENNA:			return "RF_ANTENNA";
+	case HostCmd_CMD_802_11_DEAUTHENTICATE:		return "DEAUTHENTICATE";
+	case HostCmd_CMD_MAC_CONTROL:			return "MAC_CONTROL";
+	case HostCmd_CMD_802_11_AD_HOC_START:		return "AD_HOC_START";
+	case HostCmd_CMD_802_11_AD_HOC_JOIN:		return "AD_HOC_JOIN";
+	case HostCmd_CMD_802_11_AD_HOC_STOP:		return "AD_HOC_STOP";
+	case HostCmd_CMD_802_11_MAC_ADDRESS:		return "MAC_ADDRESS";
+	case HostCmd_CMD_802_11D_DOMAIN_INFO:		return "DOMAIN_INFO";
+	case HostCmd_CMD_802_11_KEY_MATERIAL:		return "KEY_MATERIAL";
+	case HostCmd_CMD_802_11_BG_SCAN_CONFIG:		return "BG_SCAN_CONFIG";
+	case HostCmd_CMD_802_11_BG_SCAN_QUERY:		return "BG_SCAN_QUERY";
+	case HostCmd_CMD_WMM_GET_STATUS:		return "WMM_GET_STATUS";
+	case HostCmd_CMD_802_11_SUBSCRIBE_EVENT:	return "SUBSCRIBE_EVENT";
+	case HostCmd_CMD_802_11_TX_RATE_QUERY:		return "TX_RATE_QUERY";
+	case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:	return "IBSS_COALESCING_STATUS";
+	case HostCmd_CMD_MEM_ACCESS:			return "MEM_ACCESS";
+	case HostCmd_CMD_CFG_DATA:			return "CFG_DATA";
+	case HostCmd_CMD_VERSION_EXT:			return "VERSION_EXT";
+	case HostCmd_CMD_MEF_CFG:			return "MEF_CFG";
+	case HostCmd_CMD_RSSI_INFO:			return "RSSI_INFO";
+	case HostCmd_CMD_FUNC_INIT:			return "FUNC_INIT";
+	case HostCmd_CMD_FUNC_SHUTDOWN:			return "FUNC_SHUTDOWN";
+	case HOST_CMD_APCMD_SYS_RESET:			return "SYS_RESET";
+	case HostCmd_CMD_UAP_SYS_CONFIG:		return "UAP_SYS_CONFIG";
+	case HostCmd_CMD_UAP_BSS_START:			return "UAP_BSS_START";
+	case HostCmd_CMD_UAP_BSS_STOP:			return "UAP_BSS_STOP";
+	case HOST_CMD_APCMD_STA_LIST:			return "STA_LIST";
+	case HostCmd_CMD_UAP_STA_DEAUTH:		return "UAP_STA_DEAUTH";
+	case HostCmd_CMD_11N_CFG:			return "11N_CFG";
+	case HostCmd_CMD_11N_ADDBA_REQ:			return "ADDBA_REQ";
+	case HostCmd_CMD_11N_ADDBA_RSP:			return "ADDBA_RSP";
+	case HostCmd_CMD_11N_DELBA:			return "DELBA";
+	case HostCmd_CMD_RECONFIGURE_TX_BUFF:		return "RECONFIGURE_TX_BUFF";
+	case HostCmd_CMD_CHAN_REPORT_REQUEST:		return "CHAN_REPORT_REQUEST";
+	case HostCmd_CMD_AMSDU_AGGR_CTRL:		return "AMSDU_AGGR_CTRL";
+	case HostCmd_CMD_TXPWR_CFG:			return "TXPWR_CFG";
+	case HostCmd_CMD_TX_RATE_CFG:			return "TX_RATE_CFG";
+	case HostCmd_CMD_ROBUST_COEX:			return "ROBUST_COEX";
+	case HostCmd_CMD_802_11_PS_MODE_ENH:		return "PS_MODE_ENH";
+	case HostCmd_CMD_802_11_HS_CFG_ENH:		return "HS_CFG_ENH";
+	case HostCmd_CMD_P2P_MODE_CFG:			return "P2P_MODE_CFG";
+	case HostCmd_CMD_CAU_REG_ACCESS:		return "CAU_REG_ACCESS";
+	case HostCmd_CMD_SET_BSS_MODE:			return "SET_BSS_MODE";
+	case HostCmd_CMD_PCIE_DESC_DETAILS:		return "PCIE_DESC_DETAILS";
+	case HostCmd_CMD_802_11_SCAN_EXT:		return "SCAN_EXT";
+	case HostCmd_CMD_COALESCE_CFG:			return "COALESCE_CFG";
+	case HostCmd_CMD_MGMT_FRAME_REG:		return "MGMT_FRAME_REG";
+	case HostCmd_CMD_REMAIN_ON_CHAN:		return "REMAIN_ON_CHAN";
+	case HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:		return "GTK_REKEY_OFFLOAD_CFG";
+	case HostCmd_CMD_11AC_CFG:			return "11AC_CFG";
+	case HostCmd_CMD_HS_WAKEUP_REASON:		return "HS_WAKEUP_REASON";
+	case HostCmd_CMD_TDLS_CONFIG:			return "TDLS_CONFIG";
+	case HostCmd_CMD_MC_POLICY:			return "MC_POLICY";
+	case HostCmd_CMD_TDLS_OPER:			return "TDLS_OPER";
+	case HostCmd_CMD_FW_DUMP_EVENT:			return "FW_DUMP_EVENT";
+	case HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:		return "SDIO_SP_RX_AGGR_CFG";
+	case HostCmd_CMD_STA_CONFIGURE:			return "STA_CONFIGURE";
+	case HostCmd_CMD_CHAN_REGION_CFG:		return "CHAN_REGION_CFG";
+	case HostCmd_CMD_PACKET_AGGR_CTRL:		return "PACKET_AGGR_CTRL";
+	default:					return "UNKNOWN";
+	}
+}
+
 /*
  * This function initializes a command node.
  *
@@ -193,8 +272,8 @@ static int mwifiex_dnld_cmd_to_fw(struct mwifiex_private *priv,
 	    cmd_code != HostCmd_CMD_FUNC_SHUTDOWN &&
 	    cmd_code != HostCmd_CMD_FUNC_INIT) {
 		mwifiex_dbg(adapter, ERROR,
-			    "DNLD_CMD: FW in reset state, ignore cmd %#x\n",
-			cmd_code);
+			    "DNLD_CMD: FW in reset state, ignore cmd %s (%#x)\n",
+			    mwifiex_cmd_to_str(cmd_code), cmd_code);
 		mwifiex_recycle_cmd_node(adapter, cmd_node);
 		queue_work(adapter->workqueue, &adapter->main_work);
 		return -1;
@@ -653,8 +732,8 @@ int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,
 	/* Return error, since the command preparation failed */
 	if (ret) {
 		mwifiex_dbg(adapter, ERROR,
-			    "PREP_CMD: cmd %#x preparation failed\n",
-			cmd_no);
+			    "PREP_CMD: cmd %s (%#x) preparation failed\n",
+			    mwifiex_cmd_to_str(cmd_no), cmd_no);
 		mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
 		return -1;
 	}
@@ -902,8 +981,9 @@ int mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)
 	if (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {
 		if (ret) {
 			mwifiex_dbg(adapter, ERROR,
-				    "%s: cmd %#x failed during\t"
-				    "initialization\n", __func__, cmdresp_no);
+				    "%s: cmd %s (%#x) failed during\t"
+				    "initialization\n", __func__,
+				    mwifiex_cmd_to_str(cmdresp_no), cmdresp_no);
 			mwifiex_init_fw_complete(adapter);
 			return -1;
 		} else if (adapter->last_init_cmd == cmdresp_no)
@@ -1265,8 +1345,8 @@ mwifiex_process_sleep_confirm_resp(struct mwifiex_adapter *adapter,
 
 	if (command != HostCmd_CMD_802_11_PS_MODE_ENH) {
 		mwifiex_dbg(adapter, ERROR,
-			    "%s: rcvd unexpected resp for cmd %#x, result = %x\n",
-			    __func__, command, result);
+			    "%s: rcvd unexpected resp for cmd %s (%#x), result = %x\n",
+			    __func__, mwifiex_cmd_to_str(command), command, result);
 		return;
 	}
 
diff --git a/drivers/net/wireless/marvell/mwifiex/decl.h b/drivers/net/wireless/marvell/mwifiex/decl.h
index 326ffb0..6e1c423 100644
--- a/drivers/net/wireless/marvell/mwifiex/decl.h
+++ b/drivers/net/wireless/marvell/mwifiex/decl.h
@@ -18,7 +18,7 @@
 #include <net/cfg80211.h>
 
 #define MWIFIEX_BSS_COEX_COUNT	     2
-#define MWIFIEX_MAX_BSS_NUM         (3)
+#define MWIFIEX_MAX_BSS_NUM         (4)
 
 #define MWIFIEX_DMA_ALIGN_SZ	    64
 #define MWIFIEX_RX_HEADROOM	    64
@@ -100,7 +100,7 @@
 #define MWIFIEX_RATE_INDEX_OFDM0   4
 
 #define MWIFIEX_MAX_STA_NUM		3
-#define MWIFIEX_MAX_UAP_NUM		3
+#define MWIFIEX_MAX_UAP_NUM		4
 #define MWIFIEX_MAX_P2P_NUM		3
 
 #define MWIFIEX_A_BAND_START_FREQ	5000
diff --git a/drivers/net/wireless/marvell/mwifiex/main.h b/drivers/net/wireless/marvell/mwifiex/main.h
index 1758824..b3a1341 100644
--- a/drivers/net/wireless/marvell/mwifiex/main.h
+++ b/drivers/net/wireless/marvell/mwifiex/main.h
@@ -1084,6 +1084,8 @@ void mwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter);
 void mwifiex_cancel_pending_scan_cmd(struct mwifiex_adapter *adapter);
 void mwifiex_cancel_scan(struct mwifiex_adapter *adapter);
 
+const char *mwifiex_cmd_to_str(u16 command);
+
 void mwifiex_recycle_cmd_node(struct mwifiex_adapter *adapter,
 			      struct cmd_ctrl_node *cmd_node);
 
diff --git a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
index 7b69d27..d1c8b16 100644
--- a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
+++ b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
@@ -36,8 +36,9 @@ mwifiex_process_cmdresp_error(struct mwifiex_private *priv,
 	struct host_cmd_ds_802_11_ps_mode_enh *pm;
 
 	mwifiex_dbg(adapter, ERROR,
-		    "CMD_RESP: cmd %#x error, result=%#x\n",
-		    resp->command, resp->result);
+		    "CMD_RESP: cmd %s (%#x) error, result=%#x\n",
+		    mwifiex_cmd_to_str(le16_to_cpu(resp->command)),
+		    le16_to_cpu(resp->command), le16_to_cpu(resp->result));
 
 	if (adapter->curr_cmd->wait_q_enabled)
 		adapter->cmd_wait_q.status = -1;
diff --git a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
index 491e366..2efa858 100644
--- a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
+++ b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
@@ -802,7 +802,8 @@ int mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,
 		break;
 	default:
 		mwifiex_dbg(priv->adapter, ERROR,
-			    "PREP_CMD: unknown cmd %#x\n", cmd_no);
+			    "PREP_CMD: unknown cmd (%s) %#x\n",
+			    mwifiex_cmd_to_str(cmd_no), cmd_no);
 		return -1;
 	}
 
diff --git a/drivers/net/wireless/marvell/mwl8k.c b/drivers/net/wireless/marvell/mwl8k.c
index 7a4ef5c..1f63d93 100644
--- a/drivers/net/wireless/marvell/mwl8k.c
+++ b/drivers/net/wireless/marvell/mwl8k.c
@@ -5707,6 +5707,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw");
 MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
 
 static const struct pci_device_id mwl8k_pci_id_table[] = {
+	{ PCI_VDEVICE(MARVELL, 0x2a02), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },
@@ -6292,6 +6293,8 @@ static int mwl8k_probe(struct pci_dev *pdev,
 
 	priv->running_bsses = 0;
 
+	wait_for_completion(&priv->firmware_loading_complete);
+
 	return rc;
 
 err_stop_firmware:
@@ -6325,8 +6328,6 @@ static void mwl8k_remove(struct pci_dev *pdev)
 		return;
 	priv = hw->priv;
 
-	wait_for_completion(&priv->firmware_loading_complete);
-
 	if (priv->fw_state == FW_STATE_ERROR) {
 		mwl8k_hw_reset(priv);
 		goto unmap;
diff --git a/drivers/net/wireless/mediatek/mt7601u/usb.h b/drivers/net/wireless/mediatek/mt7601u/usb.h
index 9fdf359..66481b7 100644
--- a/drivers/net/wireless/mediatek/mt7601u/usb.h
+++ b/drivers/net/wireless/mediatek/mt7601u/usb.h
@@ -8,7 +8,7 @@
 
 #include "mt7601u.h"
 
-#define MT7601U_FIRMWARE	"mt7601u.bin"
+#define MT7601U_FIRMWARE	"mediatek/mt7601u.bin"
 
 #define MT_VEND_REQ_MAX_RETRY	10
 #define MT_VEND_REQ_TOUT_MS	300
diff --git a/drivers/net/wireless/ralink/rt2x00/Kconfig b/drivers/net/wireless/ralink/rt2x00/Kconfig
index 8f6e3d2..abaa51b 100644
--- a/drivers/net/wireless/ralink/rt2x00/Kconfig
+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
@@ -70,6 +70,7 @@ config RT2800PCI
 	select RT2X00_LIB_MMIO
 	select RT2X00_LIB_PCI
 	select RT2X00_LIB_FIRMWARE
+	select RT2X00_LIB_EEPROM
 	select RT2X00_LIB_CRYPTO
 	depends on CRC_CCITT
 	depends on EEPROM_93CX6
@@ -211,13 +212,15 @@ endif
 config RT2800SOC
 	tristate "Ralink WiSoC support"
 	depends on m
-	depends on SOC_RT288X || SOC_RT305X || SOC_MT7620
+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620
 	select RT2X00_LIB_SOC
 	select RT2X00_LIB_MMIO
 	select RT2X00_LIB_CRYPTO
 	select RT2X00_LIB_FIRMWARE
+	select RT2X00_LIB_EEPROM
 	select RT2800_LIB
 	select RT2800_LIB_MMIO
+	select MTD if SOC_RT288X || SOC_RT305X
 	help
 	  This adds support for Ralink WiSoC devices.
 	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
@@ -226,36 +229,37 @@ config RT2800SOC
 
 
 config RT2800_LIB
-	tristate
+	tristate "RT2800 USB/PCI support"
 	depends on m
 
 config RT2800_LIB_MMIO
-	tristate
+	tristate "RT2800 MMIO support"
 	depends on m
 	select RT2X00_LIB_MMIO
 	select RT2800_LIB
 
 config RT2X00_LIB_MMIO
-	tristate
+	tristate "RT2x00 MMIO support"
 	depends on m
 
 config RT2X00_LIB_PCI
-	tristate
+	tristate "RT2x00 PCI support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB_SOC
-	tristate
+	tristate "RT2x00 SoC support"
+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB_USB
-	tristate
+	tristate "RT2x00 USB support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB
-	tristate
+	tristate "RT2x00 support"
 	depends on m
 
 config RT2X00_LIB_FIRMWARE
@@ -265,6 +269,9 @@ config RT2X00_LIB_FIRMWARE
 config RT2X00_LIB_CRYPTO
 	bool
 
+config RT2X00_LIB_EEPROM
+	bool
+
 config RT2X00_LIB_LEDS
 	bool
 	default y if (RT2X00_LIB=y && LEDS_CLASS=y) || (RT2X00_LIB=m && LEDS_CLASS!=n)
diff --git a/drivers/net/wireless/ralink/rt2x00/Makefile b/drivers/net/wireless/ralink/rt2x00/Makefile
index 4a2156b..94335ec 100644
--- a/drivers/net/wireless/ralink/rt2x00/Makefile
+++ b/drivers/net/wireless/ralink/rt2x00/Makefile
@@ -8,6 +8,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+= rt2x00debug.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
 
 obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
 obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800.h b/drivers/net/wireless/ralink/rt2x00/rt2800.h
index 8930589..cbfa680 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
@@ -1056,6 +1056,11 @@
 #define MIMO_PS_CFG_RX_STBY_POL		FIELD32(0x00000010)
 #define MIMO_PS_CFG_RX_RX_STBY0		FIELD32(0x00000020)
 
+#define BB_PA_MODE_CFG0			0x1214
+#define BB_PA_MODE_CFG1			0x1218
+#define RF_PA_MODE_CFG0			0x121C
+#define RF_PA_MODE_CFG1			0x1220
+
 /*
  * EDCA_AC0_CFG:
  */
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
index d2ab374..7461d2e 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
@@ -25,6 +25,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 #include "rt2x00.h"
 #include "rt2800lib.h"
@@ -304,6 +305,24 @@ static void rt2800_rf_write(struct rt2x00_dev *rt2x00dev,
 	mutex_unlock(&rt2x00dev->csr_mutex);
 }
 
+void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
+{
+	if (!rt2x00dev->pinctrl)
+		return;
+
+	if (enable) {
+		if (!rt2x00dev->pins_default)
+			return;
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_default);
+	} else {
+		if (!rt2x00dev->pins_pa_gpio)
+			return;
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_pa_gpio);
+	}
+}
+
 static const unsigned int rt2800_eeprom_map[EEPROM_WORD_COUNT] = {
 	[EEPROM_CHIP_ID]		= 0x0000,
 	[EEPROM_VERSION]		= 0x0001,
@@ -3817,14 +3836,16 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 	rt2x00_set_field8(&rfcsr, RFCSR19_K, rf->rf4);
 	rt2800_rfcsr_write(rt2x00dev, 19, rfcsr);
 
-	/* Default: XO=20MHz , SDM mode */
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
-	rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 0x80);
-	rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		/* Default: XO=20MHz , SDM mode */
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
+		rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 0x80);
+		rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
 
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
-	rt2x00_set_field8(&rfcsr, RFCSR21_BIT8, 1);
-	rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
+		rt2x00_set_field8(&rfcsr, RFCSR21_BIT8, 1);
+		rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
+	}
 
 	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
 	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_EN_MT7620,
@@ -3858,18 +3879,23 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x20);
 	}
 
-	if (conf_is_ht40(conf)) {
-		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
-		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
-	} else {
-		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
-		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		if (conf_is_ht40(conf)) {
+			rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
+			rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
+		} else {
+			rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
+			rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
+		}
 	}
 
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 28);
-	rt2x00_set_field8(&rfcsr, RFCSR28_CH11_HT40,
-			  conf_is_ht40(conf) && (rf->channel == 11));
-	rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) == 2) {
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 28);
+		rt2x00_set_field8(&rfcsr, RFCSR28_CH11_HT40,
+				  conf_is_ht40(conf) && (rf->channel == 11));
+		rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
+	}
 
 	if (!test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags)) {
 		if (conf_is_ht40(conf)) {
@@ -3983,25 +4009,29 @@ static void rt2800_config_alc_rt6352(struct rt2x00_dev *rt2x00dev,
 	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
 		rt2x00_warn(rt2x00dev, "RF busy while configuring ALC\n");
 
-	if (chan->center_freq > 2457) {
-		bbp = rt2800_bbp_read(rt2x00dev, 30);
-		bbp = 0x40;
-		rt2800_bbp_write(rt2x00dev, 30, bbp);
-		rt2800_rfcsr_write(rt2x00dev, 39, 0);
-		if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
-			rt2800_rfcsr_write(rt2x00dev, 42, 0xfb);
-		else
-			rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
-	} else {
-		bbp = rt2800_bbp_read(rt2x00dev, 30);
-		bbp = 0x1f;
-		rt2800_bbp_write(rt2x00dev, 30, bbp);
-		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
-		if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
-			rt2800_rfcsr_write(rt2x00dev, 42, 0xdb);
-		else
-			rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		if (chan->center_freq > 2457) {
+			bbp = rt2800_bbp_read(rt2x00dev, 30);
+			bbp = 0x40;
+			rt2800_bbp_write(rt2x00dev, 30, bbp);
+			rt2800_rfcsr_write(rt2x00dev, 39, 0);
+			if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
+				rt2800_rfcsr_write(rt2x00dev, 42, 0xfb);
+			else
+				rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
+		} else {
+			bbp = rt2800_bbp_read(rt2x00dev, 30);
+			bbp = 0x1f;
+			rt2800_bbp_write(rt2x00dev, 30, bbp);
+			rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+			if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
+				rt2800_rfcsr_write(rt2x00dev, 42, 0xdb);
+			else
+				rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
+		}
 	}
+
 	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, mac_sys_ctrl);
 
 	rt2800_vco_calibration(rt2x00dev);
@@ -4494,7 +4524,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 	if (rt2x00_rt(rt2x00dev, RT6352)) {
 		/* BBP for GLRT BW */
 		bbp = conf_is_ht40(conf) ?
-		      0x10 : rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
+		      0x10 : !rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
+		      0x1a : rt2800_hw_get_chippkg(rt2x00dev) == 1 ?
 		      0x15 : 0x1a;
 		rt2800_bbp_glrt_write(rt2x00dev, 141, bbp);
 
@@ -5998,18 +6029,33 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
 	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
 	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
-		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
-		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
-		rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
-		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN, 0x6C6C666C);
-		rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN, 0x6C6C666C);
-		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
-				      0x3630363A);
-		rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
-				      0x3630363A);
+		if (rt2800_hw_get_chipver(rt2x00dev) <= 1) {
+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3,
+					      0x00000000);
+			rt2800_register_write(rt2x00dev, BB_PA_MODE_CFG0,
+					      0x000055FF);
+			rt2800_register_write(rt2x00dev, BB_PA_MODE_CFG1,
+					      0x00550055);
+			rt2800_register_write(rt2x00dev, RF_PA_MODE_CFG0,
+					      0x000055FF);
+			rt2800_register_write(rt2x00dev, RF_PA_MODE_CFG1,
+					      0x00550055);
+		} else {
+			rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
+			rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
+			rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
+			rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
+			rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN,
+					      0x6C6C666C);
+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
+					      0x6C6C666C);
+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
+					      0x3630363A);
+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
+					      0x3630363A);
+		}
 		reg = rt2800_register_read(rt2x00dev, TX_ALC_CFG_1);
 		rt2x00_set_field32(&reg, TX_ALC_CFG_1_ROS_BUSY_EN, 0);
 		rt2800_register_write(rt2x00dev, TX_ALC_CFG_1, reg);
@@ -7122,14 +7168,16 @@ static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 188, 0x00);
 	rt2800_bbp_write(rt2x00dev, 189, 0x00);
 
-	rt2800_bbp_write(rt2x00dev, 91, 0x06);
-	rt2800_bbp_write(rt2x00dev, 92, 0x04);
-	rt2800_bbp_write(rt2x00dev, 93, 0x54);
-	rt2800_bbp_write(rt2x00dev, 99, 0x50);
-	rt2800_bbp_write(rt2x00dev, 148, 0x84);
-	rt2800_bbp_write(rt2x00dev, 167, 0x80);
-	rt2800_bbp_write(rt2x00dev, 178, 0xFF);
-	rt2800_bbp_write(rt2x00dev, 106, 0x13);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_bbp_write(rt2x00dev, 91, 0x06);
+		rt2800_bbp_write(rt2x00dev, 92, 0x04);
+		rt2800_bbp_write(rt2x00dev, 93, 0x54);
+		rt2800_bbp_write(rt2x00dev, 99, 0x50);
+		rt2800_bbp_write(rt2x00dev, 148, 0x84);
+		rt2800_bbp_write(rt2x00dev, 167, 0x80);
+		rt2800_bbp_write(rt2x00dev, 178, 0xFF);
+		rt2800_bbp_write(rt2x00dev, 106, 0x13);
+	}
 
 	/* BBP for G band GLRT function (BBP_128 ~ BBP_221) */
 	rt2800_bbp_glrt_write(rt2x00dev, 0, 0x00);
@@ -10359,6 +10407,9 @@ static void rt2800_restore_rf_bbp_rt6352(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, RF_BYPASS3, 0x0);
 	}
 
+	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
+		return;
+
 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
@@ -10403,8 +10454,10 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 	u32 reg;
 
 	if (rt2x00_has_cap_external_pa(rt2x00dev) ||
-	    rt2x00_has_cap_external_lna_bg(rt2x00dev))
+	    rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
+		rt6352_enable_pa_pin(rt2x00dev, 0);
 		rt2800_restore_rf_bbp_rt6352(rt2x00dev);
+	}
 
 	rt2800_r_calibration(rt2x00dev);
 	rt2800_rf_self_txdc_cal(rt2x00dev);
@@ -10422,6 +10475,8 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 	    !rt2x00_has_cap_external_lna_bg(rt2x00dev))
 		return;
 
+	rt6352_enable_pa_pin(rt2x00dev, 1);
+
 	if (rt2x00_has_cap_external_pa(rt2x00dev)) {
 		reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
 		reg |= 0x00000101;
@@ -10432,6 +10487,9 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
 	}
 
+	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
+		return;
+
 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
@@ -10522,31 +10580,36 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
 	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
 
-	rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
-	if (rt2800_clk_is_20mhz(rt2x00dev))
-		rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
-	else
-		rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
-	rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
-	rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
-	rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
-	rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
-	rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
-	rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
-	rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
-	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
-	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
-	rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
-	rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
+		if (rt2800_clk_is_20mhz(rt2x00dev))
+			rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
+		else
+			rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
+		rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
+		rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
+		rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
+		rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
+		rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
+		rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
+		rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
+		rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
+		rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
+		rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
+		rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
+	}
 
-	rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
-	rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
-	rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
+		rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
+		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+	}
 
 	/* Initialize RF channel register to default value */
 	rt2800_rfcsr_write_chanreg(rt2x00dev, 0, 0x03);
@@ -10612,63 +10675,71 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 
 	rt2800_rfcsr_write_bank(rt2x00dev, 6, 45, 0xC5);
 
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
-	rt2800_rfcsr_write_bank(rt2x00dev, 4, 47, 0x67);
-	rt2800_rfcsr_write_bank(rt2x00dev, 6, 47, 0x69);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
-	rt2800_rfcsr_write_bank(rt2x00dev, 4, 54, 0x27);
-	rt2800_rfcsr_write_bank(rt2x00dev, 6, 54, 0x20);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
-
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
-
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-
-	/* Initialize RF channel register for DRQFN */
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
+		rt2800_rfcsr_write_bank(rt2x00dev, 4, 47, 0x67);
+		rt2800_rfcsr_write_bank(rt2x00dev, 6, 47, 0x69);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
+		rt2800_rfcsr_write_bank(rt2x00dev, 4, 54, 0x27);
+		rt2800_rfcsr_write_bank(rt2x00dev, 6, 54, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
+	}
+
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
+
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+	}
+
+	if (rt2800_hw_get_chippkg(rt2x00dev) == 0 &&
+	    rt2800_hw_get_chipver(rt2x00dev) == 1) {
+		/* Initialize RF channel register for DRQFN */
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
+	}
 
 	/* Initialize RF DC calibration register to default value */
 	rt2800_rfcsr_write_dccal(rt2x00dev, 0, 0x47);
@@ -10731,12 +10802,17 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write_dccal(rt2x00dev, 62, 0x00);
 	rt2800_rfcsr_write_dccal(rt2x00dev, 63, 0x00);
 
-	rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
+	}
 
-	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+	}
 
 	/* Do calibration and init PA/LNA */
 	rt2800_calibration_rt6352(rt2x00dev);
@@ -11282,6 +11358,17 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
 
+	{
+		struct device_node *np = rt2x00dev->dev->of_node;
+		unsigned int led_polarity;
+
+		/* Allow overriding polarity from OF */
+		if (!of_property_read_u32(np, "ralink,led-polarity",
+					  &led_polarity))
+			rt2x00_set_field16(&eeprom, EEPROM_FREQ_LED_POLARITY,
+					   led_polarity);
+	}
+
 	rt2x00dev->led_mcu_reg = eeprom;
 #endif /* CPTCFG_RT2X00_LIB_LEDS */
 
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
index 194de67..a18140c 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
@@ -76,6 +76,9 @@ struct rt2800_ops {
 	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
 	unsigned int (*drv_get_dma_done)(struct data_queue *queue);
+	int (*hw_get_chippkg)(void);
+	int (*hw_get_chipver)(void);
+	int (*hw_get_chipeco)(void);
 };
 
 static inline u32 rt2800_register_read(struct rt2x00_dev *rt2x00dev,
@@ -184,6 +187,27 @@ static inline unsigned int rt2800_drv_get_dma_done(struct data_queue *queue)
 	return rt2800ops->drv_get_dma_done(queue);
 }
 
+static inline int rt2800_hw_get_chippkg(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chippkg();
+}
+
+static inline int rt2800_hw_get_chipver(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chipver();
+}
+
+static inline int rt2800_hw_get_chipeco(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chipeco();
+}
+
 void rt2800_mcu_request(struct rt2x00_dev *rt2x00dev,
 			const u8 command, const u8 token,
 			const u8 arg0, const u8 arg1);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
index c891043..b041952 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
@@ -286,6 +286,10 @@ static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
 	return retval;
 }
 
+static int rt2800pci_get_chippkg(void) { return 0; }
+static int rt2800pci_get_chipver(void) { return 0; }
+static int rt2800pci_get_chipeco(void) { return 0; }
+
 static const struct ieee80211_ops rt2800pci_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -333,6 +337,9 @@ static const struct rt2800_ops rt2800pci_rt2800_ops = {
 	.drv_init_registers	= rt2800mmio_init_registers,
 	.drv_get_txwi		= rt2800mmio_get_txwi,
 	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+	.hw_get_chippkg		= rt2800pci_get_chippkg,
+	.hw_get_chipver		= rt2800pci_get_chipver,
+	.hw_get_chipeco		= rt2800pci_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
index 787dbf0..e0d7893 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
@@ -27,6 +27,12 @@
 #include "rt2800lib.h"
 #include "rt2800mmio.h"
 
+/* Needed to probe CHIP_VER register on MT7620 */
+#ifdef CONFIG_SOC_MT7620
+#include <asm/mach-ralink/ralink_regs.h>
+#include <asm/mach-ralink/mt7620.h>
+#endif
+
 /* Allow hardware encryption to be disabled. */
 static bool modparam_nohwcrypt;
 module_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);
@@ -90,19 +96,6 @@ static int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,
 	return retval;
 }
 
-static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
-{
-	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
-
-	if (!base_addr)
-		return -ENOMEM;
-
-	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
-
-	iounmap(base_addr);
-	return 0;
-}
-
 /* Firmware functions */
 static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
 {
@@ -131,6 +124,27 @@ static int rt2800soc_write_firmware(struct rt2x00_dev *rt2x00dev,
 	return 0;
 }
 
+#ifdef CONFIG_SOC_MT7620
+static int rt2800soc_get_chippkg(void)
+{
+	return mt7620_get_pkg();
+}
+
+static int rt2800soc_get_chipver(void)
+{
+	return mt7620_get_chipver();
+}
+
+static int rt2800soc_get_chipeco(void)
+{
+	return mt7620_get_eco();
+}
+#else
+static int rt2800soc_get_chippkg(void) { return 0; }
+static int rt2800soc_get_chipver(void) { return 0; }
+static int rt2800soc_get_chipeco(void) { return 0; }
+#endif
+
 static const struct ieee80211_ops rt2800soc_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -172,12 +186,15 @@ static const struct rt2800_ops rt2800soc_rt2800_ops = {
 	.register_multiread	= rt2x00mmio_register_multiread,
 	.register_multiwrite	= rt2x00mmio_register_multiwrite,
 	.regbusy_read		= rt2x00mmio_regbusy_read,
-	.read_eeprom		= rt2800soc_read_eeprom,
+	.read_eeprom		= rt2x00lib_read_eeprom,
 	.hwcrypt_disabled	= rt2800soc_hwcrypt_disabled,
 	.drv_write_firmware	= rt2800soc_write_firmware,
 	.drv_init_registers	= rt2800mmio_init_registers,
 	.drv_get_txwi		= rt2800mmio_get_txwi,
 	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+	.hw_get_chippkg		= rt2800soc_get_chippkg,
+	.hw_get_chipver		= rt2800soc_get_chipver,
+	.hw_get_chipeco		= rt2800soc_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {
@@ -243,10 +260,17 @@ static int rt2800soc_probe(struct platform_device *pdev)
 	return rt2x00soc_probe(pdev, &rt2800soc_ops);
 }
 
+static const struct of_device_id rt2880_wmac_match[] = {
+	{ .compatible = "ralink,rt2880-wmac" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rt2880_wmac_match);
+
 static struct platform_driver rt2800soc_driver = {
 	.driver		= {
 		.name		= "rt2800_wmac",
 		.mod_name	= KBUILD_MODNAME,
+		.of_match_table	= rt2880_wmac_match,
 	},
 	.probe		= rt2800soc_probe,
 	.remove		= rt2x00soc_remove,
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
index a37f8ea..2663447 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
@@ -628,6 +628,10 @@ static int rt2800usb_probe_hw(struct rt2x00_dev *rt2x00dev)
 	return 0;
 }
 
+static int rt2800usb_get_chippkg(void) { return 0; }
+static int rt2800usb_get_chipver(void) { return 0; }
+static int rt2800usb_get_chipeco(void) { return 0; }
+
 static const struct ieee80211_ops rt2800usb_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -676,6 +680,9 @@ static const struct rt2800_ops rt2800usb_rt2800_ops = {
 	.drv_init_registers	= rt2800usb_init_registers,
 	.drv_get_txwi		= rt2800usb_get_txwi,
 	.drv_get_dma_done	= rt2800usb_get_dma_done,
+	.hw_get_chippkg		= rt2800usb_get_chippkg,
+	.hw_get_chipver		= rt2800usb_get_chipver,
+	.hw_get_chipeco		= rt2800usb_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00.h b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
index 0ac4ae9..e3cfa69 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
@@ -28,6 +28,8 @@
 #include <linux/average.h>
 #include <linux/usb.h>
 #include <linux/clk.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/rt2x00_platform.h>
 
 #include <net/mac80211.h>
 
@@ -407,6 +409,7 @@ struct hw_mode_spec {
 	unsigned int supported_bands;
 #define SUPPORT_BAND_2GHZ	0x00000001
 #define SUPPORT_BAND_5GHZ	0x00000002
+#define SUPPORT_BAND_BOTH	(SUPPORT_BAND_2GHZ | SUPPORT_BAND_5GHZ)
 
 	unsigned int supported_rates;
 #define SUPPORT_RATE_CCK	0x00000001
@@ -702,6 +705,7 @@ enum rt2x00_capability_flags {
 	REQUIRE_HT_TX_DESC,
 	REQUIRE_PS_AUTOWAKE,
 	REQUIRE_DELAYED_RFKILL,
+	REQUIRE_EEPROM_FILE,
 
 	/*
 	 * Capabilities
@@ -1024,6 +1028,11 @@ struct rt2x00_dev {
 
 	/* Clock for System On Chip devices. */
 	struct clk *clk;
+
+	/* pinctrl and states for System On Chip devices with PA/LNA. */
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_pa_gpio;
 };
 
 struct rt2x00_bar_list_entry {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
index 274524e..69f8d5a 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
@@ -990,6 +990,12 @@ static void rt2x00lib_rate(struct ieee80211_rate *entry,
 
 void rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)
 {
+	struct rt2x00_platform_data *pdata;
+
+	pdata = rt2x00dev->dev->platform_data;
+	if (pdata && pdata->mac_address)
+		ether_addr_copy(eeprom_mac_addr, pdata->mac_address);
+
 	of_get_mac_address(rt2x00dev->dev->of_node, eeprom_mac_addr);
 
 	if (!is_valid_ether_addr(eeprom_mac_addr)) {
@@ -1007,6 +1013,32 @@ static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
 	struct ieee80211_rate *rates;
 	unsigned int num_rates;
 	unsigned int i;
+#ifdef CONFIG_OF
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int enabled;
+	if (!of_property_read_u32(np, "ralink,2ghz",
+                                          &enabled) && !enabled)
+		spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
+	if (!of_property_read_u32(np, "ralink,5ghz",
+                                          &enabled) && !enabled)
+		spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
+#endif /* CONFIG_OF */
+
+	if (rt2x00dev->dev->platform_data) {
+		struct rt2x00_platform_data *pdata;
+
+		pdata = rt2x00dev->dev->platform_data;
+		if (pdata->disable_2ghz)
+			spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
+		if (pdata->disable_5ghz)
+			spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
+	}
+
+	if ((spec->supported_bands & SUPPORT_BAND_BOTH) == 0) {
+		rt2x00_err(rt2x00dev, "No supported bands\n");
+		return -EINVAL;
+	}
+
 
 	num_rates = 0;
 	if (spec->supported_rates & SUPPORT_RATE_CCK)
@@ -1330,7 +1362,7 @@ static inline void rt2x00lib_set_if_combinations(struct rt2x00_dev *rt2x00dev)
 	 */
 	if_limit = &rt2x00dev->if_limits_ap;
 	if_limit->max = rt2x00dev->ops->max_ap_intf;
-	if_limit->types = BIT(NL80211_IFTYPE_AP);
+	if_limit->types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_STATION);
 #ifdef CPTCFG_MAC80211_MESH
 	if_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);
 #endif
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
new file mode 100644
index 0000000..15c4e0b
--- /dev/null
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
@@ -0,0 +1,208 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
+ *	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
+ *	<http://rt2x00.serialmonkey.com>
+ */
+
+/*	Module: rt2x00lib
+ *	Abstract: rt2x00 eeprom file loading routines.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#if IS_ENABLED(CONFIG_MTD)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#endif
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+
+#include "rt2x00.h"
+#include "rt2x00soc.h"
+
+static void rt2800lib_eeprom_swap(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	size_t len = rt2x00dev->ops->eeprom_size;
+	int i;
+
+	if (!of_find_property(np, "ralink,eeprom-swap", NULL))
+		return;
+
+	for (i = 0; i < len / sizeof(u16); i++)
+		rt2x00dev->eeprom[i] = swab16(rt2x00dev->eeprom[i]);
+}
+
+#if IS_ENABLED(CONFIG_MTD)
+static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_OF
+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
+	int size, offset = 0;
+	struct mtd_info *mtd;
+	const char *part;
+	const __be32 *list;
+	phandle phandle;
+	size_t retlen;
+
+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
+	if (!list)
+		return -ENOENT;
+
+	phandle = be32_to_cpup(list++);
+	if (phandle)
+		mtd_np = of_find_node_by_phandle(phandle);
+	if (!mtd_np) {
+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
+		return -EINVAL;
+	}
+
+	part = of_get_property(mtd_np, "label", NULL);
+	if (!part)
+		part = mtd_np->name;
+
+	mtd = get_mtd_device_nm(part);
+	if (IS_ERR(mtd)) {
+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
+		return PTR_ERR(mtd);
+	}
+
+	if (size > sizeof(*list))
+		offset = be32_to_cpup(list);
+
+	ret = mtd_read(mtd, offset, rt2x00dev->ops->eeprom_size,
+		       &retlen, (u_char *)rt2x00dev->eeprom);
+	put_mtd_device(mtd);
+
+	if (retlen != rt2x00dev->ops->eeprom_size || ret) {
+		dev_err(rt2x00dev->dev, "failed to load eeprom from device \"%s\"\n", part);
+		return ret;
+	}
+
+	rt2800lib_eeprom_swap(rt2x00dev);
+
+	dev_info(rt2x00dev->dev, "loaded eeprom from mtd device \"%s\"\n", part);
+#endif
+
+	return ret;
+}
+#endif
+
+static int rt2800lib_read_eeprom_nvmem(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int len = rt2x00dev->ops->eeprom_size;
+	struct nvmem_cell *cell;
+	const void *data;
+	size_t retlen;
+	int ret = 0;
+
+	cell = of_nvmem_cell_get(np, "eeprom");
+	if (IS_ERR(cell))
+		return PTR_ERR(cell);
+
+	data = nvmem_cell_read(cell, &retlen);
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	if (retlen != len) {
+		dev_err(rt2x00dev->dev, "invalid eeprom size, required: 0x%04x\n", len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	memcpy(rt2x00dev->eeprom, data, len);
+
+	rt2800lib_eeprom_swap(rt2x00dev);
+
+exit:
+	kfree(data);
+	return ret;
+}
+
+static const char *
+rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
+{
+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
+#ifdef CONFIG_OF
+	struct device_node *np;
+	const char *eep;
+#endif
+
+	if (pdata && pdata->eeprom_file_name)
+		return pdata->eeprom_file_name;
+
+#ifdef CONFIG_OF
+	np = rt2x00dev->dev->of_node;
+	if (np && !of_property_read_string(np, "ralink,eeprom", &eep))
+		return eep;
+#endif
+
+	return NULL;
+}
+
+static int rt2x00lib_read_eeprom_file(struct rt2x00_dev *rt2x00dev)
+{
+	const struct firmware *ee;
+	const char *ee_name;
+	int retval;
+
+	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
+	if (!ee_name && test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags)) {
+		rt2x00_err(rt2x00dev, "Required EEPROM name is missing.");
+		return -EINVAL;
+	}
+
+	if (!ee_name)
+		return 0;
+
+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
+
+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
+	if (retval) {
+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
+		return retval;
+	}
+
+	if (!ee || !ee->size || !ee->data) {
+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
+		retval = -ENOENT;
+		goto err_exit;
+	}
+
+	if (ee->size != rt2x00dev->ops->eeprom_size) {
+		rt2x00_err(rt2x00dev,
+			   "EEPROM file size is invalid, it should be %d bytes\n",
+			   rt2x00dev->ops->eeprom_size);
+		retval = -EINVAL;
+		goto err_release_ee;
+	}
+
+	memcpy(rt2x00dev->eeprom, ee->data, rt2x00dev->ops->eeprom_size);
+
+err_release_ee:
+	release_firmware(ee);
+err_exit:
+	return retval;
+}
+
+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev)
+{
+	int ret;
+
+#if IS_ENABLED(CONFIG_MTD)
+	ret = rt2800lib_read_eeprom_mtd(rt2x00dev);
+	if (!ret)
+		return 0;
+#endif
+
+	ret = rt2800lib_read_eeprom_nvmem(rt2x00dev);
+	if (!ret)
+		return 0;
+
+	return rt2x00lib_read_eeprom_file(rt2x00dev);
+}
+EXPORT_SYMBOL_GPL(rt2x00lib_read_eeprom);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
index f5361d5..bad5ce2 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
@@ -98,6 +98,9 @@ static int rt2x00leds_register_led(struct rt2x00_dev *rt2x00dev,
 	led->led_dev.name = name;
 	led->led_dev.brightness = LED_OFF;
 
+	if (rt2x00_is_soc(rt2x00dev))
+		led->led_dev.brightness_set(&led->led_dev, LED_OFF);
+
 	retval = led_classdev_register(device, &led->led_dev);
 	if (retval) {
 		rt2x00_err(rt2x00dev, "Failed to register led handler\n");
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
index eface61..541b718 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
@@ -86,6 +86,7 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)
 	if (IS_ERR(rt2x00dev->clk))
 		rt2x00dev->clk = NULL;
 
+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
 
 	retval = rt2x00soc_alloc_reg(rt2x00dev);
@@ -96,6 +97,21 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)
 	if (retval)
 		goto exit_free_reg;
 
+	rt2x00dev->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(rt2x00dev->pinctrl)) {
+		rt2x00dev->pinctrl = NULL;
+		rt2x00dev->pins_default = NULL;
+		rt2x00dev->pins_pa_gpio = NULL;
+	} else {
+		rt2x00dev->pins_default = pinctrl_lookup_state(rt2x00dev->pinctrl, "default");
+		if (IS_ERR(rt2x00dev->pins_default))
+			rt2x00dev->pins_default = NULL;
+
+		rt2x00dev->pins_pa_gpio = pinctrl_lookup_state(rt2x00dev->pinctrl, "pa_gpio");
+		if (IS_ERR(rt2x00dev->pins_pa_gpio))
+			rt2x00dev->pins_pa_gpio = NULL;
+	}
+
 	return 0;
 
 exit_free_reg:
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h
index 021fd06..21cd951 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.h
@@ -26,4 +26,13 @@ int rt2x00soc_resume(struct platform_device *pdev);
 #define rt2x00soc_resume	NULL
 #endif /* CONFIG_PM */
 
+/*
+ * EEPROM file handlers.
+ */
+#ifdef CPTCFG_RT2X00_LIB_EEPROM
+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev);
+#else
+#define rt2x00lib_read_eeprom	NULL
+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
+
 #endif /* RT2X00SOC_H */
diff --git a/drivers/net/wireless/virtual/mac80211_hwsim.c b/drivers/net/wireless/virtual/mac80211_hwsim.c
index fec6045..326aadf 100644
--- a/drivers/net/wireless/virtual/mac80211_hwsim.c
+++ b/drivers/net/wireless/virtual/mac80211_hwsim.c
@@ -69,6 +69,10 @@ static bool mlo;
 module_param(mlo, bool, 0444);
 MODULE_PARM_DESC(mlo, "Support MLO");
 
+static bool multi_radio;
+module_param(multi_radio, bool, 0444);
+MODULE_PARM_DESC(mlo, "Support Multiple Radios per wiphy");
+
 /**
  * enum hwsim_regtest - the type of regulatory tests we offer
  *
@@ -669,6 +673,10 @@ struct mac80211_hwsim_data {
 	struct ieee80211_iface_limit if_limits[3];
 	int n_if_limits;
 
+	struct ieee80211_iface_combination if_combination_radio;
+	struct wiphy_radio_freq_range radio_range[NUM_NL80211_BANDS];
+	struct wiphy_radio radio[NUM_NL80211_BANDS];
+
 	u32 ciphers[ARRAY_SIZE(hwsim_ciphers)];
 
 	struct mac_address addresses[2];
@@ -917,6 +925,7 @@ static const struct nla_policy hwsim_genl_policy[HWSIM_ATTR_MAX + 1] = {
 	[HWSIM_ATTR_MLO_SUPPORT] = { .type = NLA_FLAG },
 	[HWSIM_ATTR_PMSR_SUPPORT] = NLA_POLICY_NESTED(hwsim_pmsr_capa_policy),
 	[HWSIM_ATTR_PMSR_RESULT] = NLA_POLICY_NESTED(hwsim_pmsr_peers_result_policy),
+	[HWSIM_ATTR_MULTI_RADIO] = { .type = NLA_FLAG },
 };
 
 #if IS_REACHABLE(CONFIG_VIRTIO)
@@ -4007,6 +4016,7 @@ struct hwsim_new_radio_params {
 	bool reg_strict;
 	bool p2p_device;
 	bool use_chanctx;
+	bool multi_radio;
 	bool destroy_on_close;
 	const char *hwname;
 	bool no_vif;
@@ -4083,6 +4093,12 @@ static int append_radio_msg(struct sk_buff *skb, int id,
 			return ret;
 	}
 
+	if (param->multi_radio) {
+		ret = nla_put_flag(skb, HWSIM_ATTR_MULTI_RADIO);
+		if (ret < 0)
+			return ret;
+	}
+
 	if (param->hwname) {
 		ret = nla_put(skb, HWSIM_ATTR_RADIO_NAME,
 			      strlen(param->hwname), param->hwname);
@@ -5099,6 +5115,7 @@ static int mac80211_hwsim_new_radio(struct genl_info *info,
 	struct net *net;
 	int idx, i;
 	int n_limits = 0;
+	int n_bands = 0;
 
 	if (WARN_ON(param->channels > 1 && !param->use_chanctx))
 		return -EINVAL;
@@ -5202,22 +5219,22 @@ static int mac80211_hwsim_new_radio(struct genl_info *info,
 		n_limits++;
 	}
 
+	data->if_combination.radar_detect_widths =
+				BIT(NL80211_CHAN_WIDTH_5) |
+				BIT(NL80211_CHAN_WIDTH_10) |
+				BIT(NL80211_CHAN_WIDTH_20_NOHT) |
+				BIT(NL80211_CHAN_WIDTH_20) |
+				BIT(NL80211_CHAN_WIDTH_40) |
+				BIT(NL80211_CHAN_WIDTH_80) |
+				BIT(NL80211_CHAN_WIDTH_160);
+
 	if (data->use_chanctx) {
 		hw->wiphy->max_scan_ssids = 255;
 		hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
 		hw->wiphy->max_remain_on_channel_duration = 1000;
-		data->if_combination.radar_detect_widths = 0;
 		data->if_combination.num_different_channels = data->channels;
 	} else {
 		data->if_combination.num_different_channels = 1;
-		data->if_combination.radar_detect_widths =
-					BIT(NL80211_CHAN_WIDTH_5) |
-					BIT(NL80211_CHAN_WIDTH_10) |
-					BIT(NL80211_CHAN_WIDTH_20_NOHT) |
-					BIT(NL80211_CHAN_WIDTH_20) |
-					BIT(NL80211_CHAN_WIDTH_40) |
-					BIT(NL80211_CHAN_WIDTH_80) |
-					BIT(NL80211_CHAN_WIDTH_160);
 	}
 
 	if (!n_limits) {
@@ -5333,6 +5350,9 @@ static int mac80211_hwsim_new_radio(struct genl_info *info,
 
 	for (band = NL80211_BAND_2GHZ; band < NUM_NL80211_BANDS; band++) {
 		struct ieee80211_supported_band *sband = &data->bands[band];
+		struct wiphy_radio_freq_range *radio_range;
+		const struct ieee80211_channel *c;
+		struct wiphy_radio *radio;
 
 		sband->band = band;
 
@@ -5406,8 +5426,36 @@ static int mac80211_hwsim_new_radio(struct genl_info *info,
 		mac80211_hwsim_sband_capab(sband);
 
 		hw->wiphy->bands[band] = sband;
+
+		if (!param->multi_radio)
+			continue;
+
+		c = sband->channels;
+		radio_range = &data->radio_range[n_bands];
+		radio_range->start_freq = ieee80211_channel_to_khz(c) - 10000;
+
+		c += sband->n_channels - 1;
+		radio_range->end_freq = ieee80211_channel_to_khz(c) + 10000;
+
+		radio = &data->radio[n_bands++];
+		radio->freq_range = radio_range;
+		radio->n_freq_range = 1;
+		radio->iface_combinations = &data->if_combination_radio;
+		radio->n_iface_combinations = 1;
 	}
 
+	if (param->multi_radio) {
+		hw->wiphy->radio = data->radio;
+		hw->wiphy->n_radio = n_bands;
+
+		memcpy(&data->if_combination_radio, &data->if_combination,
+		       sizeof(data->if_combination));
+		data->if_combination.num_different_channels *= n_bands;
+	}
+
+	if (data->use_chanctx)
+		data->if_combination.radar_detect_widths = 0;
+
 	/* By default all radios belong to the first group */
 	data->group = 1;
 	mutex_init(&data->mutex);
@@ -6025,6 +6073,9 @@ static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)
 	else
 		param.use_chanctx = (param.channels > 1);
 
+	if (info->attrs[HWSIM_ATTR_MULTI_RADIO])
+		param.multi_radio = true;
+
 	if (info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2])
 		param.reg_alpha2 =
 			nla_data(info->attrs[HWSIM_ATTR_REG_HINT_ALPHA2]);
@@ -6105,7 +6156,7 @@ static int hwsim_new_radio_nl(struct sk_buff *msg, struct genl_info *info)
 
 	param.mlo = info->attrs[HWSIM_ATTR_MLO_SUPPORT];
 
-	if (param.mlo)
+	if (param.mlo || param.multi_radio)
 		param.use_chanctx = true;
 
 	if (info->attrs[HWSIM_ATTR_RADIO_NAME]) {
@@ -6802,7 +6853,8 @@ static int __init init_mac80211_hwsim(void)
 
 		param.p2p_device = support_p2p_device;
 		param.mlo = mlo;
-		param.use_chanctx = channels > 1 || mlo;
+		param.multi_radio = multi_radio;
+		param.use_chanctx = channels > 1 || mlo || multi_radio;
 		param.iftypes = HWSIM_IFTYPE_SUPPORT_MASK;
 		if (param.p2p_device)
 			param.iftypes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
diff --git a/drivers/net/wireless/virtual/mac80211_hwsim.h b/drivers/net/wireless/virtual/mac80211_hwsim.h
index 21b1afd..3cfa7bd 100644
--- a/drivers/net/wireless/virtual/mac80211_hwsim.h
+++ b/drivers/net/wireless/virtual/mac80211_hwsim.h
@@ -157,6 +157,9 @@ enum hwsim_commands {
  *	to provide details about peer measurement request (nl80211_peer_measurement_attrs)
  * @HWSIM_ATTR_PMSR_RESULT: nested attributed used with %HWSIM_CMD_REPORT_PMSR
  *	to provide peer measurement result (nl80211_peer_measurement_attrs)
+ * @HWSIM_ATTR_MULTI_RADIO: Register multiple wiphy radios (flag).
+ *	Adds one radio for each band. Number of supported channels will be set for
+ *	each radio instead of for the wiphy.
  * @__HWSIM_ATTR_MAX: enum limit
  */
 enum hwsim_attrs {
@@ -189,6 +192,7 @@ enum hwsim_attrs {
 	HWSIM_ATTR_PMSR_SUPPORT,
 	HWSIM_ATTR_PMSR_REQUEST,
 	HWSIM_ATTR_PMSR_RESULT,
+	HWSIM_ATTR_MULTI_RADIO,
 	__HWSIM_ATTR_MAX,
 };
 #define HWSIM_ATTR_MAX (__HWSIM_ATTR_MAX - 1)
diff --git a/drivers/staging/rtl8723bs/Kconfig b/drivers/staging/rtl8723bs/Kconfig
index b51916c..b46ff98 100644
--- a/drivers/staging/rtl8723bs/Kconfig
+++ b/drivers/staging/rtl8723bs/Kconfig
@@ -5,7 +5,6 @@ config RTL8723BS
 	depends on m
 	depends on WLAN && MMC && CFG80211
 	depends on m
-	select CFG80211_WEXT
 	depends on CRYPTO
 	select BPAUTO_CRYPTO_LIB_ARC4
 	help
diff --git a/include/linux/ath5k_platform.h b/include/linux/ath5k_platform.h
new file mode 100644
index 0000000..ec85224
--- /dev/null
+++ b/include/linux/ath5k_platform.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2008 Atheros Communications Inc.
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LINUX_ATH5K_PLATFORM_H
+#define _LINUX_ATH5K_PLATFORM_H
+
+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
+
+struct ath5k_platform_data {
+	u16 *eeprom_data;
+	u8 *macaddr;
+};
+
+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/include/linux/bcma/bcma.h b/include/linux/bcma/bcma.h
deleted file mode 100644
index ec7b0d7..0000000
--- a/include/linux/bcma/bcma.h
+++ /dev/null
@@ -1,489 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_H_
-#define LINUX_BCMA_H_
-
-#include <linux/pci.h>
-#include <linux/mod_devicetable.h>
-
-#include <linux/bcma/bcma_driver_arm_c9.h>
-#include <linux/bcma/bcma_driver_chipcommon.h>
-#include <linux/bcma/bcma_driver_pci.h>
-#include <linux/bcma/bcma_driver_pcie2.h>
-#include <linux/bcma/bcma_driver_mips.h>
-#include <linux/bcma/bcma_driver_gmac_cmn.h>
-#include <linux/ssb/ssb.h> /* SPROM sharing */
-
-#include <linux/bcma/bcma_regs.h>
-
-struct bcma_device;
-struct bcma_bus;
-
-enum bcma_hosttype {
-	BCMA_HOSTTYPE_PCI,
-	BCMA_HOSTTYPE_SDIO,
-	BCMA_HOSTTYPE_SOC,
-};
-
-struct bcma_chipinfo {
-	u16 id;
-	u8 rev;
-	u8 pkg;
-};
-
-struct bcma_boardinfo {
-	u16 vendor;
-	u16 type;
-};
-
-enum bcma_clkmode {
-	BCMA_CLKMODE_FAST,
-	BCMA_CLKMODE_DYNAMIC,
-};
-
-struct bcma_host_ops {
-	u8 (*read8)(struct bcma_device *core, u16 offset);
-	u16 (*read16)(struct bcma_device *core, u16 offset);
-	u32 (*read32)(struct bcma_device *core, u16 offset);
-	void (*write8)(struct bcma_device *core, u16 offset, u8 value);
-	void (*write16)(struct bcma_device *core, u16 offset, u16 value);
-	void (*write32)(struct bcma_device *core, u16 offset, u32 value);
-#ifdef CPTCFG_BCMA_BLOCKIO
-	void (*block_read)(struct bcma_device *core, void *buffer,
-			   size_t count, u16 offset, u8 reg_width);
-	void (*block_write)(struct bcma_device *core, const void *buffer,
-			    size_t count, u16 offset, u8 reg_width);
-#endif
-	/* Agent ops */
-	u32 (*aread32)(struct bcma_device *core, u16 offset);
-	void (*awrite32)(struct bcma_device *core, u16 offset, u32 value);
-};
-
-/* Core manufacturers */
-#define BCMA_MANUF_ARM			0x43B
-#define BCMA_MANUF_MIPS			0x4A7
-#define BCMA_MANUF_BCM			0x4BF
-
-/* Core class values. */
-#define BCMA_CL_SIM			0x0
-#define BCMA_CL_EROM			0x1
-#define BCMA_CL_CORESIGHT		0x9
-#define BCMA_CL_VERIF			0xB
-#define BCMA_CL_OPTIMO			0xD
-#define BCMA_CL_GEN			0xE
-#define BCMA_CL_PRIMECELL		0xF
-
-/* Core-ID values. */
-#define BCMA_CORE_OOB_ROUTER		0x367	/* Out of band */
-#define BCMA_CORE_4706_CHIPCOMMON	0x500
-#define BCMA_CORE_NS_PCIEG2		0x501
-#define BCMA_CORE_NS_DMA		0x502
-#define BCMA_CORE_NS_SDIO3		0x503
-#define BCMA_CORE_NS_USB20		0x504
-#define BCMA_CORE_NS_USB30		0x505
-#define BCMA_CORE_NS_A9JTAG		0x506
-#define BCMA_CORE_NS_DDR23		0x507
-#define BCMA_CORE_NS_ROM		0x508
-#define BCMA_CORE_NS_NAND		0x509
-#define BCMA_CORE_NS_QSPI		0x50A
-#define BCMA_CORE_NS_CHIPCOMMON_B	0x50B
-#define BCMA_CORE_4706_SOC_RAM		0x50E
-#define BCMA_CORE_ARMCA9		0x510
-#define BCMA_CORE_4706_MAC_GBIT		0x52D
-#define BCMA_CORE_AMEMC			0x52E	/* DDR1/2 memory controller core */
-#define BCMA_CORE_ALTA			0x534	/* I2S core */
-#define BCMA_CORE_4706_MAC_GBIT_COMMON	0x5DC
-#define BCMA_CORE_DDR23_PHY		0x5DD
-#define BCMA_CORE_INVALID		0x700
-#define BCMA_CORE_CHIPCOMMON		0x800
-#define BCMA_CORE_ILINE20		0x801
-#define BCMA_CORE_SRAM			0x802
-#define BCMA_CORE_SDRAM			0x803
-#define BCMA_CORE_PCI			0x804
-#define BCMA_CORE_MIPS			0x805
-#define BCMA_CORE_ETHERNET		0x806
-#define BCMA_CORE_V90			0x807
-#define BCMA_CORE_USB11_HOSTDEV		0x808
-#define BCMA_CORE_ADSL			0x809
-#define BCMA_CORE_ILINE100		0x80A
-#define BCMA_CORE_IPSEC			0x80B
-#define BCMA_CORE_UTOPIA		0x80C
-#define BCMA_CORE_PCMCIA		0x80D
-#define BCMA_CORE_INTERNAL_MEM		0x80E
-#define BCMA_CORE_MEMC_SDRAM		0x80F
-#define BCMA_CORE_OFDM			0x810
-#define BCMA_CORE_EXTIF			0x811
-#define BCMA_CORE_80211			0x812
-#define BCMA_CORE_PHY_A			0x813
-#define BCMA_CORE_PHY_B			0x814
-#define BCMA_CORE_PHY_G			0x815
-#define BCMA_CORE_MIPS_3302		0x816
-#define BCMA_CORE_USB11_HOST		0x817
-#define BCMA_CORE_USB11_DEV		0x818
-#define BCMA_CORE_USB20_HOST		0x819
-#define BCMA_CORE_USB20_DEV		0x81A
-#define BCMA_CORE_SDIO_HOST		0x81B
-#define BCMA_CORE_ROBOSWITCH		0x81C
-#define BCMA_CORE_PARA_ATA		0x81D
-#define BCMA_CORE_SATA_XORDMA		0x81E
-#define BCMA_CORE_ETHERNET_GBIT		0x81F
-#define BCMA_CORE_PCIE			0x820
-#define BCMA_CORE_PHY_N			0x821
-#define BCMA_CORE_SRAM_CTL		0x822
-#define BCMA_CORE_MINI_MACPHY		0x823
-#define BCMA_CORE_ARM_1176		0x824
-#define BCMA_CORE_ARM_7TDMI		0x825
-#define BCMA_CORE_PHY_LP		0x826
-#define BCMA_CORE_PMU			0x827
-#define BCMA_CORE_PHY_SSN		0x828
-#define BCMA_CORE_SDIO_DEV		0x829
-#define BCMA_CORE_ARM_CM3		0x82A
-#define BCMA_CORE_PHY_HT		0x82B
-#define BCMA_CORE_MIPS_74K		0x82C
-#define BCMA_CORE_MAC_GBIT		0x82D
-#define BCMA_CORE_DDR12_MEM_CTL		0x82E
-#define BCMA_CORE_PCIE_RC		0x82F	/* PCIe Root Complex */
-#define BCMA_CORE_OCP_OCP_BRIDGE	0x830
-#define BCMA_CORE_SHARED_COMMON		0x831
-#define BCMA_CORE_OCP_AHB_BRIDGE	0x832
-#define BCMA_CORE_SPI_HOST		0x833
-#define BCMA_CORE_I2S			0x834
-#define BCMA_CORE_SDR_DDR1_MEM_CTL	0x835	/* SDR/DDR1 memory controller core */
-#define BCMA_CORE_SHIM			0x837	/* SHIM component in ubus/6362 */
-#define BCMA_CORE_PHY_AC		0x83B
-#define BCMA_CORE_PCIE2			0x83C	/* PCI Express Gen2 */
-#define BCMA_CORE_USB30_DEV		0x83D
-#define BCMA_CORE_ARM_CR4		0x83E
-#define BCMA_CORE_GCI			0x840
-#define BCMA_CORE_CMEM			0x846	/* CNDS DDR2/3 memory controller */
-#define BCMA_CORE_ARM_CA7		0x847
-#define BCMA_CORE_SYS_MEM		0x849
-#define BCMA_CORE_DEFAULT		0xFFF
-
-#define BCMA_MAX_NR_CORES		16
-#define BCMA_CORE_SIZE			0x1000
-
-/* Chip IDs of PCIe devices */
-#define BCMA_CHIP_ID_BCM4313	0x4313
-#define BCMA_CHIP_ID_BCM43142	43142
-#define BCMA_CHIP_ID_BCM43131	43131
-#define BCMA_CHIP_ID_BCM43217	43217
-#define BCMA_CHIP_ID_BCM43222	43222
-#define BCMA_CHIP_ID_BCM43224	43224
-#define  BCMA_PKG_ID_BCM43224_FAB_CSM	0x8
-#define  BCMA_PKG_ID_BCM43224_FAB_SMIC	0xa
-#define BCMA_CHIP_ID_BCM43225	43225
-#define BCMA_CHIP_ID_BCM43227	43227
-#define BCMA_CHIP_ID_BCM43228	43228
-#define BCMA_CHIP_ID_BCM43421	43421
-#define BCMA_CHIP_ID_BCM43428	43428
-#define BCMA_CHIP_ID_BCM43431	43431
-#define BCMA_CHIP_ID_BCM43460	43460
-#define BCMA_CHIP_ID_BCM4331	0x4331
-#define BCMA_CHIP_ID_BCM6362	0x6362
-#define BCMA_CHIP_ID_BCM4360	0x4360
-#define BCMA_CHIP_ID_BCM4352	0x4352
-
-/* Chip IDs of SoCs */
-#define BCMA_CHIP_ID_BCM4706	0x5300
-#define  BCMA_PKG_ID_BCM4706L	1
-#define BCMA_CHIP_ID_BCM4716	0x4716
-#define  BCMA_PKG_ID_BCM4716	8
-#define  BCMA_PKG_ID_BCM4717	9
-#define  BCMA_PKG_ID_BCM4718	10
-#define BCMA_CHIP_ID_BCM47162	47162
-#define BCMA_CHIP_ID_BCM4748	0x4748
-#define BCMA_CHIP_ID_BCM4749	0x4749
-#define BCMA_CHIP_ID_BCM5356	0x5356
-#define BCMA_CHIP_ID_BCM5357	0x5357
-#define  BCMA_PKG_ID_BCM5358	9
-#define  BCMA_PKG_ID_BCM47186	10
-#define  BCMA_PKG_ID_BCM5357	11
-#define BCMA_CHIP_ID_BCM53572	53572
-#define  BCMA_PKG_ID_BCM47188	9
-#define BCMA_CHIP_ID_BCM4707	53010
-#define  BCMA_PKG_ID_BCM4707	1
-#define  BCMA_PKG_ID_BCM4708	2
-#define  BCMA_PKG_ID_BCM4709	0
-#define BCMA_CHIP_ID_BCM47094	53030
-#define BCMA_CHIP_ID_BCM53018	53018
-#define BCMA_CHIP_ID_BCM53573	53573
-#define  BCMA_PKG_ID_BCM53573	0
-#define  BCMA_PKG_ID_BCM47189	1
-
-/* Board types (on PCI usually equals to the subsystem dev id) */
-/* BCM4313 */
-#define BCMA_BOARD_TYPE_BCM94313BU	0X050F
-#define BCMA_BOARD_TYPE_BCM94313HM	0X0510
-#define BCMA_BOARD_TYPE_BCM94313EPA	0X0511
-#define BCMA_BOARD_TYPE_BCM94313HMG	0X051C
-/* BCM4716 */
-#define BCMA_BOARD_TYPE_BCM94716NR2	0X04CD
-/* BCM43224 */
-#define BCMA_BOARD_TYPE_BCM943224X21	0X056E
-#define BCMA_BOARD_TYPE_BCM943224X21_FCC	0X00D1
-#define BCMA_BOARD_TYPE_BCM943224X21B	0X00E9
-#define BCMA_BOARD_TYPE_BCM943224M93	0X008B
-#define BCMA_BOARD_TYPE_BCM943224M93A	0X0090
-#define BCMA_BOARD_TYPE_BCM943224X16	0X0093
-#define BCMA_BOARD_TYPE_BCM94322X9	0X008D
-#define BCMA_BOARD_TYPE_BCM94322M35E	0X008E
-/* BCM43228 */
-#define BCMA_BOARD_TYPE_BCM943228BU8	0X0540
-#define BCMA_BOARD_TYPE_BCM943228BU9	0X0541
-#define BCMA_BOARD_TYPE_BCM943228BU	0X0542
-#define BCMA_BOARD_TYPE_BCM943227HM4L	0X0543
-#define BCMA_BOARD_TYPE_BCM943227HMB	0X0544
-#define BCMA_BOARD_TYPE_BCM943228HM4L	0X0545
-#define BCMA_BOARD_TYPE_BCM943228SD	0X0573
-/* BCM4331 */
-#define BCMA_BOARD_TYPE_BCM94331X19	0X00D6
-#define BCMA_BOARD_TYPE_BCM94331X28	0X00E4
-#define BCMA_BOARD_TYPE_BCM94331X28B	0X010E
-#define BCMA_BOARD_TYPE_BCM94331PCIEBT3AX	0X00E4
-#define BCMA_BOARD_TYPE_BCM94331X12_2G	0X00EC
-#define BCMA_BOARD_TYPE_BCM94331X12_5G	0X00ED
-#define BCMA_BOARD_TYPE_BCM94331X29B	0X00EF
-#define BCMA_BOARD_TYPE_BCM94331CSAX	0X00EF
-#define BCMA_BOARD_TYPE_BCM94331X19C	0X00F5
-#define BCMA_BOARD_TYPE_BCM94331X33	0X00F4
-#define BCMA_BOARD_TYPE_BCM94331BU	0X0523
-#define BCMA_BOARD_TYPE_BCM94331S9BU	0X0524
-#define BCMA_BOARD_TYPE_BCM94331MC	0X0525
-#define BCMA_BOARD_TYPE_BCM94331MCI	0X0526
-#define BCMA_BOARD_TYPE_BCM94331PCIEBT4	0X0527
-#define BCMA_BOARD_TYPE_BCM94331HM	0X0574
-#define BCMA_BOARD_TYPE_BCM94331PCIEDUAL	0X059B
-#define BCMA_BOARD_TYPE_BCM94331MCH5	0X05A9
-#define BCMA_BOARD_TYPE_BCM94331CS	0X05C6
-#define BCMA_BOARD_TYPE_BCM94331CD	0X05DA
-/* BCM53572 */
-#define BCMA_BOARD_TYPE_BCM953572BU	0X058D
-#define BCMA_BOARD_TYPE_BCM953572NR2	0X058E
-#define BCMA_BOARD_TYPE_BCM947188NR2	0X058F
-#define BCMA_BOARD_TYPE_BCM953572SDRNR2	0X0590
-/* BCM43142 */
-#define BCMA_BOARD_TYPE_BCM943142HM	0X05E0
-
-struct bcma_device {
-	struct bcma_bus *bus;
-	struct bcma_device_id id;
-
-	struct device dev;
-	struct device *dma_dev;
-
-	unsigned int irq;
-	bool dev_registered;
-
-	u8 core_index;
-	u8 core_unit;
-
-	u32 addr;
-	u32 addr_s[8];
-	u32 wrap;
-
-	void __iomem *io_addr;
-	void __iomem *io_wrap;
-
-	void *drvdata;
-	struct list_head list;
-};
-
-static inline void *bcma_get_drvdata(struct bcma_device *core)
-{
-	return core->drvdata;
-}
-static inline void bcma_set_drvdata(struct bcma_device *core, void *drvdata)
-{
-	core->drvdata = drvdata;
-}
-
-struct bcma_driver {
-	const char *name;
-	const struct bcma_device_id *id_table;
-
-	int (*probe)(struct bcma_device *dev);
-	void (*remove)(struct bcma_device *dev);
-	int (*suspend)(struct bcma_device *dev);
-	int (*resume)(struct bcma_device *dev);
-	void (*shutdown)(struct bcma_device *dev);
-
-	struct device_driver drv;
-};
-extern
-int __bcma_driver_register(struct bcma_driver *drv, struct module *owner);
-#define bcma_driver_register(drv) \
-	__bcma_driver_register(drv, THIS_MODULE)
-
-extern void bcma_driver_unregister(struct bcma_driver *drv);
-
-/* module_bcma_driver() - Helper macro for drivers that don't do
- * anything special in module init/exit.  This eliminates a lot of
- * boilerplate.  Each module may only use this macro once, and
- * calling it replaces module_init() and module_exit()
- */
-#define module_bcma_driver(__bcma_driver) \
-	module_driver(__bcma_driver, bcma_driver_register, \
-			bcma_driver_unregister)
-
-/* Set a fallback SPROM.
- * See kdoc at the function definition for complete documentation. */
-extern int bcma_arch_register_fallback_sprom(
-		int (*sprom_callback)(struct bcma_bus *bus,
-		struct ssb_sprom *out));
-
-struct bcma_bus {
-	struct device *dev;
-
-	/* The MMIO area. */
-	void __iomem *mmio;
-
-	const struct bcma_host_ops *ops;
-
-	enum bcma_hosttype hosttype;
-	bool host_is_pcie2; /* Used for BCMA_HOSTTYPE_PCI only */
-	struct pci_dev *host_pci; /* PCI bus pointer (BCMA_HOSTTYPE_PCI only) */
-
-	struct bcma_chipinfo chipinfo;
-
-	struct bcma_boardinfo boardinfo;
-
-	struct bcma_device *mapped_core;
-	struct list_head cores;
-	u8 nr_cores;
-	u8 num;
-
-	struct bcma_drv_cc drv_cc;
-	struct bcma_drv_cc_b drv_cc_b;
-	struct bcma_drv_pci drv_pci[2];
-	struct bcma_drv_pcie2 drv_pcie2;
-	struct bcma_drv_mips drv_mips;
-	struct bcma_drv_gmac_cmn drv_gmac_cmn;
-
-	/* We decided to share SPROM struct with SSB as long as we do not need
-	 * any hacks for BCMA. This simplifies drivers code. */
-	struct ssb_sprom sprom;
-};
-
-static inline u32 bcma_read8(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->read8(core, offset);
-}
-static inline u32 bcma_read16(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->read16(core, offset);
-}
-static inline u32 bcma_read32(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->read32(core, offset);
-}
-static inline
-void bcma_write8(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->write8(core, offset, value);
-}
-static inline
-void bcma_write16(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->write16(core, offset, value);
-}
-static inline
-void bcma_write32(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->write32(core, offset, value);
-}
-#ifdef CPTCFG_BCMA_BLOCKIO
-static inline void bcma_block_read(struct bcma_device *core, void *buffer,
-				   size_t count, u16 offset, u8 reg_width)
-{
-	core->bus->ops->block_read(core, buffer, count, offset, reg_width);
-}
-static inline void bcma_block_write(struct bcma_device *core,
-				    const void *buffer, size_t count,
-				    u16 offset, u8 reg_width)
-{
-	core->bus->ops->block_write(core, buffer, count, offset, reg_width);
-}
-#endif
-static inline u32 bcma_aread32(struct bcma_device *core, u16 offset)
-{
-	return core->bus->ops->aread32(core, offset);
-}
-static inline
-void bcma_awrite32(struct bcma_device *core, u16 offset, u32 value)
-{
-	core->bus->ops->awrite32(core, offset, value);
-}
-
-static inline void bcma_mask32(struct bcma_device *cc, u16 offset, u32 mask)
-{
-	bcma_write32(cc, offset, bcma_read32(cc, offset) & mask);
-}
-static inline void bcma_set32(struct bcma_device *cc, u16 offset, u32 set)
-{
-	bcma_write32(cc, offset, bcma_read32(cc, offset) | set);
-}
-static inline void bcma_maskset32(struct bcma_device *cc,
-				  u16 offset, u32 mask, u32 set)
-{
-	bcma_write32(cc, offset, (bcma_read32(cc, offset) & mask) | set);
-}
-static inline void bcma_mask16(struct bcma_device *cc, u16 offset, u16 mask)
-{
-	bcma_write16(cc, offset, bcma_read16(cc, offset) & mask);
-}
-static inline void bcma_set16(struct bcma_device *cc, u16 offset, u16 set)
-{
-	bcma_write16(cc, offset, bcma_read16(cc, offset) | set);
-}
-static inline void bcma_maskset16(struct bcma_device *cc,
-				  u16 offset, u16 mask, u16 set)
-{
-	bcma_write16(cc, offset, (bcma_read16(cc, offset) & mask) | set);
-}
-
-extern struct bcma_device *bcma_find_core_unit(struct bcma_bus *bus, u16 coreid,
-					       u8 unit);
-static inline struct bcma_device *bcma_find_core(struct bcma_bus *bus,
-						 u16 coreid)
-{
-	return bcma_find_core_unit(bus, coreid, 0);
-}
-
-#ifdef CPTCFG_BCMA_HOST_PCI
-extern void bcma_host_pci_up(struct bcma_bus *bus);
-extern void bcma_host_pci_down(struct bcma_bus *bus);
-extern int bcma_host_pci_irq_ctl(struct bcma_bus *bus,
-				 struct bcma_device *core, bool enable);
-#else
-static inline void bcma_host_pci_up(struct bcma_bus *bus)
-{
-}
-static inline void bcma_host_pci_down(struct bcma_bus *bus)
-{
-}
-static inline int bcma_host_pci_irq_ctl(struct bcma_bus *bus,
-					struct bcma_device *core, bool enable)
-{
-	if (bus->hosttype == BCMA_HOSTTYPE_PCI)
-		return -ENOTSUPP;
-	return 0;
-}
-#endif
-
-extern bool bcma_core_is_enabled(struct bcma_device *core);
-extern void bcma_core_disable(struct bcma_device *core, u32 flags);
-extern int bcma_core_enable(struct bcma_device *core, u32 flags);
-extern void bcma_core_set_clockmode(struct bcma_device *core,
-				    enum bcma_clkmode clkmode);
-extern void bcma_core_pll_ctl(struct bcma_device *core, u32 req, u32 status,
-			      bool on);
-extern u32 bcma_chipco_pll_read(struct bcma_drv_cc *cc, u32 offset);
-#define BCMA_DMA_TRANSLATION_MASK	0xC0000000
-#define  BCMA_DMA_TRANSLATION_NONE	0x00000000
-#define  BCMA_DMA_TRANSLATION_DMA32_CMT	0x40000000 /* Client Mode Translation for 32-bit DMA */
-#define  BCMA_DMA_TRANSLATION_DMA64_CMT	0x80000000 /* Client Mode Translation for 64-bit DMA */
-extern u32 bcma_core_dma_translation(struct bcma_device *core);
-
-extern unsigned int bcma_core_irq(struct bcma_device *core, int num);
-
-#endif /* LINUX_BCMA_H_ */
diff --git a/include/linux/bcma/bcma_driver_arm_c9.h b/include/linux/bcma/bcma_driver_arm_c9.h
deleted file mode 100644
index 688cf59..0000000
--- a/include/linux/bcma/bcma_driver_arm_c9.h
+++ /dev/null
@@ -1,16 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_ARM_C9_H_
-#define LINUX_BCMA_DRIVER_ARM_C9_H_
-
-/* DMU (Device Management Unit) */
-#define BCMA_DMU_CRU_USB2_CONTROL			0x0164
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_NDIV_MASK	0x00000FFC
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_NDIV_SHIFT	2
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_MASK	0x00007000
-#define  BCMA_DMU_CRU_USB2_CONTROL_USB_PLL_PDIV_SHIFT	12
-#define BCMA_DMU_CRU_CLKSET_KEY				0x0180
-#define BCMA_DMU_CRU_STRAPS_CTRL			0x02A0
-#define  BCMA_DMU_CRU_STRAPS_CTRL_USB3			0x00000010
-#define  BCMA_DMU_CRU_STRAPS_CTRL_4BYTE			0x00008000
-
-#endif /* LINUX_BCMA_DRIVER_ARM_C9_H_ */
diff --git a/include/linux/bcma/bcma_driver_chipcommon.h b/include/linux/bcma/bcma_driver_chipcommon.h
deleted file mode 100644
index 2f57df8..0000000
--- a/include/linux/bcma/bcma_driver_chipcommon.h
+++ /dev/null
@@ -1,722 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_CC_H_
-#define LINUX_BCMA_DRIVER_CC_H_
-
-#include <linux/platform_device.h>
-#include <linux/platform_data/brcmnand.h>
-#include <linux/gpio/driver.h>
-
-/** ChipCommon core registers. **/
-#define BCMA_CC_ID			0x0000
-#define  BCMA_CC_ID_ID			0x0000FFFF
-#define  BCMA_CC_ID_ID_SHIFT		0
-#define  BCMA_CC_ID_REV			0x000F0000
-#define  BCMA_CC_ID_REV_SHIFT		16
-#define  BCMA_CC_ID_PKG			0x00F00000
-#define  BCMA_CC_ID_PKG_SHIFT		20
-#define  BCMA_CC_ID_NRCORES		0x0F000000
-#define  BCMA_CC_ID_NRCORES_SHIFT	24
-#define  BCMA_CC_ID_TYPE		0xF0000000
-#define  BCMA_CC_ID_TYPE_SHIFT		28
-#define BCMA_CC_CAP			0x0004		/* Capabilities */
-#define  BCMA_CC_CAP_NRUART		0x00000003	/* # of UARTs */
-#define  BCMA_CC_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
-#define  BCMA_CC_CAP_UARTCLK		0x00000018	/* UART clock select */
-#define   BCMA_CC_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
-#define  BCMA_CC_CAP_UARTGPIO		0x00000020	/* UARTs on GPIO 15-12 */
-#define  BCMA_CC_CAP_EXTBUS		0x000000C0	/* External buses present */
-#define  BCMA_CC_CAP_FLASHT		0x00000700	/* Flash Type */
-#define   BCMA_CC_FLASHT_NONE		0x00000000	/* No flash */
-#define   BCMA_CC_FLASHT_STSER		0x00000100	/* ST serial flash */
-#define   BCMA_CC_FLASHT_ATSER		0x00000200	/* Atmel serial flash */
-#define   BCMA_CC_FLASHT_NAND		0x00000300	/* NAND flash */
-#define	  BCMA_CC_FLASHT_PARA		0x00000700	/* Parallel flash */
-#define  BCMA_CC_CAP_PLLT		0x00038000	/* PLL Type */
-#define   BCMA_PLLTYPE_NONE		0x00000000
-#define   BCMA_PLLTYPE_1		0x00010000	/* 48Mhz base, 3 dividers */
-#define   BCMA_PLLTYPE_2		0x00020000	/* 48Mhz, 4 dividers */
-#define   BCMA_PLLTYPE_3		0x00030000	/* 25Mhz, 2 dividers */
-#define   BCMA_PLLTYPE_4		0x00008000	/* 48Mhz, 4 dividers */
-#define   BCMA_PLLTYPE_5		0x00018000	/* 25Mhz, 4 dividers */
-#define   BCMA_PLLTYPE_6		0x00028000	/* 100/200 or 120/240 only */
-#define   BCMA_PLLTYPE_7		0x00038000	/* 25Mhz, 4 dividers */
-#define  BCMA_CC_CAP_PCTL		0x00040000	/* Power Control */
-#define  BCMA_CC_CAP_OTPS		0x00380000	/* OTP size */
-#define  BCMA_CC_CAP_OTPS_SHIFT		19
-#define  BCMA_CC_CAP_OTPS_BASE		5
-#define  BCMA_CC_CAP_JTAGM		0x00400000	/* JTAG master present */
-#define  BCMA_CC_CAP_BROM		0x00800000	/* Internal boot ROM active */
-#define  BCMA_CC_CAP_64BIT		0x08000000	/* 64-bit Backplane */
-#define  BCMA_CC_CAP_PMU		0x10000000	/* PMU available (rev >= 20) */
-#define  BCMA_CC_CAP_ECI		0x20000000	/* ECI available (rev >= 20) */
-#define  BCMA_CC_CAP_SPROM		0x40000000	/* SPROM present */
-#define  BCMA_CC_CAP_NFLASH		0x80000000	/* NAND flash present (rev >= 35 or BCM4706?) */
-#define BCMA_CC_CORECTL			0x0008
-#define  BCMA_CC_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
-#define	 BCMA_CC_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
-#define  BCMA_CC_CORECTL_UARTCLKEN	0x00000008	/* UART clock enable (rev >= 21) */
-#define BCMA_CC_BIST			0x000C
-#define BCMA_CC_OTPS			0x0010		/* OTP status */
-#define	 BCMA_CC_OTPS_PROGFAIL		0x80000000
-#define	 BCMA_CC_OTPS_PROTECT		0x00000007
-#define	 BCMA_CC_OTPS_HW_PROTECT	0x00000001
-#define	 BCMA_CC_OTPS_SW_PROTECT	0x00000002
-#define	 BCMA_CC_OTPS_CID_PROTECT	0x00000004
-#define  BCMA_CC_OTPS_GU_PROG_IND	0x00000F00	/* General Use programmed indication */
-#define  BCMA_CC_OTPS_GU_PROG_IND_SHIFT	8
-#define  BCMA_CC_OTPS_GU_PROG_HW	0x00000100	/* HW region programmed */
-#define BCMA_CC_OTPC			0x0014		/* OTP control */
-#define	 BCMA_CC_OTPC_RECWAIT		0xFF000000
-#define	 BCMA_CC_OTPC_PROGWAIT		0x00FFFF00
-#define	 BCMA_CC_OTPC_PRW_SHIFT		8
-#define	 BCMA_CC_OTPC_MAXFAIL		0x00000038
-#define	 BCMA_CC_OTPC_VSEL		0x00000006
-#define	 BCMA_CC_OTPC_SELVL		0x00000001
-#define BCMA_CC_OTPP			0x0018		/* OTP prog */
-#define	 BCMA_CC_OTPP_COL		0x000000FF
-#define	 BCMA_CC_OTPP_ROW		0x0000FF00
-#define	 BCMA_CC_OTPP_ROW_SHIFT		8
-#define	 BCMA_CC_OTPP_READERR		0x10000000
-#define	 BCMA_CC_OTPP_VALUE		0x20000000
-#define	 BCMA_CC_OTPP_READ		0x40000000
-#define	 BCMA_CC_OTPP_START		0x80000000
-#define	 BCMA_CC_OTPP_BUSY		0x80000000
-#define BCMA_CC_OTPL			0x001C		/* OTP layout */
-#define  BCMA_CC_OTPL_GURGN_OFFSET	0x00000FFF	/* offset of general use region */
-#define BCMA_CC_IRQSTAT			0x0020
-#define BCMA_CC_IRQMASK			0x0024
-#define	 BCMA_CC_IRQ_GPIO		0x00000001	/* gpio intr */
-#define	 BCMA_CC_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
-#define	 BCMA_CC_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
-#define BCMA_CC_CHIPCTL			0x0028		/* Rev >= 11 only */
-#define BCMA_CC_CHIPSTAT		0x002C		/* Rev >= 11 only */
-#define  BCMA_CC_CHIPST_4313_SPROM_PRESENT	1
-#define  BCMA_CC_CHIPST_4313_OTP_PRESENT	2
-#define  BCMA_CC_CHIPST_4331_SPROM_PRESENT	2
-#define  BCMA_CC_CHIPST_4331_OTP_PRESENT	4
-#define  BCMA_CC_CHIPST_43228_ILP_DIV_EN	0x00000001
-#define  BCMA_CC_CHIPST_43228_OTP_PRESENT	0x00000002
-#define  BCMA_CC_CHIPST_43228_SERDES_REFCLK_PADSEL	0x00000004
-#define  BCMA_CC_CHIPST_43228_SDIO_MODE		0x00000008
-#define  BCMA_CC_CHIPST_43228_SDIO_OTP_PRESENT	0x00000010
-#define  BCMA_CC_CHIPST_43228_SDIO_RESET	0x00000020
-#define  BCMA_CC_CHIPST_4706_PKG_OPTION		BIT(0) /* 0: full-featured package 1: low-cost package */
-#define  BCMA_CC_CHIPST_4706_SFLASH_PRESENT	BIT(1) /* 0: parallel, 1: serial flash is present */
-#define  BCMA_CC_CHIPST_4706_SFLASH_TYPE	BIT(2) /* 0: 8b-p/ST-s flash, 1: 16b-p/Atmal-s flash */
-#define  BCMA_CC_CHIPST_4706_MIPS_BENDIAN	BIT(3) /* 0: little, 1: big endian */
-#define  BCMA_CC_CHIPST_4706_PCIE1_DISABLE	BIT(5) /* PCIE1 enable strap pin */
-#define  BCMA_CC_CHIPST_5357_NAND_BOOT		BIT(4) /* NAND boot, valid for CC rev 38 and/or BCM5357 */
-#define  BCMA_CC_CHIPST_4360_XTAL_40MZ		0x00000001
-#define BCMA_CC_JCMD			0x0030		/* Rev >= 10 only */
-#define  BCMA_CC_JCMD_START		0x80000000
-#define  BCMA_CC_JCMD_BUSY		0x80000000
-#define  BCMA_CC_JCMD_PAUSE		0x40000000
-#define  BCMA_CC_JCMD0_ACC_MASK		0x0000F000
-#define  BCMA_CC_JCMD0_ACC_IRDR		0x00000000
-#define  BCMA_CC_JCMD0_ACC_DR		0x00001000
-#define  BCMA_CC_JCMD0_ACC_IR		0x00002000
-#define  BCMA_CC_JCMD0_ACC_RESET	0x00003000
-#define  BCMA_CC_JCMD0_ACC_IRPDR	0x00004000
-#define  BCMA_CC_JCMD0_ACC_PDR		0x00005000
-#define  BCMA_CC_JCMD0_IRW_MASK		0x00000F00
-#define  BCMA_CC_JCMD_ACC_MASK		0x000F0000	/* Changes for corerev 11 */
-#define  BCMA_CC_JCMD_ACC_IRDR		0x00000000
-#define  BCMA_CC_JCMD_ACC_DR		0x00010000
-#define  BCMA_CC_JCMD_ACC_IR		0x00020000
-#define  BCMA_CC_JCMD_ACC_RESET		0x00030000
-#define  BCMA_CC_JCMD_ACC_IRPDR		0x00040000
-#define  BCMA_CC_JCMD_ACC_PDR		0x00050000
-#define  BCMA_CC_JCMD_IRW_MASK		0x00001F00
-#define  BCMA_CC_JCMD_IRW_SHIFT		8
-#define  BCMA_CC_JCMD_DRW_MASK		0x0000003F
-#define BCMA_CC_JIR			0x0034		/* Rev >= 10 only */
-#define BCMA_CC_JDR			0x0038		/* Rev >= 10 only */
-#define BCMA_CC_JCTL			0x003C		/* Rev >= 10 only */
-#define  BCMA_CC_JCTL_FORCE_CLK		4		/* Force clock */
-#define  BCMA_CC_JCTL_EXT_EN		2		/* Enable external targets */
-#define  BCMA_CC_JCTL_EN		1		/* Enable Jtag master */
-#define BCMA_CC_FLASHCTL		0x0040
-/* Start/busy bit in flashcontrol */
-#define  BCMA_CC_FLASHCTL_OPCODE	0x000000ff
-#define  BCMA_CC_FLASHCTL_ACTION	0x00000700
-#define  BCMA_CC_FLASHCTL_CS_ACTIVE	0x00001000	/* Chip Select Active, rev >= 20 */
-#define  BCMA_CC_FLASHCTL_START		0x80000000
-#define  BCMA_CC_FLASHCTL_BUSY		BCMA_CC_FLASHCTL_START
-/* Flashcontrol action + opcodes for ST flashes */
-#define  BCMA_CC_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
-#define  BCMA_CC_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
-#define  BCMA_CC_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
-#define  BCMA_CC_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
-#define  BCMA_CC_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
-#define  BCMA_CC_FLASHCTL_ST_PP		0x0302		/* Page Program */
-#define  BCMA_CC_FLASHCTL_ST_SE		0x02d8		/* Sector Erase */
-#define  BCMA_CC_FLASHCTL_ST_BE		0x00c7		/* Bulk Erase */
-#define  BCMA_CC_FLASHCTL_ST_DP		0x00b9		/* Deep Power-down */
-#define  BCMA_CC_FLASHCTL_ST_RES	0x03ab		/* Read Electronic Signature */
-#define  BCMA_CC_FLASHCTL_ST_CSA	0x1000		/* Keep chip select asserted */
-#define  BCMA_CC_FLASHCTL_ST_SSE	0x0220		/* Sub-sector Erase */
-/* Flashcontrol action + opcodes for Atmel flashes */
-#define  BCMA_CC_FLASHCTL_AT_READ			0x07e8
-#define  BCMA_CC_FLASHCTL_AT_PAGE_READ			0x07d2
-#define  BCMA_CC_FLASHCTL_AT_STATUS			0x01d7
-#define  BCMA_CC_FLASHCTL_AT_BUF1_WRITE			0x0384
-#define  BCMA_CC_FLASHCTL_AT_BUF2_WRITE			0x0387
-#define  BCMA_CC_FLASHCTL_AT_BUF1_ERASE_PROGRAM		0x0283
-#define  BCMA_CC_FLASHCTL_AT_BUF2_ERASE_PROGRAM		0x0286
-#define  BCMA_CC_FLASHCTL_AT_BUF1_PROGRAM		0x0288
-#define  BCMA_CC_FLASHCTL_AT_BUF2_PROGRAM		0x0289
-#define  BCMA_CC_FLASHCTL_AT_PAGE_ERASE			0x0281
-#define  BCMA_CC_FLASHCTL_AT_BLOCK_ERASE		0x0250
-#define  BCMA_CC_FLASHCTL_AT_BUF1_WRITE_ERASE_PROGRAM	0x0382
-#define  BCMA_CC_FLASHCTL_AT_BUF2_WRITE_ERASE_PROGRAM	0x0385
-#define  BCMA_CC_FLASHCTL_AT_BUF1_LOAD			0x0253
-#define  BCMA_CC_FLASHCTL_AT_BUF2_LOAD			0x0255
-#define  BCMA_CC_FLASHCTL_AT_BUF1_COMPARE		0x0260
-#define  BCMA_CC_FLASHCTL_AT_BUF2_COMPARE		0x0261
-#define  BCMA_CC_FLASHCTL_AT_BUF1_REPROGRAM		0x0258
-#define  BCMA_CC_FLASHCTL_AT_BUF2_REPROGRAM		0x0259
-#define BCMA_CC_FLASHADDR		0x0044
-#define BCMA_CC_FLASHDATA		0x0048
-/* Status register bits for ST flashes */
-#define  BCMA_CC_FLASHDATA_ST_WIP	0x01		/* Write In Progress */
-#define  BCMA_CC_FLASHDATA_ST_WEL	0x02		/* Write Enable Latch */
-#define  BCMA_CC_FLASHDATA_ST_BP_MASK	0x1c		/* Block Protect */
-#define  BCMA_CC_FLASHDATA_ST_BP_SHIFT	2
-#define  BCMA_CC_FLASHDATA_ST_SRWD	0x80		/* Status Register Write Disable */
-/* Status register bits for Atmel flashes */
-#define  BCMA_CC_FLASHDATA_AT_READY	0x80
-#define  BCMA_CC_FLASHDATA_AT_MISMATCH	0x40
-#define  BCMA_CC_FLASHDATA_AT_ID_MASK	0x38
-#define  BCMA_CC_FLASHDATA_AT_ID_SHIFT	3
-#define BCMA_CC_BCAST_ADDR		0x0050
-#define BCMA_CC_BCAST_DATA		0x0054
-#define BCMA_CC_GPIOPULLUP		0x0058		/* Rev >= 20 only */
-#define BCMA_CC_GPIOPULLDOWN		0x005C		/* Rev >= 20 only */
-#define BCMA_CC_GPIOIN			0x0060
-#define BCMA_CC_GPIOOUT			0x0064
-#define BCMA_CC_GPIOOUTEN		0x0068
-#define BCMA_CC_GPIOCTL			0x006C
-#define BCMA_CC_GPIOPOL			0x0070
-#define BCMA_CC_GPIOIRQ			0x0074
-#define BCMA_CC_WATCHDOG		0x0080
-#define BCMA_CC_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
-#define  BCMA_CC_GPIOTIMER_OFFTIME	0x0000FFFF
-#define  BCMA_CC_GPIOTIMER_OFFTIME_SHIFT	0
-#define  BCMA_CC_GPIOTIMER_ONTIME	0xFFFF0000
-#define  BCMA_CC_GPIOTIMER_ONTIME_SHIFT	16
-#define BCMA_CC_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
-#define BCMA_CC_CLOCK_N			0x0090
-#define BCMA_CC_CLOCK_SB		0x0094
-#define BCMA_CC_CLOCK_PCI		0x0098
-#define BCMA_CC_CLOCK_M2		0x009C
-#define BCMA_CC_CLOCK_MIPS		0x00A0
-#define BCMA_CC_CLKDIV			0x00A4		/* Rev >= 3 only */
-#define	 BCMA_CC_CLKDIV_SFLASH		0x0F000000
-#define	 BCMA_CC_CLKDIV_SFLASH_SHIFT	24
-#define	 BCMA_CC_CLKDIV_OTP		0x000F0000
-#define	 BCMA_CC_CLKDIV_OTP_SHIFT	16
-#define	 BCMA_CC_CLKDIV_JTAG		0x00000F00
-#define	 BCMA_CC_CLKDIV_JTAG_SHIFT	8
-#define	 BCMA_CC_CLKDIV_UART		0x000000FF
-#define BCMA_CC_CAP_EXT			0x00AC		/* Capabilities */
-#define  BCMA_CC_CAP_EXT_SECI_PRESENT	0x00000001
-#define  BCMA_CC_CAP_EXT_GSIO_PRESENT	0x00000002
-#define  BCMA_CC_CAP_EXT_GCI_PRESENT	0x00000004
-#define  BCMA_CC_CAP_EXT_SECI_PUART_PRESENT		0x00000008    /* UART present */
-#define  BCMA_CC_CAP_EXT_AOB_PRESENT	0x00000040
-#define BCMA_CC_PLLONDELAY		0x00B0		/* Rev >= 4 only */
-#define BCMA_CC_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
-#define BCMA_CC_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
-#define  BCMA_CC_SLOWCLKCTL_SRC		0x00000007	/* slow clock source mask */
-#define	  BCMA_CC_SLOWCLKCTL_SRC_LPO	0x00000000	/* source of slow clock is LPO */
-#define   BCMA_CC_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
-#define	  BCMA_CC_SLOECLKCTL_SRC_PCI	0x00000002	/* source of slow clock is PCI */
-#define  BCMA_CC_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
-#define  BCMA_CC_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
-#define  BCMA_CC_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
-#define  BCMA_CC_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
-#define  BCMA_CC_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
-#define  BCMA_CC_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
-#define  BCMA_CC_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
-#define  BCMA_CC_SLOWCLKCTL_CLKDIV_SHIFT	16
-#define BCMA_CC_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
-#define	 BCMA_CC_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
-#define	 BCMA_CC_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
-#define	 BCMA_CC_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
-#define	 BCMA_CC_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
-#define	 BCMA_CC_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
-#define  BCMA_CC_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
-#define  BCMA_CC_SYSCLKCTL_CLKDIV_SHIFT	16
-#define BCMA_CC_CLKSTSTR		0x00C4		/* Rev >= 3 only */
-#define BCMA_CC_EROM			0x00FC
-#define BCMA_CC_PCMCIA_CFG		0x0100
-#define BCMA_CC_PCMCIA_MEMWAIT		0x0104
-#define BCMA_CC_PCMCIA_ATTRWAIT		0x0108
-#define BCMA_CC_PCMCIA_IOWAIT		0x010C
-#define BCMA_CC_IDE_CFG			0x0110
-#define BCMA_CC_IDE_MEMWAIT		0x0114
-#define BCMA_CC_IDE_ATTRWAIT		0x0118
-#define BCMA_CC_IDE_IOWAIT		0x011C
-#define BCMA_CC_PROG_CFG		0x0120
-#define BCMA_CC_PROG_WAITCNT		0x0124
-#define BCMA_CC_FLASH_CFG		0x0128
-#define  BCMA_CC_FLASH_CFG_DS		0x0010	/* Data size, 0=8bit, 1=16bit */
-#define BCMA_CC_FLASH_WAITCNT		0x012C
-#define BCMA_CC_SROM_CONTROL		0x0190
-#define  BCMA_CC_SROM_CONTROL_START	0x80000000
-#define  BCMA_CC_SROM_CONTROL_BUSY	0x80000000
-#define  BCMA_CC_SROM_CONTROL_OPCODE	0x60000000
-#define  BCMA_CC_SROM_CONTROL_OP_READ	0x00000000
-#define  BCMA_CC_SROM_CONTROL_OP_WRITE	0x20000000
-#define  BCMA_CC_SROM_CONTROL_OP_WRDIS	0x40000000
-#define  BCMA_CC_SROM_CONTROL_OP_WREN	0x60000000
-#define  BCMA_CC_SROM_CONTROL_OTPSEL	0x00000010
-#define  BCMA_CC_SROM_CONTROL_OTP_PRESENT	0x00000020
-#define  BCMA_CC_SROM_CONTROL_LOCK	0x00000008
-#define  BCMA_CC_SROM_CONTROL_SIZE_MASK	0x00000006
-#define  BCMA_CC_SROM_CONTROL_SIZE_1K	0x00000000
-#define  BCMA_CC_SROM_CONTROL_SIZE_4K	0x00000002
-#define  BCMA_CC_SROM_CONTROL_SIZE_16K	0x00000004
-#define  BCMA_CC_SROM_CONTROL_SIZE_SHIFT	1
-#define  BCMA_CC_SROM_CONTROL_PRESENT	0x00000001
-/* Block 0x140 - 0x190 registers are chipset specific */
-#define BCMA_CC_4706_FLASHSCFG		0x18C		/* Flash struct configuration */
-#define  BCMA_CC_4706_FLASHSCFG_MASK	0x000000ff
-#define  BCMA_CC_4706_FLASHSCFG_SF1	0x00000001	/* 2nd serial flash present */
-#define  BCMA_CC_4706_FLASHSCFG_PF1	0x00000002	/* 2nd parallel flash present */
-#define  BCMA_CC_4706_FLASHSCFG_SF1_TYPE	0x00000004	/* 2nd serial flash type : 0 : ST, 1 : Atmel */
-#define  BCMA_CC_4706_FLASHSCFG_NF1	0x00000008	/* 2nd NAND flash present */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_MASK	0x000000f0
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_4MB	0x00000010	/* 4MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_8MB	0x00000020	/* 8MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_16MB	0x00000030	/* 16MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_32MB	0x00000040	/* 32MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_64MB	0x00000050	/* 64MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_128MB	0x00000060	/* 128MB */
-#define  BCMA_CC_4706_FLASHSCFG_1ST_MADDR_SEG_256MB	0x00000070	/* 256MB */
-/* NAND flash registers for BCM4706 (corerev = 31) */
-#define BCMA_CC_NFLASH_CTL		0x01A0
-#define  BCMA_CC_NFLASH_CTL_ERR		0x08000000
-#define BCMA_CC_NFLASH_CONF		0x01A4
-#define BCMA_CC_NFLASH_COL_ADDR		0x01A8
-#define BCMA_CC_NFLASH_ROW_ADDR		0x01AC
-#define BCMA_CC_NFLASH_DATA		0x01B0
-#define BCMA_CC_NFLASH_WAITCNT0		0x01B4
-/* 0x1E0 is defined as shared BCMA_CLKCTLST */
-#define BCMA_CC_HW_WORKAROUND		0x01E4 /* Hardware workaround (rev >= 20) */
-#define BCMA_CC_UART0_DATA		0x0300
-#define BCMA_CC_UART0_IMR		0x0304
-#define BCMA_CC_UART0_FCR		0x0308
-#define BCMA_CC_UART0_LCR		0x030C
-#define BCMA_CC_UART0_MCR		0x0310
-#define BCMA_CC_UART0_LSR		0x0314
-#define BCMA_CC_UART0_MSR		0x0318
-#define BCMA_CC_UART0_SCRATCH		0x031C
-#define BCMA_CC_UART1_DATA		0x0400
-#define BCMA_CC_UART1_IMR		0x0404
-#define BCMA_CC_UART1_FCR		0x0408
-#define BCMA_CC_UART1_LCR		0x040C
-#define BCMA_CC_UART1_MCR		0x0410
-#define BCMA_CC_UART1_LSR		0x0414
-#define BCMA_CC_UART1_MSR		0x0418
-#define BCMA_CC_UART1_SCRATCH		0x041C
-/* PMU registers (rev >= 20) */
-#define BCMA_CC_PMU_CTL			0x0600 /* PMU control */
-#define  BCMA_CC_PMU_CTL_ILP_DIV	0xFFFF0000 /* ILP div mask */
-#define  BCMA_CC_PMU_CTL_ILP_DIV_SHIFT	16
-#define  BCMA_CC_PMU_CTL_RES		0x00006000 /* reset control mask */
-#define  BCMA_CC_PMU_CTL_RES_SHIFT	13
-#define  BCMA_CC_PMU_CTL_RES_RELOAD	0x2	/* reload POR values */
-#define  BCMA_CC_PMU_CTL_PLL_UPD	0x00000400
-#define  BCMA_CC_PMU_CTL_NOILPONW	0x00000200 /* No ILP on wait */
-#define  BCMA_CC_PMU_CTL_HTREQEN	0x00000100 /* HT req enable */
-#define  BCMA_CC_PMU_CTL_ALPREQEN	0x00000080 /* ALP req enable */
-#define  BCMA_CC_PMU_CTL_XTALFREQ	0x0000007C /* Crystal freq */
-#define  BCMA_CC_PMU_CTL_XTALFREQ_SHIFT	2
-#define  BCMA_CC_PMU_CTL_ILPDIVEN	0x00000002 /* ILP div enable */
-#define  BCMA_CC_PMU_CTL_LPOSEL		0x00000001 /* LPO sel */
-#define BCMA_CC_PMU_CAP			0x0604 /* PMU capabilities */
-#define  BCMA_CC_PMU_CAP_REVISION	0x000000FF /* Revision mask */
-#define BCMA_CC_PMU_STAT		0x0608 /* PMU status */
-#define  BCMA_CC_PMU_STAT_EXT_LPO_AVAIL	0x00000100
-#define  BCMA_CC_PMU_STAT_WDRESET	0x00000080
-#define  BCMA_CC_PMU_STAT_INTPEND	0x00000040 /* Interrupt pending */
-#define  BCMA_CC_PMU_STAT_SBCLKST	0x00000030 /* Backplane clock status? */
-#define  BCMA_CC_PMU_STAT_HAVEALP	0x00000008 /* ALP available */
-#define  BCMA_CC_PMU_STAT_HAVEHT	0x00000004 /* HT available */
-#define  BCMA_CC_PMU_STAT_RESINIT	0x00000003 /* Res init */
-#define BCMA_CC_PMU_RES_STAT		0x060C /* PMU res status */
-#define BCMA_CC_PMU_RES_PEND		0x0610 /* PMU res pending */
-#define BCMA_CC_PMU_TIMER		0x0614 /* PMU timer */
-#define BCMA_CC_PMU_MINRES_MSK		0x0618 /* PMU min res mask */
-#define BCMA_CC_PMU_MAXRES_MSK		0x061C /* PMU max res mask */
-#define BCMA_CC_PMU_RES_TABSEL		0x0620 /* PMU res table sel */
-#define BCMA_CC_PMU_RES_DEPMSK		0x0624 /* PMU res dep mask */
-#define BCMA_CC_PMU_RES_UPDNTM		0x0628 /* PMU res updown timer */
-#define BCMA_CC_PMU_RES_TIMER		0x062C /* PMU res timer */
-#define BCMA_CC_PMU_CLKSTRETCH		0x0630 /* PMU clockstretch */
-#define BCMA_CC_PMU_WATCHDOG		0x0634 /* PMU watchdog */
-#define BCMA_CC_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
-#define BCMA_CC_PMU_RES_REQT		0x0644 /* PMU res req timer */
-#define BCMA_CC_PMU_RES_REQM		0x0648 /* PMU res req mask */
-#define BCMA_CC_PMU_CHIPCTL_ADDR	0x0650
-#define BCMA_CC_PMU_CHIPCTL_DATA	0x0654
-#define BCMA_CC_PMU_REGCTL_ADDR		0x0658
-#define BCMA_CC_PMU_REGCTL_DATA		0x065C
-#define BCMA_CC_PMU_PLLCTL_ADDR		0x0660
-#define BCMA_CC_PMU_PLLCTL_DATA		0x0664
-#define BCMA_CC_PMU_STRAPOPT		0x0668 /* (corerev >= 28) */
-#define BCMA_CC_PMU_XTAL_FREQ		0x066C /* (pmurev >= 10) */
-#define  BCMA_CC_PMU_XTAL_FREQ_ILPCTL_MASK	0x00001FFF
-#define  BCMA_CC_PMU_XTAL_FREQ_MEASURE_MASK	0x80000000
-#define  BCMA_CC_PMU_XTAL_FREQ_MEASURE_SHIFT	31
-#define BCMA_CC_SPROM			0x0800 /* SPROM beginning */
-/* NAND flash MLC controller registers (corerev >= 38) */
-#define BCMA_CC_NAND_REVISION		0x0C00
-#define BCMA_CC_NAND_CMD_START		0x0C04
-#define BCMA_CC_NAND_CMD_ADDR_X		0x0C08
-#define BCMA_CC_NAND_CMD_ADDR		0x0C0C
-#define BCMA_CC_NAND_CMD_END_ADDR	0x0C10
-#define BCMA_CC_NAND_CS_NAND_SELECT	0x0C14
-#define BCMA_CC_NAND_CS_NAND_XOR	0x0C18
-#define BCMA_CC_NAND_SPARE_RD0		0x0C20
-#define BCMA_CC_NAND_SPARE_RD4		0x0C24
-#define BCMA_CC_NAND_SPARE_RD8		0x0C28
-#define BCMA_CC_NAND_SPARE_RD12		0x0C2C
-#define BCMA_CC_NAND_SPARE_WR0		0x0C30
-#define BCMA_CC_NAND_SPARE_WR4		0x0C34
-#define BCMA_CC_NAND_SPARE_WR8		0x0C38
-#define BCMA_CC_NAND_SPARE_WR12		0x0C3C
-#define BCMA_CC_NAND_ACC_CONTROL	0x0C40
-#define BCMA_CC_NAND_CONFIG		0x0C48
-#define BCMA_CC_NAND_TIMING_1		0x0C50
-#define BCMA_CC_NAND_TIMING_2		0x0C54
-#define BCMA_CC_NAND_SEMAPHORE		0x0C58
-#define BCMA_CC_NAND_DEVID		0x0C60
-#define BCMA_CC_NAND_DEVID_X		0x0C64
-#define BCMA_CC_NAND_BLOCK_LOCK_STATUS	0x0C68
-#define BCMA_CC_NAND_INTFC_STATUS	0x0C6C
-#define BCMA_CC_NAND_ECC_CORR_ADDR_X	0x0C70
-#define BCMA_CC_NAND_ECC_CORR_ADDR	0x0C74
-#define BCMA_CC_NAND_ECC_UNC_ADDR_X	0x0C78
-#define BCMA_CC_NAND_ECC_UNC_ADDR	0x0C7C
-#define BCMA_CC_NAND_READ_ERROR_COUNT	0x0C80
-#define BCMA_CC_NAND_CORR_STAT_THRESHOLD	0x0C84
-#define BCMA_CC_NAND_READ_ADDR_X	0x0C90
-#define BCMA_CC_NAND_READ_ADDR		0x0C94
-#define BCMA_CC_NAND_PAGE_PROGRAM_ADDR_X	0x0C98
-#define BCMA_CC_NAND_PAGE_PROGRAM_ADDR	0x0C9C
-#define BCMA_CC_NAND_COPY_BACK_ADDR_X	0x0CA0
-#define BCMA_CC_NAND_COPY_BACK_ADDR	0x0CA4
-#define BCMA_CC_NAND_BLOCK_ERASE_ADDR_X	0x0CA8
-#define BCMA_CC_NAND_BLOCK_ERASE_ADDR	0x0CAC
-#define BCMA_CC_NAND_INV_READ_ADDR_X	0x0CB0
-#define BCMA_CC_NAND_INV_READ_ADDR	0x0CB4
-#define BCMA_CC_NAND_BLK_WR_PROTECT	0x0CC0
-#define BCMA_CC_NAND_ACC_CONTROL_CS1	0x0CD0
-#define BCMA_CC_NAND_CONFIG_CS1		0x0CD4
-#define BCMA_CC_NAND_TIMING_1_CS1	0x0CD8
-#define BCMA_CC_NAND_TIMING_2_CS1	0x0CDC
-#define BCMA_CC_NAND_SPARE_RD16		0x0D30
-#define BCMA_CC_NAND_SPARE_RD20		0x0D34
-#define BCMA_CC_NAND_SPARE_RD24		0x0D38
-#define BCMA_CC_NAND_SPARE_RD28		0x0D3C
-#define BCMA_CC_NAND_CACHE_ADDR		0x0D40
-#define BCMA_CC_NAND_CACHE_DATA		0x0D44
-#define BCMA_CC_NAND_CTRL_CONFIG	0x0D48
-#define BCMA_CC_NAND_CTRL_STATUS	0x0D4C
-
-/* Divider allocation in 4716/47162/5356 */
-#define BCMA_CC_PMU5_MAINPLL_CPU	1
-#define BCMA_CC_PMU5_MAINPLL_MEM	2
-#define BCMA_CC_PMU5_MAINPLL_SSB	3
-
-/* PLL usage in 4716/47162 */
-#define BCMA_CC_PMU4716_MAINPLL_PLL0	12
-
-/* PLL usage in 5356/5357 */
-#define BCMA_CC_PMU5356_MAINPLL_PLL0	0
-#define BCMA_CC_PMU5357_MAINPLL_PLL0	0
-
-/* 4706 PMU */
-#define BCMA_CC_PMU4706_MAINPLL_PLL0	0
-#define BCMA_CC_PMU6_4706_PROCPLL_OFF	4	/* The CPU PLL */
-#define  BCMA_CC_PMU6_4706_PROC_P2DIV_MASK	0x000f0000
-#define  BCMA_CC_PMU6_4706_PROC_P2DIV_SHIFT	16
-#define  BCMA_CC_PMU6_4706_PROC_P1DIV_MASK	0x0000f000
-#define  BCMA_CC_PMU6_4706_PROC_P1DIV_SHIFT	12
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_INT_MASK	0x00000ff8
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_INT_SHIFT	3
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_MASK	0x00000007
-#define  BCMA_CC_PMU6_4706_PROC_NDIV_MODE_SHIFT	0
-
-/* PMU rev 15 */
-#define BCMA_CC_PMU15_PLL_PLLCTL0	0
-#define  BCMA_CC_PMU15_PLL_PC0_CLKSEL_MASK	0x00000003
-#define  BCMA_CC_PMU15_PLL_PC0_CLKSEL_SHIFT	0
-#define  BCMA_CC_PMU15_PLL_PC0_FREQTGT_MASK	0x003FFFFC
-#define  BCMA_CC_PMU15_PLL_PC0_FREQTGT_SHIFT	2
-#define  BCMA_CC_PMU15_PLL_PC0_PRESCALE_MASK	0x00C00000
-#define  BCMA_CC_PMU15_PLL_PC0_PRESCALE_SHIFT	22
-#define  BCMA_CC_PMU15_PLL_PC0_KPCTRL_MASK	0x07000000
-#define  BCMA_CC_PMU15_PLL_PC0_KPCTRL_SHIFT	24
-#define  BCMA_CC_PMU15_PLL_PC0_FCNTCTRL_MASK	0x38000000
-#define  BCMA_CC_PMU15_PLL_PC0_FCNTCTRL_SHIFT	27
-#define  BCMA_CC_PMU15_PLL_PC0_FDCMODE_MASK	0x40000000
-#define  BCMA_CC_PMU15_PLL_PC0_FDCMODE_SHIFT	30
-#define  BCMA_CC_PMU15_PLL_PC0_CTRLBIAS_MASK	0x80000000
-#define  BCMA_CC_PMU15_PLL_PC0_CTRLBIAS_SHIFT	31
-
-/* ALP clock on pre-PMU chips */
-#define BCMA_CC_PMU_ALP_CLOCK		20000000
-/* HT clock for systems with PMU-enabled chipcommon */
-#define BCMA_CC_PMU_HT_CLOCK		80000000
-
-/* PMU rev 5 (& 6) */
-#define BCMA_CC_PPL_P1P2_OFF		0
-#define BCMA_CC_PPL_P1_MASK		0x0f000000
-#define BCMA_CC_PPL_P1_SHIFT		24
-#define BCMA_CC_PPL_P2_MASK		0x00f00000
-#define BCMA_CC_PPL_P2_SHIFT		20
-#define BCMA_CC_PPL_M14_OFF		1
-#define BCMA_CC_PPL_MDIV_MASK		0x000000ff
-#define BCMA_CC_PPL_MDIV_WIDTH		8
-#define BCMA_CC_PPL_NM5_OFF		2
-#define BCMA_CC_PPL_NDIV_MASK		0xfff00000
-#define BCMA_CC_PPL_NDIV_SHIFT		20
-#define BCMA_CC_PPL_FMAB_OFF		3
-#define BCMA_CC_PPL_MRAT_MASK		0xf0000000
-#define BCMA_CC_PPL_MRAT_SHIFT		28
-#define BCMA_CC_PPL_ABRAT_MASK		0x08000000
-#define BCMA_CC_PPL_ABRAT_SHIFT		27
-#define BCMA_CC_PPL_FDIV_MASK		0x07ffffff
-#define BCMA_CC_PPL_PLLCTL_OFF		4
-#define BCMA_CC_PPL_PCHI_OFF		5
-#define BCMA_CC_PPL_PCHI_MASK		0x0000003f
-
-#define BCMA_CC_PMU_PLL_CTL0		0
-#define BCMA_CC_PMU_PLL_CTL1		1
-#define BCMA_CC_PMU_PLL_CTL2		2
-#define BCMA_CC_PMU_PLL_CTL3		3
-#define BCMA_CC_PMU_PLL_CTL4		4
-#define BCMA_CC_PMU_PLL_CTL5		5
-
-#define BCMA_CC_PMU1_PLL0_PC0_P1DIV_MASK	0x00f00000
-#define BCMA_CC_PMU1_PLL0_PC0_P1DIV_SHIFT	20
-
-#define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_MASK	0x1ff00000
-#define BCMA_CC_PMU1_PLL0_PC2_NDIV_INT_SHIFT	20
-
-#define BCMA_CCB_MII_MNG_CTL		0x0000
-#define BCMA_CCB_MII_MNG_CMD_DATA	0x0004
-
-/* BCM4331 ChipControl numbers. */
-#define BCMA_CHIPCTL_4331_BT_COEXIST		BIT(0)	/* 0 disable */
-#define BCMA_CHIPCTL_4331_SECI			BIT(1)	/* 0 SECI is disabled (JATG functional) */
-#define BCMA_CHIPCTL_4331_EXT_LNA		BIT(2)	/* 0 disable */
-#define BCMA_CHIPCTL_4331_SPROM_GPIO13_15	BIT(3)	/* sprom/gpio13-15 mux */
-#define BCMA_CHIPCTL_4331_EXTPA_EN		BIT(4)	/* 0 ext pa disable, 1 ext pa enabled */
-#define BCMA_CHIPCTL_4331_GPIOCLK_ON_SPROMCS	BIT(5)	/* set drive out GPIO_CLK on sprom_cs pin */
-#define BCMA_CHIPCTL_4331_PCIE_MDIO_ON_SPROMCS	BIT(6)	/* use sprom_cs pin as PCIE mdio interface */
-#define BCMA_CHIPCTL_4331_EXTPA_ON_GPIO2_5	BIT(7)	/* aband extpa will be at gpio2/5 and sprom_dout */
-#define BCMA_CHIPCTL_4331_OVR_PIPEAUXCLKEN	BIT(8)	/* override core control on pipe_AuxClkEnable */
-#define BCMA_CHIPCTL_4331_OVR_PIPEAUXPWRDOWN	BIT(9)	/* override core control on pipe_AuxPowerDown */
-#define BCMA_CHIPCTL_4331_PCIE_AUXCLKEN		BIT(10)	/* pcie_auxclkenable */
-#define BCMA_CHIPCTL_4331_PCIE_PIPE_PLLDOWN	BIT(11)	/* pcie_pipe_pllpowerdown */
-#define BCMA_CHIPCTL_4331_EXTPA_EN2		BIT(12)	/* 0 ext pa disable, 1 ext pa enabled */
-#define BCMA_CHIPCTL_4331_BT_SHD0_ON_GPIO4	BIT(16)	/* enable bt_shd0 at gpio4 */
-#define BCMA_CHIPCTL_4331_BT_SHD1_ON_GPIO5	BIT(17)	/* enable bt_shd1 at gpio5 */
-
-/* 43224 chip-specific ChipControl register bits */
-#define BCMA_CCTRL_43224_GPIO_TOGGLE		0x8000		/* gpio[3:0] pins as btcoex or s/w gpio */
-#define BCMA_CCTRL_43224A0_12MA_LED_DRIVE	0x00F000F0	/* 12 mA drive strength */
-#define BCMA_CCTRL_43224B0_12MA_LED_DRIVE	0xF0		/* 12 mA drive strength for later 43224s */
-
-/* 4313 Chip specific ChipControl register bits */
-#define BCMA_CCTRL_4313_12MA_LED_DRIVE		0x00000007	/* 12 mA drive strengh for later 4313 */
-
-/* BCM5357 ChipControl register bits */
-#define BCMA_CHIPCTL_5357_EXTPA			BIT(14)
-#define BCMA_CHIPCTL_5357_ANT_MUX_2O3		BIT(15)
-#define BCMA_CHIPCTL_5357_NFLASH		BIT(16)
-#define BCMA_CHIPCTL_5357_I2S_PINS_ENABLE	BIT(18)
-#define BCMA_CHIPCTL_5357_I2CSPI_PINS_ENABLE	BIT(19)
-
-#define BCMA_RES_4314_LPLDO_PU			BIT(0)
-#define BCMA_RES_4314_PMU_SLEEP_DIS		BIT(1)
-#define BCMA_RES_4314_PMU_BG_PU			BIT(2)
-#define BCMA_RES_4314_CBUCK_LPOM_PU		BIT(3)
-#define BCMA_RES_4314_CBUCK_PFM_PU		BIT(4)
-#define BCMA_RES_4314_CLDO_PU			BIT(5)
-#define BCMA_RES_4314_LPLDO2_LVM		BIT(6)
-#define BCMA_RES_4314_WL_PMU_PU			BIT(7)
-#define BCMA_RES_4314_LNLDO_PU			BIT(8)
-#define BCMA_RES_4314_LDO3P3_PU			BIT(9)
-#define BCMA_RES_4314_OTP_PU			BIT(10)
-#define BCMA_RES_4314_XTAL_PU			BIT(11)
-#define BCMA_RES_4314_WL_PWRSW_PU		BIT(12)
-#define BCMA_RES_4314_LQ_AVAIL			BIT(13)
-#define BCMA_RES_4314_LOGIC_RET			BIT(14)
-#define BCMA_RES_4314_MEM_SLEEP			BIT(15)
-#define BCMA_RES_4314_MACPHY_RET		BIT(16)
-#define BCMA_RES_4314_WL_CORE_READY		BIT(17)
-#define BCMA_RES_4314_ILP_REQ			BIT(18)
-#define BCMA_RES_4314_ALP_AVAIL			BIT(19)
-#define BCMA_RES_4314_MISC_PWRSW_PU		BIT(20)
-#define BCMA_RES_4314_SYNTH_PWRSW_PU		BIT(21)
-#define BCMA_RES_4314_RX_PWRSW_PU		BIT(22)
-#define BCMA_RES_4314_RADIO_PU			BIT(23)
-#define BCMA_RES_4314_VCO_LDO_PU		BIT(24)
-#define BCMA_RES_4314_AFE_LDO_PU		BIT(25)
-#define BCMA_RES_4314_RX_LDO_PU			BIT(26)
-#define BCMA_RES_4314_TX_LDO_PU			BIT(27)
-#define BCMA_RES_4314_HT_AVAIL			BIT(28)
-#define BCMA_RES_4314_MACPHY_CLK_AVAIL		BIT(29)
-
-/* Data for the PMU, if available.
- * Check availability with ((struct bcma_chipcommon)->capabilities & BCMA_CC_CAP_PMU)
- */
-struct bcma_chipcommon_pmu {
-	struct bcma_device *core;	/* Can be separated core or just ChipCommon one */
-	u8 rev;			/* PMU revision */
-	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
-};
-
-#ifdef CPTCFG_BCMA_PFLASH
-struct bcma_pflash {
-	bool present;
-};
-#endif
-
-#ifdef CPTCFG_BCMA_SFLASH
-struct mtd_info;
-
-struct bcma_sflash {
-	bool present;
-	u32 blocksize;
-	u16 numblocks;
-	u32 size;
-};
-#endif
-
-#ifdef CPTCFG_BCMA_NFLASH
-struct bcma_nflash {
-	/* Must be the fist member for the brcmnand driver to
-	 * de-reference that structure.
-	 */
-	struct brcmnand_platform_data brcmnand_info;
-	bool present;
-	bool boot;		/* This is the flash the SoC boots from */
-};
-#endif
-
-#ifdef CPTCFG_BCMA_DRIVER_MIPS
-struct bcma_serial_port {
-	void *regs;
-	unsigned long clockspeed;
-	unsigned int irq;
-	unsigned int baud_base;
-	unsigned int reg_shift;
-};
-#endif /* CPTCFG_BCMA_DRIVER_MIPS */
-
-struct bcma_drv_cc {
-	struct bcma_device *core;
-	u32 status;
-	u32 capabilities;
-	u32 capabilities_ext;
-	u8 setup_done:1;
-	u8 early_setup_done:1;
-	/* Fast Powerup Delay constant */
-	u16 fast_pwrup_delay;
-	struct bcma_chipcommon_pmu pmu;
-#ifdef CPTCFG_BCMA_PFLASH
-	struct bcma_pflash pflash;
-#endif
-#ifdef CPTCFG_BCMA_SFLASH
-	struct bcma_sflash sflash;
-#endif
-#ifdef CPTCFG_BCMA_NFLASH
-	struct bcma_nflash nflash;
-#endif
-
-#ifdef CPTCFG_BCMA_DRIVER_MIPS
-	int nr_serial_ports;
-	struct bcma_serial_port serial_ports[4];
-#endif /* CPTCFG_BCMA_DRIVER_MIPS */
-	u32 ticks_per_ms;
-	struct platform_device *watchdog;
-
-	/* Lock for GPIO register access. */
-	spinlock_t gpio_lock;
-#ifdef CPTCFG_BCMA_DRIVER_GPIO
-	struct gpio_chip gpio;
-#endif
-};
-
-struct bcma_drv_cc_b {
-	struct bcma_device *core;
-	u8 setup_done:1;
-	void __iomem *mii;
-};
-
-/* Register access */
-#define bcma_cc_read32(cc, offset) \
-	bcma_read32((cc)->core, offset)
-#define bcma_cc_write32(cc, offset, val) \
-	bcma_write32((cc)->core, offset, val)
-
-#define bcma_cc_mask32(cc, offset, mask) \
-	bcma_cc_write32(cc, offset, bcma_cc_read32(cc, offset) & (mask))
-#define bcma_cc_set32(cc, offset, set) \
-	bcma_cc_write32(cc, offset, bcma_cc_read32(cc, offset) | (set))
-#define bcma_cc_maskset32(cc, offset, mask, set) \
-	bcma_cc_write32(cc, offset, (bcma_cc_read32(cc, offset) & (mask)) | (set))
-
-/* PMU registers access */
-#define bcma_pmu_read32(cc, offset) \
-	bcma_read32((cc)->pmu.core, offset)
-#define bcma_pmu_write32(cc, offset, val) \
-	bcma_write32((cc)->pmu.core, offset, val)
-
-#define bcma_pmu_mask32(cc, offset, mask) \
-	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) & (mask))
-#define bcma_pmu_set32(cc, offset, set) \
-	bcma_pmu_write32(cc, offset, bcma_pmu_read32(cc, offset) | (set))
-#define bcma_pmu_maskset32(cc, offset, mask, set) \
-	bcma_pmu_write32(cc, offset, (bcma_pmu_read32(cc, offset) & (mask)) | (set))
-
-extern u32 bcma_chipco_watchdog_timer_set(struct bcma_drv_cc *cc, u32 ticks);
-
-extern u32 bcma_chipco_get_alp_clock(struct bcma_drv_cc *cc);
-
-void bcma_chipco_irq_mask(struct bcma_drv_cc *cc, u32 mask, u32 value);
-
-u32 bcma_chipco_irq_status(struct bcma_drv_cc *cc, u32 mask);
-
-/* Chipcommon GPIO pin access. */
-u32 bcma_chipco_gpio_in(struct bcma_drv_cc *cc, u32 mask);
-u32 bcma_chipco_gpio_out(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_outen(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_control(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_intmask(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_polarity(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_pullup(struct bcma_drv_cc *cc, u32 mask, u32 value);
-u32 bcma_chipco_gpio_pulldown(struct bcma_drv_cc *cc, u32 mask, u32 value);
-
-/* PMU support */
-extern void bcma_chipco_pll_write(struct bcma_drv_cc *cc, u32 offset,
-				  u32 value);
-extern void bcma_chipco_pll_maskset(struct bcma_drv_cc *cc, u32 offset,
-				    u32 mask, u32 set);
-extern void bcma_chipco_chipctl_maskset(struct bcma_drv_cc *cc,
-					u32 offset, u32 mask, u32 set);
-extern void bcma_chipco_regctl_maskset(struct bcma_drv_cc *cc,
-				       u32 offset, u32 mask, u32 set);
-extern void bcma_pmu_spuravoid_pllupdate(struct bcma_drv_cc *cc, int spuravoid);
-
-extern u32 bcma_pmu_get_bus_clock(struct bcma_drv_cc *cc);
-
-void bcma_chipco_b_mii_write(struct bcma_drv_cc_b *ccb, u32 offset, u32 value);
-
-#endif /* LINUX_BCMA_DRIVER_CC_H_ */
diff --git a/include/linux/bcma/bcma_driver_gmac_cmn.h b/include/linux/bcma/bcma_driver_gmac_cmn.h
deleted file mode 100644
index 420e222..0000000
--- a/include/linux/bcma/bcma_driver_gmac_cmn.h
+++ /dev/null
@@ -1,95 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_GMAC_CMN_H_
-#define LINUX_BCMA_DRIVER_GMAC_CMN_H_
-
-#include <linux/types.h>
-
-#define BCMA_GMAC_CMN_STAG0		0x000
-#define BCMA_GMAC_CMN_STAG1		0x004
-#define BCMA_GMAC_CMN_STAG2		0x008
-#define BCMA_GMAC_CMN_STAG3		0x00C
-#define BCMA_GMAC_CMN_PARSER_CTL	0x020
-#define BCMA_GMAC_CMN_MIB_MAX_LEN	0x024
-#define BCMA_GMAC_CMN_PHY_ACCESS	0x100
-#define  BCMA_GMAC_CMN_PA_DATA_MASK	0x0000ffff
-#define  BCMA_GMAC_CMN_PA_ADDR_MASK	0x001f0000
-#define  BCMA_GMAC_CMN_PA_ADDR_SHIFT	16
-#define  BCMA_GMAC_CMN_PA_REG_MASK	0x1f000000
-#define  BCMA_GMAC_CMN_PA_REG_SHIFT	24
-#define  BCMA_GMAC_CMN_PA_WRITE		0x20000000
-#define  BCMA_GMAC_CMN_PA_START		0x40000000
-#define BCMA_GMAC_CMN_PHY_CTL		0x104
-#define  BCMA_GMAC_CMN_PC_EPA_MASK	0x0000001f
-#define  BCMA_GMAC_CMN_PC_MCT_MASK	0x007f0000
-#define  BCMA_GMAC_CMN_PC_MCT_SHIFT	16
-#define  BCMA_GMAC_CMN_PC_MTE		0x00800000
-#define BCMA_GMAC_CMN_GMAC0_RGMII_CTL	0x110
-#define BCMA_GMAC_CMN_CFP_ACCESS	0x200
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA0	0x210
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA1	0x214
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA2	0x218
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA3	0x21C
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA4	0x220
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA5	0x224
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA6	0x228
-#define BCMA_GMAC_CMN_CFP_TCAM_DATA7	0x22C
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK0	0x230
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK1	0x234
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK2	0x238
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK3	0x23C
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK4	0x240
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK5	0x244
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK6	0x248
-#define BCMA_GMAC_CMN_CFP_TCAM_MASK7	0x24C
-#define BCMA_GMAC_CMN_CFP_ACTION_DATA	0x250
-#define BCMA_GMAC_CMN_TCAM_BIST_CTL	0x2A0
-#define BCMA_GMAC_CMN_TCAM_BIST_STATUS	0x2A4
-#define BCMA_GMAC_CMN_TCAM_CMP_STATUS	0x2A8
-#define BCMA_GMAC_CMN_TCAM_DISABLE	0x2AC
-#define BCMA_GMAC_CMN_TCAM_TEST_CTL	0x2F0
-#define BCMA_GMAC_CMN_UDF_0_A3_A0	0x300
-#define BCMA_GMAC_CMN_UDF_0_A7_A4	0x304
-#define BCMA_GMAC_CMN_UDF_0_A8		0x308
-#define BCMA_GMAC_CMN_UDF_1_A3_A0	0x310
-#define BCMA_GMAC_CMN_UDF_1_A7_A4	0x314
-#define BCMA_GMAC_CMN_UDF_1_A8		0x318
-#define BCMA_GMAC_CMN_UDF_2_A3_A0	0x320
-#define BCMA_GMAC_CMN_UDF_2_A7_A4	0x324
-#define BCMA_GMAC_CMN_UDF_2_A8		0x328
-#define BCMA_GMAC_CMN_UDF_0_B3_B0	0x330
-#define BCMA_GMAC_CMN_UDF_0_B7_B4	0x334
-#define BCMA_GMAC_CMN_UDF_0_B8		0x338
-#define BCMA_GMAC_CMN_UDF_1_B3_B0	0x340
-#define BCMA_GMAC_CMN_UDF_1_B7_B4	0x344
-#define BCMA_GMAC_CMN_UDF_1_B8		0x348
-#define BCMA_GMAC_CMN_UDF_2_B3_B0	0x350
-#define BCMA_GMAC_CMN_UDF_2_B7_B4	0x354
-#define BCMA_GMAC_CMN_UDF_2_B8		0x358
-#define BCMA_GMAC_CMN_UDF_0_C3_C0	0x360
-#define BCMA_GMAC_CMN_UDF_0_C7_C4	0x364
-#define BCMA_GMAC_CMN_UDF_0_C8		0x368
-#define BCMA_GMAC_CMN_UDF_1_C3_C0	0x370
-#define BCMA_GMAC_CMN_UDF_1_C7_C4	0x374
-#define BCMA_GMAC_CMN_UDF_1_C8		0x378
-#define BCMA_GMAC_CMN_UDF_2_C3_C0	0x380
-#define BCMA_GMAC_CMN_UDF_2_C7_C4	0x384
-#define BCMA_GMAC_CMN_UDF_2_C8		0x388
-#define BCMA_GMAC_CMN_UDF_0_D3_D0	0x390
-#define BCMA_GMAC_CMN_UDF_0_D7_D4	0x394
-#define BCMA_GMAC_CMN_UDF_0_D11_D8	0x394
-
-struct bcma_drv_gmac_cmn {
-	struct bcma_device *core;
-
-	/* Drivers accessing BCMA_GMAC_CMN_PHY_ACCESS and
-	 * BCMA_GMAC_CMN_PHY_CTL need to take that mutex first. */
-	struct mutex phy_mutex;
-};
-
-/* Register access */
-#define gmac_cmn_read16(gc, offset)		bcma_read16((gc)->core, offset)
-#define gmac_cmn_read32(gc, offset)		bcma_read32((gc)->core, offset)
-#define gmac_cmn_write16(gc, offset, val)	bcma_write16((gc)->core, offset, val)
-#define gmac_cmn_write32(gc, offset, val)	bcma_write32((gc)->core, offset, val)
-
-#endif /* LINUX_BCMA_DRIVER_GMAC_CMN_H_ */
diff --git a/include/linux/bcma/bcma_driver_mips.h b/include/linux/bcma/bcma_driver_mips.h
deleted file mode 100644
index 798013f..0000000
--- a/include/linux/bcma/bcma_driver_mips.h
+++ /dev/null
@@ -1,45 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_MIPS_H_
-#define LINUX_BCMA_DRIVER_MIPS_H_
-
-#define BCMA_MIPS_IPSFLAG		0x0F08
-/* which sbflags get routed to mips interrupt 1 */
-#define  BCMA_MIPS_IPSFLAG_IRQ1		0x0000003F
-#define  BCMA_MIPS_IPSFLAG_IRQ1_SHIFT	0
-/* which sbflags get routed to mips interrupt 2 */
-#define  BCMA_MIPS_IPSFLAG_IRQ2		0x00003F00
-#define  BCMA_MIPS_IPSFLAG_IRQ2_SHIFT	8
-/* which sbflags get routed to mips interrupt 3 */
-#define  BCMA_MIPS_IPSFLAG_IRQ3		0x003F0000
-#define  BCMA_MIPS_IPSFLAG_IRQ3_SHIFT	16
-/* which sbflags get routed to mips interrupt 4 */
-#define  BCMA_MIPS_IPSFLAG_IRQ4		0x3F000000
-#define  BCMA_MIPS_IPSFLAG_IRQ4_SHIFT	24
-
-/* MIPS 74K core registers */
-#define BCMA_MIPS_MIPS74K_CORECTL	0x0000
-#define BCMA_MIPS_MIPS74K_EXCEPTBASE	0x0004
-#define BCMA_MIPS_MIPS74K_BIST		0x000C
-#define BCMA_MIPS_MIPS74K_INTMASK_INT0	0x0014
-#define BCMA_MIPS_MIPS74K_INTMASK(int) \
-	((int) * 4 + BCMA_MIPS_MIPS74K_INTMASK_INT0)
-#define BCMA_MIPS_MIPS74K_NMIMASK	0x002C
-#define BCMA_MIPS_MIPS74K_GPIOSEL	0x0040
-#define BCMA_MIPS_MIPS74K_GPIOOUT	0x0044
-#define BCMA_MIPS_MIPS74K_GPIOEN	0x0048
-#define BCMA_MIPS_MIPS74K_CLKCTLST	0x01E0
-
-#define BCMA_MIPS_OOBSELINA74		0x004
-#define BCMA_MIPS_OOBSELOUTA30		0x100
-
-struct bcma_device;
-
-struct bcma_drv_mips {
-	struct bcma_device *core;
-	u8 setup_done:1;
-	u8 early_setup_done:1;
-};
-
-extern u32 bcma_cpu_clock(struct bcma_drv_mips *mcore);
-
-#endif /* LINUX_BCMA_DRIVER_MIPS_H_ */
diff --git a/include/linux/bcma/bcma_driver_pci.h b/include/linux/bcma/bcma_driver_pci.h
deleted file mode 100644
index bca4771..0000000
--- a/include/linux/bcma/bcma_driver_pci.h
+++ /dev/null
@@ -1,264 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_PCI_H_
-#define LINUX_BCMA_DRIVER_PCI_H_
-
-#include <linux/types.h>
-
-struct pci_dev;
-
-/** PCI core registers. **/
-#define BCMA_CORE_PCI_CTL			0x0000	/* PCI Control */
-#define  BCMA_CORE_PCI_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
-#define  BCMA_CORE_PCI_CTL_RST			0x00000002 /* PCI_RESET driven out to pin */
-#define  BCMA_CORE_PCI_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
-#define  BCMA_CORE_PCI_CTL_CLK			0x00000008 /* Gate for clock driven out to pin */
-#define BCMA_CORE_PCI_ARBCTL			0x0010	/* PCI Arbiter Control */
-#define  BCMA_CORE_PCI_ARBCTL_INTERN		0x00000001 /* Use internal arbiter */
-#define  BCMA_CORE_PCI_ARBCTL_EXTERN		0x00000002 /* Use external arbiter */
-#define  BCMA_CORE_PCI_ARBCTL_PARKID		0x00000006 /* Mask, selects which agent is parked on an idle bus */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
-#define   BCMA_CORE_PCI_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
-#define BCMA_CORE_PCI_ISTAT			0x0020	/* Interrupt status */
-#define  BCMA_CORE_PCI_ISTAT_INTA		0x00000001 /* PCI INTA# */
-#define  BCMA_CORE_PCI_ISTAT_INTB		0x00000002 /* PCI INTB# */
-#define  BCMA_CORE_PCI_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
-#define  BCMA_CORE_PCI_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
-#define  BCMA_CORE_PCI_ISTAT_PME		0x00000010 /* PCI PME# */
-#define BCMA_CORE_PCI_IMASK			0x0024	/* Interrupt mask */
-#define  BCMA_CORE_PCI_IMASK_INTA		0x00000001 /* PCI INTA# */
-#define  BCMA_CORE_PCI_IMASK_INTB		0x00000002 /* PCI INTB# */
-#define  BCMA_CORE_PCI_IMASK_SERR		0x00000004 /* PCI SERR# */
-#define  BCMA_CORE_PCI_IMASK_PERR		0x00000008 /* PCI PERR# */
-#define  BCMA_CORE_PCI_IMASK_PME		0x00000010 /* PCI PME# */
-#define BCMA_CORE_PCI_MBOX			0x0028	/* Backplane to PCI Mailbox */
-#define  BCMA_CORE_PCI_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
-#define  BCMA_CORE_PCI_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
-#define  BCMA_CORE_PCI_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
-#define  BCMA_CORE_PCI_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
-#define  BCMA_CORE_PCI_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
-#define BCMA_CORE_PCI_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
-#define  BCMA_CORE_PCI_BCAST_ADDR_MASK		0x000000FF
-#define BCMA_CORE_PCI_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
-#define BCMA_CORE_PCI_GPIO_IN			0x0060	/* rev >= 2 only */
-#define BCMA_CORE_PCI_GPIO_OUT			0x0064	/* rev >= 2 only */
-#define BCMA_CORE_PCI_GPIO_ENABLE		0x0068	/* rev >= 2 only */
-#define BCMA_CORE_PCI_GPIO_CTL			0x006C	/* rev >= 2 only */
-#define BCMA_CORE_PCI_SBTOPCI0			0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
-#define  BCMA_CORE_PCI_SBTOPCI0_MASK		0xFC000000
-#define BCMA_CORE_PCI_SBTOPCI1			0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
-#define  BCMA_CORE_PCI_SBTOPCI1_MASK		0xFC000000
-#define BCMA_CORE_PCI_SBTOPCI2			0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
-#define  BCMA_CORE_PCI_SBTOPCI2_MASK		0xC0000000
-#define BCMA_CORE_PCI_CONFIG_ADDR		0x0120	/* pcie config space access */
-#define BCMA_CORE_PCI_CONFIG_DATA		0x0124	/* pcie config space access */
-#define BCMA_CORE_PCI_MDIO_CONTROL		0x0128	/* controls the mdio access */
-#define  BCMA_CORE_PCI_MDIOCTL_DIVISOR_MASK	0x7f	/* clock to be used on MDIO */
-#define  BCMA_CORE_PCI_MDIOCTL_DIVISOR_VAL	0x2
-#define  BCMA_CORE_PCI_MDIOCTL_PREAM_EN		0x80	/* Enable preamble sequnce */
-#define  BCMA_CORE_PCI_MDIOCTL_ACCESS_DONE	0x100	/* Tranaction complete */
-#define BCMA_CORE_PCI_MDIO_DATA			0x012c	/* Data to the mdio access */
-#define  BCMA_CORE_PCI_MDIODATA_MASK		0x0000ffff /* data 2 bytes */
-#define  BCMA_CORE_PCI_MDIODATA_TA		0x00020000 /* Turnaround */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_SHF_OLD	18	/* Regaddr shift (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_MASK_OLD	0x003c0000 /* Regaddr Mask (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF_OLD	22	/* Physmedia devaddr shift (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_MASK_OLD	0x0fc00000 /* Physmedia devaddr Mask (rev < 10) */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_SHF	18	/* Regaddr shift */
-#define  BCMA_CORE_PCI_MDIODATA_REGADDR_MASK	0x007c0000 /* Regaddr Mask */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_SHF	23	/* Physmedia devaddr shift */
-#define  BCMA_CORE_PCI_MDIODATA_DEVADDR_MASK	0x0f800000 /* Physmedia devaddr Mask */
-#define  BCMA_CORE_PCI_MDIODATA_WRITE		0x10000000 /* write Transaction */
-#define  BCMA_CORE_PCI_MDIODATA_READ		0x20000000 /* Read Transaction */
-#define  BCMA_CORE_PCI_MDIODATA_START		0x40000000 /* start of Transaction */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_ADDR	0x0	/* dev address for serdes */
-#define  BCMA_CORE_PCI_MDIODATA_BLK_ADDR	0x1F	/* blk address for serdes */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_PLL		0x1d	/* SERDES PLL Dev */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_TX		0x1e	/* SERDES TX Dev */
-#define  BCMA_CORE_PCI_MDIODATA_DEV_RX		0x1f	/* SERDES RX Dev */
-#define BCMA_CORE_PCI_PCIEIND_ADDR		0x0130	/* indirect access to the internal register */
-#define BCMA_CORE_PCI_PCIEIND_DATA		0x0134	/* Data to/from the internal register */
-#define BCMA_CORE_PCI_CLKREQENCTRL		0x0138	/*  >= rev 6, Clkreq rdma control */
-#define BCMA_CORE_PCI_PCICFG0			0x0400	/* PCI config space 0 (rev >= 8) */
-#define BCMA_CORE_PCI_PCICFG1			0x0500	/* PCI config space 1 (rev >= 8) */
-#define BCMA_CORE_PCI_PCICFG2			0x0600	/* PCI config space 2 (rev >= 8) */
-#define BCMA_CORE_PCI_PCICFG3			0x0700	/* PCI config space 3 (rev >= 8) */
-#define BCMA_CORE_PCI_SPROM(wordoffset)		(0x0800 + ((wordoffset) * 2)) /* SPROM shadow area (72 bytes) */
-#define  BCMA_CORE_PCI_SPROM_PI_OFFSET		0	/* first word */
-#define   BCMA_CORE_PCI_SPROM_PI_MASK		0xf000	/* bit 15:12 */
-#define   BCMA_CORE_PCI_SPROM_PI_SHIFT		12	/* bit 15:12 */
-#define  BCMA_CORE_PCI_SPROM_MISC_CONFIG	5	/* word 5 */
-#define   BCMA_CORE_PCI_SPROM_L23READY_EXIT_NOPERST	0x8000	/* bit 15 */
-#define   BCMA_CORE_PCI_SPROM_CLKREQ_OFFSET_REV5	20	/* word 20 for srom rev <= 5 */
-#define   BCMA_CORE_PCI_SPROM_CLKREQ_ENB	0x0800	/* bit 11 */
-
-/* SBtoPCIx */
-#define BCMA_CORE_PCI_SBTOPCI_MEM		0x00000000
-#define BCMA_CORE_PCI_SBTOPCI_IO		0x00000001
-#define BCMA_CORE_PCI_SBTOPCI_CFG0		0x00000002
-#define BCMA_CORE_PCI_SBTOPCI_CFG1		0x00000003
-#define BCMA_CORE_PCI_SBTOPCI_PREF		0x00000004 /* Prefetch enable */
-#define BCMA_CORE_PCI_SBTOPCI_BURST		0x00000008 /* Burst enable */
-#define BCMA_CORE_PCI_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
-#define BCMA_CORE_PCI_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
-#define  BCMA_CORE_PCI_SBTOPCI_RC_READ		0x00000000 /* Memory read */
-#define  BCMA_CORE_PCI_SBTOPCI_RC_READL		0x00000010 /* Memory read line */
-#define  BCMA_CORE_PCI_SBTOPCI_RC_READM		0x00000020 /* Memory read multiple */
-
-/* PCIE protocol PHY diagnostic registers */
-#define BCMA_CORE_PCI_PLP_MODEREG		0x200	/* Mode */
-#define BCMA_CORE_PCI_PLP_STATUSREG		0x204	/* Status */
-#define  BCMA_CORE_PCI_PLP_POLARITYINV_STAT	0x10	/* Status reg PCIE_PLP_STATUSREG */
-#define BCMA_CORE_PCI_PLP_LTSSMCTRLREG		0x208	/* LTSSM control */
-#define BCMA_CORE_PCI_PLP_LTLINKNUMREG		0x20c	/* Link Training Link number */
-#define BCMA_CORE_PCI_PLP_LTLANENUMREG		0x210	/* Link Training Lane number */
-#define BCMA_CORE_PCI_PLP_LTNFTSREG		0x214	/* Link Training N_FTS */
-#define BCMA_CORE_PCI_PLP_ATTNREG		0x218	/* Attention */
-#define BCMA_CORE_PCI_PLP_ATTNMASKREG		0x21C	/* Attention Mask */
-#define BCMA_CORE_PCI_PLP_RXERRCTR		0x220	/* Rx Error */
-#define BCMA_CORE_PCI_PLP_RXFRMERRCTR		0x224	/* Rx Framing Error */
-#define BCMA_CORE_PCI_PLP_RXERRTHRESHREG	0x228	/* Rx Error threshold */
-#define BCMA_CORE_PCI_PLP_TESTCTRLREG		0x22C	/* Test Control reg */
-#define BCMA_CORE_PCI_PLP_SERDESCTRLOVRDREG	0x230	/* SERDES Control Override */
-#define BCMA_CORE_PCI_PLP_TIMINGOVRDREG		0x234	/* Timing param override */
-#define BCMA_CORE_PCI_PLP_RXTXSMDIAGREG		0x238	/* RXTX State Machine Diag */
-#define BCMA_CORE_PCI_PLP_LTSSMDIAGREG		0x23C	/* LTSSM State Machine Diag */
-
-/* PCIE protocol DLLP diagnostic registers */
-#define BCMA_CORE_PCI_DLLP_LCREG		0x100	/* Link Control */
-#define BCMA_CORE_PCI_DLLP_LSREG		0x104	/* Link Status */
-#define BCMA_CORE_PCI_DLLP_LAREG		0x108	/* Link Attention */
-#define  BCMA_CORE_PCI_DLLP_LSREG_LINKUP	(1 << 16)
-#define BCMA_CORE_PCI_DLLP_LAMASKREG		0x10C	/* Link Attention Mask */
-#define BCMA_CORE_PCI_DLLP_NEXTTXSEQNUMREG	0x110	/* Next Tx Seq Num */
-#define BCMA_CORE_PCI_DLLP_ACKEDTXSEQNUMREG	0x114	/* Acked Tx Seq Num */
-#define BCMA_CORE_PCI_DLLP_PURGEDTXSEQNUMREG	0x118	/* Purged Tx Seq Num */
-#define BCMA_CORE_PCI_DLLP_RXSEQNUMREG		0x11C	/* Rx Sequence Number */
-#define BCMA_CORE_PCI_DLLP_LRREG		0x120	/* Link Replay */
-#define BCMA_CORE_PCI_DLLP_LACKTOREG		0x124	/* Link Ack Timeout */
-#define BCMA_CORE_PCI_DLLP_PMTHRESHREG		0x128	/* Power Management Threshold */
-#define  BCMA_CORE_PCI_ASPMTIMER_EXTEND		0x01000000 /* > rev7: enable extend ASPM timer */
-#define BCMA_CORE_PCI_DLLP_RTRYWPREG		0x12C	/* Retry buffer write ptr */
-#define BCMA_CORE_PCI_DLLP_RTRYRPREG		0x130	/* Retry buffer Read ptr */
-#define BCMA_CORE_PCI_DLLP_RTRYPPREG		0x134	/* Retry buffer Purged ptr */
-#define BCMA_CORE_PCI_DLLP_RTRRWREG		0x138	/* Retry buffer Read/Write */
-#define BCMA_CORE_PCI_DLLP_ECTHRESHREG		0x13C	/* Error Count Threshold */
-#define BCMA_CORE_PCI_DLLP_TLPERRCTRREG		0x140	/* TLP Error Counter */
-#define BCMA_CORE_PCI_DLLP_ERRCTRREG		0x144	/* Error Counter */
-#define BCMA_CORE_PCI_DLLP_NAKRXCTRREG		0x148	/* NAK Received Counter */
-#define BCMA_CORE_PCI_DLLP_TESTREG		0x14C	/* Test */
-#define BCMA_CORE_PCI_DLLP_PKTBIST		0x150	/* Packet BIST */
-#define BCMA_CORE_PCI_DLLP_PCIE11		0x154	/* DLLP PCIE 1.1 reg */
-
-/* SERDES RX registers */
-#define BCMA_CORE_PCI_SERDES_RX_CTRL		1	/* Rx cntrl */
-#define  BCMA_CORE_PCI_SERDES_RX_CTRL_FORCE	0x80	/* rxpolarity_force */
-#define  BCMA_CORE_PCI_SERDES_RX_CTRL_POLARITY	0x40	/* rxpolarity_value */
-#define BCMA_CORE_PCI_SERDES_RX_TIMER1		2	/* Rx Timer1 */
-#define BCMA_CORE_PCI_SERDES_RX_CDR		6	/* CDR */
-#define BCMA_CORE_PCI_SERDES_RX_CDRBW		7	/* CDR BW */
-
-/* SERDES PLL registers */
-#define BCMA_CORE_PCI_SERDES_PLL_CTRL		1	/* PLL control reg */
-#define BCMA_CORE_PCI_PLL_CTRL_FREQDET_EN	0x4000	/* bit 14 is FREQDET on */
-
-/* PCIcore specific boardflags */
-#define BCMA_CORE_PCI_BFL_NOPCI			0x00000400 /* Board leaves PCI floating */
-
-/* PCIE Config space accessing MACROS */
-#define BCMA_CORE_PCI_CFG_BUS_SHIFT		24	/* Bus shift */
-#define BCMA_CORE_PCI_CFG_SLOT_SHIFT		19	/* Slot/Device shift */
-#define BCMA_CORE_PCI_CFG_FUN_SHIFT		16	/* Function shift */
-#define BCMA_CORE_PCI_CFG_OFF_SHIFT		0	/* Register shift */
-
-#define BCMA_CORE_PCI_CFG_BUS_MASK		0xff	/* Bus mask */
-#define BCMA_CORE_PCI_CFG_SLOT_MASK		0x1f	/* Slot/Device mask */
-#define BCMA_CORE_PCI_CFG_FUN_MASK		7	/* Function mask */
-#define BCMA_CORE_PCI_CFG_OFF_MASK		0xfff	/* Register mask */
-
-#define BCMA_CORE_PCI_CFG_DEVCTRL		0xd8
-
-#define BCMA_CORE_PCI_
-
-/* MDIO devices (SERDES modules) */
-#define BCMA_CORE_PCI_MDIO_IEEE0		0x000
-#define BCMA_CORE_PCI_MDIO_IEEE1		0x001
-#define BCMA_CORE_PCI_MDIO_BLK0			0x800
-#define BCMA_CORE_PCI_MDIO_BLK1			0x801
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT0		0x16
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT1		0x17
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT2		0x18
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT3		0x19
-#define  BCMA_CORE_PCI_MDIO_BLK1_MGMT4		0x1A
-#define BCMA_CORE_PCI_MDIO_BLK2			0x802
-#define BCMA_CORE_PCI_MDIO_BLK3			0x803
-#define BCMA_CORE_PCI_MDIO_BLK4			0x804
-#define BCMA_CORE_PCI_MDIO_TXPLL		0x808	/* TXPLL register block idx */
-#define BCMA_CORE_PCI_MDIO_TXCTRL0		0x820
-#define BCMA_CORE_PCI_MDIO_SERDESID		0x831
-#define BCMA_CORE_PCI_MDIO_RXCTRL0		0x840
-
-/* PCIE Root Capability Register bits (Host mode only) */
-#define BCMA_CORE_PCI_RC_CRS_VISIBILITY		0x0001
-
-struct bcma_drv_pci;
-struct bcma_bus;
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI_HOSTMODE
-struct bcma_drv_pci_host {
-	struct bcma_drv_pci *pdev;
-
-	u32 host_cfg_addr;
-	spinlock_t cfgspace_lock;
-
-	struct pci_controller pci_controller;
-	struct pci_ops pci_ops;
-	struct resource mem_resource;
-	struct resource io_resource;
-};
-#endif
-
-struct bcma_drv_pci {
-	struct bcma_device *core;
-	u8 early_setup_done:1;
-	u8 setup_done:1;
-	u8 hostmode:1;
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI_HOSTMODE
-	struct bcma_drv_pci_host *host_controller;
-#endif
-};
-
-/* Register access */
-#define pcicore_read16(pc, offset)		bcma_read16((pc)->core, offset)
-#define pcicore_read32(pc, offset)		bcma_read32((pc)->core, offset)
-#define pcicore_write16(pc, offset, val)	bcma_write16((pc)->core, offset, val)
-#define pcicore_write32(pc, offset, val)	bcma_write32((pc)->core, offset, val)
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI
-extern void bcma_core_pci_power_save(struct bcma_bus *bus, bool up);
-#else
-static inline void bcma_core_pci_power_save(struct bcma_bus *bus, bool up)
-{
-}
-#endif
-
-#ifdef CPTCFG_BCMA_DRIVER_PCI_HOSTMODE
-extern int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev);
-extern int bcma_core_pci_plat_dev_init(struct pci_dev *dev);
-#else
-static inline int bcma_core_pci_pcibios_map_irq(const struct pci_dev *dev)
-{
-	return -ENOTSUPP;
-}
-static inline int bcma_core_pci_plat_dev_init(struct pci_dev *dev)
-{
-	return -ENOTSUPP;
-}
-#endif
-
-#endif /* LINUX_BCMA_DRIVER_PCI_H_ */
diff --git a/include/linux/bcma/bcma_driver_pcie2.h b/include/linux/bcma/bcma_driver_pcie2.h
deleted file mode 100644
index 91ce515..0000000
--- a/include/linux/bcma/bcma_driver_pcie2.h
+++ /dev/null
@@ -1,159 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_DRIVER_PCIE2_H_
-#define LINUX_BCMA_DRIVER_PCIE2_H_
-
-#define BCMA_CORE_PCIE2_CLK_CONTROL		0x0000
-#define  PCIE2_CLKC_RST_OE			0x0001 /* When set, drives PCI_RESET out to pin */
-#define  PCIE2_CLKC_RST				0x0002 /* Value driven out to pin */
-#define  PCIE2_CLKC_SPERST			0x0004 /* SurvivePeRst */
-#define  PCIE2_CLKC_DISABLE_L1CLK_GATING	0x0010
-#define  PCIE2_CLKC_DLYPERST			0x0100 /* Delay PeRst to CoE Core */
-#define  PCIE2_CLKC_DISSPROMLD			0x0200 /* DisableSpromLoadOnPerst */
-#define  PCIE2_CLKC_WAKE_MODE_L2		0x1000 /* Wake on L2 */
-#define BCMA_CORE_PCIE2_RC_PM_CONTROL		0x0004
-#define BCMA_CORE_PCIE2_RC_PM_STATUS		0x0008
-#define BCMA_CORE_PCIE2_EP_PM_CONTROL		0x000C
-#define BCMA_CORE_PCIE2_EP_PM_STATUS		0x0010
-#define BCMA_CORE_PCIE2_EP_LTR_CONTROL		0x0014
-#define BCMA_CORE_PCIE2_EP_LTR_STATUS		0x0018
-#define BCMA_CORE_PCIE2_EP_OBFF_STATUS		0x001C
-#define BCMA_CORE_PCIE2_PCIE_ERR_STATUS		0x0020
-#define BCMA_CORE_PCIE2_RC_AXI_CONFIG		0x0100
-#define BCMA_CORE_PCIE2_EP_AXI_CONFIG		0x0104
-#define BCMA_CORE_PCIE2_RXDEBUG_STATUS0		0x0108
-#define BCMA_CORE_PCIE2_RXDEBUG_CONTROL0	0x010C
-#define BCMA_CORE_PCIE2_CONFIGINDADDR		0x0120
-#define BCMA_CORE_PCIE2_CONFIGINDDATA		0x0124
-#define BCMA_CORE_PCIE2_MDIOCONTROL		0x0128
-#define BCMA_CORE_PCIE2_MDIOWRDATA		0x012C
-#define BCMA_CORE_PCIE2_MDIORDDATA		0x0130
-#define BCMA_CORE_PCIE2_DATAINTF		0x0180
-#define BCMA_CORE_PCIE2_D2H_INTRLAZY_0		0x0188
-#define BCMA_CORE_PCIE2_H2D_INTRLAZY_0		0x018c
-#define BCMA_CORE_PCIE2_H2D_INTSTAT_0		0x0190
-#define BCMA_CORE_PCIE2_H2D_INTMASK_0		0x0194
-#define BCMA_CORE_PCIE2_D2H_INTSTAT_0		0x0198
-#define BCMA_CORE_PCIE2_D2H_INTMASK_0		0x019c
-#define BCMA_CORE_PCIE2_LTR_STATE		0x01A0 /* Latency Tolerance Reporting */
-#define  PCIE2_LTR_ACTIVE			2
-#define  PCIE2_LTR_ACTIVE_IDLE			1
-#define  PCIE2_LTR_SLEEP			0
-#define  PCIE2_LTR_FINAL_MASK			0x300
-#define  PCIE2_LTR_FINAL_SHIFT			8
-#define BCMA_CORE_PCIE2_PWR_INT_STATUS		0x01A4
-#define BCMA_CORE_PCIE2_PWR_INT_MASK		0x01A8
-#define BCMA_CORE_PCIE2_CFG_ADDR		0x01F8
-#define BCMA_CORE_PCIE2_CFG_DATA		0x01FC
-#define BCMA_CORE_PCIE2_SYS_EQ_PAGE		0x0200
-#define BCMA_CORE_PCIE2_SYS_MSI_PAGE		0x0204
-#define BCMA_CORE_PCIE2_SYS_MSI_INTREN		0x0208
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL0		0x0210
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL1		0x0214
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL2		0x0218
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL3		0x021C
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL4		0x0220
-#define BCMA_CORE_PCIE2_SYS_MSI_CTRL5		0x0224
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD0		0x0250
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL0		0x0254
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD1		0x0258
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL1		0x025C
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD2		0x0260
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL2		0x0264
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD3		0x0268
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL3		0x026C
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD4		0x0270
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL4		0x0274
-#define BCMA_CORE_PCIE2_SYS_EQ_HEAD5		0x0278
-#define BCMA_CORE_PCIE2_SYS_EQ_TAIL5		0x027C
-#define BCMA_CORE_PCIE2_SYS_RC_INTX_EN		0x0330
-#define BCMA_CORE_PCIE2_SYS_RC_INTX_CSR		0x0334
-#define BCMA_CORE_PCIE2_SYS_MSI_REQ		0x0340
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR_EN	0x0344
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR_CSR	0x0348
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR0		0x0350
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR1		0x0354
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR2		0x0358
-#define BCMA_CORE_PCIE2_SYS_HOST_INTR3		0x035C
-#define BCMA_CORE_PCIE2_SYS_EP_INT_EN0		0x0360
-#define BCMA_CORE_PCIE2_SYS_EP_INT_EN1		0x0364
-#define BCMA_CORE_PCIE2_SYS_EP_INT_CSR0		0x0370
-#define BCMA_CORE_PCIE2_SYS_EP_INT_CSR1		0x0374
-#define BCMA_CORE_PCIE2_SPROM(wordoffset)	(0x0800 + ((wordoffset) * 2))
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_0		0x0C00
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_1		0x0C04
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_2		0x0C08
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_3		0x0C0C
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_4		0x0C10
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_5		0x0C14
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_6		0x0C18
-#define BCMA_CORE_PCIE2_FUNC0_IMAP0_7		0x0C1C
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_0		0x0C20
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_1		0x0C24
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_2		0x0C28
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_3		0x0C2C
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_4		0x0C30
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_5		0x0C34
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_6		0x0C38
-#define BCMA_CORE_PCIE2_FUNC1_IMAP0_7		0x0C3C
-#define BCMA_CORE_PCIE2_FUNC0_IMAP1		0x0C80
-#define BCMA_CORE_PCIE2_FUNC1_IMAP1		0x0C88
-#define BCMA_CORE_PCIE2_FUNC0_IMAP2		0x0CC0
-#define BCMA_CORE_PCIE2_FUNC1_IMAP2		0x0CC8
-#define BCMA_CORE_PCIE2_IARR0_LOWER		0x0D00
-#define BCMA_CORE_PCIE2_IARR0_UPPER		0x0D04
-#define BCMA_CORE_PCIE2_IARR1_LOWER		0x0D08
-#define BCMA_CORE_PCIE2_IARR1_UPPER		0x0D0C
-#define BCMA_CORE_PCIE2_IARR2_LOWER		0x0D10
-#define BCMA_CORE_PCIE2_IARR2_UPPER		0x0D14
-#define BCMA_CORE_PCIE2_OARR0			0x0D20
-#define BCMA_CORE_PCIE2_OARR1			0x0D28
-#define BCMA_CORE_PCIE2_OARR2			0x0D30
-#define BCMA_CORE_PCIE2_OMAP0_LOWER		0x0D40
-#define BCMA_CORE_PCIE2_OMAP0_UPPER		0x0D44
-#define BCMA_CORE_PCIE2_OMAP1_LOWER		0x0D48
-#define BCMA_CORE_PCIE2_OMAP1_UPPER		0x0D4C
-#define BCMA_CORE_PCIE2_OMAP2_LOWER		0x0D50
-#define BCMA_CORE_PCIE2_OMAP2_UPPER		0x0D54
-#define BCMA_CORE_PCIE2_FUNC1_IARR1_SIZE	0x0D58
-#define BCMA_CORE_PCIE2_FUNC1_IARR2_SIZE	0x0D5C
-#define BCMA_CORE_PCIE2_MEM_CONTROL		0x0F00
-#define BCMA_CORE_PCIE2_MEM_ECC_ERRLOG0		0x0F04
-#define BCMA_CORE_PCIE2_MEM_ECC_ERRLOG1		0x0F08
-#define BCMA_CORE_PCIE2_LINK_STATUS		0x0F0C
-#define BCMA_CORE_PCIE2_STRAP_STATUS		0x0F10
-#define BCMA_CORE_PCIE2_RESET_STATUS		0x0F14
-#define BCMA_CORE_PCIE2_RESETEN_IN_LINKDOWN	0x0F18
-#define BCMA_CORE_PCIE2_MISC_INTR_EN		0x0F1C
-#define BCMA_CORE_PCIE2_TX_DEBUG_CFG		0x0F20
-#define BCMA_CORE_PCIE2_MISC_CONFIG		0x0F24
-#define BCMA_CORE_PCIE2_MISC_STATUS		0x0F28
-#define BCMA_CORE_PCIE2_INTR_EN			0x0F30
-#define BCMA_CORE_PCIE2_INTR_CLEAR		0x0F34
-#define BCMA_CORE_PCIE2_INTR_STATUS		0x0F38
-
-/* PCIE gen2 config regs */
-#define PCIE2_INTSTATUS				0x090
-#define PCIE2_INTMASK				0x094
-#define PCIE2_SBMBX				0x098
-
-#define PCIE2_PMCR_REFUP			0x1814 /* Trefup time */
-
-#define PCIE2_CAP_DEVSTSCTRL2_OFFSET		0xD4
-#define PCIE2_CAP_DEVSTSCTRL2_LTRENAB		0x400
-#define PCIE2_PVT_REG_PM_CLK_PERIOD		0x184c
-
-struct bcma_drv_pcie2 {
-	struct bcma_device *core;
-
-	u16 reqsize;
-};
-
-#define pcie2_read16(pcie2, offset)		bcma_read16((pcie2)->core, offset)
-#define pcie2_read32(pcie2, offset)		bcma_read32((pcie2)->core, offset)
-#define pcie2_write16(pcie2, offset, val)	bcma_write16((pcie2)->core, offset, val)
-#define pcie2_write32(pcie2, offset, val)	bcma_write32((pcie2)->core, offset, val)
-
-#define pcie2_set32(pcie2, offset, set)		bcma_set32((pcie2)->core, offset, set)
-#define pcie2_mask32(pcie2, offset, mask)	bcma_mask32((pcie2)->core, offset, mask)
-
-#endif /* LINUX_BCMA_DRIVER_PCIE2_H_ */
diff --git a/include/linux/bcma/bcma_regs.h b/include/linux/bcma/bcma_regs.h
deleted file mode 100644
index 944105c..0000000
--- a/include/linux/bcma/bcma_regs.h
+++ /dev/null
@@ -1,104 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_REGS_H_
-#define LINUX_BCMA_REGS_H_
-
-/* Some single registers are shared between many cores */
-/* BCMA_CLKCTLST: ChipCommon (rev >= 20), PCIe, 80211 */
-#define BCMA_CLKCTLST			0x01E0 /* Clock control and status */
-#define  BCMA_CLKCTLST_FORCEALP		0x00000001 /* Force ALP request */
-#define  BCMA_CLKCTLST_FORCEHT		0x00000002 /* Force HT request */
-#define  BCMA_CLKCTLST_FORCEILP		0x00000004 /* Force ILP request */
-#define  BCMA_CLKCTLST_HAVEALPREQ	0x00000008 /* ALP available request */
-#define  BCMA_CLKCTLST_HAVEHTREQ	0x00000010 /* HT available request */
-#define  BCMA_CLKCTLST_HWCROFF		0x00000020 /* Force HW clock request off */
-#define  BCMA_CLKCTLST_HQCLKREQ		0x00000040 /* HQ Clock */
-#define  BCMA_CLKCTLST_EXTRESREQ	0x00000700 /* Mask of external resource requests */
-#define  BCMA_CLKCTLST_EXTRESREQ_SHIFT	8
-#define  BCMA_CLKCTLST_HAVEALP		0x00010000 /* ALP available */
-#define  BCMA_CLKCTLST_HAVEHT		0x00020000 /* HT available */
-#define  BCMA_CLKCTLST_BP_ON_ALP	0x00040000 /* RO: running on ALP clock */
-#define  BCMA_CLKCTLST_BP_ON_HT		0x00080000 /* RO: running on HT clock */
-#define  BCMA_CLKCTLST_EXTRESST		0x07000000 /* Mask of external resource status */
-#define  BCMA_CLKCTLST_EXTRESST_SHIFT	24
-/* Is there any BCM4328 on BCMA bus? */
-#define  BCMA_CLKCTLST_4328A0_HAVEHT	0x00010000 /* 4328a0 has reversed bits */
-#define  BCMA_CLKCTLST_4328A0_HAVEALP	0x00020000 /* 4328a0 has reversed bits */
-
-/* Agent registers (common for every core) */
-#define BCMA_OOB_SEL_OUT_A30		0x0100
-#define BCMA_IOCTL			0x0408 /* IO control */
-#define  BCMA_IOCTL_CLK			0x0001
-#define  BCMA_IOCTL_FGC			0x0002
-#define  BCMA_IOCTL_CORE_BITS		0x3FFC
-#define  BCMA_IOCTL_PME_EN		0x4000
-#define  BCMA_IOCTL_BIST_EN		0x8000
-#define BCMA_IOST			0x0500 /* IO status */
-#define  BCMA_IOST_CORE_BITS		0x0FFF
-#define  BCMA_IOST_DMA64		0x1000
-#define  BCMA_IOST_GATED_CLK		0x2000
-#define  BCMA_IOST_BIST_ERROR		0x4000
-#define  BCMA_IOST_BIST_DONE		0x8000
-#define BCMA_RESET_CTL			0x0800
-#define  BCMA_RESET_CTL_RESET		0x0001
-#define BCMA_RESET_ST			0x0804
-
-#define BCMA_NS_ROM_IOST_BOOT_DEV_MASK	0x0003
-#define BCMA_NS_ROM_IOST_BOOT_DEV_NOR	0x0000
-#define BCMA_NS_ROM_IOST_BOOT_DEV_NAND	0x0001
-#define BCMA_NS_ROM_IOST_BOOT_DEV_ROM	0x0002
-
-/* BCMA PCI config space registers. */
-#define BCMA_PCI_PMCSR			0x44
-#define  BCMA_PCI_PE			0x100
-#define BCMA_PCI_BAR0_WIN		0x80	/* Backplane address space 0 */
-#define BCMA_PCI_BAR1_WIN		0x84	/* Backplane address space 1 */
-#define BCMA_PCI_SPROMCTL		0x88	/* SPROM control */
-#define  BCMA_PCI_SPROMCTL_WE		0x10	/* SPROM write enable */
-#define BCMA_PCI_BAR1_CONTROL		0x8c	/* Address space 1 burst control */
-#define BCMA_PCI_IRQS			0x90	/* PCI interrupts */
-#define BCMA_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
-#define BCMA_PCI_BACKPLANE_IRQS		0x98	/* Backplane Interrupts */
-#define BCMA_PCI_BAR0_WIN2		0xAC
-#define BCMA_PCI_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
-#define BCMA_PCI_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
-#define BCMA_PCI_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
-#define  BCMA_PCI_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
-#define  BCMA_PCI_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
-#define  BCMA_PCI_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
-#define  BCMA_PCI_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
-
-#define BCMA_PCIE2_BAR0_WIN2		0x70
-
-/* SiliconBackplane Address Map.
- * All regions may not exist on all chips.
- */
-#define BCMA_SOC_SDRAM_BASE		0x00000000U	/* Physical SDRAM */
-#define BCMA_SOC_PCI_MEM		0x08000000U	/* Host Mode sb2pcitranslation0 (64 MB) */
-#define BCMA_SOC_PCI_MEM_SZ		(64 * 1024 * 1024)
-#define BCMA_SOC_PCI_CFG		0x0c000000U	/* Host Mode sb2pcitranslation1 (64 MB) */
-#define BCMA_SOC_SDRAM_SWAPPED		0x10000000U	/* Byteswapped Physical SDRAM */
-#define BCMA_SOC_SDRAM_R2		0x80000000U	/* Region 2 for sdram (512 MB) */
-
-
-#define BCMA_SOC_PCI_DMA		0x40000000U	/* Client Mode sb2pcitranslation2 (1 GB) */
-#define BCMA_SOC_PCI_DMA2		0x80000000U	/* Client Mode sb2pcitranslation2 (1 GB) */
-#define BCMA_SOC_PCI_DMA_SZ		0x40000000U	/* Client Mode sb2pcitranslation2 size in bytes */
-#define BCMA_SOC_PCIE_DMA_L32		0x00000000U	/* PCIE Client Mode sb2pcitranslation2
-							 * (2 ZettaBytes), low 32 bits
-							 */
-#define BCMA_SOC_PCIE_DMA_H32		0x80000000U	/* PCIE Client Mode sb2pcitranslation2
-							 * (2 ZettaBytes), high 32 bits
-							 */
-
-#define BCMA_SOC_PCI1_MEM		0x40000000U	/* Host Mode sb2pcitranslation0 (64 MB) */
-#define BCMA_SOC_PCI1_CFG		0x44000000U	/* Host Mode sb2pcitranslation1 (64 MB) */
-#define BCMA_SOC_PCIE1_DMA_H32		0xc0000000U	/* PCIE Client Mode sb2pcitranslation2
-							 * (2 ZettaBytes), high 32 bits
-							 */
-
-#define BCMA_SOC_FLASH1			0x1fc00000	/* MIPS Flash Region 1 */
-#define BCMA_SOC_FLASH1_SZ		0x00400000	/* MIPS Size of Flash Region 1 */
-#define BCMA_SOC_FLASH2			0x1c000000	/* Flash Region 2 (region 1 shadowed here) */
-#define BCMA_SOC_FLASH2_SZ		0x02000000	/* Size of Flash Region 2 */
-
-#endif /* LINUX_BCMA_REGS_H_ */
diff --git a/include/linux/bcma/bcma_soc.h b/include/linux/bcma/bcma_soc.h
deleted file mode 100644
index f3c4351..0000000
--- a/include/linux/bcma/bcma_soc.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_BCMA_SOC_H_
-#define LINUX_BCMA_SOC_H_
-
-#include <linux/bcma/bcma.h>
-
-struct bcma_soc {
-	struct bcma_bus bus;
-	struct device *dev;
-};
-
-int __init bcma_host_soc_register(struct bcma_soc *soc);
-int __init bcma_host_soc_init(struct bcma_soc *soc);
-
-int bcma_bus_register(struct bcma_bus *bus);
-
-#endif /* LINUX_BCMA_SOC_H_ */
diff --git a/include/linux/mhi.h b/include/linux/mhi.h
deleted file mode 100644
index 77b8c0a..0000000
--- a/include/linux/mhi.h
+++ /dev/null
@@ -1,801 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- *
- */
-#ifndef _MHI_H_
-#define _MHI_H_
-
-#include <linux/device.h>
-#include <linux/dma-direction.h>
-#include <linux/mutex.h>
-#include <linux/skbuff.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-#include <linux/workqueue.h>
-
-#define MHI_MAX_OEM_PK_HASH_SEGMENTS 16
-
-struct mhi_chan;
-struct mhi_event;
-struct mhi_ctxt;
-struct mhi_cmd;
-struct mhi_buf_info;
-
-/**
- * enum mhi_callback - MHI callback
- * @MHI_CB_IDLE: MHI entered idle state
- * @MHI_CB_PENDING_DATA: New data available for client to process
- * @MHI_CB_LPM_ENTER: MHI host entered low power mode
- * @MHI_CB_LPM_EXIT: MHI host about to exit low power mode
- * @MHI_CB_EE_RDDM: MHI device entered RDDM exec env
- * @MHI_CB_EE_MISSION_MODE: MHI device entered Mission Mode exec env
- * @MHI_CB_SYS_ERROR: MHI device entered error state (may recover)
- * @MHI_CB_FATAL_ERROR: MHI device entered fatal error state
- * @MHI_CB_BW_REQ: Received a bandwidth switch request from device
- */
-enum mhi_callback {
-	MHI_CB_IDLE,
-	MHI_CB_PENDING_DATA,
-	MHI_CB_LPM_ENTER,
-	MHI_CB_LPM_EXIT,
-	MHI_CB_EE_RDDM,
-	MHI_CB_EE_MISSION_MODE,
-	MHI_CB_SYS_ERROR,
-	MHI_CB_FATAL_ERROR,
-	MHI_CB_BW_REQ,
-};
-
-/**
- * enum mhi_flags - Transfer flags
- * @MHI_EOB: End of buffer for bulk transfer
- * @MHI_EOT: End of transfer
- * @MHI_CHAIN: Linked transfer
- */
-enum mhi_flags {
-	MHI_EOB = BIT(0),
-	MHI_EOT = BIT(1),
-	MHI_CHAIN = BIT(2),
-};
-
-/**
- * enum mhi_device_type - Device types
- * @MHI_DEVICE_XFER: Handles data transfer
- * @MHI_DEVICE_CONTROLLER: Control device
- */
-enum mhi_device_type {
-	MHI_DEVICE_XFER,
-	MHI_DEVICE_CONTROLLER,
-};
-
-/**
- * enum mhi_ch_type - Channel types
- * @MHI_CH_TYPE_INVALID: Invalid channel type
- * @MHI_CH_TYPE_OUTBOUND: Outbound channel to the device
- * @MHI_CH_TYPE_INBOUND: Inbound channel from the device
- * @MHI_CH_TYPE_INBOUND_COALESCED: Coalesced channel for the device to combine
- *				   multiple packets and send them as a single
- *				   large packet to reduce CPU consumption
- */
-enum mhi_ch_type {
-	MHI_CH_TYPE_INVALID = 0,
-	MHI_CH_TYPE_OUTBOUND = DMA_TO_DEVICE,
-	MHI_CH_TYPE_INBOUND = DMA_FROM_DEVICE,
-	MHI_CH_TYPE_INBOUND_COALESCED = 3,
-};
-
-/**
- * struct image_info - Firmware and RDDM table
- * @mhi_buf: Buffer for firmware and RDDM table
- * @entries: # of entries in table
- */
-struct image_info {
-	struct mhi_buf *mhi_buf;
-	/* private: from internal.h */
-	struct bhi_vec_entry *bhi_vec;
-	/* public: */
-	u32 entries;
-};
-
-/**
- * struct mhi_link_info - BW requirement
- * target_link_speed - Link speed as defined by TLS bits in LinkControl reg
- * target_link_width - Link width as defined by NLW bits in LinkStatus reg
- */
-struct mhi_link_info {
-	unsigned int target_link_speed;
-	unsigned int target_link_width;
-};
-
-/**
- * enum mhi_ee_type - Execution environment types
- * @MHI_EE_PBL: Primary Bootloader
- * @MHI_EE_SBL: Secondary Bootloader
- * @MHI_EE_AMSS: Modem, aka the primary runtime EE
- * @MHI_EE_RDDM: Ram dump download mode
- * @MHI_EE_WFW: WLAN firmware mode
- * @MHI_EE_PTHRU: Passthrough
- * @MHI_EE_EDL: Embedded downloader
- * @MHI_EE_FP: Flash Programmer Environment
- */
-enum mhi_ee_type {
-	MHI_EE_PBL,
-	MHI_EE_SBL,
-	MHI_EE_AMSS,
-	MHI_EE_RDDM,
-	MHI_EE_WFW,
-	MHI_EE_PTHRU,
-	MHI_EE_EDL,
-	MHI_EE_FP,
-	MHI_EE_MAX_SUPPORTED = MHI_EE_FP,
-	MHI_EE_DISABLE_TRANSITION, /* local EE, not related to mhi spec */
-	MHI_EE_NOT_SUPPORTED,
-	MHI_EE_MAX,
-};
-
-/**
- * enum mhi_state - MHI states
- * @MHI_STATE_RESET: Reset state
- * @MHI_STATE_READY: Ready state
- * @MHI_STATE_M0: M0 state
- * @MHI_STATE_M1: M1 state
- * @MHI_STATE_M2: M2 state
- * @MHI_STATE_M3: M3 state
- * @MHI_STATE_M3_FAST: M3 Fast state
- * @MHI_STATE_BHI: BHI state
- * @MHI_STATE_SYS_ERR: System Error state
- */
-enum mhi_state {
-	MHI_STATE_RESET = 0x0,
-	MHI_STATE_READY = 0x1,
-	MHI_STATE_M0 = 0x2,
-	MHI_STATE_M1 = 0x3,
-	MHI_STATE_M2 = 0x4,
-	MHI_STATE_M3 = 0x5,
-	MHI_STATE_M3_FAST = 0x6,
-	MHI_STATE_BHI = 0x7,
-	MHI_STATE_SYS_ERR = 0xFF,
-	MHI_STATE_MAX,
-};
-
-/**
- * enum mhi_ch_ee_mask - Execution environment mask for channel
- * @MHI_CH_EE_PBL: Allow channel to be used in PBL EE
- * @MHI_CH_EE_SBL: Allow channel to be used in SBL EE
- * @MHI_CH_EE_AMSS: Allow channel to be used in AMSS EE
- * @MHI_CH_EE_RDDM: Allow channel to be used in RDDM EE
- * @MHI_CH_EE_PTHRU: Allow channel to be used in PTHRU EE
- * @MHI_CH_EE_WFW: Allow channel to be used in WFW EE
- * @MHI_CH_EE_EDL: Allow channel to be used in EDL EE
- */
-enum mhi_ch_ee_mask {
-	MHI_CH_EE_PBL = BIT(MHI_EE_PBL),
-	MHI_CH_EE_SBL = BIT(MHI_EE_SBL),
-	MHI_CH_EE_AMSS = BIT(MHI_EE_AMSS),
-	MHI_CH_EE_RDDM = BIT(MHI_EE_RDDM),
-	MHI_CH_EE_PTHRU = BIT(MHI_EE_PTHRU),
-	MHI_CH_EE_WFW = BIT(MHI_EE_WFW),
-	MHI_CH_EE_EDL = BIT(MHI_EE_EDL),
-};
-
-/**
- * enum mhi_er_data_type - Event ring data types
- * @MHI_ER_DATA: Only client data over this ring
- * @MHI_ER_CTRL: MHI control data and client data
- */
-enum mhi_er_data_type {
-	MHI_ER_DATA,
-	MHI_ER_CTRL,
-};
-
-/**
- * enum mhi_db_brst_mode - Doorbell mode
- * @MHI_DB_BRST_DISABLE: Burst mode disable
- * @MHI_DB_BRST_ENABLE: Burst mode enable
- */
-enum mhi_db_brst_mode {
-	MHI_DB_BRST_DISABLE = 0x2,
-	MHI_DB_BRST_ENABLE = 0x3,
-};
-
-/**
- * struct mhi_channel_config - Channel configuration structure for controller
- * @name: The name of this channel
- * @num: The number assigned to this channel
- * @num_elements: The number of elements that can be queued to this channel
- * @local_elements: The local ring length of the channel
- * @event_ring: The event ring index that services this channel
- * @dir: Direction that data may flow on this channel
- * @type: Channel type
- * @ee_mask: Execution Environment mask for this channel
- * @pollcfg: Polling configuration for burst mode.  0 is default.  milliseconds
-	     for UL channels, multiple of 8 ring elements for DL channels
- * @doorbell: Doorbell mode
- * @lpm_notify: The channel master requires low power mode notifications
- * @offload_channel: The client manages the channel completely
- * @doorbell_mode_switch: Channel switches to doorbell mode on M0 transition
- * @auto_queue: Framework will automatically queue buffers for DL traffic
- * @wake-capable: Channel capable of waking up the system
- */
-struct mhi_channel_config {
-	char *name;
-	u32 num;
-	u32 num_elements;
-	u32 local_elements;
-	u32 event_ring;
-	enum dma_data_direction dir;
-	enum mhi_ch_type type;
-	u32 ee_mask;
-	u32 pollcfg;
-	enum mhi_db_brst_mode doorbell;
-	bool lpm_notify;
-	bool offload_channel;
-	bool doorbell_mode_switch;
-	bool auto_queue;
-	bool wake_capable;
-};
-
-/**
- * struct mhi_event_config - Event ring configuration structure for controller
- * @num_elements: The number of elements that can be queued to this ring
- * @irq_moderation_ms: Delay irq for additional events to be aggregated
- * @irq: IRQ associated with this ring
- * @channel: Dedicated channel number. U32_MAX indicates a non-dedicated ring
- * @priority: Priority of this ring. Use 1 for now
- * @mode: Doorbell mode
- * @data_type: Type of data this ring will process
- * @hardware_event: This ring is associated with hardware channels
- * @client_managed: This ring is client managed
- * @offload_channel: This ring is associated with an offloaded channel
- */
-struct mhi_event_config {
-	u32 num_elements;
-	u32 irq_moderation_ms;
-	u32 irq;
-	u32 channel;
-	u32 priority;
-	enum mhi_db_brst_mode mode;
-	enum mhi_er_data_type data_type;
-	bool hardware_event;
-	bool client_managed;
-	bool offload_channel;
-};
-
-/**
- * struct mhi_controller_config - Root MHI controller configuration
- * @max_channels: Maximum number of channels supported
- * @timeout_ms: Timeout value for operations. 0 means use default
- * @ready_timeout_ms: Timeout value for waiting device to be ready (optional)
- * @buf_len: Size of automatically allocated buffers. 0 means use default
- * @num_channels: Number of channels defined in @ch_cfg
- * @ch_cfg: Array of defined channels
- * @num_events: Number of event rings defined in @event_cfg
- * @event_cfg: Array of defined event rings
- * @use_bounce_buf: Use a bounce buffer pool due to limited DDR access
- * @m2_no_db: Host is not allowed to ring DB in M2 state
- */
-struct mhi_controller_config {
-	u32 max_channels;
-	u32 timeout_ms;
-	u32 ready_timeout_ms;
-	u32 buf_len;
-	u32 num_channels;
-	const struct mhi_channel_config *ch_cfg;
-	u32 num_events;
-	struct mhi_event_config *event_cfg;
-	bool use_bounce_buf;
-	bool m2_no_db;
-};
-
-/**
- * struct mhi_controller - Master MHI controller structure
- * @cntrl_dev: Pointer to the struct device of physical bus acting as the MHI
- *            controller (required)
- * @mhi_dev: MHI device instance for the controller
- * @debugfs_dentry: MHI controller debugfs directory
- * @regs: Base address of MHI MMIO register space (required)
- * @bhi: Points to base of MHI BHI register space
- * @bhie: Points to base of MHI BHIe register space
- * @wake_db: MHI WAKE doorbell register address
- * @iova_start: IOMMU starting address for data (required)
- * @iova_stop: IOMMU stop address for data (required)
- * @fw_image: Firmware image name for normal booting (optional)
- * @fw_data: Firmware image data content for normal booting, used only
- *           if fw_image is NULL and fbc_download is true (optional)
- * @fw_sz: Firmware image data size for normal booting, used only if fw_image
- *         is NULL and fbc_download is true (optional)
- * @edl_image: Firmware image name for emergency download mode (optional)
- * @rddm_size: RAM dump size that host should allocate for debugging purpose
- * @sbl_size: SBL image size downloaded through BHIe (optional)
- * @seg_len: BHIe vector size (optional)
- * @reg_len: Length of the MHI MMIO region (required)
- * @fbc_image: Points to firmware image buffer
- * @rddm_image: Points to RAM dump buffer
- * @mhi_chan: Points to the channel configuration table
- * @lpm_chans: List of channels that require LPM notifications
- * @irq: base irq # to request (required)
- * @max_chan: Maximum number of channels the controller supports
- * @total_ev_rings: Total # of event rings allocated
- * @hw_ev_rings: Number of hardware event rings
- * @sw_ev_rings: Number of software event rings
- * @nr_irqs: Number of IRQ allocated by bus master (required)
- * @serial_number: MHI controller serial number obtained from BHI
- * @mhi_event: MHI event ring configurations table
- * @mhi_cmd: MHI command ring configurations table
- * @mhi_ctxt: MHI device context, shared memory between host and device
- * @pm_mutex: Mutex for suspend/resume operation
- * @pm_lock: Lock for protecting MHI power management state
- * @timeout_ms: Timeout in ms for state transitions
- * @ready_timeout_ms: Timeout in ms for waiting device to be ready (optional)
- * @pm_state: MHI power management state
- * @db_access: DB access states
- * @ee: MHI device execution environment
- * @dev_state: MHI device state
- * @dev_wake: Device wakeup count
- * @pending_pkts: Pending packets for the controller
- * @M0, M2, M3: Counters to track number of device MHI state changes
- * @transition_list: List of MHI state transitions
- * @transition_lock: Lock for protecting MHI state transition list
- * @wlock: Lock for protecting device wakeup
- * @mhi_link_info: Device bandwidth info
- * @st_worker: State transition worker
- * @hiprio_wq: High priority workqueue for MHI work such as state transitions
- * @state_event: State change event
- * @status_cb: CB function to notify power states of the device (required)
- * @wake_get: CB function to assert device wake (optional)
- * @wake_put: CB function to de-assert device wake (optional)
- * @wake_toggle: CB function to assert and de-assert device wake (optional)
- * @runtime_get: CB function to controller runtime resume (required)
- * @runtime_put: CB function to decrement pm usage (required)
- * @map_single: CB function to create TRE buffer
- * @unmap_single: CB function to destroy TRE buffer
- * @read_reg: Read a MHI register via the physical link (required)
- * @write_reg: Write a MHI register via the physical link (required)
- * @reset: Controller specific reset function (optional)
- * @buffer_len: Bounce buffer length
- * @index: Index of the MHI controller instance
- * @bounce_buf: Use of bounce buffer
- * @fbc_download: MHI host needs to do complete image transfer (optional)
- * @wake_set: Device wakeup set flag
- * @irq_flags: irq flags passed to request_irq (optional)
- * @mru: the default MRU for the MHI device
- *
- * Fields marked as (required) need to be populated by the controller driver
- * before calling mhi_register_controller(). For the fields marked as (optional)
- * they can be populated depending on the usecase.
- */
-struct mhi_controller {
-	struct device *cntrl_dev;
-	struct mhi_device *mhi_dev;
-	struct dentry *debugfs_dentry;
-	void __iomem *regs;
-	void __iomem *bhi;
-	void __iomem *bhie;
-	void __iomem *wake_db;
-
-	dma_addr_t iova_start;
-	dma_addr_t iova_stop;
-	const char *fw_image;
-	const u8 *fw_data;
-	size_t fw_sz;
-	const char *edl_image;
-	size_t rddm_size;
-	size_t sbl_size;
-	size_t seg_len;
-	size_t reg_len;
-	struct image_info *fbc_image;
-	struct image_info *rddm_image;
-	struct mhi_chan *mhi_chan;
-	struct list_head lpm_chans;
-	int *irq;
-	u32 max_chan;
-	u32 total_ev_rings;
-	u32 hw_ev_rings;
-	u32 sw_ev_rings;
-	u32 nr_irqs;
-	u32 serial_number;
-
-	struct mhi_event *mhi_event;
-	struct mhi_cmd *mhi_cmd;
-	struct mhi_ctxt *mhi_ctxt;
-
-	struct mutex pm_mutex;
-	rwlock_t pm_lock;
-	u32 timeout_ms;
-	u32 ready_timeout_ms;
-	u32 pm_state;
-	u32 db_access;
-	enum mhi_ee_type ee;
-	enum mhi_state dev_state;
-	atomic_t dev_wake;
-	atomic_t pending_pkts;
-	u32 M0, M2, M3;
-	struct list_head transition_list;
-	spinlock_t transition_lock;
-	spinlock_t wlock;
-	struct mhi_link_info mhi_link_info;
-	struct work_struct st_worker;
-	struct workqueue_struct *hiprio_wq;
-	wait_queue_head_t state_event;
-
-	void (*status_cb)(struct mhi_controller *mhi_cntrl,
-			  enum mhi_callback cb);
-	void (*wake_get)(struct mhi_controller *mhi_cntrl, bool override);
-	void (*wake_put)(struct mhi_controller *mhi_cntrl, bool override);
-	void (*wake_toggle)(struct mhi_controller *mhi_cntrl);
-	int (*runtime_get)(struct mhi_controller *mhi_cntrl);
-	void (*runtime_put)(struct mhi_controller *mhi_cntrl);
-	int (*map_single)(struct mhi_controller *mhi_cntrl,
-			  struct mhi_buf_info *buf);
-	void (*unmap_single)(struct mhi_controller *mhi_cntrl,
-			     struct mhi_buf_info *buf);
-	int (*read_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,
-			u32 *out);
-	void (*write_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,
-			  u32 val);
-	void (*reset)(struct mhi_controller *mhi_cntrl);
-
-	size_t buffer_len;
-	int index;
-	bool bounce_buf;
-	bool fbc_download;
-	bool wake_set;
-	unsigned long irq_flags;
-	u32 mru;
-};
-
-/**
- * struct mhi_device - Structure representing an MHI device which binds
- *                     to channels or is associated with controllers
- * @id: Pointer to MHI device ID struct
- * @name: Name of the associated MHI device
- * @mhi_cntrl: Controller the device belongs to
- * @ul_chan: UL channel for the device
- * @dl_chan: DL channel for the device
- * @dev: Driver model device node for the MHI device
- * @dev_type: MHI device type
- * @ul_chan_id: MHI channel id for UL transfer
- * @dl_chan_id: MHI channel id for DL transfer
- * @dev_wake: Device wakeup counter
- */
-struct mhi_device {
-	const struct mhi_device_id *id;
-	const char *name;
-	struct mhi_controller *mhi_cntrl;
-	struct mhi_chan *ul_chan;
-	struct mhi_chan *dl_chan;
-	struct device dev;
-	enum mhi_device_type dev_type;
-	int ul_chan_id;
-	int dl_chan_id;
-	u32 dev_wake;
-};
-
-/**
- * struct mhi_result - Completed buffer information
- * @buf_addr: Address of data buffer
- * @bytes_xferd: # of bytes transferred
- * @dir: Channel direction
- * @transaction_status: Status of last transaction
- */
-struct mhi_result {
-	void *buf_addr;
-	size_t bytes_xferd;
-	enum dma_data_direction dir;
-	int transaction_status;
-};
-
-/**
- * struct mhi_buf - MHI Buffer description
- * @buf: Virtual address of the buffer
- * @name: Buffer label. For offload channel, configurations name must be:
- *        ECA - Event context array data
- *        CCA - Channel context array data
- * @dma_addr: IOMMU address of the buffer
- * @len: # of bytes
- */
-struct mhi_buf {
-	void *buf;
-	const char *name;
-	dma_addr_t dma_addr;
-	size_t len;
-};
-
-/**
- * struct mhi_driver - Structure representing a MHI client driver
- * @probe: CB function for client driver probe function
- * @remove: CB function for client driver remove function
- * @ul_xfer_cb: CB function for UL data transfer
- * @dl_xfer_cb: CB function for DL data transfer
- * @status_cb: CB functions for asynchronous status
- * @driver: Device driver model driver
- */
-struct mhi_driver {
-	const struct mhi_device_id *id_table;
-	int (*probe)(struct mhi_device *mhi_dev,
-		     const struct mhi_device_id *id);
-	void (*remove)(struct mhi_device *mhi_dev);
-	void (*ul_xfer_cb)(struct mhi_device *mhi_dev,
-			   struct mhi_result *result);
-	void (*dl_xfer_cb)(struct mhi_device *mhi_dev,
-			   struct mhi_result *result);
-	void (*status_cb)(struct mhi_device *mhi_dev, enum mhi_callback mhi_cb);
-	struct device_driver driver;
-};
-
-#define to_mhi_driver(drv) container_of(drv, struct mhi_driver, driver)
-#define to_mhi_device(dev) container_of(dev, struct mhi_device, dev)
-
-/**
- * mhi_alloc_controller - Allocate the MHI Controller structure
- * Allocate the mhi_controller structure using zero initialized memory
- */
-struct mhi_controller *mhi_alloc_controller(void);
-
-/**
- * mhi_free_controller - Free the MHI Controller structure
- * Free the mhi_controller structure which was previously allocated
- */
-void mhi_free_controller(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_register_controller - Register MHI controller
- * @mhi_cntrl: MHI controller to register
- * @config: Configuration to use for the controller
- */
-int mhi_register_controller(struct mhi_controller *mhi_cntrl,
-			const struct mhi_controller_config *config);
-
-/**
- * mhi_unregister_controller - Unregister MHI controller
- * @mhi_cntrl: MHI controller to unregister
- */
-void mhi_unregister_controller(struct mhi_controller *mhi_cntrl);
-
-/*
- * module_mhi_driver() - Helper macro for drivers that don't do
- * anything special other than using default mhi_driver_register() and
- * mhi_driver_unregister().  This eliminates a lot of boilerplate.
- * Each module may only use this macro once.
- */
-#define module_mhi_driver(mhi_drv) \
-	module_driver(mhi_drv, mhi_driver_register, \
-		      mhi_driver_unregister)
-
-/*
- * Macro to avoid include chaining to get THIS_MODULE
- */
-#define mhi_driver_register(mhi_drv) \
-	__mhi_driver_register(mhi_drv, THIS_MODULE)
-
-/**
- * __mhi_driver_register - Register driver with MHI framework
- * @mhi_drv: Driver associated with the device
- * @owner: The module owner
- */
-int __mhi_driver_register(struct mhi_driver *mhi_drv, struct module *owner);
-
-/**
- * mhi_driver_unregister - Unregister a driver for mhi_devices
- * @mhi_drv: Driver associated with the device
- */
-void mhi_driver_unregister(struct mhi_driver *mhi_drv);
-
-/**
- * mhi_set_mhi_state - Set MHI device state
- * @mhi_cntrl: MHI controller
- * @state: State to set
- */
-void mhi_set_mhi_state(struct mhi_controller *mhi_cntrl,
-		       enum mhi_state state);
-
-/**
- * mhi_notify - Notify the MHI client driver about client device status
- * @mhi_dev: MHI device instance
- * @cb_reason: MHI callback reason
- */
-void mhi_notify(struct mhi_device *mhi_dev, enum mhi_callback cb_reason);
-
-/**
- * mhi_get_free_desc_count - Get transfer ring length
- * Get # of TD available to queue buffers
- * @mhi_dev: Device associated with the channels
- * @dir: Direction of the channel
- */
-int mhi_get_free_desc_count(struct mhi_device *mhi_dev,
-				enum dma_data_direction dir);
-
-/**
- * mhi_prepare_for_power_up - Do pre-initialization before power up.
- *                            This is optional, call this before power up if
- *                            the controller does not want bus framework to
- *                            automatically free any allocated memory during
- *                            shutdown process.
- * @mhi_cntrl: MHI controller
- */
-int mhi_prepare_for_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_async_power_up - Start MHI power up sequence
- * @mhi_cntrl: MHI controller
- */
-int mhi_async_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_sync_power_up - Start MHI power up sequence and wait till the device
- *                     enters valid EE state
- * @mhi_cntrl: MHI controller
- */
-int mhi_sync_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_power_down - Start MHI power down sequence
- * @mhi_cntrl: MHI controller
- * @graceful: Link is still accessible, so do a graceful shutdown process
- */
-void mhi_power_down(struct mhi_controller *mhi_cntrl, bool graceful);
-
-/**
- * mhi_unprepare_after_power_down - Free any allocated memory after power down
- * @mhi_cntrl: MHI controller
- */
-void mhi_unprepare_after_power_down(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_suspend - Move MHI into a suspended state
- * @mhi_cntrl: MHI controller
- */
-int mhi_pm_suspend(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_resume - Resume MHI from suspended state
- * @mhi_cntrl: MHI controller
- */
-int mhi_pm_resume(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_resume_force - Force resume MHI from suspended state
- * @mhi_cntrl: MHI controller
- *
- * Resume the device irrespective of its MHI state. As per the MHI spec, devices
- * has to be in M3 state during resume. But some devices seem to be in a
- * different MHI state other than M3 but they continue working fine if allowed.
- * This API is intented to be used for such devices.
- *
- * Return: 0 if the resume succeeds, a negative error code otherwise
- */
-int mhi_pm_resume_force(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_download_rddm_image - Download ramdump image from device for
- *                           debugging purpose.
- * @mhi_cntrl: MHI controller
- * @in_panic: Download rddm image during kernel panic
- */
-int mhi_download_rddm_image(struct mhi_controller *mhi_cntrl, bool in_panic);
-
-/**
- * mhi_force_rddm_mode - Force device into rddm mode
- * @mhi_cntrl: MHI controller
- */
-int mhi_force_rddm_mode(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_get_exec_env - Get BHI execution environment of the device
- * @mhi_cntrl: MHI controller
- */
-enum mhi_ee_type mhi_get_exec_env(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_get_mhi_state - Get MHI state of the device
- * @mhi_cntrl: MHI controller
- */
-enum mhi_state mhi_get_mhi_state(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_soc_reset - Trigger a device reset. This can be used as a last resort
- *		   to reset and recover a device.
- * @mhi_cntrl: MHI controller
- */
-void mhi_soc_reset(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_device_get - Disable device low power mode
- * @mhi_dev: Device associated with the channel
- */
-void mhi_device_get(struct mhi_device *mhi_dev);
-
-/**
- * mhi_device_get_sync - Disable device low power mode. Synchronously
- *                       take the controller out of suspended state
- * @mhi_dev: Device associated with the channel
- */
-int mhi_device_get_sync(struct mhi_device *mhi_dev);
-
-/**
- * mhi_device_put - Re-enable device low power mode
- * @mhi_dev: Device associated with the channel
- */
-void mhi_device_put(struct mhi_device *mhi_dev);
-
-/**
- * mhi_prepare_for_transfer - Setup UL and DL channels for data transfer.
- * @mhi_dev: Device associated with the channels
- *
- * Allocate and initialize the channel context and also issue the START channel
- * command to both channels. Channels can be started only if both host and
- * device execution environments match and channels are in a DISABLED state.
- */
-int mhi_prepare_for_transfer(struct mhi_device *mhi_dev);
-
-/**
- * mhi_prepare_for_transfer_autoqueue - Setup UL and DL channels with auto queue
- *                                      buffers for DL traffic
- * @mhi_dev: Device associated with the channels
- *
- * Allocate and initialize the channel context and also issue the START channel
- * command to both channels. Channels can be started only if both host and
- * device execution environments match and channels are in a DISABLED state.
- * The MHI core will automatically allocate and queue buffers for the DL traffic.
- */
-int mhi_prepare_for_transfer_autoqueue(struct mhi_device *mhi_dev);
-
-/**
- * mhi_unprepare_from_transfer - Reset UL and DL channels for data transfer.
- *                               Issue the RESET channel command and let the
- *                               device clean-up the context so no incoming
- *                               transfers are seen on the host. Free memory
- *                               associated with the context on host. If device
- *                               is unresponsive, only perform a host side
- *                               clean-up. Channels can be reset only if both
- *                               host and device execution environments match
- *                               and channels are in an ENABLED, STOPPED or
- *                               SUSPENDED state.
- * @mhi_dev: Device associated with the channels
- */
-void mhi_unprepare_from_transfer(struct mhi_device *mhi_dev);
-
-/**
- * mhi_queue_dma - Send or receive DMA mapped buffers from client device
- *                 over MHI channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @mhi_buf: Buffer for holding the DMA mapped data
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_dma(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  struct mhi_buf *mhi_buf, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_buf - Send or receive raw buffers from client device over MHI
- *                 channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @buf: Buffer for holding the data
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_buf(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  void *buf, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_skb - Send or receive SKBs from client device over MHI channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @skb: Buffer for holding SKBs
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_skb(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  struct sk_buff *skb, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_is_full - Determine whether queueing new elements is possible
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- */
-bool mhi_queue_is_full(struct mhi_device *mhi_dev, enum dma_data_direction dir);
-
-#endif /* _MHI_H_ */
diff --git a/include/linux/rt2x00_platform.h b/include/linux/rt2x00_platform.h
new file mode 100644
index 0000000..e10377e
--- /dev/null
+++ b/include/linux/rt2x00_platform.h
@@ -0,0 +1,23 @@
+/*
+ * Platform data definition for the rt2x00 driver
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#ifndef _RT2X00_PLATFORM_H
+#define _RT2X00_PLATFORM_H
+
+struct rt2x00_platform_data {
+	char *eeprom_file_name;
+	const u8 *mac_address;
+
+	int disable_2ghz;
+	int disable_5ghz;
+};
+
+#endif /* _RT2X00_PLATFORM_H */
diff --git a/include/linux/ssb/ssb.h b/include/linux/ssb/ssb.h
deleted file mode 100644
index 734554e..0000000
--- a/include/linux/ssb/ssb.h
+++ /dev/null
@@ -1,682 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_H_
-#define LINUX_SSB_H_
-
-#include <linux/device.h>
-#include <linux/list.h>
-#include <linux/types.h>
-#include <linux/spinlock.h>
-#include <linux/pci.h>
-#include <linux/gpio/driver.h>
-#include <linux/mod_devicetable.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-
-#include <linux/ssb/ssb_regs.h>
-
-
-struct pcmcia_device;
-struct ssb_bus;
-struct ssb_driver;
-
-struct ssb_sprom_core_pwr_info {
-	u8 itssi_2g, itssi_5g;
-	u8 maxpwr_2g, maxpwr_5gl, maxpwr_5g, maxpwr_5gh;
-	u16 pa_2g[4], pa_5gl[4], pa_5g[4], pa_5gh[4];
-};
-
-struct ssb_sprom {
-	u8 revision;
-	u8 il0mac[6] __aligned(sizeof(u16));	/* MAC address for 802.11b/g */
-	u8 et0mac[6] __aligned(sizeof(u16));	/* MAC address for Ethernet */
-	u8 et1mac[6] __aligned(sizeof(u16));	/* MAC address for 802.11a */
-	u8 et2mac[6] __aligned(sizeof(u16));	/* MAC address for extra Ethernet */
-	u8 et0phyaddr;		/* MII address for enet0 */
-	u8 et1phyaddr;		/* MII address for enet1 */
-	u8 et2phyaddr;		/* MII address for enet2 */
-	u8 et0mdcport;		/* MDIO for enet0 */
-	u8 et1mdcport;		/* MDIO for enet1 */
-	u8 et2mdcport;		/* MDIO for enet2 */
-	u16 dev_id;		/* Device ID overriding e.g. PCI ID */
-	u16 board_rev;		/* Board revision number from SPROM. */
-	u16 board_num;		/* Board number from SPROM. */
-	u16 board_type;		/* Board type from SPROM. */
-	u8 country_code;	/* Country Code */
-	char alpha2[2];		/* Country Code as two chars like EU or US */
-	u8 leddc_on_time;	/* LED Powersave Duty Cycle On Count */
-	u8 leddc_off_time;	/* LED Powersave Duty Cycle Off Count */
-	u8 ant_available_a;	/* 2GHz antenna available bits (up to 4) */
-	u8 ant_available_bg;	/* 5GHz antenna available bits (up to 4) */
-	u16 pa0b0;
-	u16 pa0b1;
-	u16 pa0b2;
-	u16 pa1b0;
-	u16 pa1b1;
-	u16 pa1b2;
-	u16 pa1lob0;
-	u16 pa1lob1;
-	u16 pa1lob2;
-	u16 pa1hib0;
-	u16 pa1hib1;
-	u16 pa1hib2;
-	u8 gpio0;		/* GPIO pin 0 */
-	u8 gpio1;		/* GPIO pin 1 */
-	u8 gpio2;		/* GPIO pin 2 */
-	u8 gpio3;		/* GPIO pin 3 */
-	u8 maxpwr_bg;		/* 2.4GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 maxpwr_al;		/* 5.2GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 maxpwr_a;		/* 5.3GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 maxpwr_ah;		/* 5.8GHz Amplifier Max Power (in dBm Q5.2) */
-	u8 itssi_a;		/* Idle TSSI Target for A-PHY */
-	u8 itssi_bg;		/* Idle TSSI Target for B/G-PHY */
-	u8 tri2g;		/* 2.4GHz TX isolation */
-	u8 tri5gl;		/* 5.2GHz TX isolation */
-	u8 tri5g;		/* 5.3GHz TX isolation */
-	u8 tri5gh;		/* 5.8GHz TX isolation */
-	u8 txpid2g[4];		/* 2GHz TX power index */
-	u8 txpid5gl[4];		/* 4.9 - 5.1GHz TX power index */
-	u8 txpid5g[4];		/* 5.1 - 5.5GHz TX power index */
-	u8 txpid5gh[4];		/* 5.5 - ...GHz TX power index */
-	s8 rxpo2g;		/* 2GHz RX power offset */
-	s8 rxpo5g;		/* 5GHz RX power offset */
-	u8 rssisav2g;		/* 2GHz RSSI params */
-	u8 rssismc2g;
-	u8 rssismf2g;
-	u8 bxa2g;		/* 2GHz BX arch */
-	u8 rssisav5g;		/* 5GHz RSSI params */
-	u8 rssismc5g;
-	u8 rssismf5g;
-	u8 bxa5g;		/* 5GHz BX arch */
-	u16 cck2gpo;		/* CCK power offset */
-	u32 ofdm2gpo;		/* 2.4GHz OFDM power offset */
-	u32 ofdm5glpo;		/* 5.2GHz OFDM power offset */
-	u32 ofdm5gpo;		/* 5.3GHz OFDM power offset */
-	u32 ofdm5ghpo;		/* 5.8GHz OFDM power offset */
-	u32 boardflags;
-	u32 boardflags2;
-	u32 boardflags3;
-	/* TODO: Switch all drivers to new u32 fields and drop below ones */
-	u16 boardflags_lo;	/* Board flags (bits 0-15) */
-	u16 boardflags_hi;	/* Board flags (bits 16-31) */
-	u16 boardflags2_lo;	/* Board flags (bits 32-47) */
-	u16 boardflags2_hi;	/* Board flags (bits 48-63) */
-
-	struct ssb_sprom_core_pwr_info core_pwr_info[4];
-
-	/* Antenna gain values for up to 4 antennas
-	 * on each band. Values in dBm/4 (Q5.2). Negative gain means the
-	 * loss in the connectors is bigger than the gain. */
-	struct {
-		s8 a0, a1, a2, a3;
-	} antenna_gain;
-
-	struct {
-		struct {
-			u8 tssipos, extpa_gain, pdet_range, tr_iso, antswlut;
-		} ghz2;
-		struct {
-			u8 tssipos, extpa_gain, pdet_range, tr_iso, antswlut;
-		} ghz5;
-	} fem;
-
-	u16 mcs2gpo[8];
-	u16 mcs5gpo[8];
-	u16 mcs5glpo[8];
-	u16 mcs5ghpo[8];
-	u8 opo;
-
-	u8 rxgainerr2ga[3];
-	u8 rxgainerr5gla[3];
-	u8 rxgainerr5gma[3];
-	u8 rxgainerr5gha[3];
-	u8 rxgainerr5gua[3];
-
-	u8 noiselvl2ga[3];
-	u8 noiselvl5gla[3];
-	u8 noiselvl5gma[3];
-	u8 noiselvl5gha[3];
-	u8 noiselvl5gua[3];
-
-	u8 regrev;
-	u8 txchain;
-	u8 rxchain;
-	u8 antswitch;
-	u16 cddpo;
-	u16 stbcpo;
-	u16 bw40po;
-	u16 bwduppo;
-
-	u8 tempthresh;
-	u8 tempoffset;
-	u16 rawtempsense;
-	u8 measpower;
-	u8 tempsense_slope;
-	u8 tempcorrx;
-	u8 tempsense_option;
-	u8 freqoffset_corr;
-	u8 iqcal_swp_dis;
-	u8 hw_iqcal_en;
-	u8 elna2g;
-	u8 elna5g;
-	u8 phycal_tempdelta;
-	u8 temps_period;
-	u8 temps_hysteresis;
-	u8 measpower1;
-	u8 measpower2;
-	u8 pcieingress_war;
-
-	/* power per rate from sromrev 9 */
-	u16 cckbw202gpo;
-	u16 cckbw20ul2gpo;
-	u32 legofdmbw202gpo;
-	u32 legofdmbw20ul2gpo;
-	u32 legofdmbw205glpo;
-	u32 legofdmbw20ul5glpo;
-	u32 legofdmbw205gmpo;
-	u32 legofdmbw20ul5gmpo;
-	u32 legofdmbw205ghpo;
-	u32 legofdmbw20ul5ghpo;
-	u32 mcsbw202gpo;
-	u32 mcsbw20ul2gpo;
-	u32 mcsbw402gpo;
-	u32 mcsbw205glpo;
-	u32 mcsbw20ul5glpo;
-	u32 mcsbw405glpo;
-	u32 mcsbw205gmpo;
-	u32 mcsbw20ul5gmpo;
-	u32 mcsbw405gmpo;
-	u32 mcsbw205ghpo;
-	u32 mcsbw20ul5ghpo;
-	u32 mcsbw405ghpo;
-	u16 mcs32po;
-	u16 legofdm40duppo;
-	u8 sar2g;
-	u8 sar5g;
-};
-
-/* Information about the PCB the circuitry is soldered on. */
-struct ssb_boardinfo {
-	u16 vendor;
-	u16 type;
-};
-
-
-struct ssb_device;
-/* Lowlevel read/write operations on the device MMIO.
- * Internal, don't use that outside of ssb. */
-struct ssb_bus_ops {
-	u8 (*read8)(struct ssb_device *dev, u16 offset);
-	u16 (*read16)(struct ssb_device *dev, u16 offset);
-	u32 (*read32)(struct ssb_device *dev, u16 offset);
-	void (*write8)(struct ssb_device *dev, u16 offset, u8 value);
-	void (*write16)(struct ssb_device *dev, u16 offset, u16 value);
-	void (*write32)(struct ssb_device *dev, u16 offset, u32 value);
-#ifdef CPTCFG_SSB_BLOCKIO
-	void (*block_read)(struct ssb_device *dev, void *buffer,
-			   size_t count, u16 offset, u8 reg_width);
-	void (*block_write)(struct ssb_device *dev, const void *buffer,
-			    size_t count, u16 offset, u8 reg_width);
-#endif
-};
-
-
-/* Core-ID values. */
-#define SSB_DEV_CHIPCOMMON	0x800
-#define SSB_DEV_ILINE20		0x801
-#define SSB_DEV_SDRAM		0x803
-#define SSB_DEV_PCI		0x804
-#define SSB_DEV_MIPS		0x805
-#define SSB_DEV_ETHERNET	0x806
-#define SSB_DEV_V90		0x807
-#define SSB_DEV_USB11_HOSTDEV	0x808
-#define SSB_DEV_ADSL		0x809
-#define SSB_DEV_ILINE100	0x80A
-#define SSB_DEV_IPSEC		0x80B
-#define SSB_DEV_PCMCIA		0x80D
-#define SSB_DEV_INTERNAL_MEM	0x80E
-#define SSB_DEV_MEMC_SDRAM	0x80F
-#define SSB_DEV_EXTIF		0x811
-#define SSB_DEV_80211		0x812
-#define SSB_DEV_MIPS_3302	0x816
-#define SSB_DEV_USB11_HOST	0x817
-#define SSB_DEV_USB11_DEV	0x818
-#define SSB_DEV_USB20_HOST	0x819
-#define SSB_DEV_USB20_DEV	0x81A
-#define SSB_DEV_SDIO_HOST	0x81B
-#define SSB_DEV_ROBOSWITCH	0x81C
-#define SSB_DEV_PARA_ATA	0x81D
-#define SSB_DEV_SATA_XORDMA	0x81E
-#define SSB_DEV_ETHERNET_GBIT	0x81F
-#define SSB_DEV_PCIE		0x820
-#define SSB_DEV_MIMO_PHY	0x821
-#define SSB_DEV_SRAM_CTRLR	0x822
-#define SSB_DEV_MINI_MACPHY	0x823
-#define SSB_DEV_ARM_1176	0x824
-#define SSB_DEV_ARM_7TDMI	0x825
-#define SSB_DEV_ARM_CM3		0x82A
-
-/* Vendor-ID values */
-#define SSB_VENDOR_BROADCOM	0x4243
-
-/* Some kernel subsystems poke with dev->drvdata, so we must use the
- * following ugly workaround to get from struct device to struct ssb_device */
-struct __ssb_dev_wrapper {
-	struct device dev;
-	struct ssb_device *sdev;
-};
-
-struct ssb_device {
-	/* Having a copy of the ops pointer in each dev struct
-	 * is an optimization. */
-	const struct ssb_bus_ops *ops;
-
-	struct device *dev, *dma_dev;
-
-	struct ssb_bus *bus;
-	struct ssb_device_id id;
-
-	u8 core_index;
-	unsigned int irq;
-
-	/* Internal-only stuff follows. */
-	void *drvdata;		/* Per-device data */
-	void *devtypedata;	/* Per-devicetype (eg 802.11) data */
-};
-
-/* Go from struct device to struct ssb_device. */
-static inline
-struct ssb_device * dev_to_ssb_dev(const struct device *dev)
-{
-	struct __ssb_dev_wrapper *wrap;
-	wrap = container_of(dev, struct __ssb_dev_wrapper, dev);
-	return wrap->sdev;
-}
-
-/* Device specific user data */
-static inline
-void ssb_set_drvdata(struct ssb_device *dev, void *data)
-{
-	dev->drvdata = data;
-}
-static inline
-void * ssb_get_drvdata(struct ssb_device *dev)
-{
-	return dev->drvdata;
-}
-
-/* Devicetype specific user data. This is per device-type (not per device) */
-void ssb_set_devtypedata(struct ssb_device *dev, void *data);
-static inline
-void * ssb_get_devtypedata(struct ssb_device *dev)
-{
-	return dev->devtypedata;
-}
-
-
-struct ssb_driver {
-	const char *name;
-	const struct ssb_device_id *id_table;
-
-	int (*probe)(struct ssb_device *dev, const struct ssb_device_id *id);
-	void (*remove)(struct ssb_device *dev);
-	int (*suspend)(struct ssb_device *dev, pm_message_t state);
-	int (*resume)(struct ssb_device *dev);
-	void (*shutdown)(struct ssb_device *dev);
-
-	struct device_driver drv;
-};
-#define drv_to_ssb_drv(_drv) container_of(_drv, struct ssb_driver, drv)
-
-extern int __ssb_driver_register(struct ssb_driver *drv, struct module *owner);
-#define ssb_driver_register(drv) \
-	__ssb_driver_register(drv, THIS_MODULE)
-
-extern void ssb_driver_unregister(struct ssb_driver *drv);
-
-
-
-
-enum ssb_bustype {
-	SSB_BUSTYPE_SSB,	/* This SSB bus is the system bus */
-	SSB_BUSTYPE_PCI,	/* SSB is connected to PCI bus */
-	SSB_BUSTYPE_PCMCIA,	/* SSB is connected to PCMCIA bus */
-	SSB_BUSTYPE_SDIO,	/* SSB is connected to SDIO bus */
-};
-
-/* board_vendor */
-#define SSB_BOARDVENDOR_BCM	0x14E4	/* Broadcom */
-#define SSB_BOARDVENDOR_DELL	0x1028	/* Dell */
-#define SSB_BOARDVENDOR_HP	0x0E11	/* HP */
-/* board_type */
-#define SSB_BOARD_BCM94301CB	0x0406
-#define SSB_BOARD_BCM94301MP	0x0407
-#define SSB_BOARD_BU4309	0x040A
-#define SSB_BOARD_BCM94309CB	0x040B
-#define SSB_BOARD_BCM4309MP	0x040C
-#define SSB_BOARD_BU4306	0x0416
-#define SSB_BOARD_BCM94306MP	0x0418
-#define SSB_BOARD_BCM4309G	0x0421
-#define SSB_BOARD_BCM4306CB	0x0417
-#define SSB_BOARD_BCM94306PC	0x0425	/* pcmcia 3.3v 4306 card */
-#define SSB_BOARD_BCM94306CBSG	0x042B	/* with SiGe PA */
-#define SSB_BOARD_PCSG94306	0x042D	/* with SiGe PA */
-#define SSB_BOARD_BU4704SD	0x042E	/* with sdram */
-#define SSB_BOARD_BCM94704AGR	0x042F	/* dual 11a/11g Router */
-#define SSB_BOARD_BCM94308MP	0x0430	/* 11a-only minipci */
-#define SSB_BOARD_BU4318	0x0447
-#define SSB_BOARD_CB4318	0x0448
-#define SSB_BOARD_MPG4318	0x0449
-#define SSB_BOARD_MP4318	0x044A
-#define SSB_BOARD_SD4318	0x044B
-#define SSB_BOARD_BCM94306P	0x044C	/* with SiGe */
-#define SSB_BOARD_BCM94303MP	0x044E
-#define SSB_BOARD_BCM94306MPM	0x0450
-#define SSB_BOARD_BCM94306MPL	0x0453
-#define SSB_BOARD_PC4303	0x0454	/* pcmcia */
-#define SSB_BOARD_BCM94306MPLNA	0x0457
-#define SSB_BOARD_BCM94306MPH	0x045B
-#define SSB_BOARD_BCM94306PCIV	0x045C
-#define SSB_BOARD_BCM94318MPGH	0x0463
-#define SSB_BOARD_BU4311	0x0464
-#define SSB_BOARD_BCM94311MC	0x0465
-#define SSB_BOARD_BCM94311MCAG	0x0466
-/* 4321 boards */
-#define SSB_BOARD_BU4321	0x046B
-#define SSB_BOARD_BU4321E	0x047C
-#define SSB_BOARD_MP4321	0x046C
-#define SSB_BOARD_CB2_4321	0x046D
-#define SSB_BOARD_CB2_4321_AG	0x0066
-#define SSB_BOARD_MC4321	0x046E
-/* 4325 boards */
-#define SSB_BOARD_BCM94325DEVBU	0x0490
-#define SSB_BOARD_BCM94325BGABU	0x0491
-#define SSB_BOARD_BCM94325SDGWB	0x0492
-#define SSB_BOARD_BCM94325SDGMDL	0x04AA
-#define SSB_BOARD_BCM94325SDGMDL2	0x04C6
-#define SSB_BOARD_BCM94325SDGMDL3	0x04C9
-#define SSB_BOARD_BCM94325SDABGWBA	0x04E1
-/* 4322 boards */
-#define SSB_BOARD_BCM94322MC	0x04A4
-#define SSB_BOARD_BCM94322USB	0x04A8	/* dualband */
-#define SSB_BOARD_BCM94322HM	0x04B0
-#define SSB_BOARD_BCM94322USB2D	0x04Bf	/* single band discrete front end */
-/* 4312 boards */
-#define SSB_BOARD_BU4312	0x048A
-#define SSB_BOARD_BCM4312MCGSG	0x04B5
-/* chip_package */
-#define SSB_CHIPPACK_BCM4712S	1	/* Small 200pin 4712 */
-#define SSB_CHIPPACK_BCM4712M	2	/* Medium 225pin 4712 */
-#define SSB_CHIPPACK_BCM4712L	0	/* Large 340pin 4712 */
-
-#include <linux/ssb/ssb_driver_chipcommon.h>
-#include <linux/ssb/ssb_driver_mips.h>
-#include <linux/ssb/ssb_driver_extif.h>
-#include <linux/ssb/ssb_driver_pci.h>
-
-struct ssb_bus {
-	/* The MMIO area. */
-	void __iomem *mmio;
-
-	const struct ssb_bus_ops *ops;
-
-	/* The core currently mapped into the MMIO window.
-	 * Not valid on all host-buses. So don't use outside of SSB. */
-	struct ssb_device *mapped_device;
-	union {
-		/* Currently mapped PCMCIA segment. (bustype == SSB_BUSTYPE_PCMCIA only) */
-		u8 mapped_pcmcia_seg;
-		/* Current SSB base address window for SDIO. */
-		u32 sdio_sbaddr;
-	};
-	/* Lock for core and segment switching.
-	 * On PCMCIA-host busses this is used to protect the whole MMIO access. */
-	spinlock_t bar_lock;
-
-	/* The host-bus this backplane is running on. */
-	enum ssb_bustype bustype;
-	/* Pointers to the host-bus. Check bustype before using any of these pointers. */
-	union {
-		/* Pointer to the PCI bus (only valid if bustype == SSB_BUSTYPE_PCI). */
-		struct pci_dev *host_pci;
-		/* Pointer to the PCMCIA device (only if bustype == SSB_BUSTYPE_PCMCIA). */
-		struct pcmcia_device *host_pcmcia;
-		/* Pointer to the SDIO device (only if bustype == SSB_BUSTYPE_SDIO). */
-		struct sdio_func *host_sdio;
-	};
-
-	/* See enum ssb_quirks */
-	unsigned int quirks;
-
-#ifdef CPTCFG_SSB_SPROM
-	/* Mutex to protect the SPROM writing. */
-	struct mutex sprom_mutex;
-#endif
-
-	/* ID information about the Chip. */
-	u16 chip_id;
-	u8 chip_rev;
-	u16 sprom_offset;
-	u16 sprom_size;		/* number of words in sprom */
-	u8 chip_package;
-
-	/* List of devices (cores) on the backplane. */
-	struct ssb_device devices[SSB_MAX_NR_CORES];
-	u8 nr_devices;
-
-	/* Software ID number for this bus. */
-	unsigned int busnumber;
-
-	/* The ChipCommon device (if available). */
-	struct ssb_chipcommon chipco;
-	/* The PCI-core device (if available). */
-	struct ssb_pcicore pcicore;
-	/* The MIPS-core device (if available). */
-	struct ssb_mipscore mipscore;
-	/* The EXTif-core device (if available). */
-	struct ssb_extif extif;
-
-	/* The following structure elements are not available in early
-	 * SSB initialization. Though, they are available for regular
-	 * registered drivers at any stage. So be careful when
-	 * using them in the ssb core code. */
-
-	/* ID information about the PCB. */
-	struct ssb_boardinfo boardinfo;
-	/* Contents of the SPROM. */
-	struct ssb_sprom sprom;
-	/* If the board has a cardbus slot, this is set to true. */
-	bool has_cardbus_slot;
-
-#ifdef CPTCFG_SSB_EMBEDDED
-	/* Lock for GPIO register access. */
-	spinlock_t gpio_lock;
-	struct platform_device *watchdog;
-#endif /* EMBEDDED */
-#ifdef CPTCFG_SSB_DRIVER_GPIO
-	struct gpio_chip gpio;
-	struct irq_domain *irq_domain;
-#endif /* DRIVER_GPIO */
-
-	/* Internal-only stuff follows. Do not touch. */
-	struct list_head list;
-	/* Is the bus already powered up? */
-	bool powered_up;
-	int power_warn_count;
-};
-
-enum ssb_quirks {
-	/* SDIO connected card requires performing a read after writing a 32-bit value */
-	SSB_QUIRK_SDIO_READ_AFTER_WRITE32	= (1 << 0),
-};
-
-/* The initialization-invariants. */
-struct ssb_init_invariants {
-	/* Versioning information about the PCB. */
-	struct ssb_boardinfo boardinfo;
-	/* The SPROM information. That's either stored in an
-	 * EEPROM or NVRAM on the board. */
-	struct ssb_sprom sprom;
-	/* If the board has a cardbus slot, this is set to true. */
-	bool has_cardbus_slot;
-};
-/* Type of function to fetch the invariants. */
-typedef int (*ssb_invariants_func_t)(struct ssb_bus *bus,
-				     struct ssb_init_invariants *iv);
-
-/* Register SoC bus. */
-extern int ssb_bus_host_soc_register(struct ssb_bus *bus,
-				     unsigned long baseaddr);
-#ifdef CPTCFG_SSB_PCIHOST
-extern int ssb_bus_pcibus_register(struct ssb_bus *bus,
-				   struct pci_dev *host_pci);
-#endif /* CPTCFG_SSB_PCIHOST */
-#ifdef CPTCFG_SSB_PCMCIAHOST
-extern int ssb_bus_pcmciabus_register(struct ssb_bus *bus,
-				      struct pcmcia_device *pcmcia_dev,
-				      unsigned long baseaddr);
-#endif /* CPTCFG_SSB_PCMCIAHOST */
-#ifdef CPTCFG_SSB_SDIOHOST
-extern int ssb_bus_sdiobus_register(struct ssb_bus *bus,
-				    struct sdio_func *sdio_func,
-				    unsigned int quirks);
-#endif /* CPTCFG_SSB_SDIOHOST */
-
-
-extern void ssb_bus_unregister(struct ssb_bus *bus);
-
-/* Does the device have an SPROM? */
-extern bool ssb_is_sprom_available(struct ssb_bus *bus);
-
-/* Set a fallback SPROM.
- * See kdoc at the function definition for complete documentation. */
-extern int ssb_arch_register_fallback_sprom(
-		int (*sprom_callback)(struct ssb_bus *bus,
-		struct ssb_sprom *out));
-
-/* Suspend a SSB bus.
- * Call this from the parent bus suspend routine. */
-extern int ssb_bus_suspend(struct ssb_bus *bus);
-/* Resume a SSB bus.
- * Call this from the parent bus resume routine. */
-extern int ssb_bus_resume(struct ssb_bus *bus);
-
-extern u32 ssb_clockspeed(struct ssb_bus *bus);
-
-/* Is the device enabled in hardware? */
-int ssb_device_is_enabled(struct ssb_device *dev);
-/* Enable a device and pass device-specific SSB_TMSLOW flags.
- * If no device-specific flags are available, use 0. */
-void ssb_device_enable(struct ssb_device *dev, u32 core_specific_flags);
-/* Disable a device in hardware and pass SSB_TMSLOW flags (if any). */
-void ssb_device_disable(struct ssb_device *dev, u32 core_specific_flags);
-
-
-/* Device MMIO register read/write functions. */
-static inline u8 ssb_read8(struct ssb_device *dev, u16 offset)
-{
-	return dev->ops->read8(dev, offset);
-}
-static inline u16 ssb_read16(struct ssb_device *dev, u16 offset)
-{
-	return dev->ops->read16(dev, offset);
-}
-static inline u32 ssb_read32(struct ssb_device *dev, u16 offset)
-{
-	return dev->ops->read32(dev, offset);
-}
-static inline void ssb_write8(struct ssb_device *dev, u16 offset, u8 value)
-{
-	dev->ops->write8(dev, offset, value);
-}
-static inline void ssb_write16(struct ssb_device *dev, u16 offset, u16 value)
-{
-	dev->ops->write16(dev, offset, value);
-}
-static inline void ssb_write32(struct ssb_device *dev, u16 offset, u32 value)
-{
-	dev->ops->write32(dev, offset, value);
-}
-#ifdef CPTCFG_SSB_BLOCKIO
-static inline void ssb_block_read(struct ssb_device *dev, void *buffer,
-				  size_t count, u16 offset, u8 reg_width)
-{
-	dev->ops->block_read(dev, buffer, count, offset, reg_width);
-}
-
-static inline void ssb_block_write(struct ssb_device *dev, const void *buffer,
-				   size_t count, u16 offset, u8 reg_width)
-{
-	dev->ops->block_write(dev, buffer, count, offset, reg_width);
-}
-#endif /* CPTCFG_SSB_BLOCKIO */
-
-
-/* The SSB DMA API. Use this API for any DMA operation on the device.
- * This API basically is a wrapper that calls the correct DMA API for
- * the host device type the SSB device is attached to. */
-
-/* Translation (routing) bits that need to be ORed to DMA
- * addresses before they are given to a device. */
-extern u32 ssb_dma_translation(struct ssb_device *dev);
-#define SSB_DMA_TRANSLATION_MASK	0xC0000000
-#define SSB_DMA_TRANSLATION_SHIFT	30
-
-static inline void __cold __ssb_dma_not_implemented(struct ssb_device *dev)
-{
-#ifdef CONFIG_SSB_DEBUG
-	printk(KERN_ERR "SSB: BUG! Calling DMA API for "
-	       "unsupported bustype %d\n", dev->bus->bustype);
-#endif /* DEBUG */
-}
-
-#ifdef CPTCFG_SSB_PCIHOST
-/* PCI-host wrapper driver */
-extern int ssb_pcihost_register(struct pci_driver *driver);
-static inline void ssb_pcihost_unregister(struct pci_driver *driver)
-{
-	pci_unregister_driver(driver);
-}
-
-static inline
-void ssb_pcihost_set_power_state(struct ssb_device *sdev, pci_power_t state)
-{
-	if (sdev->bus->bustype == SSB_BUSTYPE_PCI)
-		pci_set_power_state(sdev->bus->host_pci, state);
-}
-#else
-static inline void ssb_pcihost_unregister(struct pci_driver *driver)
-{
-}
-
-static inline
-void ssb_pcihost_set_power_state(struct ssb_device *sdev, pci_power_t state)
-{
-}
-#endif /* CPTCFG_SSB_PCIHOST */
-
-
-/* If a driver is shutdown or suspended, call this to signal
- * that the bus may be completely powered down. SSB will decide,
- * if it's really time to power down the bus, based on if there
- * are other devices that want to run. */
-extern int ssb_bus_may_powerdown(struct ssb_bus *bus);
-/* Before initializing and enabling a device, call this to power-up the bus.
- * If you want to allow use of dynamic-power-control, pass the flag.
- * Otherwise static always-on powercontrol will be used. */
-extern int ssb_bus_powerup(struct ssb_bus *bus, bool dynamic_pctl);
-
-extern void ssb_commit_settings(struct ssb_bus *bus);
-
-/* Various helper functions */
-extern u32 ssb_admatch_base(u32 adm);
-extern u32 ssb_admatch_size(u32 adm);
-
-/* PCI device mapping and fixup routines.
- * Called from the architecture pcibios init code.
- * These are only available on SSB_EMBEDDED configurations. */
-#ifdef CPTCFG_SSB_EMBEDDED
-int ssb_pcibios_plat_dev_init(struct pci_dev *dev);
-int ssb_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
-#endif /* CPTCFG_SSB_EMBEDDED */
-
-#endif /* LINUX_SSB_H_ */
diff --git a/include/linux/ssb/ssb_driver_chipcommon.h b/include/linux/ssb/ssb_driver_chipcommon.h
deleted file mode 100644
index 1bb4651..0000000
--- a/include/linux/ssb/ssb_driver_chipcommon.h
+++ /dev/null
@@ -1,672 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-#ifndef LINUX_SSB_CHIPCO_H_
-#define LINUX_SSB_CHIPCO_H_
-
-/* SonicsSiliconBackplane CHIPCOMMON core hardware definitions
- *
- * The chipcommon core provides chip identification, SB control,
- * jtag, 0/1/2 uarts, clock frequency control, a watchdog interrupt timer,
- * gpio interface, extbus, and support for serial and parallel flashes.
- *
- * Copyright 2005, Broadcom Corporation
- * Copyright 2006, Michael Buesch <m@bues.ch>
- */
-
-/** ChipCommon core registers. **/
-
-#define SSB_CHIPCO_CHIPID		0x0000
-#define  SSB_CHIPCO_IDMASK		0x0000FFFF
-#define  SSB_CHIPCO_REVMASK		0x000F0000
-#define  SSB_CHIPCO_REVSHIFT		16
-#define  SSB_CHIPCO_PACKMASK		0x00F00000
-#define  SSB_CHIPCO_PACKSHIFT		20
-#define  SSB_CHIPCO_NRCORESMASK		0x0F000000
-#define  SSB_CHIPCO_NRCORESSHIFT	24
-#define SSB_CHIPCO_CAP	 		0x0004		/* Capabilities */
-#define  SSB_CHIPCO_CAP_NRUART		0x00000003	/* # of UARTs */
-#define  SSB_CHIPCO_CAP_MIPSEB		0x00000004	/* MIPS in BigEndian Mode */
-#define  SSB_CHIPCO_CAP_UARTCLK		0x00000018	/* UART clock select */
-#define   SSB_CHIPCO_CAP_UARTCLK_INT	0x00000008	/* UARTs are driven by internal divided clock */
-#define  SSB_CHIPCO_CAP_UARTGPIO	0x00000020	/* UARTs on GPIO 15-12 */
-#define  SSB_CHIPCO_CAP_EXTBUS		0x000000C0	/* External buses present */
-#define  SSB_CHIPCO_CAP_FLASHT		0x00000700	/* Flash Type */
-#define   SSB_CHIPCO_FLASHT_NONE	0x00000000	/* No flash */
-#define   SSB_CHIPCO_FLASHT_STSER	0x00000100	/* ST serial flash */
-#define   SSB_CHIPCO_FLASHT_ATSER	0x00000200	/* Atmel serial flash */
-#define	  SSB_CHIPCO_FLASHT_PARA	0x00000700	/* Parallel flash */
-#define  SSB_CHIPCO_CAP_PLLT		0x00038000	/* PLL Type */
-#define   SSB_PLLTYPE_NONE		0x00000000
-#define   SSB_PLLTYPE_1			0x00010000	/* 48Mhz base, 3 dividers */
-#define   SSB_PLLTYPE_2			0x00020000	/* 48Mhz, 4 dividers */
-#define   SSB_PLLTYPE_3			0x00030000	/* 25Mhz, 2 dividers */
-#define   SSB_PLLTYPE_4			0x00008000	/* 48Mhz, 4 dividers */
-#define   SSB_PLLTYPE_5			0x00018000	/* 25Mhz, 4 dividers */
-#define   SSB_PLLTYPE_6			0x00028000	/* 100/200 or 120/240 only */
-#define   SSB_PLLTYPE_7			0x00038000	/* 25Mhz, 4 dividers */
-#define  SSB_CHIPCO_CAP_PCTL		0x00040000	/* Power Control */
-#define  SSB_CHIPCO_CAP_OTPS		0x00380000	/* OTP size */
-#define  SSB_CHIPCO_CAP_OTPS_SHIFT	19
-#define  SSB_CHIPCO_CAP_OTPS_BASE	5
-#define  SSB_CHIPCO_CAP_JTAGM		0x00400000	/* JTAG master present */
-#define  SSB_CHIPCO_CAP_BROM		0x00800000	/* Internal boot ROM active */
-#define  SSB_CHIPCO_CAP_64BIT		0x08000000	/* 64-bit Backplane */
-#define  SSB_CHIPCO_CAP_PMU		0x10000000	/* PMU available (rev >= 20) */
-#define  SSB_CHIPCO_CAP_ECI		0x20000000	/* ECI available (rev >= 20) */
-#define  SSB_CHIPCO_CAP_SPROM		0x40000000	/* SPROM present */
-#define SSB_CHIPCO_CORECTL		0x0008
-#define  SSB_CHIPCO_CORECTL_UARTCLK0	0x00000001	/* Drive UART with internal clock */
-#define	 SSB_CHIPCO_CORECTL_SE		0x00000002	/* sync clk out enable (corerev >= 3) */
-#define  SSB_CHIPCO_CORECTL_UARTCLKEN	0x00000008	/* UART clock enable (rev >= 21) */
-#define SSB_CHIPCO_BIST			0x000C
-#define SSB_CHIPCO_OTPS			0x0010		/* OTP status */
-#define	 SSB_CHIPCO_OTPS_PROGFAIL	0x80000000
-#define	 SSB_CHIPCO_OTPS_PROTECT	0x00000007
-#define	 SSB_CHIPCO_OTPS_HW_PROTECT	0x00000001
-#define	 SSB_CHIPCO_OTPS_SW_PROTECT	0x00000002
-#define	 SSB_CHIPCO_OTPS_CID_PROTECT	0x00000004
-#define SSB_CHIPCO_OTPC			0x0014		/* OTP control */
-#define	 SSB_CHIPCO_OTPC_RECWAIT	0xFF000000
-#define	 SSB_CHIPCO_OTPC_PROGWAIT	0x00FFFF00
-#define	 SSB_CHIPCO_OTPC_PRW_SHIFT	8
-#define	 SSB_CHIPCO_OTPC_MAXFAIL	0x00000038
-#define	 SSB_CHIPCO_OTPC_VSEL		0x00000006
-#define	 SSB_CHIPCO_OTPC_SELVL		0x00000001
-#define SSB_CHIPCO_OTPP			0x0018		/* OTP prog */
-#define	 SSB_CHIPCO_OTPP_COL		0x000000FF
-#define	 SSB_CHIPCO_OTPP_ROW		0x0000FF00
-#define	 SSB_CHIPCO_OTPP_ROW_SHIFT	8
-#define	 SSB_CHIPCO_OTPP_READERR	0x10000000
-#define	 SSB_CHIPCO_OTPP_VALUE		0x20000000
-#define	 SSB_CHIPCO_OTPP_READ		0x40000000
-#define	 SSB_CHIPCO_OTPP_START		0x80000000
-#define	 SSB_CHIPCO_OTPP_BUSY		0x80000000
-#define SSB_CHIPCO_IRQSTAT		0x0020
-#define SSB_CHIPCO_IRQMASK		0x0024
-#define	 SSB_CHIPCO_IRQ_GPIO		0x00000001	/* gpio intr */
-#define	 SSB_CHIPCO_IRQ_EXT		0x00000002	/* ro: ext intr pin (corerev >= 3) */
-#define	 SSB_CHIPCO_IRQ_WDRESET		0x80000000	/* watchdog reset occurred */
-#define SSB_CHIPCO_CHIPCTL		0x0028		/* Rev >= 11 only */
-#define SSB_CHIPCO_CHIPSTAT		0x002C		/* Rev >= 11 only */
-#define SSB_CHIPCO_JCMD			0x0030		/* Rev >= 10 only */
-#define  SSB_CHIPCO_JCMD_START		0x80000000
-#define  SSB_CHIPCO_JCMD_BUSY		0x80000000
-#define  SSB_CHIPCO_JCMD_PAUSE		0x40000000
-#define  SSB_CHIPCO_JCMD0_ACC_MASK	0x0000F000
-#define  SSB_CHIPCO_JCMD0_ACC_IRDR	0x00000000
-#define  SSB_CHIPCO_JCMD0_ACC_DR	0x00001000
-#define  SSB_CHIPCO_JCMD0_ACC_IR	0x00002000
-#define  SSB_CHIPCO_JCMD0_ACC_RESET	0x00003000
-#define  SSB_CHIPCO_JCMD0_ACC_IRPDR	0x00004000
-#define  SSB_CHIPCO_JCMD0_ACC_PDR	0x00005000
-#define  SSB_CHIPCO_JCMD0_IRW_MASK	0x00000F00
-#define  SSB_CHIPCO_JCMD_ACC_MASK	0x000F0000	/* Changes for corerev 11 */
-#define  SSB_CHIPCO_JCMD_ACC_IRDR	0x00000000
-#define  SSB_CHIPCO_JCMD_ACC_DR		0x00010000
-#define  SSB_CHIPCO_JCMD_ACC_IR		0x00020000
-#define  SSB_CHIPCO_JCMD_ACC_RESET	0x00030000
-#define  SSB_CHIPCO_JCMD_ACC_IRPDR	0x00040000
-#define  SSB_CHIPCO_JCMD_ACC_PDR	0x00050000
-#define  SSB_CHIPCO_JCMD_IRW_MASK	0x00001F00
-#define  SSB_CHIPCO_JCMD_IRW_SHIFT	8
-#define  SSB_CHIPCO_JCMD_DRW_MASK	0x0000003F
-#define SSB_CHIPCO_JIR			0x0034		/* Rev >= 10 only */
-#define SSB_CHIPCO_JDR			0x0038		/* Rev >= 10 only */
-#define SSB_CHIPCO_JCTL			0x003C		/* Rev >= 10 only */
-#define  SSB_CHIPCO_JCTL_FORCE_CLK	4		/* Force clock */
-#define  SSB_CHIPCO_JCTL_EXT_EN		2		/* Enable external targets */
-#define  SSB_CHIPCO_JCTL_EN		1		/* Enable Jtag master */
-#define SSB_CHIPCO_FLASHCTL		0x0040
-#define  SSB_CHIPCO_FLASHCTL_START	0x80000000
-#define  SSB_CHIPCO_FLASHCTL_BUSY	SSB_CHIPCO_FLASHCTL_START
-#define SSB_CHIPCO_FLASHADDR		0x0044
-#define SSB_CHIPCO_FLASHDATA		0x0048
-#define SSB_CHIPCO_BCAST_ADDR		0x0050
-#define SSB_CHIPCO_BCAST_DATA		0x0054
-#define SSB_CHIPCO_GPIOPULLUP		0x0058		/* Rev >= 20 only */
-#define SSB_CHIPCO_GPIOPULLDOWN		0x005C		/* Rev >= 20 only */
-#define SSB_CHIPCO_GPIOIN		0x0060
-#define SSB_CHIPCO_GPIOOUT		0x0064
-#define SSB_CHIPCO_GPIOOUTEN		0x0068
-#define SSB_CHIPCO_GPIOCTL		0x006C
-#define SSB_CHIPCO_GPIOPOL		0x0070
-#define SSB_CHIPCO_GPIOIRQ		0x0074
-#define SSB_CHIPCO_WATCHDOG		0x0080
-#define SSB_CHIPCO_GPIOTIMER		0x0088		/* LED powersave (corerev >= 16) */
-#define  SSB_CHIPCO_GPIOTIMER_OFFTIME	0x0000FFFF
-#define  SSB_CHIPCO_GPIOTIMER_OFFTIME_SHIFT	0
-#define  SSB_CHIPCO_GPIOTIMER_ONTIME	0xFFFF0000
-#define  SSB_CHIPCO_GPIOTIMER_ONTIME_SHIFT	16
-#define SSB_CHIPCO_GPIOTOUTM		0x008C		/* LED powersave (corerev >= 16) */
-#define SSB_CHIPCO_CLOCK_N		0x0090
-#define SSB_CHIPCO_CLOCK_SB		0x0094
-#define SSB_CHIPCO_CLOCK_PCI		0x0098
-#define SSB_CHIPCO_CLOCK_M2		0x009C
-#define SSB_CHIPCO_CLOCK_MIPS		0x00A0
-#define SSB_CHIPCO_CLKDIV		0x00A4		/* Rev >= 3 only */
-#define	 SSB_CHIPCO_CLKDIV_SFLASH	0x0F000000
-#define	 SSB_CHIPCO_CLKDIV_SFLASH_SHIFT	24
-#define	 SSB_CHIPCO_CLKDIV_OTP		0x000F0000
-#define	 SSB_CHIPCO_CLKDIV_OTP_SHIFT	16
-#define	 SSB_CHIPCO_CLKDIV_JTAG		0x00000F00
-#define	 SSB_CHIPCO_CLKDIV_JTAG_SHIFT	8
-#define	 SSB_CHIPCO_CLKDIV_UART		0x000000FF
-#define SSB_CHIPCO_PLLONDELAY		0x00B0		/* Rev >= 4 only */
-#define SSB_CHIPCO_FREFSELDELAY		0x00B4		/* Rev >= 4 only */
-#define SSB_CHIPCO_SLOWCLKCTL		0x00B8		/* 6 <= Rev <= 9 only */
-#define  SSB_CHIPCO_SLOWCLKCTL_SRC	0x00000007	/* slow clock source mask */
-#define	  SSB_CHIPCO_SLOWCLKCTL_SRC_LPO		0x00000000	/* source of slow clock is LPO */
-#define   SSB_CHIPCO_SLOWCLKCTL_SRC_XTAL	0x00000001	/* source of slow clock is crystal */
-#define	  SSB_CHIPCO_SLOECLKCTL_SRC_PCI		0x00000002	/* source of slow clock is PCI */
-#define  SSB_CHIPCO_SLOWCLKCTL_LPOFREQ	0x00000200	/* LPOFreqSel, 1: 160Khz, 0: 32KHz */
-#define  SSB_CHIPCO_SLOWCLKCTL_LPOPD	0x00000400	/* LPOPowerDown, 1: LPO is disabled, 0: LPO is enabled */
-#define  SSB_CHIPCO_SLOWCLKCTL_FSLOW	0x00000800	/* ForceSlowClk, 1: sb/cores running on slow clock, 0: power logic control */
-#define  SSB_CHIPCO_SLOWCLKCTL_IPLL	0x00001000	/* IgnorePllOffReq, 1/0: power logic ignores/honors PLL clock disable requests from core */
-#define  SSB_CHIPCO_SLOWCLKCTL_ENXTAL	0x00002000	/* XtalControlEn, 1/0: power logic does/doesn't disable crystal when appropriate */
-#define  SSB_CHIPCO_SLOWCLKCTL_XTALPU	0x00004000	/* XtalPU (RO), 1/0: crystal running/disabled */
-#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV	0xFFFF0000	/* ClockDivider (SlowClk = 1/(4+divisor)) */
-#define  SSB_CHIPCO_SLOWCLKCTL_CLKDIV_SHIFT	16
-#define SSB_CHIPCO_SYSCLKCTL		0x00C0		/* Rev >= 3 only */
-#define	 SSB_CHIPCO_SYSCLKCTL_IDLPEN	0x00000001	/* ILPen: Enable Idle Low Power */
-#define	 SSB_CHIPCO_SYSCLKCTL_ALPEN	0x00000002	/* ALPen: Enable Active Low Power */
-#define	 SSB_CHIPCO_SYSCLKCTL_PLLEN	0x00000004	/* ForcePLLOn */
-#define	 SSB_CHIPCO_SYSCLKCTL_FORCEALP	0x00000008	/* Force ALP (or HT if ALPen is not set */
-#define	 SSB_CHIPCO_SYSCLKCTL_FORCEHT	0x00000010	/* Force HT */
-#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV	0xFFFF0000	/* ClkDiv  (ILP = 1/(4+divisor)) */
-#define  SSB_CHIPCO_SYSCLKCTL_CLKDIV_SHIFT	16
-#define SSB_CHIPCO_CLKSTSTR		0x00C4		/* Rev >= 3 only */
-#define SSB_CHIPCO_PCMCIA_CFG		0x0100
-#define SSB_CHIPCO_PCMCIA_MEMWAIT	0x0104
-#define SSB_CHIPCO_PCMCIA_ATTRWAIT	0x0108
-#define SSB_CHIPCO_PCMCIA_IOWAIT	0x010C
-#define SSB_CHIPCO_IDE_CFG		0x0110
-#define SSB_CHIPCO_IDE_MEMWAIT		0x0114
-#define SSB_CHIPCO_IDE_ATTRWAIT		0x0118
-#define SSB_CHIPCO_IDE_IOWAIT		0x011C
-#define SSB_CHIPCO_PROG_CFG		0x0120
-#define SSB_CHIPCO_PROG_WAITCNT		0x0124
-#define SSB_CHIPCO_FLASH_CFG		0x0128
-#define SSB_CHIPCO_FLASH_WAITCNT	0x012C
-#define SSB_CHIPCO_CLKCTLST		0x01E0 /* Clock control and status (rev >= 20) */
-#define  SSB_CHIPCO_CLKCTLST_FORCEALP	0x00000001 /* Force ALP request */
-#define  SSB_CHIPCO_CLKCTLST_FORCEHT	0x00000002 /* Force HT request */
-#define  SSB_CHIPCO_CLKCTLST_FORCEILP	0x00000004 /* Force ILP request */
-#define  SSB_CHIPCO_CLKCTLST_HAVEALPREQ	0x00000008 /* ALP available request */
-#define  SSB_CHIPCO_CLKCTLST_HAVEHTREQ	0x00000010 /* HT available request */
-#define  SSB_CHIPCO_CLKCTLST_HWCROFF	0x00000020 /* Force HW clock request off */
-#define  SSB_CHIPCO_CLKCTLST_HAVEALP	0x00010000 /* ALP available */
-#define  SSB_CHIPCO_CLKCTLST_HAVEHT	0x00020000 /* HT available */
-#define  SSB_CHIPCO_CLKCTLST_4328A0_HAVEHT	0x00010000 /* 4328a0 has reversed bits */
-#define  SSB_CHIPCO_CLKCTLST_4328A0_HAVEALP	0x00020000 /* 4328a0 has reversed bits */
-#define SSB_CHIPCO_HW_WORKAROUND	0x01E4 /* Hardware workaround (rev >= 20) */
-#define SSB_CHIPCO_UART0_DATA		0x0300
-#define SSB_CHIPCO_UART0_IMR		0x0304
-#define SSB_CHIPCO_UART0_FCR		0x0308
-#define SSB_CHIPCO_UART0_LCR		0x030C
-#define SSB_CHIPCO_UART0_MCR		0x0310
-#define SSB_CHIPCO_UART0_LSR		0x0314
-#define SSB_CHIPCO_UART0_MSR		0x0318
-#define SSB_CHIPCO_UART0_SCRATCH	0x031C
-#define SSB_CHIPCO_UART1_DATA		0x0400
-#define SSB_CHIPCO_UART1_IMR		0x0404
-#define SSB_CHIPCO_UART1_FCR		0x0408
-#define SSB_CHIPCO_UART1_LCR		0x040C
-#define SSB_CHIPCO_UART1_MCR		0x0410
-#define SSB_CHIPCO_UART1_LSR		0x0414
-#define SSB_CHIPCO_UART1_MSR		0x0418
-#define SSB_CHIPCO_UART1_SCRATCH	0x041C
-/* PMU registers (rev >= 20) */
-#define SSB_CHIPCO_PMU_CTL			0x0600 /* PMU control */
-#define  SSB_CHIPCO_PMU_CTL_ILP_DIV		0xFFFF0000 /* ILP div mask */
-#define  SSB_CHIPCO_PMU_CTL_ILP_DIV_SHIFT	16
-#define  SSB_CHIPCO_PMU_CTL_PLL_UPD		0x00000400
-#define  SSB_CHIPCO_PMU_CTL_NOILPONW		0x00000200 /* No ILP on wait */
-#define  SSB_CHIPCO_PMU_CTL_HTREQEN		0x00000100 /* HT req enable */
-#define  SSB_CHIPCO_PMU_CTL_ALPREQEN		0x00000080 /* ALP req enable */
-#define  SSB_CHIPCO_PMU_CTL_XTALFREQ		0x0000007C /* Crystal freq */
-#define  SSB_CHIPCO_PMU_CTL_XTALFREQ_SHIFT	2
-#define  SSB_CHIPCO_PMU_CTL_ILPDIVEN		0x00000002 /* ILP div enable */
-#define  SSB_CHIPCO_PMU_CTL_LPOSEL		0x00000001 /* LPO sel */
-#define SSB_CHIPCO_PMU_CAP			0x0604 /* PMU capabilities */
-#define  SSB_CHIPCO_PMU_CAP_REVISION		0x000000FF /* Revision mask */
-#define SSB_CHIPCO_PMU_STAT			0x0608 /* PMU status */
-#define  SSB_CHIPCO_PMU_STAT_INTPEND		0x00000040 /* Interrupt pending */
-#define  SSB_CHIPCO_PMU_STAT_SBCLKST		0x00000030 /* Backplane clock status? */
-#define  SSB_CHIPCO_PMU_STAT_HAVEALP		0x00000008 /* ALP available */
-#define  SSB_CHIPCO_PMU_STAT_HAVEHT		0x00000004 /* HT available */
-#define  SSB_CHIPCO_PMU_STAT_RESINIT		0x00000003 /* Res init */
-#define SSB_CHIPCO_PMU_RES_STAT			0x060C /* PMU res status */
-#define SSB_CHIPCO_PMU_RES_PEND			0x0610 /* PMU res pending */
-#define SSB_CHIPCO_PMU_TIMER			0x0614 /* PMU timer */
-#define SSB_CHIPCO_PMU_MINRES_MSK		0x0618 /* PMU min res mask */
-#define SSB_CHIPCO_PMU_MAXRES_MSK		0x061C /* PMU max res mask */
-#define SSB_CHIPCO_PMU_RES_TABSEL		0x0620 /* PMU res table sel */
-#define SSB_CHIPCO_PMU_RES_DEPMSK		0x0624 /* PMU res dep mask */
-#define SSB_CHIPCO_PMU_RES_UPDNTM		0x0628 /* PMU res updown timer */
-#define SSB_CHIPCO_PMU_RES_TIMER		0x062C /* PMU res timer */
-#define SSB_CHIPCO_PMU_CLKSTRETCH		0x0630 /* PMU clockstretch */
-#define SSB_CHIPCO_PMU_WATCHDOG			0x0634 /* PMU watchdog */
-#define SSB_CHIPCO_PMU_RES_REQTS		0x0640 /* PMU res req timer sel */
-#define SSB_CHIPCO_PMU_RES_REQT			0x0644 /* PMU res req timer */
-#define SSB_CHIPCO_PMU_RES_REQM			0x0648 /* PMU res req mask */
-#define SSB_CHIPCO_CHIPCTL_ADDR			0x0650
-#define SSB_CHIPCO_CHIPCTL_DATA			0x0654
-#define SSB_CHIPCO_REGCTL_ADDR			0x0658
-#define SSB_CHIPCO_REGCTL_DATA			0x065C
-#define SSB_CHIPCO_PLLCTL_ADDR			0x0660
-#define SSB_CHIPCO_PLLCTL_DATA			0x0664
-
-
-
-/** PMU PLL registers */
-
-/* PMU rev 0 PLL registers */
-#define SSB_PMU0_PLLCTL0			0
-#define  SSB_PMU0_PLLCTL0_PDIV_MSK		0x00000001
-#define  SSB_PMU0_PLLCTL0_PDIV_FREQ		25000 /* kHz */
-#define SSB_PMU0_PLLCTL1			1
-#define  SSB_PMU0_PLLCTL1_WILD_IMSK		0xF0000000 /* Wild int mask (low nibble) */
-#define  SSB_PMU0_PLLCTL1_WILD_IMSK_SHIFT	28
-#define  SSB_PMU0_PLLCTL1_WILD_FMSK		0x0FFFFF00 /* Wild frac mask */
-#define  SSB_PMU0_PLLCTL1_WILD_FMSK_SHIFT	8
-#define  SSB_PMU0_PLLCTL1_STOPMOD		0x00000040 /* Stop mod */
-#define SSB_PMU0_PLLCTL2			2
-#define  SSB_PMU0_PLLCTL2_WILD_IMSKHI		0x0000000F /* Wild int mask (high nibble) */
-#define  SSB_PMU0_PLLCTL2_WILD_IMSKHI_SHIFT	0
-
-/* PMU rev 1 PLL registers */
-#define SSB_PMU1_PLLCTL0			0
-#define  SSB_PMU1_PLLCTL0_P1DIV			0x00F00000 /* P1 div */
-#define  SSB_PMU1_PLLCTL0_P1DIV_SHIFT		20
-#define  SSB_PMU1_PLLCTL0_P2DIV			0x0F000000 /* P2 div */
-#define  SSB_PMU1_PLLCTL0_P2DIV_SHIFT		24
-#define SSB_PMU1_PLLCTL1			1
-#define  SSB_PMU1_PLLCTL1_M1DIV			0x000000FF /* M1 div */
-#define  SSB_PMU1_PLLCTL1_M1DIV_SHIFT		0
-#define  SSB_PMU1_PLLCTL1_M2DIV			0x0000FF00 /* M2 div */
-#define  SSB_PMU1_PLLCTL1_M2DIV_SHIFT		8
-#define  SSB_PMU1_PLLCTL1_M3DIV			0x00FF0000 /* M3 div */
-#define  SSB_PMU1_PLLCTL1_M3DIV_SHIFT		16
-#define  SSB_PMU1_PLLCTL1_M4DIV			0xFF000000 /* M4 div */
-#define  SSB_PMU1_PLLCTL1_M4DIV_SHIFT		24
-#define SSB_PMU1_PLLCTL2			2
-#define  SSB_PMU1_PLLCTL2_M5DIV			0x000000FF /* M5 div */
-#define  SSB_PMU1_PLLCTL2_M5DIV_SHIFT		0
-#define  SSB_PMU1_PLLCTL2_M6DIV			0x0000FF00 /* M6 div */
-#define  SSB_PMU1_PLLCTL2_M6DIV_SHIFT		8
-#define  SSB_PMU1_PLLCTL2_NDIVMODE		0x000E0000 /* NDIV mode */
-#define  SSB_PMU1_PLLCTL2_NDIVMODE_SHIFT	17
-#define  SSB_PMU1_PLLCTL2_NDIVINT		0x1FF00000 /* NDIV int */
-#define  SSB_PMU1_PLLCTL2_NDIVINT_SHIFT		20
-#define SSB_PMU1_PLLCTL3			3
-#define  SSB_PMU1_PLLCTL3_NDIVFRAC		0x00FFFFFF /* NDIV frac */
-#define  SSB_PMU1_PLLCTL3_NDIVFRAC_SHIFT	0
-#define SSB_PMU1_PLLCTL4			4
-#define SSB_PMU1_PLLCTL5			5
-#define  SSB_PMU1_PLLCTL5_CLKDRV		0xFFFFFF00 /* clk drv */
-#define  SSB_PMU1_PLLCTL5_CLKDRV_SHIFT		8
-
-/* BCM4312 PLL resource numbers. */
-#define SSB_PMURES_4312_SWITCHER_BURST		0
-#define SSB_PMURES_4312_SWITCHER_PWM    	1
-#define SSB_PMURES_4312_PA_REF_LDO		2
-#define SSB_PMURES_4312_CORE_LDO_BURST		3
-#define SSB_PMURES_4312_CORE_LDO_PWM		4
-#define SSB_PMURES_4312_RADIO_LDO		5
-#define SSB_PMURES_4312_ILP_REQUEST		6
-#define SSB_PMURES_4312_BG_FILTBYP		7
-#define SSB_PMURES_4312_TX_FILTBYP		8
-#define SSB_PMURES_4312_RX_FILTBYP		9
-#define SSB_PMURES_4312_XTAL_PU			10
-#define SSB_PMURES_4312_ALP_AVAIL		11
-#define SSB_PMURES_4312_BB_PLL_FILTBYP		12
-#define SSB_PMURES_4312_RF_PLL_FILTBYP		13
-#define SSB_PMURES_4312_HT_AVAIL		14
-
-/* BCM4325 PLL resource numbers. */
-#define SSB_PMURES_4325_BUCK_BOOST_BURST	0
-#define SSB_PMURES_4325_CBUCK_BURST		1
-#define SSB_PMURES_4325_CBUCK_PWM		2
-#define SSB_PMURES_4325_CLDO_CBUCK_BURST	3
-#define SSB_PMURES_4325_CLDO_CBUCK_PWM		4
-#define SSB_PMURES_4325_BUCK_BOOST_PWM		5
-#define SSB_PMURES_4325_ILP_REQUEST		6
-#define SSB_PMURES_4325_ABUCK_BURST		7
-#define SSB_PMURES_4325_ABUCK_PWM		8
-#define SSB_PMURES_4325_LNLDO1_PU		9
-#define SSB_PMURES_4325_LNLDO2_PU		10
-#define SSB_PMURES_4325_LNLDO3_PU		11
-#define SSB_PMURES_4325_LNLDO4_PU		12
-#define SSB_PMURES_4325_XTAL_PU			13
-#define SSB_PMURES_4325_ALP_AVAIL		14
-#define SSB_PMURES_4325_RX_PWRSW_PU		15
-#define SSB_PMURES_4325_TX_PWRSW_PU		16
-#define SSB_PMURES_4325_RFPLL_PWRSW_PU		17
-#define SSB_PMURES_4325_LOGEN_PWRSW_PU		18
-#define SSB_PMURES_4325_AFE_PWRSW_PU		19
-#define SSB_PMURES_4325_BBPLL_PWRSW_PU		20
-#define SSB_PMURES_4325_HT_AVAIL		21
-
-/* BCM4328 PLL resource numbers. */
-#define SSB_PMURES_4328_EXT_SWITCHER_PWM	0
-#define SSB_PMURES_4328_BB_SWITCHER_PWM		1
-#define SSB_PMURES_4328_BB_SWITCHER_BURST	2
-#define SSB_PMURES_4328_BB_EXT_SWITCHER_BURST	3
-#define SSB_PMURES_4328_ILP_REQUEST		4
-#define SSB_PMURES_4328_RADIO_SWITCHER_PWM	5
-#define SSB_PMURES_4328_RADIO_SWITCHER_BURST	6
-#define SSB_PMURES_4328_ROM_SWITCH		7
-#define SSB_PMURES_4328_PA_REF_LDO		8
-#define SSB_PMURES_4328_RADIO_LDO		9
-#define SSB_PMURES_4328_AFE_LDO			10
-#define SSB_PMURES_4328_PLL_LDO			11
-#define SSB_PMURES_4328_BG_FILTBYP		12
-#define SSB_PMURES_4328_TX_FILTBYP		13
-#define SSB_PMURES_4328_RX_FILTBYP		14
-#define SSB_PMURES_4328_XTAL_PU			15
-#define SSB_PMURES_4328_XTAL_EN			16
-#define SSB_PMURES_4328_BB_PLL_FILTBYP		17
-#define SSB_PMURES_4328_RF_PLL_FILTBYP		18
-#define SSB_PMURES_4328_BB_PLL_PU		19
-
-/* BCM5354 PLL resource numbers. */
-#define SSB_PMURES_5354_EXT_SWITCHER_PWM	0
-#define SSB_PMURES_5354_BB_SWITCHER_PWM		1
-#define SSB_PMURES_5354_BB_SWITCHER_BURST	2
-#define SSB_PMURES_5354_BB_EXT_SWITCHER_BURST	3
-#define SSB_PMURES_5354_ILP_REQUEST		4
-#define SSB_PMURES_5354_RADIO_SWITCHER_PWM	5
-#define SSB_PMURES_5354_RADIO_SWITCHER_BURST	6
-#define SSB_PMURES_5354_ROM_SWITCH		7
-#define SSB_PMURES_5354_PA_REF_LDO		8
-#define SSB_PMURES_5354_RADIO_LDO		9
-#define SSB_PMURES_5354_AFE_LDO			10
-#define SSB_PMURES_5354_PLL_LDO			11
-#define SSB_PMURES_5354_BG_FILTBYP		12
-#define SSB_PMURES_5354_TX_FILTBYP		13
-#define SSB_PMURES_5354_RX_FILTBYP		14
-#define SSB_PMURES_5354_XTAL_PU			15
-#define SSB_PMURES_5354_XTAL_EN			16
-#define SSB_PMURES_5354_BB_PLL_FILTBYP		17
-#define SSB_PMURES_5354_RF_PLL_FILTBYP		18
-#define SSB_PMURES_5354_BB_PLL_PU		19
-
-
-
-/** Chip specific Chip-Status register contents. */
-#define SSB_CHIPCO_CHST_4322_SPROM_EXISTS	0x00000040 /* SPROM present */
-#define SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL	0x00000003
-#define SSB_CHIPCO_CHST_4325_DEFCIS_SEL		0 /* OTP is powered up, use def. CIS, no SPROM */
-#define SSB_CHIPCO_CHST_4325_SPROM_SEL		1 /* OTP is powered up, SPROM is present */
-#define SSB_CHIPCO_CHST_4325_OTP_SEL		2 /* OTP is powered up, no SPROM */
-#define SSB_CHIPCO_CHST_4325_OTP_PWRDN		3 /* OTP is powered down, SPROM is present */
-#define SSB_CHIPCO_CHST_4325_SDIO_USB_MODE	0x00000004
-#define SSB_CHIPCO_CHST_4325_SDIO_USB_MODE_SHIFT  2
-#define SSB_CHIPCO_CHST_4325_RCAL_VALID		0x00000008
-#define SSB_CHIPCO_CHST_4325_RCAL_VALID_SHIFT	3
-#define SSB_CHIPCO_CHST_4325_RCAL_VALUE		0x000001F0
-#define SSB_CHIPCO_CHST_4325_RCAL_VALUE_SHIFT	4
-#define SSB_CHIPCO_CHST_4325_PMUTOP_2B 		0x00000200 /* 1 for 2b, 0 for to 2a */
-
-/** Macros to determine SPROM presence based on Chip-Status register. */
-#define SSB_CHIPCO_CHST_4312_SPROM_PRESENT(status) \
-	((status & SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL) != \
-		SSB_CHIPCO_CHST_4325_OTP_SEL)
-#define SSB_CHIPCO_CHST_4322_SPROM_PRESENT(status) \
-	(status & SSB_CHIPCO_CHST_4322_SPROM_EXISTS)
-#define SSB_CHIPCO_CHST_4325_SPROM_PRESENT(status) \
-	(((status & SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL) != \
-		SSB_CHIPCO_CHST_4325_DEFCIS_SEL) && \
-	 ((status & SSB_CHIPCO_CHST_4325_SPROM_OTP_SEL) != \
-		SSB_CHIPCO_CHST_4325_OTP_SEL))
-
-
-
-/** Clockcontrol masks and values **/
-
-/* SSB_CHIPCO_CLOCK_N */
-#define	SSB_CHIPCO_CLK_N1		0x0000003F	/* n1 control */
-#define	SSB_CHIPCO_CLK_N2		0x00003F00	/* n2 control */
-#define	SSB_CHIPCO_CLK_N2_SHIFT		8
-#define	SSB_CHIPCO_CLK_PLLC		0x000F0000	/* pll control */
-#define	SSB_CHIPCO_CLK_PLLC_SHIFT	16
-
-/* SSB_CHIPCO_CLOCK_SB/PCI/UART */
-#define	SSB_CHIPCO_CLK_M1		0x0000003F	/* m1 control */
-#define	SSB_CHIPCO_CLK_M2		0x00003F00	/* m2 control */
-#define	SSB_CHIPCO_CLK_M2_SHIFT		8
-#define	SSB_CHIPCO_CLK_M3		0x003F0000	/* m3 control */
-#define	SSB_CHIPCO_CLK_M3_SHIFT		16
-#define	SSB_CHIPCO_CLK_MC		0x1F000000	/* mux control */
-#define	SSB_CHIPCO_CLK_MC_SHIFT		24
-
-/* N3M Clock control magic field values */
-#define	SSB_CHIPCO_CLK_F6_2		0x02		/* A factor of 2 in */
-#define	SSB_CHIPCO_CLK_F6_3		0x03		/* 6-bit fields like */
-#define	SSB_CHIPCO_CLK_F6_4		0x05		/* N1, M1 or M3 */
-#define	SSB_CHIPCO_CLK_F6_5		0x09
-#define	SSB_CHIPCO_CLK_F6_6		0x11
-#define	SSB_CHIPCO_CLK_F6_7		0x21
-
-#define	SSB_CHIPCO_CLK_F5_BIAS		5		/* 5-bit fields get this added */
-
-#define	SSB_CHIPCO_CLK_MC_BYPASS	0x08
-#define	SSB_CHIPCO_CLK_MC_M1		0x04
-#define	SSB_CHIPCO_CLK_MC_M1M2		0x02
-#define	SSB_CHIPCO_CLK_MC_M1M2M3	0x01
-#define	SSB_CHIPCO_CLK_MC_M1M3		0x11
-
-/* Type 2 Clock control magic field values */
-#define	SSB_CHIPCO_CLK_T2_BIAS		2		/* n1, n2, m1 & m3 bias */
-#define	SSB_CHIPCO_CLK_T2M2_BIAS	3		/* m2 bias */
-
-#define	SSB_CHIPCO_CLK_T2MC_M1BYP	1
-#define	SSB_CHIPCO_CLK_T2MC_M2BYP	2
-#define	SSB_CHIPCO_CLK_T2MC_M3BYP	4
-
-/* Type 6 Clock control magic field values */
-#define	SSB_CHIPCO_CLK_T6_MMASK		1		/* bits of interest in m */
-#define	SSB_CHIPCO_CLK_T6_M0		120000000	/* sb clock for m = 0 */
-#define	SSB_CHIPCO_CLK_T6_M1		100000000	/* sb clock for m = 1 */
-#define	SSB_CHIPCO_CLK_SB2MIPS_T6(sb)	(2 * (sb))
-
-/* Common clock base */
-#define	SSB_CHIPCO_CLK_BASE1		24000000	/* Half the clock freq */
-#define SSB_CHIPCO_CLK_BASE2		12500000	/* Alternate crystal on some PLL's */
-
-/* Clock control values for 200Mhz in 5350 */
-#define	SSB_CHIPCO_CLK_5350_N		0x0311
-#define	SSB_CHIPCO_CLK_5350_M		0x04020009
-
-
-/** Bits in the config registers **/
-
-#define	SSB_CHIPCO_CFG_EN		0x0001		/* Enable */
-#define	SSB_CHIPCO_CFG_EXTM		0x000E		/* Extif Mode */
-#define	 SSB_CHIPCO_CFG_EXTM_ASYNC	0x0002		/* Async/Parallel flash */
-#define	 SSB_CHIPCO_CFG_EXTM_SYNC	0x0004		/* Synchronous */
-#define	 SSB_CHIPCO_CFG_EXTM_PCMCIA	0x0008		/* PCMCIA */
-#define	 SSB_CHIPCO_CFG_EXTM_IDE	0x000A		/* IDE */
-#define	SSB_CHIPCO_CFG_DS16		0x0010		/* Data size, 0=8bit, 1=16bit */
-#define	SSB_CHIPCO_CFG_CLKDIV		0x0060		/* Sync: Clock divisor */
-#define	SSB_CHIPCO_CFG_CLKEN		0x0080		/* Sync: Clock enable */
-#define	SSB_CHIPCO_CFG_BSTRO		0x0100		/* Sync: Size/Bytestrobe */
-
-
-/** Flash-specific control/status values */
-
-/* flashcontrol opcodes for ST flashes */
-#define SSB_CHIPCO_FLASHCTL_ST_WREN	0x0006		/* Write Enable */
-#define SSB_CHIPCO_FLASHCTL_ST_WRDIS	0x0004		/* Write Disable */
-#define SSB_CHIPCO_FLASHCTL_ST_RDSR	0x0105		/* Read Status Register */
-#define SSB_CHIPCO_FLASHCTL_ST_WRSR	0x0101		/* Write Status Register */
-#define SSB_CHIPCO_FLASHCTL_ST_READ	0x0303		/* Read Data Bytes */
-#define SSB_CHIPCO_FLASHCTL_ST_PP	0x0302		/* Page Program */
-#define SSB_CHIPCO_FLASHCTL_ST_SE	0x02D8		/* Sector Erase */
-#define SSB_CHIPCO_FLASHCTL_ST_BE	0x00C7		/* Bulk Erase */
-#define SSB_CHIPCO_FLASHCTL_ST_DP	0x00B9		/* Deep Power-down */
-#define SSB_CHIPCO_FLASHCTL_ST_RES	0x03AB		/* Read Electronic Signature */
-#define SSB_CHIPCO_FLASHCTL_ST_CSA	0x1000		/* Keep chip select asserted */
-#define SSB_CHIPCO_FLASHCTL_ST_SSE	0x0220		/* Sub-sector Erase */
-
-/* Status register bits for ST flashes */
-#define SSB_CHIPCO_FLASHSTA_ST_WIP	0x01		/* Write In Progress */
-#define SSB_CHIPCO_FLASHSTA_ST_WEL	0x02		/* Write Enable Latch */
-#define SSB_CHIPCO_FLASHSTA_ST_BP	0x1C		/* Block Protect */
-#define SSB_CHIPCO_FLASHSTA_ST_BP_SHIFT	2
-#define SSB_CHIPCO_FLASHSTA_ST_SRWD	0x80		/* Status Register Write Disable */
-
-/* flashcontrol opcodes for Atmel flashes */
-#define SSB_CHIPCO_FLASHCTL_AT_READ		0x07E8
-#define SSB_CHIPCO_FLASHCTL_AT_PAGE_READ	0x07D2
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_READ	/* FIXME */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_READ	/* FIXME */
-#define SSB_CHIPCO_FLASHCTL_AT_STATUS		0x01D7
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRITE	0x0384
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRITE	0x0387
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_ERASE_PRGM	0x0283	/* Erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_ERASE_PRGM	0x0286	/* Erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_PROGRAM	0x0288
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_PROGRAM	0x0289
-#define SSB_CHIPCO_FLASHCTL_AT_PAGE_ERASE	0x0281
-#define SSB_CHIPCO_FLASHCTL_AT_BLOCK_ERASE	0x0250
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_WRER_PRGM	0x0382	/* Write erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_WRER_PRGM	0x0385	/* Write erase program */
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_LOAD	0x0253
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_LOAD	0x0255
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_COMPARE	0x0260
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_COMPARE	0x0261
-#define SSB_CHIPCO_FLASHCTL_AT_BUF1_REPROGRAM	0x0258
-#define SSB_CHIPCO_FLASHCTL_AT_BUF2_REPROGRAM	0x0259
-
-/* Status register bits for Atmel flashes */
-#define SSB_CHIPCO_FLASHSTA_AT_READY	0x80
-#define SSB_CHIPCO_FLASHSTA_AT_MISMATCH	0x40
-#define SSB_CHIPCO_FLASHSTA_AT_ID	0x38
-#define SSB_CHIPCO_FLASHSTA_AT_ID_SHIFT	3
-
-
-/** OTP **/
-
-/* OTP regions */
-#define	SSB_CHIPCO_OTP_HW_REGION	SSB_CHIPCO_OTPS_HW_PROTECT
-#define	SSB_CHIPCO_OTP_SW_REGION	SSB_CHIPCO_OTPS_SW_PROTECT
-#define	SSB_CHIPCO_OTP_CID_REGION	SSB_CHIPCO_OTPS_CID_PROTECT
-
-/* OTP regions (Byte offsets from otp size) */
-#define	SSB_CHIPCO_OTP_SWLIM_OFF	(-8)
-#define	SSB_CHIPCO_OTP_CIDBASE_OFF	0
-#define	SSB_CHIPCO_OTP_CIDLIM_OFF	8
-
-/* Predefined OTP words (Word offset from otp size) */
-#define	SSB_CHIPCO_OTP_BOUNDARY_OFF	(-4)
-#define	SSB_CHIPCO_OTP_HWSIGN_OFF	(-3)
-#define	SSB_CHIPCO_OTP_SWSIGN_OFF	(-2)
-#define	SSB_CHIPCO_OTP_CIDSIGN_OFF	(-1)
-
-#define	SSB_CHIPCO_OTP_CID_OFF		0
-#define	SSB_CHIPCO_OTP_PKG_OFF		1
-#define	SSB_CHIPCO_OTP_FID_OFF		2
-#define	SSB_CHIPCO_OTP_RSV_OFF		3
-#define	SSB_CHIPCO_OTP_LIM_OFF		4
-
-#define	SSB_CHIPCO_OTP_SIGNATURE	0x578A
-#define	SSB_CHIPCO_OTP_MAGIC		0x4E56
-
-
-struct ssb_device;
-struct ssb_serial_port;
-
-/* Data for the PMU, if available.
- * Check availability with ((struct ssb_chipcommon)->capabilities & SSB_CHIPCO_CAP_PMU)
- */
-struct ssb_chipcommon_pmu {
-	u8 rev;			/* PMU revision */
-	u32 crystalfreq;	/* The active crystal frequency (in kHz) */
-};
-
-struct ssb_chipcommon {
-	struct ssb_device *dev;
-	u32 capabilities;
-	u32 status;
-	/* Fast Powerup Delay constant */
-	u16 fast_pwrup_delay;
-	spinlock_t gpio_lock;
-	struct ssb_chipcommon_pmu pmu;
-	u32 ticks_per_ms;
-	u32 max_timer_ms;
-};
-
-static inline bool ssb_chipco_available(struct ssb_chipcommon *cc)
-{
-	return (cc->dev != NULL);
-}
-
-/* Register access */
-#define chipco_read32(cc, offset)	ssb_read32((cc)->dev, offset)
-#define chipco_write32(cc, offset, val)	ssb_write32((cc)->dev, offset, val)
-
-#define chipco_mask32(cc, offset, mask) \
-		chipco_write32(cc, offset, chipco_read32(cc, offset) & (mask))
-#define chipco_set32(cc, offset, set) \
-		chipco_write32(cc, offset, chipco_read32(cc, offset) | (set))
-#define chipco_maskset32(cc, offset, mask, set) \
-		chipco_write32(cc, offset, (chipco_read32(cc, offset) & (mask)) | (set))
-
-extern void ssb_chipcommon_init(struct ssb_chipcommon *cc);
-
-extern void ssb_chipco_suspend(struct ssb_chipcommon *cc);
-extern void ssb_chipco_resume(struct ssb_chipcommon *cc);
-
-extern void ssb_chipco_get_clockcpu(struct ssb_chipcommon *cc,
-                                    u32 *plltype, u32 *n, u32 *m);
-extern void ssb_chipco_get_clockcontrol(struct ssb_chipcommon *cc,
-					u32 *plltype, u32 *n, u32 *m);
-extern void ssb_chipco_timing_init(struct ssb_chipcommon *cc,
-				   unsigned long ns_per_cycle);
-
-enum ssb_clkmode {
-	SSB_CLKMODE_SLOW,
-	SSB_CLKMODE_FAST,
-	SSB_CLKMODE_DYNAMIC,
-};
-
-extern void ssb_chipco_set_clockmode(struct ssb_chipcommon *cc,
-				     enum ssb_clkmode mode);
-
-extern u32 ssb_chipco_watchdog_timer_set(struct ssb_chipcommon *cc, u32 ticks);
-
-void ssb_chipco_irq_mask(struct ssb_chipcommon *cc, u32 mask, u32 value);
-
-u32 ssb_chipco_irq_status(struct ssb_chipcommon *cc, u32 mask);
-
-/* Chipcommon GPIO pin access. */
-u32 ssb_chipco_gpio_in(struct ssb_chipcommon *cc, u32 mask);
-u32 ssb_chipco_gpio_out(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_outen(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_control(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_intmask(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_polarity(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_pullup(struct ssb_chipcommon *cc, u32 mask, u32 value);
-u32 ssb_chipco_gpio_pulldown(struct ssb_chipcommon *cc, u32 mask, u32 value);
-
-#ifdef CPTCFG_SSB_SERIAL
-extern int ssb_chipco_serial_init(struct ssb_chipcommon *cc,
-				  struct ssb_serial_port *ports);
-#endif /* CPTCFG_SSB_SERIAL */
-
-/* PMU support */
-extern void ssb_pmu_init(struct ssb_chipcommon *cc);
-
-enum ssb_pmu_ldo_volt_id {
-	LDO_PAREF = 0,
-	LDO_VOLT1,
-	LDO_VOLT2,
-	LDO_VOLT3,
-};
-
-void ssb_pmu_set_ldo_voltage(struct ssb_chipcommon *cc,
-			     enum ssb_pmu_ldo_volt_id id, u32 voltage);
-void ssb_pmu_set_ldo_paref(struct ssb_chipcommon *cc, bool on);
-void ssb_pmu_spuravoid_pllupdate(struct ssb_chipcommon *cc, int spuravoid);
-
-#endif /* LINUX_SSB_CHIPCO_H_ */
diff --git a/include/linux/ssb/ssb_driver_extif.h b/include/linux/ssb/ssb_driver_extif.h
deleted file mode 100644
index 7fcf3c0..0000000
--- a/include/linux/ssb/ssb_driver_extif.h
+++ /dev/null
@@ -1,258 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Hardware-specific External Interface I/O core definitions
- * for the BCM47xx family of SiliconBackplane-based chips.
- *
- * The External Interface core supports a total of three external chip selects
- * supporting external interfaces. One of the external chip selects is
- * used for Flash, one is used for PCMCIA, and the other may be
- * programmed to support either a synchronous interface or an
- * asynchronous interface. The asynchronous interface can be used to
- * support external devices such as UARTs and the BCM2019 Bluetooth
- * baseband processor.
- * The external interface core also contains 2 on-chip 16550 UARTs, clock
- * frequency control, a watchdog interrupt timer, and a GPIO interface.
- *
- * Copyright 2005, Broadcom Corporation
- * Copyright 2006, Michael Buesch
- */
-#ifndef LINUX_SSB_EXTIFCORE_H_
-#define LINUX_SSB_EXTIFCORE_H_
-
-/* external interface address space */
-#define	SSB_EXTIF_PCMCIA_MEMBASE(x)	(x)
-#define	SSB_EXTIF_PCMCIA_IOBASE(x)	((x) + 0x100000)
-#define	SSB_EXTIF_PCMCIA_CFGBASE(x)	((x) + 0x200000)
-#define	SSB_EXTIF_CFGIF_BASE(x)		((x) + 0x800000)
-#define	SSB_EXTIF_FLASH_BASE(x)		((x) + 0xc00000)
-
-#define SSB_EXTIF_NR_GPIOOUT		5
-/* GPIO NOTE:
- * The multiple instances of output and output enable registers
- * are present to allow driver software for multiple cores to control
- * gpio outputs without needing to share a single register pair.
- * Use the following helper macro to get a register offset value.
- */
-#define SSB_EXTIF_GPIO_OUT(index)	({		\
-	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
-	SSB_EXTIF_GPIO_OUT_BASE + ((index) * 8);	\
-					})
-#define SSB_EXTIF_GPIO_OUTEN(index)	({		\
-	BUILD_BUG_ON(index >= SSB_EXTIF_NR_GPIOOUT);	\
-	SSB_EXTIF_GPIO_OUTEN_BASE + ((index) * 8);	\
-					})
-
-/** EXTIF core registers **/
-
-#define SSB_EXTIF_CTL			0x0000
-#define  SSB_EXTIF_CTL_UARTEN		(1 << 0) /* UART enable */
-#define SSB_EXTIF_EXTSTAT		0x0004
-#define  SSB_EXTIF_EXTSTAT_EMODE	(1 << 0) /* Endian mode (ro) */
-#define  SSB_EXTIF_EXTSTAT_EIRQPIN	(1 << 1) /* External interrupt pin (ro) */
-#define  SSB_EXTIF_EXTSTAT_GPIOIRQPIN	(1 << 2) /* GPIO interrupt pin (ro) */
-#define SSB_EXTIF_PCMCIA_CFG		0x0010
-#define SSB_EXTIF_PCMCIA_MEMWAIT	0x0014
-#define SSB_EXTIF_PCMCIA_ATTRWAIT	0x0018
-#define SSB_EXTIF_PCMCIA_IOWAIT		0x001C
-#define SSB_EXTIF_PROG_CFG		0x0020
-#define SSB_EXTIF_PROG_WAITCNT		0x0024
-#define SSB_EXTIF_FLASH_CFG		0x0028
-#define SSB_EXTIF_FLASH_WAITCNT		0x002C
-#define SSB_EXTIF_WATCHDOG		0x0040
-#define SSB_EXTIF_CLOCK_N		0x0044
-#define SSB_EXTIF_CLOCK_SB		0x0048
-#define SSB_EXTIF_CLOCK_PCI		0x004C
-#define SSB_EXTIF_CLOCK_MII		0x0050
-#define SSB_EXTIF_GPIO_IN		0x0060
-#define SSB_EXTIF_GPIO_OUT_BASE		0x0064
-#define SSB_EXTIF_GPIO_OUTEN_BASE	0x0068
-#define SSB_EXTIF_EJTAG_OUTEN		0x0090
-#define SSB_EXTIF_GPIO_INTPOL		0x0094
-#define SSB_EXTIF_GPIO_INTMASK		0x0098
-#define SSB_EXTIF_UART_DATA		0x0300
-#define SSB_EXTIF_UART_TIMER		0x0310
-#define SSB_EXTIF_UART_FCR		0x0320
-#define SSB_EXTIF_UART_LCR		0x0330
-#define SSB_EXTIF_UART_MCR		0x0340
-#define SSB_EXTIF_UART_LSR		0x0350
-#define SSB_EXTIF_UART_MSR		0x0360
-#define SSB_EXTIF_UART_SCRATCH		0x0370
-
-
-
-
-/* pcmcia/prog/flash_config */
-#define	SSB_EXTCFG_EN			(1 << 0)	/* enable */
-#define	SSB_EXTCFG_MODE			0xE		/* mode */
-#define	SSB_EXTCFG_MODE_SHIFT		1
-#define	 SSB_EXTCFG_MODE_FLASH		0x0		/* flash/asynchronous mode */
-#define	 SSB_EXTCFG_MODE_SYNC		0x2		/* synchronous mode */
-#define	 SSB_EXTCFG_MODE_PCMCIA		0x4		/* pcmcia mode */
-#define	SSB_EXTCFG_DS16			(1 << 4)	/* destsize:  0=8bit, 1=16bit */
-#define	SSB_EXTCFG_BSWAP		(1 << 5)	/* byteswap */
-#define	SSB_EXTCFG_CLKDIV		0xC0		/* clock divider */
-#define	SSB_EXTCFG_CLKDIV_SHIFT		6
-#define	 SSB_EXTCFG_CLKDIV_2		0x0		/* backplane/2 */
-#define	 SSB_EXTCFG_CLKDIV_3		0x40		/* backplane/3 */
-#define	 SSB_EXTCFG_CLKDIV_4		0x80		/* backplane/4 */
-#define	SSB_EXTCFG_CLKEN		(1 << 8)	/* clock enable */
-#define	SSB_EXTCFG_STROBE		(1 << 9)	/* size/bytestrobe (synch only) */
-
-/* pcmcia_memwait */
-#define	SSB_PCMCIA_MEMW_0		0x0000003F	/* waitcount0 */
-#define	SSB_PCMCIA_MEMW_1		0x00001F00	/* waitcount1 */
-#define	SSB_PCMCIA_MEMW_1_SHIFT		8
-#define	SSB_PCMCIA_MEMW_2		0x001F0000	/* waitcount2 */
-#define	SSB_PCMCIA_MEMW_2_SHIFT		16
-#define	SSB_PCMCIA_MEMW_3		0x1F000000	/* waitcount3 */
-#define	SSB_PCMCIA_MEMW_3_SHIFT		24
-
-/* pcmcia_attrwait */
-#define	SSB_PCMCIA_ATTW_0		0x0000003F	/* waitcount0 */
-#define	SSB_PCMCIA_ATTW_1		0x00001F00	/* waitcount1 */
-#define	SSB_PCMCIA_ATTW_1_SHIFT		8
-#define	SSB_PCMCIA_ATTW_2		0x001F0000	/* waitcount2 */
-#define	SSB_PCMCIA_ATTW_2_SHIFT		16
-#define	SSB_PCMCIA_ATTW_3		0x1F000000	/* waitcount3 */
-#define	SSB_PCMCIA_ATTW_3_SHIFT		24
-
-/* pcmcia_iowait */
-#define	SSB_PCMCIA_IOW_0		0x0000003F	/* waitcount0 */
-#define	SSB_PCMCIA_IOW_1		0x00001F00	/* waitcount1 */
-#define	SSB_PCMCIA_IOW_1_SHIFT		8
-#define	SSB_PCMCIA_IOW_2		0x001F0000	/* waitcount2 */
-#define	SSB_PCMCIA_IOW_2_SHIFT		16
-#define	SSB_PCMCIA_IOW_3		0x1F000000	/* waitcount3 */
-#define	SSB_PCMCIA_IOW_3_SHIFT		24
-
-/* prog_waitcount */
-#define	SSB_PROG_WCNT_0			0x0000001F	/* waitcount0 */
-#define	SSB_PROG_WCNT_1			0x00001F00	/* waitcount1 */
-#define	SSB_PROG_WCNT_1_SHIFT		8
-#define	SSB_PROG_WCNT_2			0x001F0000	/* waitcount2 */
-#define	SSB_PROG_WCNT_2_SHIFT		16
-#define	SSB_PROG_WCNT_3			0x1F000000	/* waitcount3 */
-#define	SSB_PROG_WCNT_3_SHIFT		24
-
-#define SSB_PROG_W0			0x0000000C
-#define SSB_PROG_W1			0x00000A00
-#define SSB_PROG_W2			0x00020000
-#define SSB_PROG_W3			0x01000000
-
-/* flash_waitcount */
-#define	SSB_FLASH_WCNT_0		0x0000001F	/* waitcount0 */
-#define	SSB_FLASH_WCNT_1		0x00001F00	/* waitcount1 */
-#define	SSB_FLASH_WCNT_1_SHIFT		8
-#define	SSB_FLASH_WCNT_2		0x001F0000	/* waitcount2 */
-#define	SSB_FLASH_WCNT_2_SHIFT		16
-#define	SSB_FLASH_WCNT_3		0x1F000000	/* waitcount3 */
-#define	SSB_FLASH_WCNT_3_SHIFT		24
-
-/* watchdog */
-#define SSB_EXTIF_WATCHDOG_CLK		48000000	/* Hz */
-
-#define SSB_EXTIF_WATCHDOG_MAX_TIMER	((1 << 28) - 1)
-#define SSB_EXTIF_WATCHDOG_MAX_TIMER_MS	(SSB_EXTIF_WATCHDOG_MAX_TIMER \
-					 / (SSB_EXTIF_WATCHDOG_CLK / 1000))
-
-
-#ifdef CPTCFG_SSB_DRIVER_EXTIF
-
-struct ssb_extif {
-	struct ssb_device *dev;
-	spinlock_t gpio_lock;
-};
-
-static inline bool ssb_extif_available(struct ssb_extif *extif)
-{
-	return (extif->dev != NULL);
-}
-
-extern void ssb_extif_get_clockcontrol(struct ssb_extif *extif,
-			               u32 *plltype, u32 *n, u32 *m);
-
-extern void ssb_extif_timing_init(struct ssb_extif *extif,
-				  unsigned long ns);
-
-extern u32 ssb_extif_watchdog_timer_set(struct ssb_extif *extif, u32 ticks);
-
-/* Extif GPIO pin access */
-u32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask);
-u32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask, u32 value);
-u32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask, u32 value);
-u32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask, u32 value);
-u32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask, u32 value);
-
-#ifdef CPTCFG_SSB_SERIAL
-extern int ssb_extif_serial_init(struct ssb_extif *extif,
-				 struct ssb_serial_port *ports);
-#endif /* CPTCFG_SSB_SERIAL */
-
-
-#else /* CPTCFG_SSB_DRIVER_EXTIF */
-/* extif disabled */
-
-struct ssb_extif {
-};
-
-static inline bool ssb_extif_available(struct ssb_extif *extif)
-{
-	return false;
-}
-
-static inline
-void ssb_extif_get_clockcontrol(struct ssb_extif *extif,
-			        u32 *plltype, u32 *n, u32 *m)
-{
-}
-
-static inline
-void ssb_extif_timing_init(struct ssb_extif *extif, unsigned long ns)
-{
-}
-
-static inline
-u32 ssb_extif_watchdog_timer_set(struct ssb_extif *extif, u32 ticks)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_in(struct ssb_extif *extif, u32 mask)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_out(struct ssb_extif *extif, u32 mask,
-				     u32 value)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_outen(struct ssb_extif *extif, u32 mask,
-				       u32 value)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_polarity(struct ssb_extif *extif, u32 mask,
-					  u32 value)
-{
-	return 0;
-}
-
-static inline u32 ssb_extif_gpio_intmask(struct ssb_extif *extif, u32 mask,
-					 u32 value)
-{
-	return 0;
-}
-
-#ifdef CPTCFG_SSB_SERIAL
-static inline int ssb_extif_serial_init(struct ssb_extif *extif,
-					struct ssb_serial_port *ports)
-{
-	return 0;
-}
-#endif /* CPTCFG_SSB_SERIAL */
-
-#endif /* CPTCFG_SSB_DRIVER_EXTIF */
-#endif /* LINUX_SSB_EXTIFCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_gige.h b/include/linux/ssb/ssb_driver_gige.h
deleted file mode 100644
index e3145df..0000000
--- a/include/linux/ssb/ssb_driver_gige.h
+++ /dev/null
@@ -1,194 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_DRIVER_GIGE_H_
-#define LINUX_SSB_DRIVER_GIGE_H_
-
-#include <linux/ssb/ssb.h>
-#include <linux/bug.h>
-#include <linux/pci.h>
-#include <linux/spinlock.h>
-
-
-#ifdef CPTCFG_SSB_DRIVER_GIGE
-
-
-#define SSB_GIGE_PCIIO			0x0000 /* PCI I/O Registers (1024 bytes) */
-#define SSB_GIGE_RESERVED		0x0400 /* Reserved (1024 bytes) */
-#define SSB_GIGE_PCICFG			0x0800 /* PCI config space (256 bytes) */
-#define SSB_GIGE_SHIM_FLUSHSTAT		0x0C00 /* PCI to OCP: Flush status control (32bit) */
-#define SSB_GIGE_SHIM_FLUSHRDA		0x0C04 /* PCI to OCP: Flush read address (32bit) */
-#define SSB_GIGE_SHIM_FLUSHTO		0x0C08 /* PCI to OCP: Flush timeout counter (32bit) */
-#define SSB_GIGE_SHIM_BARRIER		0x0C0C /* PCI to OCP: Barrier register (32bit) */
-#define SSB_GIGE_SHIM_MAOCPSI		0x0C10 /* PCI to OCP: MaocpSI Control (32bit) */
-#define SSB_GIGE_SHIM_SIOCPMA		0x0C14 /* PCI to OCP: SiocpMa Control (32bit) */
-
-/* TM Status High flags */
-#define SSB_GIGE_TMSHIGH_RGMII		0x00010000 /* Have an RGMII PHY-bus */
-/* TM Status Low flags */
-#define SSB_GIGE_TMSLOW_TXBYPASS	0x00080000 /* TX bypass (no delay) */
-#define SSB_GIGE_TMSLOW_RXBYPASS	0x00100000 /* RX bypass (no delay) */
-#define SSB_GIGE_TMSLOW_DLLEN		0x01000000 /* Enable DLL controls */
-
-/* Boardflags (low) */
-#define SSB_GIGE_BFL_ROBOSWITCH		0x0010
-
-
-#define SSB_GIGE_MEM_RES_NAME		"SSB Broadcom 47xx GigE memory"
-#define SSB_GIGE_IO_RES_NAME		"SSB Broadcom 47xx GigE I/O"
-
-struct ssb_gige {
-	struct ssb_device *dev;
-
-	spinlock_t lock;
-
-	/* True, if the device has an RGMII bus.
-	 * False, if the device has a GMII bus. */
-	bool has_rgmii;
-
-	/* The PCI controller device. */
-	struct pci_controller pci_controller;
-	struct pci_ops pci_ops;
-	struct resource mem_resource;
-	struct resource io_resource;
-};
-
-/* Check whether a PCI device is a SSB Gigabit Ethernet core. */
-extern bool pdev_is_ssb_gige_core(struct pci_dev *pdev);
-
-/* Convert a pci_dev pointer to a ssb_gige pointer. */
-static inline struct ssb_gige * pdev_to_ssb_gige(struct pci_dev *pdev)
-{
-	if (!pdev_is_ssb_gige_core(pdev))
-		return NULL;
-	return container_of(pdev->bus->ops, struct ssb_gige, pci_ops);
-}
-
-/* Returns whether the PHY is connected by an RGMII bus. */
-static inline bool ssb_gige_is_rgmii(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	return (dev ? dev->has_rgmii : 0);
-}
-
-/* Returns whether we have a Roboswitch. */
-static inline bool ssb_gige_have_roboswitch(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (dev)
-		return !!(dev->dev->bus->sprom.boardflags_lo &
-			  SSB_GIGE_BFL_ROBOSWITCH);
-	return false;
-}
-
-/* Returns whether we can only do one DMA at once. */
-static inline bool ssb_gige_one_dma_at_once(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (dev)
-		return ((dev->dev->bus->chip_id == 0x4785) &&
-			(dev->dev->bus->chip_rev < 2));
-	return false;
-}
-
-/* Returns whether we must flush posted writes. */
-static inline bool ssb_gige_must_flush_posted_writes(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (dev)
-		return (dev->dev->bus->chip_id == 0x4785);
-	return false;
-}
-
-/* Get the device MAC address */
-static inline int ssb_gige_get_macaddr(struct pci_dev *pdev, u8 *macaddr)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (!dev)
-		return -ENODEV;
-
-	memcpy(macaddr, dev->dev->bus->sprom.et0mac, 6);
-	return 0;
-}
-
-/* Get the device phy address */
-static inline int ssb_gige_get_phyaddr(struct pci_dev *pdev)
-{
-	struct ssb_gige *dev = pdev_to_ssb_gige(pdev);
-	if (!dev)
-		return -ENODEV;
-
-	return dev->dev->bus->sprom.et0phyaddr;
-}
-
-extern int ssb_gige_pcibios_plat_dev_init(struct ssb_device *sdev,
-					  struct pci_dev *pdev);
-extern int ssb_gige_map_irq(struct ssb_device *sdev,
-			    const struct pci_dev *pdev);
-
-/* The GigE driver is not a standalone module, because we don't have support
- * for unregistering the driver. So we could not unload the module anyway. */
-extern int ssb_gige_init(void);
-static inline void ssb_gige_exit(void)
-{
-	/* Currently we can not unregister the GigE driver,
-	 * because we can not unregister the PCI bridge. */
-	BUG();
-}
-
-
-#else /* CPTCFG_SSB_DRIVER_GIGE */
-/* Gigabit Ethernet driver disabled */
-
-
-static inline int ssb_gige_pcibios_plat_dev_init(struct ssb_device *sdev,
-						 struct pci_dev *pdev)
-{
-	return -ENOSYS;
-}
-static inline int ssb_gige_map_irq(struct ssb_device *sdev,
-				   const struct pci_dev *pdev)
-{
-	return -ENOSYS;
-}
-static inline int ssb_gige_init(void)
-{
-	return 0;
-}
-static inline void ssb_gige_exit(void)
-{
-}
-
-static inline bool pdev_is_ssb_gige_core(struct pci_dev *pdev)
-{
-	return false;
-}
-static inline struct ssb_gige * pdev_to_ssb_gige(struct pci_dev *pdev)
-{
-	return NULL;
-}
-static inline bool ssb_gige_is_rgmii(struct pci_dev *pdev)
-{
-	return false;
-}
-static inline bool ssb_gige_have_roboswitch(struct pci_dev *pdev)
-{
-	return false;
-}
-static inline bool ssb_gige_one_dma_at_once(struct pci_dev *pdev)
-{
-	return false;
-}
-static inline bool ssb_gige_must_flush_posted_writes(struct pci_dev *pdev)
-{
-	return false;
-}
-static inline int ssb_gige_get_macaddr(struct pci_dev *pdev, u8 *macaddr)
-{
-	return -ENODEV;
-}
-static inline int ssb_gige_get_phyaddr(struct pci_dev *pdev)
-{
-	return -ENODEV;
-}
-
-#endif /* CPTCFG_SSB_DRIVER_GIGE */
-#endif /* LINUX_SSB_DRIVER_GIGE_H_ */
diff --git a/include/linux/ssb/ssb_driver_mips.h b/include/linux/ssb/ssb_driver_mips.h
deleted file mode 100644
index f4d3ef3..0000000
--- a/include/linux/ssb/ssb_driver_mips.h
+++ /dev/null
@@ -1,71 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_MIPSCORE_H_
-#define LINUX_SSB_MIPSCORE_H_
-
-#ifdef CPTCFG_SSB_DRIVER_MIPS
-
-struct ssb_device;
-
-struct ssb_serial_port {
-	void *regs;
-	unsigned long clockspeed;
-	unsigned int irq;
-	unsigned int baud_base;
-	unsigned int reg_shift;
-};
-
-struct ssb_pflash {
-	bool present;
-	u8 buswidth;
-	u32 window;
-	u32 window_size;
-};
-
-#ifdef CPTCFG_SSB_SFLASH
-struct ssb_sflash {
-	bool present;
-	u32 window;
-	u32 blocksize;
-	u16 numblocks;
-	u32 size;
-
-	void *priv;
-};
-#endif
-
-struct ssb_mipscore {
-	struct ssb_device *dev;
-
-	int nr_serial_ports;
-	struct ssb_serial_port serial_ports[4];
-
-	struct ssb_pflash pflash;
-#ifdef CPTCFG_SSB_SFLASH
-	struct ssb_sflash sflash;
-#endif
-};
-
-extern void ssb_mipscore_init(struct ssb_mipscore *mcore);
-extern u32 ssb_cpu_clock(struct ssb_mipscore *mcore);
-
-extern unsigned int ssb_mips_irq(struct ssb_device *dev);
-
-
-#else /* CPTCFG_SSB_DRIVER_MIPS */
-
-struct ssb_mipscore {
-};
-
-static inline
-void ssb_mipscore_init(struct ssb_mipscore *mcore)
-{
-}
-
-static inline unsigned int ssb_mips_irq(struct ssb_device *dev)
-{
-	return 0;
-}
-
-#endif /* CPTCFG_SSB_DRIVER_MIPS */
-
-#endif /* LINUX_SSB_MIPSCORE_H_ */
diff --git a/include/linux/ssb/ssb_driver_pci.h b/include/linux/ssb/ssb_driver_pci.h
deleted file mode 100644
index 90a1dda..0000000
--- a/include/linux/ssb/ssb_driver_pci.h
+++ /dev/null
@@ -1,131 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_PCICORE_H_
-#define LINUX_SSB_PCICORE_H_
-
-#include <linux/types.h>
-
-struct pci_dev;
-
-
-#ifdef CPTCFG_SSB_DRIVER_PCICORE
-
-/* PCI core registers. */
-#define SSB_PCICORE_CTL			0x0000	/* PCI Control */
-#define  SSB_PCICORE_CTL_RST_OE		0x00000001 /* PCI_RESET Output Enable */
-#define  SSB_PCICORE_CTL_RST		0x00000002 /* PCI_RESET driven out to pin */
-#define  SSB_PCICORE_CTL_CLK_OE		0x00000004 /* Clock gate Output Enable */
-#define  SSB_PCICORE_CTL_CLK		0x00000008 /* Gate for clock driven out to pin */
-#define SSB_PCICORE_ARBCTL		0x0010	/* PCI Arbiter Control */
-#define  SSB_PCICORE_ARBCTL_INTERN	0x00000001 /* Use internal arbiter */
-#define  SSB_PCICORE_ARBCTL_EXTERN	0x00000002 /* Use external arbiter */
-#define  SSB_PCICORE_ARBCTL_PARKID	0x00000006 /* Mask, selects which agent is parked on an idle bus */
-#define   SSB_PCICORE_ARBCTL_PARKID_LAST	0x00000000 /* Last requestor */
-#define   SSB_PCICORE_ARBCTL_PARKID_4710	0x00000002 /* 4710 */
-#define   SSB_PCICORE_ARBCTL_PARKID_EXT0	0x00000004 /* External requestor 0 */
-#define   SSB_PCICORE_ARBCTL_PARKID_EXT1	0x00000006 /* External requestor 1 */
-#define SSB_PCICORE_ISTAT		0x0020	/* Interrupt status */
-#define  SSB_PCICORE_ISTAT_INTA		0x00000001 /* PCI INTA# */
-#define  SSB_PCICORE_ISTAT_INTB		0x00000002 /* PCI INTB# */
-#define  SSB_PCICORE_ISTAT_SERR		0x00000004 /* PCI SERR# (write to clear) */
-#define  SSB_PCICORE_ISTAT_PERR		0x00000008 /* PCI PERR# (write to clear) */
-#define  SSB_PCICORE_ISTAT_PME		0x00000010 /* PCI PME# */
-#define SSB_PCICORE_IMASK		0x0024	/* Interrupt mask */
-#define  SSB_PCICORE_IMASK_INTA		0x00000001 /* PCI INTA# */
-#define  SSB_PCICORE_IMASK_INTB		0x00000002 /* PCI INTB# */
-#define  SSB_PCICORE_IMASK_SERR		0x00000004 /* PCI SERR# */
-#define  SSB_PCICORE_IMASK_PERR		0x00000008 /* PCI PERR# */
-#define  SSB_PCICORE_IMASK_PME		0x00000010 /* PCI PME# */
-#define SSB_PCICORE_MBOX		0x0028	/* Backplane to PCI Mailbox */
-#define  SSB_PCICORE_MBOX_F0_0		0x00000100 /* PCI function 0, INT 0 */
-#define  SSB_PCICORE_MBOX_F0_1		0x00000200 /* PCI function 0, INT 1 */
-#define  SSB_PCICORE_MBOX_F1_0		0x00000400 /* PCI function 1, INT 0 */
-#define  SSB_PCICORE_MBOX_F1_1		0x00000800 /* PCI function 1, INT 1 */
-#define  SSB_PCICORE_MBOX_F2_0		0x00001000 /* PCI function 2, INT 0 */
-#define  SSB_PCICORE_MBOX_F2_1		0x00002000 /* PCI function 2, INT 1 */
-#define  SSB_PCICORE_MBOX_F3_0		0x00004000 /* PCI function 3, INT 0 */
-#define  SSB_PCICORE_MBOX_F3_1		0x00008000 /* PCI function 3, INT 1 */
-#define SSB_PCICORE_BCAST_ADDR		0x0050	/* Backplane Broadcast Address */
-#define  SSB_PCICORE_BCAST_ADDR_MASK	0x000000FF
-#define SSB_PCICORE_BCAST_DATA		0x0054	/* Backplane Broadcast Data */
-#define SSB_PCICORE_GPIO_IN		0x0060	/* rev >= 2 only */
-#define SSB_PCICORE_GPIO_OUT		0x0064	/* rev >= 2 only */
-#define SSB_PCICORE_GPIO_ENABLE		0x0068	/* rev >= 2 only */
-#define SSB_PCICORE_GPIO_CTL		0x006C	/* rev >= 2 only */
-#define SSB_PCICORE_SBTOPCI0		0x0100	/* Backplane to PCI translation 0 (sbtopci0) */
-#define  SSB_PCICORE_SBTOPCI0_MASK	0xFC000000
-#define SSB_PCICORE_SBTOPCI1		0x0104	/* Backplane to PCI translation 1 (sbtopci1) */
-#define  SSB_PCICORE_SBTOPCI1_MASK	0xFC000000
-#define SSB_PCICORE_SBTOPCI2		0x0108	/* Backplane to PCI translation 2 (sbtopci2) */
-#define  SSB_PCICORE_SBTOPCI2_MASK	0xC0000000
-#define SSB_PCICORE_PCICFG0		0x0400	/* PCI config space 0 (rev >= 8) */
-#define SSB_PCICORE_PCICFG1		0x0500	/* PCI config space 1 (rev >= 8) */
-#define SSB_PCICORE_PCICFG2		0x0600	/* PCI config space 2 (rev >= 8) */
-#define SSB_PCICORE_PCICFG3		0x0700	/* PCI config space 3 (rev >= 8) */
-#define SSB_PCICORE_SPROM(wordoffset)	(0x0800 + ((wordoffset) * 2)) /* SPROM shadow area (72 bytes) */
-
-/* SBtoPCIx */
-#define SSB_PCICORE_SBTOPCI_MEM		0x00000000
-#define SSB_PCICORE_SBTOPCI_IO		0x00000001
-#define SSB_PCICORE_SBTOPCI_CFG0	0x00000002
-#define SSB_PCICORE_SBTOPCI_CFG1	0x00000003
-#define SSB_PCICORE_SBTOPCI_PREF	0x00000004 /* Prefetch enable */
-#define SSB_PCICORE_SBTOPCI_BURST	0x00000008 /* Burst enable */
-#define SSB_PCICORE_SBTOPCI_MRM		0x00000020 /* Memory Read Multiple */
-#define SSB_PCICORE_SBTOPCI_RC		0x00000030 /* Read Command mask (rev >= 11) */
-#define  SSB_PCICORE_SBTOPCI_RC_READ	0x00000000 /* Memory read */
-#define  SSB_PCICORE_SBTOPCI_RC_READL	0x00000010 /* Memory read line */
-#define  SSB_PCICORE_SBTOPCI_RC_READM	0x00000020 /* Memory read multiple */
-
-
-/* PCIcore specific boardflags */
-#define SSB_PCICORE_BFL_NOPCI		0x00000400 /* Board leaves PCI floating */
-
-
-struct ssb_pcicore {
-	struct ssb_device *dev;
-	u8 setup_done:1;
-	u8 hostmode:1;
-	u8 cardbusmode:1;
-};
-
-extern void ssb_pcicore_init(struct ssb_pcicore *pc);
-
-/* Enable IRQ routing for a specific device */
-extern int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
-					  struct ssb_device *dev);
-
-int ssb_pcicore_plat_dev_init(struct pci_dev *d);
-int ssb_pcicore_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin);
-
-
-#else /* CPTCFG_SSB_DRIVER_PCICORE */
-
-
-struct ssb_pcicore {
-};
-
-static inline
-void ssb_pcicore_init(struct ssb_pcicore *pc)
-{
-}
-
-static inline
-int ssb_pcicore_dev_irqvecs_enable(struct ssb_pcicore *pc,
-				   struct ssb_device *dev)
-{
-	return 0;
-}
-
-static inline
-int ssb_pcicore_plat_dev_init(struct pci_dev *d)
-{
-	return -ENODEV;
-}
-static inline
-int ssb_pcicore_pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
-{
-	return -ENODEV;
-}
-
-#endif /* CPTCFG_SSB_DRIVER_PCICORE */
-#endif /* LINUX_SSB_PCICORE_H_ */
diff --git a/include/linux/ssb/ssb_embedded.h b/include/linux/ssb/ssb_embedded.h
deleted file mode 100644
index 49604ac..0000000
--- a/include/linux/ssb/ssb_embedded.h
+++ /dev/null
@@ -1,19 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_EMBEDDED_H_
-#define LINUX_SSB_EMBEDDED_H_
-
-#include <linux/types.h>
-#include <linux/ssb/ssb.h>
-
-
-extern int ssb_watchdog_timer_set(struct ssb_bus *bus, u32 ticks);
-
-/* Generic GPIO API */
-u32 ssb_gpio_in(struct ssb_bus *bus, u32 mask);
-u32 ssb_gpio_out(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_outen(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_control(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_intmask(struct ssb_bus *bus, u32 mask, u32 value);
-u32 ssb_gpio_polarity(struct ssb_bus *bus, u32 mask, u32 value);
-
-#endif /* LINUX_SSB_EMBEDDED_H_ */
diff --git a/include/linux/ssb/ssb_regs.h b/include/linux/ssb/ssb_regs.h
deleted file mode 100644
index 210f464..0000000
--- a/include/linux/ssb/ssb_regs.h
+++ /dev/null
@@ -1,687 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-#ifndef LINUX_SSB_REGS_H_
-#define LINUX_SSB_REGS_H_
-
-
-/* SiliconBackplane Address Map.
- * All regions may not exist on all chips.
- */
-#define SSB_SDRAM_BASE		0x00000000U	/* Physical SDRAM */
-#define SSB_PCI_MEM		0x08000000U	/* Host Mode sb2pcitranslation0 (64 MB) */
-#define SSB_PCI_CFG		0x0c000000U	/* Host Mode sb2pcitranslation1 (64 MB) */
-#define	SSB_SDRAM_SWAPPED	0x10000000U	/* Byteswapped Physical SDRAM */
-#define SSB_ENUM_BASE    	0x18000000U	/* Enumeration space base */
-#define	SSB_ENUM_LIMIT		0x18010000U	/* Enumeration space limit */
-
-#define	SSB_FLASH2		0x1c000000U	/* Flash Region 2 (region 1 shadowed here) */
-#define	SSB_FLASH2_SZ		0x02000000U	/* Size of Flash Region 2 */
-
-#define	SSB_EXTIF_BASE		0x1f000000U	/* External Interface region base address */
-#define	SSB_FLASH1		0x1fc00000U	/* Flash Region 1 */
-#define	SSB_FLASH1_SZ		0x00400000U	/* Size of Flash Region 1 */
-
-#define SSB_PCI_DMA		0x40000000U	/* Client Mode sb2pcitranslation2 (1 GB) */
-#define SSB_PCI_DMA_SZ		0x40000000U	/* Client Mode sb2pcitranslation2 size in bytes */
-#define SSB_PCIE_DMA_L32	0x00000000U	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), low 32 bits */
-#define SSB_PCIE_DMA_H32	0x80000000U	/* PCIE Client Mode sb2pcitranslation2 (2 ZettaBytes), high 32 bits */
-#define	SSB_EUART		(SSB_EXTIF_BASE + 0x00800000)
-#define	SSB_LED			(SSB_EXTIF_BASE + 0x00900000)
-
-
-/* Enumeration space constants */
-#define SSB_CORE_SIZE		0x1000	/* Size of a core MMIO area */
-#define SSB_MAX_NR_CORES	((SSB_ENUM_LIMIT - SSB_ENUM_BASE) / SSB_CORE_SIZE)
-
-
-/* mips address */
-#define	SSB_EJTAG		0xff200000	/* MIPS EJTAG space (2M) */
-
-
-/* SSB PCI config space registers. */
-#define SSB_PMCSR		0x44
-#define  SSB_PE			0x100
-#define	SSB_BAR0_WIN		0x80	/* Backplane address space 0 */
-#define	SSB_BAR1_WIN		0x84	/* Backplane address space 1 */
-#define	SSB_SPROMCTL		0x88	/* SPROM control */
-#define  SSB_SPROMCTL_WE	0x10	/* SPROM write enable */
-#define	SSB_BAR1_CONTROL	0x8c	/* Address space 1 burst control */
-#define SSB_PCI_IRQS		0x90	/* PCI interrupts */
-#define SSB_PCI_IRQMASK		0x94	/* PCI IRQ control and mask (pcirev >= 6 only) */
-#define SSB_BACKPLANE_IRQS	0x98	/* Backplane Interrupts */
-#define SSB_GPIO_IN		0xB0	/* GPIO Input (pcirev >= 3 only) */
-#define SSB_GPIO_OUT		0xB4	/* GPIO Output (pcirev >= 3 only) */
-#define SSB_GPIO_OUT_ENABLE	0xB8	/* GPIO Output Enable/Disable (pcirev >= 3 only) */
-#define  SSB_GPIO_SCS		0x10	/* PCI config space bit 4 for 4306c0 slow clock source */
-#define  SSB_GPIO_HWRAD		0x20	/* PCI config space GPIO 13 for hw radio disable */
-#define  SSB_GPIO_XTAL		0x40	/* PCI config space GPIO 14 for Xtal powerup */
-#define  SSB_GPIO_PLL		0x80	/* PCI config space GPIO 15 for PLL powerdown */
-
-
-#define SSB_BAR0_MAX_RETRIES	50
-
-/* Silicon backplane configuration register definitions */
-#define SSB_IPSFLAG		0x0F08
-#define	 SSB_IPSFLAG_IRQ1	0x0000003F /* which sbflags get routed to mips interrupt 1 */
-#define	 SSB_IPSFLAG_IRQ1_SHIFT	0
-#define	 SSB_IPSFLAG_IRQ2	0x00003F00 /* which sbflags get routed to mips interrupt 2 */
-#define	 SSB_IPSFLAG_IRQ2_SHIFT	8
-#define	 SSB_IPSFLAG_IRQ3	0x003F0000 /* which sbflags get routed to mips interrupt 3 */
-#define	 SSB_IPSFLAG_IRQ3_SHIFT	16
-#define	 SSB_IPSFLAG_IRQ4	0x3F000000 /* which sbflags get routed to mips interrupt 4 */
-#define	 SSB_IPSFLAG_IRQ4_SHIFT	24
-#define SSB_TPSFLAG		0x0F18
-#define  SSB_TPSFLAG_BPFLAG	0x0000003F /* Backplane flag # */
-#define  SSB_TPSFLAG_ALWAYSIRQ	0x00000040 /* IRQ is always sent on the Backplane */
-#define SSB_TMERRLOGA		0x0F48
-#define SSB_TMERRLOG		0x0F50
-#define SSB_ADMATCH3		0x0F60
-#define SSB_ADMATCH2		0x0F68
-#define SSB_ADMATCH1		0x0F70
-#define SSB_IMSTATE		0x0F90     /* SB Initiator Agent State */
-#define  SSB_IMSTATE_PC		0x0000000f /* Pipe Count */
-#define  SSB_IMSTATE_AP_MASK	0x00000030 /* Arbitration Priority */
-#define  SSB_IMSTATE_AP_BOTH	0x00000000 /* Use both timeslices and token */
-#define  SSB_IMSTATE_AP_TS	0x00000010 /* Use timeslices only */
-#define  SSB_IMSTATE_AP_TK	0x00000020 /* Use token only */
-#define  SSB_IMSTATE_AP_RSV	0x00000030 /* Reserved */
-#define  SSB_IMSTATE_IBE	0x00020000 /* In Band Error */
-#define  SSB_IMSTATE_TO		0x00040000 /* Timeout */
-#define  SSB_IMSTATE_BUSY	0x01800000 /* Busy (Backplane rev >= 2.3 only) */
-#define  SSB_IMSTATE_REJECT	0x02000000 /* Reject (Backplane rev >= 2.3 only) */
-#define SSB_INTVEC		0x0F94     /* SB Interrupt Mask */
-#define  SSB_INTVEC_PCI		0x00000001 /* Enable interrupts for PCI */
-#define  SSB_INTVEC_ENET0	0x00000002 /* Enable interrupts for enet 0 */
-#define  SSB_INTVEC_ILINE20	0x00000004 /* Enable interrupts for iline20 */
-#define  SSB_INTVEC_CODEC	0x00000008 /* Enable interrupts for v90 codec */
-#define  SSB_INTVEC_USB		0x00000010 /* Enable interrupts for usb */
-#define  SSB_INTVEC_EXTIF	0x00000020 /* Enable interrupts for external i/f */
-#define  SSB_INTVEC_ENET1	0x00000040 /* Enable interrupts for enet 1 */
-#define SSB_TMSLOW		0x0F98     /* SB Target State Low */
-#define  SSB_TMSLOW_RESET	0x00000001 /* Reset */
-#define  SSB_TMSLOW_REJECT	0x00000002 /* Reject (Standard Backplane) */
-#define  SSB_TMSLOW_REJECT_23	0x00000004 /* Reject (Backplane rev 2.3) */
-#define  SSB_TMSLOW_CLOCK	0x00010000 /* Clock Enable */
-#define  SSB_TMSLOW_FGC		0x00020000 /* Force Gated Clocks On */
-#define  SSB_TMSLOW_PE		0x40000000 /* Power Management Enable */
-#define  SSB_TMSLOW_BE		0x80000000 /* BIST Enable */
-#define SSB_TMSHIGH		0x0F9C     /* SB Target State High */
-#define  SSB_TMSHIGH_SERR	0x00000001 /* S-error */
-#define  SSB_TMSHIGH_INT	0x00000002 /* Interrupt */
-#define  SSB_TMSHIGH_BUSY	0x00000004 /* Busy */
-#define  SSB_TMSHIGH_TO		0x00000020 /* Timeout. Backplane rev >= 2.3 only */
-#define  SSB_TMSHIGH_COREFL	0x1FFF0000 /* Core specific flags */
-#define  SSB_TMSHIGH_COREFL_SHIFT	16
-#define  SSB_TMSHIGH_DMA64	0x10000000 /* 64bit DMA supported */
-#define  SSB_TMSHIGH_GCR	0x20000000 /* Gated Clock Request */
-#define  SSB_TMSHIGH_BISTF	0x40000000 /* BIST Failed */
-#define  SSB_TMSHIGH_BISTD	0x80000000 /* BIST Done */
-#define SSB_BWA0		0x0FA0
-#define SSB_IMCFGLO		0x0FA8
-#define  SSB_IMCFGLO_SERTO	0x00000007 /* Service timeout */
-#define  SSB_IMCFGLO_REQTO	0x00000070 /* Request timeout */
-#define  SSB_IMCFGLO_REQTO_SHIFT	4
-#define  SSB_IMCFGLO_CONNID	0x00FF0000 /* Connection ID */
-#define  SSB_IMCFGLO_CONNID_SHIFT	16
-#define SSB_IMCFGHI		0x0FAC
-#define SSB_ADMATCH0		0x0FB0
-#define SSB_TMCFGLO		0x0FB8
-#define SSB_TMCFGHI		0x0FBC
-#define SSB_BCONFIG		0x0FC0
-#define SSB_BSTATE		0x0FC8
-#define SSB_ACTCFG		0x0FD8
-#define SSB_FLAGST		0x0FE8
-#define SSB_IDLOW		0x0FF8
-#define  SSB_IDLOW_CFGSP	0x00000003 /* Config Space */
-#define  SSB_IDLOW_ADDRNGE	0x00000038 /* Address Ranges supported */
-#define  SSB_IDLOW_ADDRNGE_SHIFT	3
-#define  SSB_IDLOW_SYNC		0x00000040
-#define  SSB_IDLOW_INITIATOR	0x00000080
-#define  SSB_IDLOW_MIBL		0x00000F00 /* Minimum Backplane latency */
-#define  SSB_IDLOW_MIBL_SHIFT	8
-#define  SSB_IDLOW_MABL		0x0000F000 /* Maximum Backplane latency */
-#define  SSB_IDLOW_MABL_SHIFT	12
-#define  SSB_IDLOW_TIF		0x00010000 /* This Initiator is first */
-#define  SSB_IDLOW_CCW		0x000C0000 /* Cycle counter width */
-#define  SSB_IDLOW_CCW_SHIFT	18
-#define  SSB_IDLOW_TPT		0x00F00000 /* Target ports */
-#define  SSB_IDLOW_TPT_SHIFT	20
-#define  SSB_IDLOW_INITP	0x0F000000 /* Initiator ports */
-#define  SSB_IDLOW_INITP_SHIFT	24
-#define  SSB_IDLOW_SSBREV	0xF0000000 /* Sonics Backplane Revision code */
-#define  SSB_IDLOW_SSBREV_22	0x00000000 /* <= 2.2 */
-#define  SSB_IDLOW_SSBREV_23	0x10000000 /* 2.3 */
-#define  SSB_IDLOW_SSBREV_24	0x40000000 /* ?? Found in BCM4328 */
-#define  SSB_IDLOW_SSBREV_25	0x50000000 /* ?? Not Found yet */
-#define  SSB_IDLOW_SSBREV_26	0x60000000 /* ?? Found in some BCM4311/2 */
-#define  SSB_IDLOW_SSBREV_27	0x70000000 /* ?? Found in some BCM4311/2 */
-#define SSB_IDHIGH		0x0FFC     /* SB Identification High */
-#define  SSB_IDHIGH_RCLO	0x0000000F /* Revision Code (low part) */
-#define  SSB_IDHIGH_CC		0x00008FF0 /* Core Code */
-#define  SSB_IDHIGH_CC_SHIFT	4
-#define  SSB_IDHIGH_RCHI	0x00007000 /* Revision Code (high part) */
-#define  SSB_IDHIGH_RCHI_SHIFT	8	   /* yes, shift 8 is right */
-#define  SSB_IDHIGH_VC		0xFFFF0000 /* Vendor Code */
-#define  SSB_IDHIGH_VC_SHIFT	16
-
-/* SPROM shadow area. If not otherwise noted, fields are
- * two bytes wide. Note that the SPROM can _only_ be read
- * in two-byte quantities.
- */
-#define SSB_SPROMSIZE_WORDS		64
-#define SSB_SPROMSIZE_BYTES		(SSB_SPROMSIZE_WORDS * sizeof(u16))
-#define SSB_SPROMSIZE_WORDS_R123	64
-#define SSB_SPROMSIZE_WORDS_R4		220
-#define SSB_SPROMSIZE_BYTES_R123	(SSB_SPROMSIZE_WORDS_R123 * sizeof(u16))
-#define SSB_SPROMSIZE_BYTES_R4		(SSB_SPROMSIZE_WORDS_R4 * sizeof(u16))
-#define SSB_SPROMSIZE_WORDS_R10		230
-#define SSB_SPROMSIZE_WORDS_R11		234
-#define SSB_SPROM_BASE1			0x1000
-#define SSB_SPROM_BASE31		0x0800
-#define SSB_SPROM_REVISION		0x007E
-#define  SSB_SPROM_REVISION_REV		0x00FF	/* SPROM Revision number */
-#define  SSB_SPROM_REVISION_CRC		0xFF00	/* SPROM CRC8 value */
-#define  SSB_SPROM_REVISION_CRC_SHIFT	8
-
-/* SPROM Revision 1 */
-#define SSB_SPROM1_SPID			0x0004	/* Subsystem Product ID for PCI */
-#define SSB_SPROM1_SVID			0x0006	/* Subsystem Vendor ID for PCI */
-#define SSB_SPROM1_PID			0x0008	/* Product ID for PCI */
-#define SSB_SPROM1_IL0MAC		0x0048	/* 6 bytes MAC address for 802.11b/g */
-#define SSB_SPROM1_ET0MAC		0x004E	/* 6 bytes MAC address for Ethernet */
-#define SSB_SPROM1_ET1MAC		0x0054	/* 6 bytes MAC address for 802.11a */
-#define SSB_SPROM1_ETHPHY		0x005A	/* Ethernet PHY settings */
-#define  SSB_SPROM1_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
-#define  SSB_SPROM1_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
-#define  SSB_SPROM1_ETHPHY_ET1A_SHIFT	5
-#define  SSB_SPROM1_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
-#define  SSB_SPROM1_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
-#define SSB_SPROM1_BINF			0x005C	/* Board info */
-#define  SSB_SPROM1_BINF_BREV		0x00FF	/* Board Revision */
-#define  SSB_SPROM1_BINF_CCODE		0x0F00	/* Country Code */
-#define  SSB_SPROM1_BINF_CCODE_SHIFT	8
-#define  SSB_SPROM1_BINF_ANTBG		0x3000	/* Available B-PHY and G-PHY antennas */
-#define  SSB_SPROM1_BINF_ANTBG_SHIFT	12
-#define  SSB_SPROM1_BINF_ANTA		0xC000	/* Available A-PHY antennas */
-#define  SSB_SPROM1_BINF_ANTA_SHIFT	14
-#define SSB_SPROM1_PA0B0		0x005E
-#define SSB_SPROM1_PA0B1		0x0060
-#define SSB_SPROM1_PA0B2		0x0062
-#define SSB_SPROM1_GPIOA		0x0064	/* General Purpose IO pins 0 and 1 */
-#define  SSB_SPROM1_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM1_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM1_GPIOA_P1_SHIFT	8
-#define SSB_SPROM1_GPIOB		0x0066	/* General Purpuse IO pins 2 and 3 */
-#define  SSB_SPROM1_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM1_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM1_GPIOB_P3_SHIFT	8
-#define SSB_SPROM1_MAXPWR		0x0068	/* Power Amplifier Max Power */
-#define  SSB_SPROM1_MAXPWR_BG		0x00FF	/* B-PHY and G-PHY (in dBm Q5.2) */
-#define  SSB_SPROM1_MAXPWR_A		0xFF00	/* A-PHY (in dBm Q5.2) */
-#define  SSB_SPROM1_MAXPWR_A_SHIFT	8
-#define SSB_SPROM1_PA1B0		0x006A
-#define SSB_SPROM1_PA1B1		0x006C
-#define SSB_SPROM1_PA1B2		0x006E
-#define SSB_SPROM1_ITSSI		0x0070	/* Idle TSSI Target */
-#define  SSB_SPROM1_ITSSI_BG		0x00FF	/* B-PHY and G-PHY*/
-#define  SSB_SPROM1_ITSSI_A		0xFF00	/* A-PHY */
-#define  SSB_SPROM1_ITSSI_A_SHIFT	8
-#define SSB_SPROM1_BFLLO		0x0072	/* Boardflags (low 16 bits) */
-#define SSB_SPROM1_AGAIN		0x0074	/* Antenna Gain (in dBm Q5.2) */
-#define  SSB_SPROM1_AGAIN_BG		0x00FF	/* B-PHY and G-PHY */
-#define  SSB_SPROM1_AGAIN_BG_SHIFT	0
-#define  SSB_SPROM1_AGAIN_A		0xFF00	/* A-PHY */
-#define  SSB_SPROM1_AGAIN_A_SHIFT	8
-#define SSB_SPROM1_CCODE		0x0076
-
-/* SPROM Revision 2 (inherits from rev 1) */
-#define SSB_SPROM2_BFLHI		0x0038	/* Boardflags (high 16 bits) */
-#define SSB_SPROM2_MAXP_A		0x003A	/* A-PHY Max Power */
-#define  SSB_SPROM2_MAXP_A_HI		0x00FF	/* Max Power High */
-#define  SSB_SPROM2_MAXP_A_LO		0xFF00	/* Max Power Low */
-#define  SSB_SPROM2_MAXP_A_LO_SHIFT	8
-#define SSB_SPROM2_PA1LOB0		0x003C	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1LOB1		0x003E	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1LOB2		0x0040	/* A-PHY PowerAmplifier Low Settings */
-#define SSB_SPROM2_PA1HIB0		0x0042	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_PA1HIB1		0x0044	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_PA1HIB2		0x0046	/* A-PHY PowerAmplifier High Settings */
-#define SSB_SPROM2_OPO			0x0078	/* OFDM Power Offset from CCK Level */
-#define  SSB_SPROM2_OPO_VALUE		0x00FF
-#define  SSB_SPROM2_OPO_UNUSED		0xFF00
-#define SSB_SPROM2_CCODE		0x007C	/* Two char Country Code */
-
-/* SPROM Revision 3 (inherits most data from rev 2) */
-#define SSB_SPROM3_OFDMAPO		0x002C	/* A-PHY OFDM Mid Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_OFDMALPO		0x0030	/* A-PHY OFDM Low Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_OFDMAHPO		0x0034	/* A-PHY OFDM High Power Offset (4 bytes, BigEndian) */
-#define SSB_SPROM3_GPIOLDC		0x0042	/* GPIO LED Powersave Duty Cycle (4 bytes, BigEndian) */
-#define  SSB_SPROM3_GPIOLDC_OFF		0x0000FF00	/* Off Count */
-#define  SSB_SPROM3_GPIOLDC_OFF_SHIFT	8
-#define  SSB_SPROM3_GPIOLDC_ON		0x00FF0000	/* On Count */
-#define  SSB_SPROM3_GPIOLDC_ON_SHIFT	16
-#define SSB_SPROM3_IL0MAC		0x004A	/* 6 bytes MAC address for 802.11b/g */
-#define SSB_SPROM3_CCKPO		0x0078	/* CCK Power Offset */
-#define  SSB_SPROM3_CCKPO_1M		0x000F	/* 1M Rate PO */
-#define  SSB_SPROM3_CCKPO_2M		0x00F0	/* 2M Rate PO */
-#define  SSB_SPROM3_CCKPO_2M_SHIFT	4
-#define  SSB_SPROM3_CCKPO_55M		0x0F00	/* 5.5M Rate PO */
-#define  SSB_SPROM3_CCKPO_55M_SHIFT	8
-#define  SSB_SPROM3_CCKPO_11M		0xF000	/* 11M Rate PO */
-#define  SSB_SPROM3_CCKPO_11M_SHIFT	12
-#define  SSB_SPROM3_OFDMGPO		0x107A	/* G-PHY OFDM Power Offset (4 bytes, BigEndian) */
-
-/* SPROM Revision 4 */
-#define SSB_SPROM4_BOARDREV		0x0042	/* Board revision */
-#define SSB_SPROM4_BFLLO		0x0044	/* Boardflags (low 16 bits) */
-#define SSB_SPROM4_BFLHI		0x0046  /* Board Flags Hi */
-#define SSB_SPROM4_BFL2LO		0x0048	/* Board flags 2 (low 16 bits) */
-#define SSB_SPROM4_BFL2HI		0x004A	/* Board flags 2 Hi */
-#define SSB_SPROM4_IL0MAC		0x004C	/* 6 byte MAC address for a/b/g/n */
-#define SSB_SPROM4_CCODE		0x0052	/* Country Code (2 bytes) */
-#define SSB_SPROM4_GPIOA		0x0056	/* Gen. Purpose IO # 0 and 1 */
-#define  SSB_SPROM4_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM4_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM4_GPIOA_P1_SHIFT	8
-#define SSB_SPROM4_GPIOB		0x0058	/* Gen. Purpose IO # 2 and 3 */
-#define  SSB_SPROM4_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM4_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM4_GPIOB_P3_SHIFT	8
-#define SSB_SPROM4_ETHPHY		0x005A	/* Ethernet PHY settings ?? */
-#define  SSB_SPROM4_ETHPHY_ET0A		0x001F	/* MII Address for enet0 */
-#define  SSB_SPROM4_ETHPHY_ET1A		0x03E0	/* MII Address for enet1 */
-#define  SSB_SPROM4_ETHPHY_ET1A_SHIFT	5
-#define  SSB_SPROM4_ETHPHY_ET0M		(1<<14)	/* MDIO for enet0 */
-#define  SSB_SPROM4_ETHPHY_ET1M		(1<<15)	/* MDIO for enet1 */
-#define SSB_SPROM4_ANTAVAIL		0x005C  /* Antenna available bitfields */
-#define  SSB_SPROM4_ANTAVAIL_BG		0x00FF	/* B-PHY and G-PHY bitfield */
-#define  SSB_SPROM4_ANTAVAIL_BG_SHIFT	0
-#define  SSB_SPROM4_ANTAVAIL_A		0xFF00	/* A-PHY bitfield */
-#define  SSB_SPROM4_ANTAVAIL_A_SHIFT	8
-#define SSB_SPROM4_AGAIN01		0x005E	/* Antenna Gain (in dBm Q5.2) */
-#define  SSB_SPROM4_AGAIN0		0x00FF	/* Antenna 0 */
-#define  SSB_SPROM4_AGAIN0_SHIFT	0
-#define  SSB_SPROM4_AGAIN1		0xFF00	/* Antenna 1 */
-#define  SSB_SPROM4_AGAIN1_SHIFT	8
-#define SSB_SPROM4_AGAIN23		0x0060
-#define  SSB_SPROM4_AGAIN2		0x00FF	/* Antenna 2 */
-#define  SSB_SPROM4_AGAIN2_SHIFT	0
-#define  SSB_SPROM4_AGAIN3		0xFF00	/* Antenna 3 */
-#define  SSB_SPROM4_AGAIN3_SHIFT	8
-#define SSB_SPROM4_TXPID2G01		0x0062 	/* TX Power Index 2GHz */
-#define  SSB_SPROM4_TXPID2G0		0x00FF
-#define  SSB_SPROM4_TXPID2G0_SHIFT	0
-#define  SSB_SPROM4_TXPID2G1		0xFF00
-#define  SSB_SPROM4_TXPID2G1_SHIFT	8
-#define SSB_SPROM4_TXPID2G23		0x0064 	/* TX Power Index 2GHz */
-#define  SSB_SPROM4_TXPID2G2		0x00FF
-#define  SSB_SPROM4_TXPID2G2_SHIFT	0
-#define  SSB_SPROM4_TXPID2G3		0xFF00
-#define  SSB_SPROM4_TXPID2G3_SHIFT	8
-#define SSB_SPROM4_TXPID5G01		0x0066 	/* TX Power Index 5GHz middle subband */
-#define  SSB_SPROM4_TXPID5G0		0x00FF
-#define  SSB_SPROM4_TXPID5G0_SHIFT	0
-#define  SSB_SPROM4_TXPID5G1		0xFF00
-#define  SSB_SPROM4_TXPID5G1_SHIFT	8
-#define SSB_SPROM4_TXPID5G23		0x0068 	/* TX Power Index 5GHz middle subband */
-#define  SSB_SPROM4_TXPID5G2		0x00FF
-#define  SSB_SPROM4_TXPID5G2_SHIFT	0
-#define  SSB_SPROM4_TXPID5G3		0xFF00
-#define  SSB_SPROM4_TXPID5G3_SHIFT	8
-#define SSB_SPROM4_TXPID5GL01		0x006A 	/* TX Power Index 5GHz low subband */
-#define  SSB_SPROM4_TXPID5GL0		0x00FF
-#define  SSB_SPROM4_TXPID5GL0_SHIFT	0
-#define  SSB_SPROM4_TXPID5GL1		0xFF00
-#define  SSB_SPROM4_TXPID5GL1_SHIFT	8
-#define SSB_SPROM4_TXPID5GL23		0x006C 	/* TX Power Index 5GHz low subband */
-#define  SSB_SPROM4_TXPID5GL2		0x00FF
-#define  SSB_SPROM4_TXPID5GL2_SHIFT	0
-#define  SSB_SPROM4_TXPID5GL3		0xFF00
-#define  SSB_SPROM4_TXPID5GL3_SHIFT	8
-#define SSB_SPROM4_TXPID5GH01		0x006E 	/* TX Power Index 5GHz high subband */
-#define  SSB_SPROM4_TXPID5GH0		0x00FF
-#define  SSB_SPROM4_TXPID5GH0_SHIFT	0
-#define  SSB_SPROM4_TXPID5GH1		0xFF00
-#define  SSB_SPROM4_TXPID5GH1_SHIFT	8
-#define SSB_SPROM4_TXPID5GH23		0x0070 	/* TX Power Index 5GHz high subband */
-#define  SSB_SPROM4_TXPID5GH2		0x00FF
-#define  SSB_SPROM4_TXPID5GH2_SHIFT	0
-#define  SSB_SPROM4_TXPID5GH3		0xFF00
-#define  SSB_SPROM4_TXPID5GH3_SHIFT	8
-
-/* There are 4 blocks with power info sharing the same layout */
-#define SSB_SPROM4_PWR_INFO_CORE0	0x0080
-#define SSB_SPROM4_PWR_INFO_CORE1	0x00AE
-#define SSB_SPROM4_PWR_INFO_CORE2	0x00DC
-#define SSB_SPROM4_PWR_INFO_CORE3	0x010A
-
-#define SSB_SPROM4_2G_MAXP_ITSSI	0x00	/* 2 GHz ITSSI and 2 GHz Max Power */
-#define  SSB_SPROM4_2G_MAXP		0x00FF
-#define  SSB_SPROM4_2G_ITSSI		0xFF00
-#define  SSB_SPROM4_2G_ITSSI_SHIFT	8
-#define SSB_SPROM4_2G_PA_0		0x02	/* 2 GHz power amp */
-#define SSB_SPROM4_2G_PA_1		0x04
-#define SSB_SPROM4_2G_PA_2		0x06
-#define SSB_SPROM4_2G_PA_3		0x08
-#define SSB_SPROM4_5G_MAXP_ITSSI	0x0A	/* 5 GHz ITSSI and 5.3 GHz Max Power */
-#define  SSB_SPROM4_5G_MAXP		0x00FF
-#define  SSB_SPROM4_5G_ITSSI		0xFF00
-#define  SSB_SPROM4_5G_ITSSI_SHIFT	8
-#define SSB_SPROM4_5GHL_MAXP		0x0C	/* 5.2 GHz and 5.8 GHz Max Power */
-#define  SSB_SPROM4_5GH_MAXP		0x00FF
-#define  SSB_SPROM4_5GL_MAXP		0xFF00
-#define  SSB_SPROM4_5GL_MAXP_SHIFT	8
-#define SSB_SPROM4_5G_PA_0		0x0E	/* 5.3 GHz power amp */
-#define SSB_SPROM4_5G_PA_1		0x10
-#define SSB_SPROM4_5G_PA_2		0x12
-#define SSB_SPROM4_5G_PA_3		0x14
-#define SSB_SPROM4_5GL_PA_0		0x16	/* 5.2 GHz power amp */
-#define SSB_SPROM4_5GL_PA_1		0x18
-#define SSB_SPROM4_5GL_PA_2		0x1A
-#define SSB_SPROM4_5GL_PA_3		0x1C
-#define SSB_SPROM4_5GH_PA_0		0x1E	/* 5.8 GHz power amp */
-#define SSB_SPROM4_5GH_PA_1		0x20
-#define SSB_SPROM4_5GH_PA_2		0x22
-#define SSB_SPROM4_5GH_PA_3		0x24
-
-/* TODO: Make it deprecated */
-#define SSB_SPROM4_MAXP_BG		0x0080  /* Max Power BG in path 1 */
-#define  SSB_SPROM4_MAXP_BG_MASK	0x00FF  /* Mask for Max Power BG */
-#define  SSB_SPROM4_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
-#define  SSB_SPROM4_ITSSI_BG_SHIFT	8
-#define SSB_SPROM4_MAXP_A		0x008A  /* Max Power A in path 1 */
-#define  SSB_SPROM4_MAXP_A_MASK		0x00FF  /* Mask for Max Power A */
-#define  SSB_SPROM4_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
-#define  SSB_SPROM4_ITSSI_A_SHIFT	8
-#define SSB_SPROM4_PA0B0		0x0082	/* The paXbY locations are */
-#define SSB_SPROM4_PA0B1		0x0084	/*   only guesses */
-#define SSB_SPROM4_PA0B2		0x0086
-#define SSB_SPROM4_PA1B0		0x008E
-#define SSB_SPROM4_PA1B1		0x0090
-#define SSB_SPROM4_PA1B2		0x0092
-
-/* SPROM Revision 5 (inherits most data from rev 4) */
-#define SSB_SPROM5_CCODE		0x0044	/* Country Code (2 bytes) */
-#define SSB_SPROM5_BFLLO		0x004A	/* Boardflags (low 16 bits) */
-#define SSB_SPROM5_BFLHI		0x004C  /* Board Flags Hi */
-#define SSB_SPROM5_BFL2LO		0x004E	/* Board flags 2 (low 16 bits) */
-#define SSB_SPROM5_BFL2HI		0x0050	/* Board flags 2 Hi */
-#define SSB_SPROM5_IL0MAC		0x0052	/* 6 byte MAC address for a/b/g/n */
-#define SSB_SPROM5_GPIOA		0x0076	/* Gen. Purpose IO # 0 and 1 */
-#define  SSB_SPROM5_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM5_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM5_GPIOA_P1_SHIFT	8
-#define SSB_SPROM5_GPIOB		0x0078	/* Gen. Purpose IO # 2 and 3 */
-#define  SSB_SPROM5_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM5_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM5_GPIOB_P3_SHIFT	8
-
-/* SPROM Revision 8 */
-#define SSB_SPROM8_BOARDREV		0x0082	/* Board revision */
-#define SSB_SPROM8_BFLLO		0x0084	/* Board flags (bits 0-15) */
-#define SSB_SPROM8_BFLHI		0x0086	/* Board flags (bits 16-31) */
-#define SSB_SPROM8_BFL2LO		0x0088	/* Board flags (bits 32-47) */
-#define SSB_SPROM8_BFL2HI		0x008A	/* Board flags (bits 48-63) */
-#define SSB_SPROM8_IL0MAC		0x008C	/* 6 byte MAC address */
-#define SSB_SPROM8_CCODE		0x0092	/* 2 byte country code */
-#define SSB_SPROM8_GPIOA		0x0096	/*Gen. Purpose IO # 0 and 1 */
-#define  SSB_SPROM8_GPIOA_P0		0x00FF	/* Pin 0 */
-#define  SSB_SPROM8_GPIOA_P1		0xFF00	/* Pin 1 */
-#define  SSB_SPROM8_GPIOA_P1_SHIFT	8
-#define SSB_SPROM8_GPIOB		0x0098	/* Gen. Purpose IO # 2 and 3 */
-#define  SSB_SPROM8_GPIOB_P2		0x00FF	/* Pin 2 */
-#define  SSB_SPROM8_GPIOB_P3		0xFF00	/* Pin 3 */
-#define  SSB_SPROM8_GPIOB_P3_SHIFT	8
-#define SSB_SPROM8_LEDDC		0x009A
-#define  SSB_SPROM8_LEDDC_ON		0xFF00	/* oncount */
-#define  SSB_SPROM8_LEDDC_ON_SHIFT	8
-#define  SSB_SPROM8_LEDDC_OFF		0x00FF	/* offcount */
-#define  SSB_SPROM8_LEDDC_OFF_SHIFT	0
-#define SSB_SPROM8_ANTAVAIL		0x009C  /* Antenna available bitfields*/
-#define  SSB_SPROM8_ANTAVAIL_A		0xFF00	/* A-PHY bitfield */
-#define  SSB_SPROM8_ANTAVAIL_A_SHIFT	8
-#define  SSB_SPROM8_ANTAVAIL_BG		0x00FF	/* B-PHY and G-PHY bitfield */
-#define  SSB_SPROM8_ANTAVAIL_BG_SHIFT	0
-#define SSB_SPROM8_AGAIN01		0x009E	/* Antenna Gain (in dBm Q5.2) */
-#define  SSB_SPROM8_AGAIN0		0x00FF	/* Antenna 0 */
-#define  SSB_SPROM8_AGAIN0_SHIFT	0
-#define  SSB_SPROM8_AGAIN1		0xFF00	/* Antenna 1 */
-#define  SSB_SPROM8_AGAIN1_SHIFT	8
-#define SSB_SPROM8_AGAIN23		0x00A0
-#define  SSB_SPROM8_AGAIN2		0x00FF	/* Antenna 2 */
-#define  SSB_SPROM8_AGAIN2_SHIFT	0
-#define  SSB_SPROM8_AGAIN3		0xFF00	/* Antenna 3 */
-#define  SSB_SPROM8_AGAIN3_SHIFT	8
-#define SSB_SPROM8_TXRXC		0x00A2
-#define  SSB_SPROM8_TXRXC_TXCHAIN	0x000f
-#define  SSB_SPROM8_TXRXC_TXCHAIN_SHIFT	0
-#define  SSB_SPROM8_TXRXC_RXCHAIN	0x00f0
-#define  SSB_SPROM8_TXRXC_RXCHAIN_SHIFT	4
-#define  SSB_SPROM8_TXRXC_SWITCH	0xff00
-#define  SSB_SPROM8_TXRXC_SWITCH_SHIFT	8
-#define SSB_SPROM8_RSSIPARM2G		0x00A4	/* RSSI params for 2GHz */
-#define  SSB_SPROM8_RSSISMF2G		0x000F
-#define  SSB_SPROM8_RSSISMC2G		0x00F0
-#define  SSB_SPROM8_RSSISMC2G_SHIFT	4
-#define  SSB_SPROM8_RSSISAV2G		0x0700
-#define  SSB_SPROM8_RSSISAV2G_SHIFT	8
-#define  SSB_SPROM8_BXA2G		0x1800
-#define  SSB_SPROM8_BXA2G_SHIFT		11
-#define SSB_SPROM8_RSSIPARM5G		0x00A6	/* RSSI params for 5GHz */
-#define  SSB_SPROM8_RSSISMF5G		0x000F
-#define  SSB_SPROM8_RSSISMC5G		0x00F0
-#define  SSB_SPROM8_RSSISMC5G_SHIFT	4
-#define  SSB_SPROM8_RSSISAV5G		0x0700
-#define  SSB_SPROM8_RSSISAV5G_SHIFT	8
-#define  SSB_SPROM8_BXA5G		0x1800
-#define  SSB_SPROM8_BXA5G_SHIFT		11
-#define SSB_SPROM8_TRI25G		0x00A8	/* TX isolation 2.4&5.3GHz */
-#define  SSB_SPROM8_TRI2G		0x00FF	/* TX isolation 2.4GHz */
-#define  SSB_SPROM8_TRI5G		0xFF00	/* TX isolation 5.3GHz */
-#define  SSB_SPROM8_TRI5G_SHIFT		8
-#define SSB_SPROM8_TRI5GHL		0x00AA	/* TX isolation 5.2/5.8GHz */
-#define  SSB_SPROM8_TRI5GL		0x00FF	/* TX isolation 5.2GHz */
-#define  SSB_SPROM8_TRI5GH		0xFF00	/* TX isolation 5.8GHz */
-#define  SSB_SPROM8_TRI5GH_SHIFT	8
-#define SSB_SPROM8_RXPO			0x00AC  /* RX power offsets */
-#define  SSB_SPROM8_RXPO2G		0x00FF	/* 2GHz RX power offset */
-#define  SSB_SPROM8_RXPO2G_SHIFT	0
-#define  SSB_SPROM8_RXPO5G		0xFF00	/* 5GHz RX power offset */
-#define  SSB_SPROM8_RXPO5G_SHIFT	8
-#define SSB_SPROM8_FEM2G		0x00AE
-#define SSB_SPROM8_FEM5G		0x00B0
-#define  SSB_SROM8_FEM_TSSIPOS		0x0001
-#define  SSB_SROM8_FEM_TSSIPOS_SHIFT	0
-#define  SSB_SROM8_FEM_EXTPA_GAIN	0x0006
-#define  SSB_SROM8_FEM_EXTPA_GAIN_SHIFT	1
-#define  SSB_SROM8_FEM_PDET_RANGE	0x00F8
-#define  SSB_SROM8_FEM_PDET_RANGE_SHIFT	3
-#define  SSB_SROM8_FEM_TR_ISO		0x0700
-#define  SSB_SROM8_FEM_TR_ISO_SHIFT	8
-#define  SSB_SROM8_FEM_ANTSWLUT		0xF800
-#define  SSB_SROM8_FEM_ANTSWLUT_SHIFT	11
-#define SSB_SPROM8_THERMAL		0x00B2
-#define  SSB_SPROM8_THERMAL_OFFSET	0x00ff
-#define  SSB_SPROM8_THERMAL_OFFSET_SHIFT	0
-#define  SSB_SPROM8_THERMAL_TRESH	0xff00
-#define  SSB_SPROM8_THERMAL_TRESH_SHIFT	8
-/* Temp sense related entries */
-#define SSB_SPROM8_RAWTS		0x00B4
-#define  SSB_SPROM8_RAWTS_RAWTEMP	0x01ff
-#define  SSB_SPROM8_RAWTS_RAWTEMP_SHIFT	0
-#define  SSB_SPROM8_RAWTS_MEASPOWER	0xfe00
-#define  SSB_SPROM8_RAWTS_MEASPOWER_SHIFT	9
-#define SSB_SPROM8_OPT_CORRX		0x00B6
-#define  SSB_SPROM8_OPT_CORRX_TEMP_SLOPE	0x00ff
-#define  SSB_SPROM8_OPT_CORRX_TEMP_SLOPE_SHIFT	0
-#define  SSB_SPROM8_OPT_CORRX_TEMPCORRX	0xfc00
-#define  SSB_SPROM8_OPT_CORRX_TEMPCORRX_SHIFT	10
-#define  SSB_SPROM8_OPT_CORRX_TEMP_OPTION	0x0300
-#define  SSB_SPROM8_OPT_CORRX_TEMP_OPTION_SHIFT	8
-/* FOC: freiquency offset correction, HWIQ: H/W IOCAL enable, IQSWP: IQ CAL swap disable */
-#define SSB_SPROM8_HWIQ_IQSWP		0x00B8
-#define  SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR	0x000f
-#define  SSB_SPROM8_HWIQ_IQSWP_FREQ_CORR_SHIFT	0
-#define  SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP	0x0010
-#define  SSB_SPROM8_HWIQ_IQSWP_IQCAL_SWP_SHIFT	4
-#define  SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL	0x0020
-#define  SSB_SPROM8_HWIQ_IQSWP_HW_IQCAL_SHIFT	5
-#define SSB_SPROM8_TEMPDELTA		0x00BC
-#define  SSB_SPROM8_TEMPDELTA_PHYCAL	0x00ff
-#define  SSB_SPROM8_TEMPDELTA_PHYCAL_SHIFT	0
-#define  SSB_SPROM8_TEMPDELTA_PERIOD	0x0f00
-#define  SSB_SPROM8_TEMPDELTA_PERIOD_SHIFT	8
-#define  SSB_SPROM8_TEMPDELTA_HYSTERESIS	0xf000
-#define  SSB_SPROM8_TEMPDELTA_HYSTERESIS_SHIFT	12
-
-/* There are 4 blocks with power info sharing the same layout */
-#define SSB_SROM8_PWR_INFO_CORE0	0x00C0
-#define SSB_SROM8_PWR_INFO_CORE1	0x00E0
-#define SSB_SROM8_PWR_INFO_CORE2	0x0100
-#define SSB_SROM8_PWR_INFO_CORE3	0x0120
-
-#define SSB_SROM8_2G_MAXP_ITSSI		0x00
-#define  SSB_SPROM8_2G_MAXP		0x00FF
-#define  SSB_SPROM8_2G_ITSSI		0xFF00
-#define  SSB_SPROM8_2G_ITSSI_SHIFT	8
-#define SSB_SROM8_2G_PA_0		0x02	/* 2GHz power amp settings */
-#define SSB_SROM8_2G_PA_1		0x04
-#define SSB_SROM8_2G_PA_2		0x06
-#define SSB_SROM8_5G_MAXP_ITSSI		0x08	/* 5GHz ITSSI and 5.3GHz Max Power */
-#define  SSB_SPROM8_5G_MAXP		0x00FF
-#define  SSB_SPROM8_5G_ITSSI		0xFF00
-#define  SSB_SPROM8_5G_ITSSI_SHIFT	8
-#define SSB_SPROM8_5GHL_MAXP		0x0A	/* 5.2GHz and 5.8GHz Max Power */
-#define  SSB_SPROM8_5GH_MAXP		0x00FF
-#define  SSB_SPROM8_5GL_MAXP		0xFF00
-#define  SSB_SPROM8_5GL_MAXP_SHIFT	8
-#define SSB_SROM8_5G_PA_0		0x0C	/* 5.3GHz power amp settings */
-#define SSB_SROM8_5G_PA_1		0x0E
-#define SSB_SROM8_5G_PA_2		0x10
-#define SSB_SROM8_5GL_PA_0		0x12	/* 5.2GHz power amp settings */
-#define SSB_SROM8_5GL_PA_1		0x14
-#define SSB_SROM8_5GL_PA_2		0x16
-#define SSB_SROM8_5GH_PA_0		0x18	/* 5.8GHz power amp settings */
-#define SSB_SROM8_5GH_PA_1		0x1A
-#define SSB_SROM8_5GH_PA_2		0x1C
-
-/* TODO: Make it deprecated */
-#define SSB_SPROM8_MAXP_BG		0x00C0  /* Max Power 2GHz in path 1 */
-#define  SSB_SPROM8_MAXP_BG_MASK	0x00FF  /* Mask for Max Power 2GHz */
-#define  SSB_SPROM8_ITSSI_BG		0xFF00	/* Mask for path 1 itssi_bg */
-#define  SSB_SPROM8_ITSSI_BG_SHIFT	8
-#define SSB_SPROM8_PA0B0		0x00C2	/* 2GHz power amp settings */
-#define SSB_SPROM8_PA0B1		0x00C4
-#define SSB_SPROM8_PA0B2		0x00C6
-#define SSB_SPROM8_MAXP_A		0x00C8  /* Max Power 5.3GHz */
-#define  SSB_SPROM8_MAXP_A_MASK		0x00FF  /* Mask for Max Power 5.3GHz */
-#define  SSB_SPROM8_ITSSI_A		0xFF00	/* Mask for path 1 itssi_a */
-#define  SSB_SPROM8_ITSSI_A_SHIFT	8
-#define SSB_SPROM8_MAXP_AHL		0x00CA  /* Max Power 5.2/5.8GHz */
-#define  SSB_SPROM8_MAXP_AH_MASK	0x00FF  /* Mask for Max Power 5.8GHz */
-#define  SSB_SPROM8_MAXP_AL_MASK	0xFF00  /* Mask for Max Power 5.2GHz */
-#define  SSB_SPROM8_MAXP_AL_SHIFT	8
-#define SSB_SPROM8_PA1B0		0x00CC	/* 5.3GHz power amp settings */
-#define SSB_SPROM8_PA1B1		0x00CE
-#define SSB_SPROM8_PA1B2		0x00D0
-#define SSB_SPROM8_PA1LOB0		0x00D2	/* 5.2GHz power amp settings */
-#define SSB_SPROM8_PA1LOB1		0x00D4
-#define SSB_SPROM8_PA1LOB2		0x00D6
-#define SSB_SPROM8_PA1HIB0		0x00D8	/* 5.8GHz power amp settings */
-#define SSB_SPROM8_PA1HIB1		0x00DA
-#define SSB_SPROM8_PA1HIB2		0x00DC
-
-#define SSB_SPROM8_CCK2GPO		0x0140	/* CCK power offset */
-#define SSB_SPROM8_OFDM2GPO		0x0142	/* 2.4GHz OFDM power offset */
-#define SSB_SPROM8_OFDM5GPO		0x0146	/* 5.3GHz OFDM power offset */
-#define SSB_SPROM8_OFDM5GLPO		0x014A	/* 5.2GHz OFDM power offset */
-#define SSB_SPROM8_OFDM5GHPO		0x014E	/* 5.8GHz OFDM power offset */
-
-#define SSB_SPROM8_2G_MCSPO		0x0152
-#define SSB_SPROM8_5G_MCSPO		0x0162
-#define SSB_SPROM8_5GL_MCSPO		0x0172
-#define SSB_SPROM8_5GH_MCSPO		0x0182
-
-#define SSB_SPROM8_CDDPO		0x0192
-#define SSB_SPROM8_STBCPO		0x0194
-#define SSB_SPROM8_BW40PO		0x0196
-#define SSB_SPROM8_BWDUPPO		0x0198
-
-/* Values for boardflags_lo read from SPROM */
-#define SSB_BFL_BTCOEXIST		0x0001	/* implements Bluetooth coexistance */
-#define SSB_BFL_PACTRL			0x0002	/* GPIO 9 controlling the PA */
-#define SSB_BFL_AIRLINEMODE		0x0004	/* implements GPIO 13 radio disable indication */
-#define SSB_BFL_RSSI			0x0008	/* software calculates nrssi slope. */
-#define SSB_BFL_ENETSPI			0x0010	/* has ephy roboswitch spi */
-#define SSB_BFL_XTAL_NOSLOW		0x0020	/* no slow clock available */
-#define SSB_BFL_CCKHIPWR		0x0040	/* can do high power CCK transmission */
-#define SSB_BFL_ENETADM			0x0080	/* has ADMtek switch */
-#define SSB_BFL_ENETVLAN		0x0100	/* can do vlan */
-#define SSB_BFL_AFTERBURNER		0x0200	/* supports Afterburner mode */
-#define SSB_BFL_NOPCI			0x0400	/* board leaves PCI floating */
-#define SSB_BFL_FEM			0x0800	/* supports the Front End Module */
-#define SSB_BFL_EXTLNA			0x1000	/* has an external LNA */
-#define SSB_BFL_HGPA			0x2000	/* had high gain PA */
-#define SSB_BFL_BTCMOD			0x4000	/* BFL_BTCOEXIST is given in alternate GPIOs */
-#define SSB_BFL_ALTIQ			0x8000	/* alternate I/Q settings */
-
-/* Values for boardflags_hi read from SPROM */
-#define SSB_BFH_NOPA			0x0001	/* has no PA */
-#define SSB_BFH_RSSIINV			0x0002	/* RSSI uses positive slope (not TSSI) */
-#define SSB_BFH_PAREF			0x0004	/* uses the PARef LDO */
-#define SSB_BFH_3TSWITCH		0x0008	/* uses a triple throw switch shared with bluetooth */
-#define SSB_BFH_PHASESHIFT		0x0010	/* can support phase shifter */
-#define SSB_BFH_BUCKBOOST		0x0020	/* has buck/booster */
-#define SSB_BFH_FEM_BT			0x0040	/* has FEM and switch to share antenna with bluetooth */
-
-/* Values for boardflags2_lo read from SPROM */
-#define SSB_BFL2_RXBB_INT_REG_DIS	0x0001	/* external RX BB regulator present */
-#define SSB_BFL2_APLL_WAR		0x0002	/* alternative A-band PLL settings implemented */
-#define SSB_BFL2_TXPWRCTRL_EN 		0x0004	/* permits enabling TX Power Control */
-#define SSB_BFL2_2X4_DIV		0x0008	/* 2x4 diversity switch */
-#define SSB_BFL2_5G_PWRGAIN		0x0010	/* supports 5G band power gain */
-#define SSB_BFL2_PCIEWAR_OVR		0x0020	/* overrides ASPM and Clkreq settings */
-#define SSB_BFL2_CAESERS_BRD		0x0040	/* is Caesers board (unused) */
-#define SSB_BFL2_BTC3WIRE		0x0080	/* used 3-wire bluetooth coexist */
-#define SSB_BFL2_SKWRKFEM_BRD		0x0100	/* 4321mcm93 uses Skyworks FEM */
-#define SSB_BFL2_SPUR_WAR		0x0200	/* has a workaround for clock-harmonic spurs */
-#define SSB_BFL2_GPLL_WAR		0x0400	/* altenative G-band PLL settings implemented */
-
-/* Values for SSB_SPROM1_BINF_CCODE */
-enum {
-	SSB_SPROM1CCODE_WORLD = 0,
-	SSB_SPROM1CCODE_THAILAND,
-	SSB_SPROM1CCODE_ISRAEL,
-	SSB_SPROM1CCODE_JORDAN,
-	SSB_SPROM1CCODE_CHINA,
-	SSB_SPROM1CCODE_JAPAN,
-	SSB_SPROM1CCODE_USA_CANADA_ANZ,
-	SSB_SPROM1CCODE_EUROPE,
-	SSB_SPROM1CCODE_USA_LOW,
-	SSB_SPROM1CCODE_JAPAN_HIGH,
-	SSB_SPROM1CCODE_ALL,
-	SSB_SPROM1CCODE_NONE,
-};
-
-/* Address-Match values and masks (SSB_ADMATCHxxx) */
-#define SSB_ADM_TYPE			0x00000003	/* Address type */
-#define  SSB_ADM_TYPE0			0
-#define  SSB_ADM_TYPE1			1
-#define  SSB_ADM_TYPE2			2
-#define SSB_ADM_AD64			0x00000004
-#define SSB_ADM_SZ0			0x000000F8	/* Type0 size */
-#define SSB_ADM_SZ0_SHIFT		3
-#define SSB_ADM_SZ1			0x000001F8	/* Type1 size */
-#define SSB_ADM_SZ1_SHIFT		3
-#define SSB_ADM_SZ2			0x000001F8	/* Type2 size */
-#define SSB_ADM_SZ2_SHIFT		3
-#define SSB_ADM_EN			0x00000400	/* Enable */
-#define SSB_ADM_NEG			0x00000800	/* Negative decode */
-#define SSB_ADM_BASE0			0xFFFFFF00	/* Type0 base address */
-#define SSB_ADM_BASE0_SHIFT		8
-#define SSB_ADM_BASE1			0xFFFFF000	/* Type1 base address for the core */
-#define SSB_ADM_BASE1_SHIFT		12
-#define SSB_ADM_BASE2			0xFFFF0000	/* Type2 base address for the core */
-#define SSB_ADM_BASE2_SHIFT		16
-
-
-#endif /* LINUX_SSB_REGS_H_ */
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 345ea08..78bb645 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -189,6 +189,8 @@ enum ieee80211_channel_flags {
  * @dfs_state: current state of this channel. Only relevant if radar is required
  *	on this channel.
  * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.
+ * @dfs_state_last_available: timestamp (jiffies) of the last time when the
+ *	channel was available.
  * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.
  * @psd: power spectral density (in dBm)
  */
@@ -206,6 +208,7 @@ struct ieee80211_channel {
 	int orig_mag, orig_mpwr;
 	enum nl80211_dfs_state dfs_state;
 	unsigned long dfs_state_entered;
+	unsigned long dfs_state_last_available;
 	unsigned int dfs_cac_ms;
 	s8 psd;
 };
@@ -1595,6 +1598,7 @@ struct cfg80211_color_change_settings {
  *
  * Used to pass interface combination parameters
  *
+ * @radio_idx: wiphy radio index or -1 for global
  * @num_different_channels: the number of different channels we want
  *	to use for verification
  * @radar_detect: a bitmap where each bit corresponds to a channel
@@ -1608,6 +1612,7 @@ struct cfg80211_color_change_settings {
  *	the verification
  */
 struct iface_combination_params {
+	int radio_idx;
 	int num_different_channels;
 	u8 radar_detect;
 	int iftype_num[NUM_NL80211_IFTYPES];
@@ -3413,6 +3418,7 @@ enum wiphy_params_flags {
 /* The per TXQ device queue limit in airtime */
 #define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L	5000
 #define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H	12000
+#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_BC	50000
 
 /* The per interface airtime threshold to switch to lower queue limit */
 #define IEEE80211_AQL_THRESHOLD			24000
@@ -4575,6 +4581,8 @@ struct mgmt_frame_regs {
  *
  * @set_hw_timestamp: Enable/disable HW timestamping of TM/FTM frames.
  * @set_ttlm: set the TID to link mapping.
+ * @get_radio_mask: get bitmask of radios in use.
+ *	(invoked with the wiphy mutex held)
  */
 struct cfg80211_ops {
 	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
@@ -4936,6 +4944,7 @@ struct cfg80211_ops {
 				    struct cfg80211_set_hw_timestamp *hwts);
 	int	(*set_ttlm)(struct wiphy *wiphy, struct net_device *dev,
 			    struct cfg80211_ttlm_params *params);
+	u32	(*get_radio_mask)(struct wiphy *wiphy, struct net_device *dev);
 };
 
 /*
@@ -5041,7 +5050,9 @@ struct ieee80211_iface_limit {
  * struct ieee80211_iface_combination - possible interface combination
  *
  * With this structure the driver can describe which interface
- * combinations it supports concurrently.
+ * combinations it supports concurrently. When set in a struct wiphy_radio,
+ * the combinations refer to combinations of interfaces currently active on
+ * that radio.
  *
  * Examples:
  *
@@ -5399,6 +5410,38 @@ struct wiphy_iftype_akm_suites {
 	int n_akm_suites;
 };
 
+/**
+ * struct wiphy_radio_freq_range - wiphy frequency range
+ * @start_freq:  start range edge frequency (kHz)
+ * @end_freq:    end range edge frequency (kHz)
+ */
+struct wiphy_radio_freq_range {
+	u32 start_freq;
+	u32 end_freq;
+};
+
+
+/**
+ * struct wiphy_radio - physical radio of a wiphy
+ * This structure describes a physical radio belonging to a wiphy.
+ * It is used to describe concurrent-channel capabilities. Only one channel
+ * can be active on the radio described by struct wiphy_radio.
+ *
+ * @freq_range: frequency range that the radio can operate on.
+ * @n_freq_range: number of elements in @freq_range
+ *
+ * @iface_combinations: Valid interface combinations array, should not
+ *	list single interface types.
+ * @n_iface_combinations: number of entries in @iface_combinations array.
+ */
+struct wiphy_radio {
+	const struct wiphy_radio_freq_range *freq_range;
+	int n_freq_range;
+
+	const struct ieee80211_iface_combination *iface_combinations;
+	int n_iface_combinations;
+};
+
 #define CFG80211_HW_TIMESTAMP_ALL_PEERS	0xffff
 
 /**
@@ -5617,6 +5660,9 @@ struct wiphy_iftype_akm_suites {
  *	A value of %CFG80211_HW_TIMESTAMP_ALL_PEERS indicates the driver
  *	supports enabling HW timestamping for all peers (i.e. no need to
  *	specify a mac address).
+ *
+ * @radio: radios belonging to this wiphy
+ * @n_radio: number of radios
  */
 struct wiphy {
 	struct mutex mtx;
@@ -5767,6 +5813,9 @@ struct wiphy {
 
 	u16 hw_timestamp_max_peers;
 
+	int n_radio;
+	const struct wiphy_radio *radio;
+
 	char priv[] __aligned(NETDEV_ALIGN);
 };
 
@@ -6435,6 +6484,15 @@ static inline bool cfg80211_channel_is_psc(struct ieee80211_channel *chan)
 	return ieee80211_frequency_to_channel(chan->center_freq) % 16 == 5;
 }
 
+/**
+ * cfg80211_radio_chandef_valid - Check if the radio supports the chandef
+ *
+ * @radio: wiphy radio
+ * @chandef: chandef for current channel
+ */
+bool cfg80211_radio_chandef_valid(const struct wiphy_radio *radio,
+				  const struct cfg80211_chan_def *chandef);
+
 /**
  * ieee80211_get_response_rate - get basic rate for a given rate
  *
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 97758f1..7d04b0c 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -250,6 +250,7 @@ struct ieee80211_chan_req {
  * @min_def: the minimum channel definition currently required.
  * @ap: the channel definition the AP actually is operating as,
  *	for use with (wider bandwidth) OFDMA
+ * @radio_idx: index of the wiphy radio used used for this channel
  * @rx_chains_static: The number of RX chains that must always be
  *	active on the channel to receive MIMO transmissions
  * @rx_chains_dynamic: The number of RX chains that must be enabled
@@ -264,6 +265,7 @@ struct ieee80211_chanctx_conf {
 	struct cfg80211_chan_def min_def;
 	struct cfg80211_chan_def ap;
 
+	int radio_idx;
 	u8 rx_chains_static, rx_chains_dynamic;
 
 	bool radar_enabled;
@@ -1180,8 +1182,8 @@ struct ieee80211_tx_info {
 	    status_data_idr:1,
 	    status_data:13,
 	    hw_queue:4,
+	    tx_time_mc:1,
 	    tx_time_est:10;
-	/* 1 free bit */
 
 	union {
 		struct {
@@ -2123,8 +2125,8 @@ static inline bool lockdep_vif_wiphy_mutex_held(struct ieee80211_vif *vif)
  *	@IEEE80211_KEY_FLAG_GENERATE_MMIC on the same key.
  * @IEEE80211_KEY_FLAG_NO_AUTO_TX: Key needs explicit Tx activation.
  * @IEEE80211_KEY_FLAG_GENERATE_MMIE: This flag should be set by the driver
- *	for a AES_CMAC key to indicate that it requires sequence number
- *	generation only
+ *	for a AES_CMAC or a AES_GMAC key to indicate that it requires sequence
+ *	number generation only
  * @IEEE80211_KEY_FLAG_SPP_AMSDU: SPP A-MSDUs can be used with this key
  *	(set by mac80211 from the sta->spp_amsdu flag)
  */
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index f23ecbd..3a05cd5 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -2061,6 +2061,10 @@ enum nl80211_commands {
  * @NL80211_ATTR_INTERFACE_COMBINATIONS: Nested attribute listing the supported
  *	interface combinations. In each nested item, it contains attributes
  *	defined in &enum nl80211_if_combination_attrs.
+ *	If the wiphy uses multiple radios (@NL80211_ATTR_WIPHY_RADIOS is set),
+ *	this attribute contains the interface combinations of the first radio.
+ *	See @NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS for the global wiphy
+ *	combinations for the sum of all radios.
  * @NL80211_ATTR_SOFTWARE_IFTYPES: Nested attribute (just like
  *	%NL80211_ATTR_SUPPORTED_IFTYPES) containing the interface types that
  *	are managed in software: interfaces of these types aren't subject to
@@ -2856,6 +2860,14 @@ enum nl80211_commands {
  *	%NL80211_CMD_ASSOCIATE indicating the SPP A-MSDUs
  *	are used on this connection
  *
+ * @NL80211_ATTR_WIPHY_RADIOS: Nested attribute describing physical radios
+ *	belonging to this wiphy. See &enum nl80211_wiphy_radio_attrs.
+ *
+ * @NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS: Nested attribute listing the
+ *	supported interface combinations for all radios combined. In each
+ *	nested item, it contains attributes defined in
+ *	&enum nl80211_if_combination_attrs.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -3401,6 +3413,9 @@ enum nl80211_attrs {
 
 	NL80211_ATTR_ASSOC_SPP_AMSDU,
 
+	NL80211_ATTR_WIPHY_RADIOS,
+	NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -7987,4 +8002,54 @@ enum nl80211_ap_settings_flags {
 	NL80211_AP_SETTINGS_SA_QUERY_OFFLOAD_SUPPORT	= 1 << 1,
 };
 
+/**
+ * enum nl80211_wiphy_radio_attrs - wiphy radio attributes
+ *
+ * @__NL80211_WIPHY_RADIO_ATTR_INVALID: Invalid
+ *
+ * @NL80211_WIPHY_RADIO_ATTR_INDEX: Index of this radio (u32)
+ * @NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE: Frequency range supported by this
+ *	radio. Attribute may be present multiple times.
+ * @NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION: Supported interface
+ *	combination for this radio. Attribute may be present multiple times
+ *	and contains attributes defined in &enum nl80211_if_combination_attrs.
+ *
+ * @__NL80211_WIPHY_RADIO_ATTR_LAST: Internal
+ * @NL80211_WIPHY_RADIO_ATTR_MAX: Highest attribute
+ */
+enum nl80211_wiphy_radio_attrs {
+	__NL80211_WIPHY_RADIO_ATTR_INVALID,
+
+	NL80211_WIPHY_RADIO_ATTR_INDEX,
+	NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE,
+	NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION,
+
+	/* keep last */
+	__NL80211_WIPHY_RADIO_ATTR_LAST,
+	NL80211_WIPHY_RADIO_ATTR_MAX = __NL80211_WIPHY_RADIO_ATTR_LAST - 1,
+};
+
+/**
+ * enum nl80211_wiphy_radio_freq_range - wiphy radio frequency range
+ *
+ * @__NL80211_WIPHY_RADIO_FREQ_ATTR_INVALID: Invalid
+ *
+ * @NL80211_WIPHY_RADIO_FREQ_ATTR_START: Frequency range start (u32).
+ *	The unit is kHz.
+ * @NL80211_WIPHY_RADIO_FREQ_ATTR_END: Frequency range end (u32).
+ *	The unit is kHz.
+ *
+ * @__NL80211_WIPHY_RADIO_FREQ_ATTR_LAST: Internal
+ * @NL80211_WIPHY_RADIO_FREQ_ATTR_MAX: Highest attribute
+ */
+enum nl80211_wiphy_radio_freq_range {
+	__NL80211_WIPHY_RADIO_FREQ_ATTR_INVALID,
+
+	NL80211_WIPHY_RADIO_FREQ_ATTR_START,
+	NL80211_WIPHY_RADIO_FREQ_ATTR_END,
+
+	__NL80211_WIPHY_RADIO_FREQ_ATTR_LAST,
+	NL80211_WIPHY_RADIO_FREQ_ATTR_MAX = __NL80211_WIPHY_RADIO_FREQ_ATTR_LAST - 1,
+};
+
 #endif /* __LINUX_NL80211_H */
diff --git a/kconf/Makefile b/kconf/Makefile
index 2004c44..c1bd620 100644
--- a/kconf/Makefile
+++ b/kconf/Makefile
@@ -1,9 +1,9 @@
-CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
 
 LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
 
 conf: conf.o zconf.tab.o
-mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags) -DLOCALE
+mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags)
 mconf_LDFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
 mconf: CFLAGS += $(mconf_CFLAGS)
 
@@ -17,7 +17,7 @@ clean:
 zconf.tab.c: zconf.lex.c
 
 %.tab.c: %.y
-	$(YACC) -o$@ -t -l $<
+	$(YACC) -Wno-yacc -o$@ -t -l $<
 
 %.lex.c: %.l
 	$(LEX) -o$@ -L $<
diff --git a/kconf/conf.c b/kconf/conf.c
index 283eeed..162fa6b 100644
--- a/kconf/conf.c
+++ b/kconf/conf.c
@@ -86,7 +86,7 @@ static int conf_askvalue(struct symbol *sym, const char *def)
 	enum symbol_type type = sym_get_type(sym);
 
 	if (!sym_has_value(sym))
-		printf(_("(NEW) "));
+		printf("%s", _("(NEW) "));
 
 	line[0] = '\n';
 	line[1] = 0;
@@ -282,7 +282,7 @@ static int conf_choice(struct menu *menu)
 			if (child->sym->name)
 				printf(" (%s)", child->sym->name);
 			if (!sym_has_value(child->sym))
-				printf(_(" (NEW)"));
+				printf("%s", _(" (NEW)"));
 			printf("\n");
 		}
 		printf(_("%*schoice"), indent - 1, "");
@@ -437,7 +437,7 @@ static void check_conf(struct menu *menu)
 				}
 			} else {
 				if (!conf_cnt++)
-					printf(_("*\n* Restart config...\n*\n"));
+					printf("%s", _("*\n* Restart config...\n*\n"));
 				rootEntry = menu_get_parent_menu(menu);
 				conf(rootEntry);
 			}
@@ -598,40 +598,12 @@ int main(int ac, char **av)
 	case oldconfig:
 	case listnewconfig:
 	case olddefconfig:
-		conf_read(NULL);
-		break;
 	case allnoconfig:
 	case allyesconfig:
 	case allmodconfig:
 	case alldefconfig:
 	case randconfig:
-		name = getenv("KCONFIG_ALLCONFIG");
-		if (!name)
-			break;
-		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
-			if (conf_read_simple(name, S_DEF_USER)) {
-				fprintf(stderr,
-					_("*** Can't read seed configuration \"%s\"!\n"),
-					name);
-				exit(1);
-			}
-			break;
-		}
-		switch (input_mode) {
-		case allnoconfig:	name = "allno.config"; break;
-		case allyesconfig:	name = "allyes.config"; break;
-		case allmodconfig:	name = "allmod.config"; break;
-		case alldefconfig:	name = "alldef.config"; break;
-		case randconfig:	name = "allrandom.config"; break;
-		default: break;
-		}
-		if (conf_read_simple(name, S_DEF_USER) &&
-		    conf_read_simple("all.config", S_DEF_USER)) {
-			fprintf(stderr,
-				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
-				name);
-			exit(1);
-		}
+		conf_read(NULL);
 		break;
 	default:
 		break;
@@ -642,7 +614,7 @@ int main(int ac, char **av)
 			name = getenv("KCONFIG_NOSILENTUPDATE");
 			if (name && *name) {
 				fprintf(stderr,
-					_("\n*** The configuration requires explicit update.\n\n"));
+					"%s", _("\n*** The configuration requires explicit update.\n\n"));
 				return 1;
 			}
 		}
@@ -694,22 +666,22 @@ int main(int ac, char **av)
 		 * All other commands are only used to generate a config.
 		 */
 		if (conf_get_changed() && conf_write(NULL)) {
-			fprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during writing of the configuration.\n\n"));
 			exit(1);
 		}
 		if (conf_write_autoconf()) {
-			fprintf(stderr, _("\n*** Error during update of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during update of the configuration.\n\n"));
 			return 1;
 		}
 	} else if (input_mode == savedefconfig) {
 		if (conf_write_defconfig(defconfig_file)) {
-			fprintf(stderr, _("n*** Error while saving defconfig to: %s\n\n"),
+			fprintf(stderr, _("\n*** Error while saving defconfig to: %s\n\n"),
 				defconfig_file);
 			return 1;
 		}
 	} else if (input_mode != listnewconfig) {
 		if (conf_write(NULL)) {
-			fprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during writing of the configuration.\n\n"));
 			exit(1);
 		}
 	}
diff --git a/kconf/confdata.c b/kconf/confdata.c
index df26c7b..1038c30 100644
--- a/kconf/confdata.c
+++ b/kconf/confdata.c
@@ -1170,6 +1170,8 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 	}
 	bool has_changed = false;
 
+	sym_clear_all_valid();
+
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
 			continue;
@@ -1213,8 +1215,6 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	}
 
-	sym_clear_all_valid();
-
 	/*
 	 * We have different type of choice blocks.
 	 * If curr.tri equals to mod then we can select several
diff --git a/local-symbols b/local-symbols
index 72523cc..ff0d0d0 100644
--- a/local-symbols
+++ b/local-symbols
@@ -59,14 +59,6 @@ MAC80211_MESH_PS_DEBUG=
 MAC80211_TDLS_DEBUG=
 MAC80211_DEBUG_COUNTERS=
 MAC80211_STA_HASH_MAX_SIZE=
-QRTR=
-QRTR_SMD=
-QRTR_TUN=
-QRTR_MHI=
-MHI_BUS=
-MHI_BUS_DEBUG=
-MHI_BUS_PCI_GENERIC=
-MHI_BUS_EP=
 QCOM_AOSS_QMP=
 QCOM_COMMAND_DB=
 QCOM_GENI_SE=
@@ -102,6 +94,7 @@ ADM8211=
 ATH_COMMON=
 WLAN_VENDOR_ATH=
 ATH_DEBUG=
+ATH_USER_REGD=
 ATH_TRACEPOINTS=
 ATH_REG_DYNAMIC_USER_REG_HINTS=
 ATH_REG_DYNAMIC_USER_CERT_TESTING=
@@ -159,6 +152,8 @@ ATH10K_SNOC=
 ATH10K_DEBUG=
 ATH10K_DEBUGFS=
 ATH10K_SPECTRAL=
+ATH10K_THERMAL=
+ATH10K_LEDS=
 ATH10K_TRACING=
 ATH10K_DFS_CERTIFIED=
 WCN36XX=
@@ -170,6 +165,7 @@ ATH11K_DEBUG=
 ATH11K_DEBUGFS=
 ATH11K_TRACING=
 ATH11K_SPECTRAL=
+ATH11K_THERMAL=
 ATH12K=
 ATH12K_DEBUG=
 ATH12K_TRACING=
@@ -337,6 +333,7 @@ RT2X00_LIB_FIRMWARE=
 RT2X00_LIB_CRYPTO=
 RT2X00_LIB_LEDS=
 RT2X00_LIB_DEBUGFS=
+RT2X00_LIB_EEPROM=
 RT2X00_DEBUG=
 WLAN_VENDOR_REALTEK=
 RTL8180=
@@ -471,43 +468,6 @@ USB_VL600=
 USB_NET_CH9200=
 USB_NET_AQC111=
 USB_RTL8153_ECM=
-SSB_POSSIBLE=
-SSB=
-SSB_SPROM=
-SSB_BLOCKIO=
-SSB_PCIHOST_POSSIBLE=
-SSB_PCIHOST=
-SSB_B43_PCI_BRIDGE=
-SSB_PCMCIAHOST_POSSIBLE=
-SSB_PCMCIAHOST=
-SSB_SDIOHOST_POSSIBLE=
-SSB_SDIOHOST=
-SSB_HOST_SOC=
-SSB_SERIAL=
-SSB_DRIVER_PCICORE_POSSIBLE=
-SSB_DRIVER_PCICORE=
-SSB_PCICORE_HOSTMODE=
-SSB_DRIVER_MIPS=
-SSB_SFLASH=
-SSB_EMBEDDED=
-SSB_DRIVER_EXTIF=
-SSB_DRIVER_GIGE=
-SSB_DRIVER_GPIO=
-BCMA_POSSIBLE=
-BCMA=
-BCMA_BLOCKIO=
-BCMA_HOST_PCI_POSSIBLE=
-BCMA_HOST_PCI=
-BCMA_HOST_SOC=
-BCMA_DRIVER_PCI=
-BCMA_DRIVER_PCI_HOSTMODE=
-BCMA_DRIVER_MIPS=
-BCMA_PFLASH=
-BCMA_SFLASH=
-BCMA_NFLASH=
-BCMA_DRIVER_GMAC_CMN=
-BCMA_DRIVER_GPIO=
-BCMA_DEBUG=
 USB_ACM=
 USB_PRINTER=
 USB_WDM=
diff --git a/local-symbols.orig b/local-symbols.orig
new file mode 100644
index 0000000..4104481
--- /dev/null
+++ b/local-symbols.orig
@@ -0,0 +1,475 @@
+BACKPORT_DIR=
+BACKPORTS_VERSION=
+BACKPORTED_KERNEL_VERSION=
+BACKPORTED_KERNEL_NAME=
+WIRELESS=
+NET_CORE=
+EXPERT=
+BP_MODULES=
+BPAUTO_BUILD_NLATTR=
+BPAUTO_USERSEL_BUILD_ALL=
+BPAUTO_WANT_DEV_COREDUMP=
+BPAUTO_CRYPTO_LIB_ARC4=
+BPAUTO_BUILD_CRYPTO_LIB_ARC4=
+CFG80211=
+NL80211_TESTMODE=
+CFG80211_DEVELOPER_WARNINGS=
+CFG80211_CERTIFICATION_ONUS=
+CFG80211_REQUIRE_SIGNED_REGDB=
+CFG80211_USE_KERNEL_REGDB_KEYS=
+CFG80211_EXTRA_REGDB_KEYDIR=
+CFG80211_REG_CELLULAR_HINTS=
+CFG80211_REG_RELAX_NO_IR=
+CFG80211_DEFAULT_PS=
+CFG80211_DEBUGFS=
+CFG80211_CRDA_SUPPORT=
+CFG80211_WEXT=
+CFG80211_WEXT_EXPORT=
+CFG80211_KUNIT_TEST=
+LIB80211=
+LIB80211_CRYPT_WEP=
+LIB80211_CRYPT_CCMP=
+LIB80211_CRYPT_TKIP=
+LIB80211_DEBUG=
+MAC80211=
+MAC80211_HAS_RC=
+MAC80211_RC_MINSTREL=
+MAC80211_RC_DEFAULT_MINSTREL=
+MAC80211_RC_DEFAULT=
+MAC80211_KUNIT_TEST=
+MAC80211_MESH=
+MAC80211_LEDS=
+MAC80211_DEBUGFS=
+MAC80211_MESSAGE_TRACING=
+MAC80211_DEBUG_MENU=
+MAC80211_NOINLINE=
+MAC80211_VERBOSE_DEBUG=
+MAC80211_MLME_DEBUG=
+MAC80211_STA_DEBUG=
+MAC80211_HT_DEBUG=
+MAC80211_OCB_DEBUG=
+MAC80211_IBSS_DEBUG=
+MAC80211_PS_DEBUG=
+MAC80211_MPL_DEBUG=
+MAC80211_MPATH_DEBUG=
+MAC80211_MHWMP_DEBUG=
+MAC80211_MESH_SYNC_DEBUG=
+MAC80211_MESH_CSA_DEBUG=
+MAC80211_MESH_PS_DEBUG=
+MAC80211_TDLS_DEBUG=
+MAC80211_DEBUG_COUNTERS=
+MAC80211_STA_HASH_MAX_SIZE=
+QCOM_AOSS_QMP=
+QCOM_COMMAND_DB=
+QCOM_GENI_SE=
+QCOM_GSBI=
+QCOM_LLCC=
+QCOM_KRYO_L2_ACCESSORS=
+QCOM_MDT_LOADER=
+QCOM_OCMEM=
+QCOM_PDR_HELPERS=
+QCOM_PMIC_PDCHARGER_ULOG=
+QCOM_PMIC_GLINK=
+QCOM_QMI_HELPERS=
+QCOM_RAMP_CTRL=
+QCOM_RMTFS_MEM=
+QCOM_RPM_MASTER_STATS=
+QCOM_RPMH=
+QCOM_SMEM=
+QCOM_SMD_RPM=
+QCOM_SMEM_STATE=
+QCOM_SMP2P=
+QCOM_SMSM=
+QCOM_SOCINFO=
+QCOM_SPM=
+QCOM_STATS=
+QCOM_WCNSS_CTRL=
+QCOM_APR=
+QCOM_ICC_BWMON=
+QCOM_INLINE_CRYPTO_ENGINE=
+QCOM_PBS=
+WLAN=
+WLAN_VENDOR_ADMTEK=
+ADM8211=
+ATH_COMMON=
+WLAN_VENDOR_ATH=
+ATH_DEBUG=
+ATH_USER_REGD=
+ATH_TRACEPOINTS=
+ATH_REG_DYNAMIC_USER_REG_HINTS=
+ATH_REG_DYNAMIC_USER_CERT_TESTING=
+ATH5K=
+ATH5K_DEBUG=
+ATH5K_TRACER=
+ATH5K_AHB=
+ATH5K_PCI=
+ATH5K_TEST_CHANNELS=
+ATH9K_HW=
+ATH9K_COMMON=
+ATH9K_COMMON_DEBUG=
+ATH9K_DFS_DEBUGFS=
+ATH9K_BTCOEX_SUPPORT=
+ATH9K=
+ATH9K_PCI=
+ATH9K_AHB=
+ATH9K_DEBUGFS=
+ATH9K_STATION_STATISTICS=
+ATH9K_TX99=
+ATH9K_DFS_CERTIFIED=
+ATH9K_DYNACK=
+ATH9K_WOW=
+ATH9K_RFKILL=
+ATH9K_CHANNEL_CONTEXT=
+ATH9K_PCOEM=
+ATH9K_PCI_NO_EEPROM=
+ATH9K_HTC=
+ATH9K_HTC_DEBUGFS=
+ATH9K_HWRNG=
+ATH9K_COMMON_SPECTRAL=
+CARL9170=
+CARL9170_LEDS=
+CARL9170_DEBUGFS=
+CARL9170_WPC=
+CARL9170_HWRNG=
+ATH6KL=
+ATH6KL_SDIO=
+ATH6KL_USB=
+ATH6KL_DEBUG=
+ATH6KL_TRACING=
+ATH6KL_REGDOMAIN=
+AR5523=
+WIL6210=
+WIL6210_ISR_COR=
+WIL6210_TRACING=
+WIL6210_DEBUGFS=
+ATH10K=
+ATH10K_CE=
+ATH10K_PCI=
+ATH10K_AHB=
+ATH10K_SDIO=
+ATH10K_USB=
+ATH10K_SNOC=
+ATH10K_DEBUG=
+ATH10K_DEBUGFS=
+ATH10K_SPECTRAL=
+ATH10K_THERMAL=
+ATH10K_LEDS=
+ATH10K_TRACING=
+ATH10K_DFS_CERTIFIED=
+WCN36XX=
+WCN36XX_DEBUGFS=
+ATH11K=
+ATH11K_AHB=
+ATH11K_PCI=
+ATH11K_DEBUG=
+ATH11K_DEBUGFS=
+ATH11K_TRACING=
+ATH11K_SPECTRAL=
+ATH11K_THERMAL=
+ATH12K=
+ATH12K_DEBUG=
+ATH12K_TRACING=
+WLAN_VENDOR_ATMEL=
+AT76C50X_USB=
+WLAN_VENDOR_BROADCOM=
+B43=
+B43_BCMA=
+B43_SSB=
+B43_BUSES_BCMA_AND_SSB=
+B43_BUSES_BCMA=
+B43_BUSES_SSB=
+B43_PCI_AUTOSELECT=
+B43_PCICORE_AUTOSELECT=
+B43_SDIO=
+B43_BCMA_PIO=
+B43_PIO=
+B43_PHY_G=
+B43_PHY_N=
+B43_PHY_LP=
+B43_PHY_HT=
+B43_PHY_LCN=
+B43_PHY_AC=
+B43_LEDS=
+B43_HWRNG=
+B43_DEBUG=
+B43LEGACY=
+B43LEGACY_PCI_AUTOSELECT=
+B43LEGACY_PCICORE_AUTOSELECT=
+B43LEGACY_LEDS=
+B43LEGACY_HWRNG=
+B43LEGACY_DEBUG=
+B43LEGACY_DMA=
+B43LEGACY_PIO=
+B43LEGACY_DMA_AND_PIO_MODE=
+B43LEGACY_DMA_MODE=
+B43LEGACY_PIO_MODE=
+BRCMUTIL=
+BRCMSMAC=
+BRCMSMAC_LEDS=
+BRCM_TRACING=
+BRCMDBG=
+BRCMFMAC=
+BRCMFMAC_PROTO_BCDC=
+BRCMFMAC_PROTO_MSGBUF=
+BRCMFMAC_SDIO=
+BRCMFMAC_USB=
+BRCMFMAC_PCIE=
+WLAN_VENDOR_INTEL=
+IPW2100=
+IPW2100_MONITOR=
+IPW2100_DEBUG=
+IPW2200=
+IPW2200_MONITOR=
+IPW2200_RADIOTAP=
+IPW2200_PROMISCUOUS=
+IPW2200_QOS=
+IPW2200_DEBUG=
+LIBIPW=
+LIBIPW_DEBUG=
+IWLEGACY=
+IWL4965=
+IWL3945=
+IWLEGACY_DEBUG=
+IWLEGACY_DEBUGFS=
+IWLWIFI=
+IWLWIFI_KUNIT_TESTS=
+IWLWIFI_LEDS=
+IWLDVM=
+IWLMVM=
+IWLWIFI_OPMODE_MODULAR=
+IWLWIFI_DEBUG=
+IWLWIFI_DEBUGFS=
+IWLWIFI_DEVICE_TRACING=
+IWLMEI=
+WLAN_VENDOR_INTERSIL=
+P54_COMMON=
+P54_USB=
+P54_PCI=
+P54_SPI=
+P54_SPI_DEFAULT_EEPROM=
+P54_LEDS=
+WLAN_VENDOR_MARVELL=
+MWL8K=
+LIBERTAS=
+LIBERTAS_USB=
+LIBERTAS_SDIO=
+LIBERTAS_SPI=
+LIBERTAS_DEBUG=
+LIBERTAS_MESH=
+LIBERTAS_THINFIRM=
+LIBERTAS_THINFIRM_DEBUG=
+LIBERTAS_THINFIRM_USB=
+MWIFIEX=
+MWIFIEX_SDIO=
+MWIFIEX_PCIE=
+MWIFIEX_USB=
+WLAN_VENDOR_MEDIATEK=
+MT7601U=
+MT76_CORE=
+MT76_LEDS=
+MT76_USB=
+MT76_SDIO=
+MT76x02_LIB=
+MT76x02_USB=
+MT76_CONNAC_LIB=
+MT792x_LIB=
+MT792x_USB=
+MT76x0_COMMON=
+MT76x0U=
+MT76x0E=
+MT76x2_COMMON=
+MT76x2E=
+MT76x2U=
+MT7603E=
+MT7615_COMMON=
+MT7615E=
+MT7622_WMAC=
+MT7663_USB_SDIO_COMMON=
+MT7663U=
+MT7663S=
+MT7915E=
+MT798X_WMAC=
+MT7921_COMMON=
+MT7921E=
+MT7921S=
+MT7921U=
+MT7996E=
+MT7925_COMMON=
+MT7925E=
+MT7925U=
+WLAN_VENDOR_MICROCHIP=
+WILC1000=
+WILC1000_SDIO=
+WILC1000_SPI=
+WILC1000_HW_OOB_INTR=
+WLAN_VENDOR_RALINK=
+RT2X00=
+RT2400PCI=
+RT2500PCI=
+RT61PCI=
+RT2800PCI=
+RT2800PCI_RT33XX=
+RT2800PCI_RT35XX=
+RT2800PCI_RT53XX=
+RT2800PCI_RT3290=
+RT2500USB=
+RT73USB=
+RT2800USB=
+RT2800USB_RT33XX=
+RT2800USB_RT35XX=
+RT2800USB_RT3573=
+RT2800USB_RT53XX=
+RT2800USB_RT55XX=
+RT2800USB_UNKNOWN=
+RT2800SOC=
+RT2800_LIB=
+RT2800_LIB_MMIO=
+RT2X00_LIB_MMIO=
+RT2X00_LIB_PCI=
+RT2X00_LIB_SOC=
+RT2X00_LIB_USB=
+RT2X00_LIB=
+RT2X00_LIB_FIRMWARE=
+RT2X00_LIB_CRYPTO=
+RT2X00_LIB_LEDS=
+RT2X00_LIB_DEBUGFS=
+RT2X00_DEBUG=
+WLAN_VENDOR_REALTEK=
+RTL8180=
+RTL8187=
+RTL8187_LEDS=
+RTL_CARDS=
+RTL8192CE=
+RTL8192SE=
+RTL8192DE=
+RTL8723AE=
+RTL8723BE=
+RTL8188EE=
+RTL8192EE=
+RTL8821AE=
+RTL8192CU=
+RTLWIFI=
+RTLWIFI_PCI=
+RTLWIFI_USB=
+RTLWIFI_DEBUG=
+RTL8192C_COMMON=
+RTL8723_COMMON=
+RTLBTCOEXIST=
+RTL8XXXU=
+RTL8XXXU_UNTESTED=
+RTW88=
+RTW88_CORE=
+RTW88_PCI=
+RTW88_SDIO=
+RTW88_USB=
+RTW88_8822B=
+RTW88_8822C=
+RTW88_8723D=
+RTW88_8821C=
+RTW88_8822BE=
+RTW88_8822BS=
+RTW88_8822BU=
+RTW88_8822CE=
+RTW88_8822CS=
+RTW88_8822CU=
+RTW88_8723DE=
+RTW88_8723DS=
+RTW88_8723DU=
+RTW88_8821CE=
+RTW88_8821CS=
+RTW88_8821CU=
+RTW88_DEBUG=
+RTW88_DEBUGFS=
+RTW89=
+RTW89_CORE=
+RTW89_PCI=
+RTW89_8851B=
+RTW89_8852A=
+RTW89_8852B=
+RTW89_8852C=
+RTW89_8851BE=
+RTW89_8852AE=
+RTW89_8852BE=
+RTW89_8852CE=
+RTW89_DEBUG=
+RTW89_DEBUGMSG=
+RTW89_DEBUGFS=
+WLAN_VENDOR_RSI=
+RSI_91X=
+RSI_DEBUGFS=
+RSI_SDIO=
+RSI_USB=
+RSI_COEX=
+WLAN_VENDOR_ST=
+CW1200=
+CW1200_WLAN_SDIO=
+CW1200_WLAN_SPI=
+WLAN_VENDOR_TI=
+WL1251=
+WL1251_SPI=
+WL1251_SDIO=
+WL12XX=
+WL18XX=
+WLCORE=
+WLCORE_SPI=
+WLCORE_SDIO=
+WLAN_VENDOR_ZYDAS=
+ZD1211RW=
+ZD1211RW_DEBUG=
+WLAN_VENDOR_QUANTENNA=
+QTNFMAC=
+QTNFMAC_PCIE=
+MAC80211_HWSIM=
+VIRT_WIFI=
+USB_NET_DRIVERS=
+USB_CATC=
+USB_KAWETH=
+USB_PEGASUS=
+USB_RTL8150=
+USB_RTL8152=
+USB_LAN78XX=
+USB_USBNET=
+USB_NET_AX8817X=
+USB_NET_AX88179_178A=
+USB_NET_CDCETHER=
+USB_NET_CDC_EEM=
+USB_NET_CDC_NCM=
+USB_NET_HUAWEI_CDC_NCM=
+USB_NET_CDC_MBIM=
+USB_NET_DM9601=
+USB_NET_SR9700=
+USB_NET_SR9800=
+USB_NET_SMSC75XX=
+USB_NET_SMSC95XX=
+USB_NET_GL620A=
+USB_NET_NET1080=
+USB_NET_PLUSB=
+USB_NET_MCS7830=
+USB_NET_RNDIS_HOST=
+USB_NET_CDC_SUBSET_ENABLE=
+USB_NET_CDC_SUBSET=
+USB_ALI_M5632=
+USB_AN2720=
+USB_BELKIN=
+USB_ARMLINUX=
+USB_EPSON2888=
+USB_KC2190=
+USB_NET_ZAURUS=
+USB_NET_CX82310_ETH=
+USB_NET_KALMIA=
+USB_NET_QMI_WWAN=
+USB_HSO=
+USB_NET_INT51X1=
+USB_CDC_PHONET=
+USB_IPHETH=
+USB_SIERRA_NET=
+USB_VL600=
+USB_NET_CH9200=
+USB_NET_AQC111=
+USB_RTL8153_ECM=
+USB_ACM=
+USB_PRINTER=
+USB_WDM=
+USB_TMC=
+STAGING=
+RTL8723BS=
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 1f1069c..4c22a02 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -263,7 +263,7 @@ static int ieee80211_start_p2p_device(struct wiphy *wiphy,
 
 	lockdep_assert_wiphy(sdata->local->hw.wiphy);
 
-	ret = ieee80211_check_combinations(sdata, NULL, 0, 0);
+	ret = ieee80211_check_combinations(sdata, NULL, 0, 0, -1);
 	if (ret < 0)
 		return ret;
 
@@ -285,7 +285,7 @@ static int ieee80211_start_nan(struct wiphy *wiphy,
 
 	lockdep_assert_wiphy(sdata->local->hw.wiphy);
 
-	ret = ieee80211_check_combinations(sdata, NULL, 0, 0);
+	ret = ieee80211_check_combinations(sdata, NULL, 0, 0, -1);
 	if (ret < 0)
 		return ret;
 
@@ -1647,12 +1647,6 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
 
 	__sta_info_flush(sdata, true, link_id);
 
-	ieee80211_remove_link_keys(link, &keys);
-	if (!list_empty(&keys)) {
-		synchronize_net();
-		ieee80211_free_key_list(local, &keys);
-	}
-
 	link_conf->enable_beacon = false;
 	sdata->beacon_rate_set = false;
 	sdata->vif.cfg.ssid_len = 0;
@@ -2850,6 +2844,8 @@ static int ieee80211_scan(struct wiphy *wiphy,
 		 */
 		fallthrough;
 	case NL80211_IFTYPE_AP:
+		/* skip check */
+		break;
 		/*
 		 * If the scan has been forced (and the driver supports
 		 * forcing), don't care about being beaconing already.
@@ -3996,7 +3992,7 @@ __ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
 		goto out;
 
 	/* if reservation is invalid then this will fail */
-	err = ieee80211_check_combinations(sdata, NULL, chanctx->mode, 0);
+	err = ieee80211_check_combinations(sdata, NULL, chanctx->mode, 0, -1);
 	if (err) {
 		ieee80211_link_unreserve_chanctx(link_data);
 		goto out;
@@ -5165,4 +5161,5 @@ const struct cfg80211_ops mac80211_config_ops = {
 	.del_link_station = ieee80211_del_link_station,
 	.set_hw_timestamp = ieee80211_set_hw_timestamp,
 	.set_ttlm = ieee80211_set_ttlm,
+	.get_radio_mask = ieee80211_get_radio_mask,
 };
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index ccacaed..a704efa 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -47,24 +47,29 @@ int ieee80211_chanctx_refcount(struct ieee80211_local *local,
 	       ieee80211_chanctx_num_reserved(local, ctx);
 }
 
-static int ieee80211_num_chanctx(struct ieee80211_local *local)
+static int ieee80211_num_chanctx(struct ieee80211_local *local, int radio_idx)
 {
 	struct ieee80211_chanctx *ctx;
 	int num = 0;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	list_for_each_entry(ctx, &local->chanctx_list, list)
+	list_for_each_entry(ctx, &local->chanctx_list, list) {
+		if (radio_idx >= 0 && ctx->conf.radio_idx != radio_idx)
+			continue;
 		num++;
+	}
 
 	return num;
 }
 
-static bool ieee80211_can_create_new_chanctx(struct ieee80211_local *local)
+static bool ieee80211_can_create_new_chanctx(struct ieee80211_local *local,
+					     int radio_idx)
 {
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	return ieee80211_num_chanctx(local) < ieee80211_max_num_channels(local);
+	return ieee80211_num_chanctx(local, radio_idx) <
+	       ieee80211_max_num_channels(local, radio_idx);
 }
 
 static struct ieee80211_chanctx *
@@ -623,7 +628,8 @@ ieee80211_chanctx_radar_required(struct ieee80211_local *local,
 static struct ieee80211_chanctx *
 ieee80211_alloc_chanctx(struct ieee80211_local *local,
 			const struct ieee80211_chan_req *chanreq,
-			enum ieee80211_chanctx_mode mode)
+			enum ieee80211_chanctx_mode mode,
+			int radio_idx)
 {
 	struct ieee80211_chanctx *ctx;
 
@@ -641,6 +647,7 @@ ieee80211_alloc_chanctx(struct ieee80211_local *local,
 	ctx->conf.rx_chains_dynamic = 1;
 	ctx->mode = mode;
 	ctx->conf.radar_enabled = false;
+	ctx->conf.radio_idx = radio_idx;
 	_ieee80211_recalc_chanctx_min_def(local, ctx, NULL);
 
 	return ctx;
@@ -673,14 +680,15 @@ static int ieee80211_add_chanctx(struct ieee80211_local *local,
 static struct ieee80211_chanctx *
 ieee80211_new_chanctx(struct ieee80211_local *local,
 		      const struct ieee80211_chan_req *chanreq,
-		      enum ieee80211_chanctx_mode mode)
+		      enum ieee80211_chanctx_mode mode,
+		      int radio_idx)
 {
 	struct ieee80211_chanctx *ctx;
 	int err;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	ctx = ieee80211_alloc_chanctx(local, chanreq, mode);
+	ctx = ieee80211_alloc_chanctx(local, chanreq, mode, radio_idx);
 	if (!ctx)
 		return ERR_PTR(-ENOMEM);
 
@@ -1026,6 +1034,107 @@ int ieee80211_link_unreserve_chanctx(struct ieee80211_link_data *link)
 	return 0;
 }
 
+static struct ieee80211_chanctx *
+ieee80211_replace_chanctx(struct ieee80211_local *local,
+			  const struct ieee80211_chan_req *chanreq,
+			  enum ieee80211_chanctx_mode mode,
+			  struct ieee80211_chanctx *curr_ctx)
+{
+	struct ieee80211_chanctx *new_ctx, *ctx;
+	struct wiphy *wiphy = local->hw.wiphy;
+	const struct wiphy_radio *radio;
+
+	if (!curr_ctx || (curr_ctx->replace_state ==
+			  IEEE80211_CHANCTX_WILL_BE_REPLACED) ||
+	    !list_empty(&curr_ctx->reserved_links)) {
+		/*
+		 * Another link already requested this context for a
+		 * reservation. Find another one hoping all links assigned
+		 * to it will also switch soon enough.
+		 *
+		 * TODO: This needs a little more work as some cases
+		 * (more than 2 chanctx capable devices) may fail which could
+		 * otherwise succeed provided some channel context juggling was
+		 * performed.
+		 *
+		 * Consider ctx1..3, link1..6, each ctx has 2 links. link1 and
+		 * link2 from ctx1 request new different chandefs starting 2
+		 * in-place reserations with ctx4 and ctx5 replacing ctx1 and
+		 * ctx2 respectively. Next link5 and link6 from ctx3 reserve
+		 * ctx4. If link3 and link4 remain on ctx2 as they are then this
+		 * fails unless `replace_ctx` from ctx5 is replaced with ctx3.
+		 */
+		list_for_each_entry(ctx, &local->chanctx_list, list) {
+			if (ctx->replace_state !=
+			    IEEE80211_CHANCTX_REPLACE_NONE)
+				continue;
+
+			if (!list_empty(&ctx->reserved_links))
+				continue;
+
+			if (ctx->conf.radio_idx >= 0) {
+				radio = &wiphy->radio[ctx->conf.radio_idx];
+				if (!cfg80211_radio_chandef_valid(radio, &chanreq->oper))
+					continue;
+			}
+
+			curr_ctx = ctx;
+			break;
+		}
+	}
+
+	/*
+	 * If that's true then all available contexts already have reservations
+	 * and cannot be used.
+	 */
+	if (!curr_ctx || (curr_ctx->replace_state ==
+			  IEEE80211_CHANCTX_WILL_BE_REPLACED) ||
+	    !list_empty(&curr_ctx->reserved_links))
+		return ERR_PTR(-EBUSY);
+
+	new_ctx = ieee80211_alloc_chanctx(local, chanreq, mode, -1);
+	if (!new_ctx)
+		return ERR_PTR(-ENOMEM);
+
+	new_ctx->replace_ctx = curr_ctx;
+	new_ctx->replace_state = IEEE80211_CHANCTX_REPLACES_OTHER;
+
+	curr_ctx->replace_ctx = new_ctx;
+	curr_ctx->replace_state = IEEE80211_CHANCTX_WILL_BE_REPLACED;
+
+	list_add_rcu(&new_ctx->list, &local->chanctx_list);
+
+	return new_ctx;
+}
+
+static bool
+ieee80211_find_available_radio(struct ieee80211_local *local,
+			       const struct ieee80211_chan_req *chanreq,
+			       int *radio_idx)
+{
+	struct wiphy *wiphy = local->hw.wiphy;
+	const struct wiphy_radio *radio;
+	int i;
+
+	*radio_idx = -1;
+	if (!wiphy->n_radio)
+		return true;
+
+	for (i = 0; i < wiphy->n_radio; i++) {
+		radio = &wiphy->radio[i];
+		if (!cfg80211_radio_chandef_valid(radio, &chanreq->oper))
+			continue;
+
+		if (!ieee80211_can_create_new_chanctx(local, i))
+			continue;
+
+		*radio_idx = i;
+		return true;
+	}
+
+	return false;
+}
+
 int ieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,
 				   const struct ieee80211_chan_req *chanreq,
 				   enum ieee80211_chanctx_mode mode,
@@ -1033,7 +1142,8 @@ int ieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,
 {
 	struct ieee80211_sub_if_data *sdata = link->sdata;
 	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_chanctx *new_ctx, *curr_ctx, *ctx;
+	struct ieee80211_chanctx *new_ctx, *curr_ctx;
+	int radio_idx;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
@@ -1043,75 +1153,15 @@ int ieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,
 
 	new_ctx = ieee80211_find_reservation_chanctx(local, chanreq, mode);
 	if (!new_ctx) {
-		if (ieee80211_can_create_new_chanctx(local)) {
-			new_ctx = ieee80211_new_chanctx(local, chanreq, mode);
-			if (IS_ERR(new_ctx))
-				return PTR_ERR(new_ctx);
-		} else {
-			if (!curr_ctx ||
-			    (curr_ctx->replace_state ==
-			     IEEE80211_CHANCTX_WILL_BE_REPLACED) ||
-			    !list_empty(&curr_ctx->reserved_links)) {
-				/*
-				 * Another link already requested this context
-				 * for a reservation. Find another one hoping
-				 * all links assigned to it will also switch
-				 * soon enough.
-				 *
-				 * TODO: This needs a little more work as some
-				 * cases (more than 2 chanctx capable devices)
-				 * may fail which could otherwise succeed
-				 * provided some channel context juggling was
-				 * performed.
-				 *
-				 * Consider ctx1..3, link1..6, each ctx has 2
-				 * links. link1 and link2 from ctx1 request new
-				 * different chandefs starting 2 in-place
-				 * reserations with ctx4 and ctx5 replacing
-				 * ctx1 and ctx2 respectively. Next link5 and
-				 * link6 from ctx3 reserve ctx4. If link3 and
-				 * link4 remain on ctx2 as they are then this
-				 * fails unless `replace_ctx` from ctx5 is
-				 * replaced with ctx3.
-				 */
-				list_for_each_entry(ctx, &local->chanctx_list,
-						    list) {
-					if (ctx->replace_state !=
-					    IEEE80211_CHANCTX_REPLACE_NONE)
-						continue;
-
-					if (!list_empty(&ctx->reserved_links))
-						continue;
-
-					curr_ctx = ctx;
-					break;
-				}
-			}
-
-			/*
-			 * If that's true then all available contexts already
-			 * have reservations and cannot be used.
-			 */
-			if (!curr_ctx ||
-			    (curr_ctx->replace_state ==
-			     IEEE80211_CHANCTX_WILL_BE_REPLACED) ||
-			    !list_empty(&curr_ctx->reserved_links))
-				return -EBUSY;
-
-			new_ctx = ieee80211_alloc_chanctx(local, chanreq, mode);
-			if (!new_ctx)
-				return -ENOMEM;
-
-			new_ctx->replace_ctx = curr_ctx;
-			new_ctx->replace_state =
-					IEEE80211_CHANCTX_REPLACES_OTHER;
-
-			curr_ctx->replace_ctx = new_ctx;
-			curr_ctx->replace_state =
-					IEEE80211_CHANCTX_WILL_BE_REPLACED;
-
-			list_add_rcu(&new_ctx->list, &local->chanctx_list);
-		}
+		if (ieee80211_can_create_new_chanctx(local, -1) &&
+		    ieee80211_find_available_radio(local, chanreq, &radio_idx))
+			new_ctx = ieee80211_new_chanctx(local, chanreq, mode,
+							radio_idx);
+		else
+			new_ctx = ieee80211_replace_chanctx(local, chanreq,
+							    mode, curr_ctx);
+		if (IS_ERR(new_ctx))
+			return PTR_ERR(new_ctx);
 	}
 
 	list_add(&link->reserved_chanctx_list, &new_ctx->reserved_links);
@@ -1714,6 +1764,7 @@ int ieee80211_link_use_channel(struct ieee80211_link_data *link,
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_chanctx *ctx;
 	u8 radar_detect_width = 0;
+	int radio_idx;
 	int ret;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
@@ -1734,15 +1785,19 @@ int ieee80211_link_use_channel(struct ieee80211_link_data *link,
 	link->radar_required = ret;
 
 	ret = ieee80211_check_combinations(sdata, &chanreq->oper, mode,
-					   radar_detect_width);
+					   radar_detect_width, -1);
 	if (ret < 0)
 		goto out;
 
 	__ieee80211_link_release_channel(link);
 
 	ctx = ieee80211_find_chanctx(local, chanreq, mode);
-	if (!ctx)
-		ctx = ieee80211_new_chanctx(local, chanreq, mode);
+	if (!ctx) {
+		if (!ieee80211_find_available_radio(local, chanreq, &radio_idx))
+			ctx = ERR_PTR(-EBUSY);
+		else
+			ctx = ieee80211_new_chanctx(local, chanreq, mode, radio_idx);
+	}
 	if (IS_ERR(ctx)) {
 		ret = PTR_ERR(ctx);
 		goto out;
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 6ba1b68..edf171e 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -215,11 +215,13 @@ static ssize_t aql_pending_read(struct file *file,
 			"VI     %u us\n"
 			"BE     %u us\n"
 			"BK     %u us\n"
+			"BC/MC  %u us\n"
 			"total  %u us\n",
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VO]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VI]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BE]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BK]),
+			atomic_read(&local->aql_bc_pending_airtime),
 			atomic_read(&local->aql_total_pending_airtime));
 	return simple_read_from_buffer(user_buf, count, ppos,
 				       buf, len);
@@ -245,7 +247,8 @@ static ssize_t aql_txq_limit_read(struct file *file,
 			"VO	%u		%u\n"
 			"VI	%u		%u\n"
 			"BE	%u		%u\n"
-			"BK	%u		%u\n",
+			"BK	%u		%u\n"
+			"BC/MC	%u\n",
 			local->aql_txq_limit_low[IEEE80211_AC_VO],
 			local->aql_txq_limit_high[IEEE80211_AC_VO],
 			local->aql_txq_limit_low[IEEE80211_AC_VI],
@@ -253,7 +256,8 @@ static ssize_t aql_txq_limit_read(struct file *file,
 			local->aql_txq_limit_low[IEEE80211_AC_BE],
 			local->aql_txq_limit_high[IEEE80211_AC_BE],
 			local->aql_txq_limit_low[IEEE80211_AC_BK],
-			local->aql_txq_limit_high[IEEE80211_AC_BK]);
+			local->aql_txq_limit_high[IEEE80211_AC_BK],
+			local->aql_txq_limit_bc);
 	return simple_read_from_buffer(user_buf, count, ppos,
 				       buf, len);
 }
@@ -279,6 +283,11 @@ static ssize_t aql_txq_limit_write(struct file *file,
 	else
 		buf[count] = '\0';
 
+	if (sscanf(buf, "mcast %u", &q_limit_low) == 1) {
+		local->aql_txq_limit_bc = q_limit_low;
+		return count;
+	}
+
 	if (sscanf(buf, "%u %u %u", &ac, &q_limit_low, &q_limit_high) != 3)
 		return -EINVAL;
 
diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c
index 7ace5cd..ff7300b 100644
--- a/net/mac80211/ibss.c
+++ b/net/mac80211/ibss.c
@@ -1745,7 +1745,7 @@ int ieee80211_ibss_join(struct ieee80211_sub_if_data *sdata,
 		IEEE80211_CHANCTX_SHARED : IEEE80211_CHANCTX_EXCLUSIVE;
 
 	ret = ieee80211_check_combinations(sdata, &params->chandef, chanmode,
-					   radar_detect_width);
+					   radar_detect_width, -1);
 	if (ret < 0)
 		return ret;
 
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 0e054d9..bb4474d 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -101,6 +101,8 @@ ieee80211_sta_keep_active(struct sta_info *sta, u8 ac)
 	return time_before_eq(jiffies, sta->airtime[ac].last_active + HZ / 10);
 }
 
+#define AIRTIME_QUANTUM_SHIFT	3
+
 struct ieee80211_bss {
 	u32 device_ts_beacon, device_ts_presp;
 
@@ -1336,10 +1338,12 @@ struct ieee80211_local {
 	spinlock_t handle_wake_tx_queue_lock;
 
 	u16 airtime_flags;
+	u32 aql_txq_limit_bc;
 	u32 aql_txq_limit_low[IEEE80211_NUM_ACS];
 	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
 	u32 aql_threshold;
 	atomic_t aql_total_pending_airtime;
+	atomic_t aql_bc_pending_airtime;
 	atomic_t aql_ac_pending_airtime[IEEE80211_NUM_ACS];
 
 	const struct ieee80211_ops *ops;
@@ -2592,8 +2596,9 @@ void ieee80211_recalc_dtim(struct ieee80211_local *local,
 int ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,
 				 const struct cfg80211_chan_def *chandef,
 				 enum ieee80211_chanctx_mode chanmode,
-				 u8 radar_detect);
-int ieee80211_max_num_channels(struct ieee80211_local *local);
+				 u8 radar_detect, int radio_idx);
+int ieee80211_max_num_channels(struct ieee80211_local *local, int radio_idx);
+u32 ieee80211_get_radio_mask(struct wiphy *wiphy, struct net_device *dev);
 void ieee80211_recalc_chanctx_chantype(struct ieee80211_local *local,
 				       struct ieee80211_chanctx *ctx);
 
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index 7c8a421..7432093 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -397,7 +397,7 @@ static int ieee80211_check_concurrent_iface(struct ieee80211_sub_if_data *sdata,
 		}
 	}
 
-	return ieee80211_check_combinations(sdata, NULL, 0, 0);
+	return ieee80211_check_combinations(sdata, NULL, 0, 0, -1);
 }
 
 static int ieee80211_check_queues(struct ieee80211_sub_if_data *sdata,
@@ -693,8 +693,12 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, bool going_do
 
 		fallthrough;
 	default:
-		if (going_down)
-			drv_remove_interface(local, sdata);
+		if (!going_down)
+			break;
+		drv_remove_interface(local, sdata);
+
+		/* Clear private driver data to prevent reuse */
+		memset(sdata->vif.drv_priv, 0, local->hw.vif_data_size);
 	}
 
 	ieee80211_recalc_ps(local);
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index 3083f24..cd04340 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -944,6 +944,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 	spin_lock_init(&local->rx_path_lock);
 	spin_lock_init(&local->queue_stop_reason_lock);
 
+	local->aql_txq_limit_bc = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_BC;
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		INIT_LIST_HEAD(&local->active_txqs[i]);
 		spin_lock_init(&local->active_txq_lock[i]);
@@ -1083,6 +1084,27 @@ static int ieee80211_init_cipher_suites(struct ieee80211_local *local)
 	return 0;
 }
 
+static bool
+ieee80211_ifcomb_check(const struct ieee80211_iface_combination *c, int n_comb)
+{
+	int i, j;
+
+	for (i = 0; i < n_comb; i++, c++) {
+		/* DFS is not supported with multi-channel combinations yet */
+		if (c->radar_detect_widths &&
+		    c->num_different_channels > 1)
+			return false;
+
+		/* mac80211 doesn't support more than one IBSS interface */
+		for (j = 0; j < c->n_limits; j++)
+			if ((c->limits[j].types & BIT(NL80211_IFTYPE_ADHOC)) &&
+			    c->limits[j].max > 1)
+				return false;
+	}
+
+	return true;
+}
+
 int ieee80211_register_hw(struct ieee80211_hw *hw)
 {
 	struct ieee80211_local *local = hw_to_local(hw);
@@ -1172,17 +1194,20 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 			if (comb->num_different_channels > 1)
 				return -EINVAL;
 		}
-	} else {
-		/* DFS is not supported with multi-channel combinations yet */
-		for (i = 0; i < local->hw.wiphy->n_iface_combinations; i++) {
-			const struct ieee80211_iface_combination *comb;
+	}
 
-			comb = &local->hw.wiphy->iface_combinations[i];
+	if (hw->wiphy->n_radio) {
+		for (i = 0; i < hw->wiphy->n_radio; i++) {
+			const struct wiphy_radio *radio = &hw->wiphy->radio[i];
 
-			if (comb->radar_detect_widths &&
-			    comb->num_different_channels > 1)
+			if (!ieee80211_ifcomb_check(radio->iface_combinations,
+						    radio->n_iface_combinations))
 				return -EINVAL;
 		}
+	} else {
+		if (!ieee80211_ifcomb_check(hw->wiphy->iface_combinations,
+					    hw->wiphy->n_iface_combinations))
+			return -EINVAL;
 	}
 
 	/* Only HW csum features are currently compatible with mac80211 */
@@ -1312,18 +1337,6 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 	hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_MONITOR);
 	hw->wiphy->software_iftypes |= BIT(NL80211_IFTYPE_MONITOR);
 
-	/* mac80211 doesn't support more than one IBSS interface right now */
-	for (i = 0; i < hw->wiphy->n_iface_combinations; i++) {
-		const struct ieee80211_iface_combination *c;
-		int j;
-
-		c = &hw->wiphy->iface_combinations[i];
-
-		for (j = 0; j < c->n_limits; j++)
-			if ((c->limits[j].types & BIT(NL80211_IFTYPE_ADHOC)) &&
-			    c->limits[j].max > 1)
-				return -EINVAL;
-	}
 
 	local->int_scan_req = kzalloc(sizeof(*local->int_scan_req) +
 				      sizeof(void *) * channels, GFP_KERNEL);
@@ -1564,24 +1577,6 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 
 	ieee80211_check_wbrf_support(local);
 
-	rtnl_lock();
-	wiphy_lock(hw->wiphy);
-
-	/* add one default STA interface if supported */
-	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION) &&
-	    !ieee80211_hw_check(hw, NO_AUTO_VIF)) {
-		struct vif_params params = {0};
-
-		result = ieee80211_if_add(local, "wlan%d", NET_NAME_ENUM, NULL,
-					  NL80211_IFTYPE_STATION, &params);
-		if (result)
-			wiphy_warn(local->hw.wiphy,
-				   "Failed to add default virtual iface\n");
-	}
-
-	wiphy_unlock(hw->wiphy);
-	rtnl_unlock();
-
 #ifdef CONFIG_INET
 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
 	result = register_inetaddr_notifier(&local->ifa_notifier);
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index b128191..802cd6c 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -580,6 +580,14 @@ minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
 	int cur_tp_avg, cur_group, cur_idx;
 	int max_gpr_group, max_gpr_idx;
 	int max_gpr_tp_avg, max_gpr_prob;
+	int min_dur;
+
+	min_dur = max(minstrel_get_duration(mi->max_tp_rate[0]),
+		      minstrel_get_duration(mi->max_tp_rate[1]));
+
+	/* make the rate at least 18% slower than max tp rates */
+	if (minstrel_get_duration(index) <= min_dur * 19 / 16)
+		return;
 
 	cur_group = MI_RATE_GROUP(index);
 	cur_idx = MI_RATE_IDX(index);
@@ -601,11 +609,6 @@ minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
 	    !minstrel_ht_is_legacy_group(max_tp_group))
 		return;
 
-	/* skip rates faster than max tp rate with lower prob */
-	if (minstrel_get_duration(mi->max_tp_rate[0]) > minstrel_get_duration(index) &&
-	    mrs->prob_avg < max_tp_prob)
-		return;
-
 	max_gpr_group = MI_RATE_GROUP(mg->max_group_prob_rate);
 	max_gpr_idx = MI_RATE_IDX(mg->max_group_prob_rate);
 	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
@@ -663,40 +666,6 @@ minstrel_ht_assign_best_tp_rates(struct minstrel_ht_sta *mi,
 
 }
 
-/*
- * Try to increase robustness of max_prob rate by decrease number of
- * streams if possible.
- */
-static inline void
-minstrel_ht_prob_rate_reduce_streams(struct minstrel_ht_sta *mi)
-{
-	struct minstrel_mcs_group_data *mg;
-	int tmp_max_streams, group, tmp_idx, tmp_prob;
-	int tmp_tp = 0;
-
-	if (!mi->sta->deflink.ht_cap.ht_supported)
-		return;
-
-	group = MI_RATE_GROUP(mi->max_tp_rate[0]);
-	tmp_max_streams = minstrel_mcs_groups[group].streams;
-	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
-		mg = &mi->groups[group];
-		if (!mi->supported[group] || group == MINSTREL_CCK_GROUP)
-			continue;
-
-		tmp_idx = MI_RATE_IDX(mg->max_group_prob_rate);
-		tmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;
-
-		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&
-		   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {
-				mi->max_prob_rate = mg->max_group_prob_rate;
-				tmp_tp = minstrel_ht_get_tp_avg(mi, group,
-								tmp_idx,
-								tmp_prob);
-		}
-	}
-}
-
 static u16
 __minstrel_ht_get_sample_rate(struct minstrel_ht_sta *mi,
 			      enum minstrel_sample_type type)
@@ -769,7 +738,8 @@ minstrel_ht_calc_rate_stats(struct minstrel_priv *mp,
 	unsigned int cur_prob;
 
 	if (unlikely(mrs->attempts > 0)) {
-		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
+		cur_prob = MINSTREL_FRAC(mrs->success + mrs->last_success,
+					 mrs->attempts + mrs->last_attempts);
 		minstrel_filter_avg_add(&mrs->prob_avg,
 					&mrs->prob_avg_1, cur_prob);
 		mrs->att_hist += mrs->attempts;
@@ -1175,8 +1145,6 @@ minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	/* Try to increase robustness of max_prob_rate*/
-	minstrel_ht_prob_rate_reduce_streams(mi);
 	minstrel_ht_refill_sample_rates(mi);
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
@@ -1255,7 +1223,7 @@ minstrel_ht_ri_txstat_valid(struct minstrel_priv *mp,
 }
 
 static void
-minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
+minstrel_downgrade_prob_rate(struct minstrel_ht_sta *mi, u16 *idx)
 {
 	int group, orig_group;
 
@@ -1270,11 +1238,7 @@ minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
 		    minstrel_mcs_groups[orig_group].streams)
 			continue;
 
-		if (primary)
-			*idx = mi->groups[group].max_group_tp_rate[0];
-		else
-			*idx = mi->groups[group].max_group_tp_rate[1];
-		break;
+		*idx = mi->groups[group].max_group_prob_rate;
 	}
 }
 
@@ -1285,7 +1249,7 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 	struct ieee80211_tx_info *info = st->info;
 	struct minstrel_ht_sta *mi = priv_sta;
 	struct ieee80211_tx_rate *ar = info->status.rates;
-	struct minstrel_rate_stats *rate, *rate2;
+	struct minstrel_rate_stats *rate;
 	struct minstrel_priv *mp = priv;
 	u32 update_interval = mp->update_interval;
 	bool last, update = false;
@@ -1353,18 +1317,13 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 		/*
 		 * check for sudden death of spatial multiplexing,
 		 * downgrade to a lower number of streams if necessary.
+		 * only do this for the max_prob_rate to prevent spurious
+		 * rate fluctuations when the link changes suddenly
 		 */
-		rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
+		rate = minstrel_get_ratestats(mi, mi->max_prob_rate);
 		if (rate->attempts > 30 &&
 		    rate->success < rate->attempts / 4) {
-			minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
-			update = true;
-		}
-
-		rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
-		if (rate2->attempts > 30 &&
-		    rate2->success < rate2->attempts / 4) {
-			minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
+			minstrel_downgrade_prob_rate(mi, &mi->max_prob_rate);
 			update = true;
 		}
 	}
diff --git a/net/mac80211/rc80211_minstrel_ht.h b/net/mac80211/rc80211_minstrel_ht.h
index f385cf6..1f78a94 100644
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -14,7 +14,7 @@
 
 /* scaled fraction values */
 #define MINSTREL_SCALE  12
-#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / div)
+#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / (div))
 #define MINSTREL_TRUNC(val) ((val) >> MINSTREL_SCALE)
 
 #define EWMA_LEVEL	96	/* ewma weighting factor [/EWMA_DIV] */
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index 16f28db..83e98c7 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -565,6 +565,11 @@ __sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 	spin_lock_init(&sta->ps_lock);
 	INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);
 	wiphy_work_init(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
+#if LINUX_VERSION_IS_LESS(6,2,0)
+	sta->ampdu_mlme.dialog_token_allocator = prandom_u32_max(U8_MAX);
+#else
+	sta->ampdu_mlme.dialog_token_allocator = get_random_u32_below(U8_MAX);
+#endif
 #ifdef CPTCFG_MAC80211_MESH
 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
 		sta->mesh = kzalloc(sizeof(*sta->mesh), gfp);
@@ -2352,13 +2357,28 @@ EXPORT_SYMBOL(ieee80211_sta_recalc_aggregates);
 
 void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
 					  struct sta_info *sta, u8 ac,
-					  u16 tx_airtime, bool tx_completed)
+					  u16 tx_airtime, bool tx_completed,
+					  bool mcast)
 {
 	int tx_pending;
 
 	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
 		return;
 
+	if (mcast) {
+		if (!tx_completed) {
+			atomic_add(tx_airtime, &local->aql_bc_pending_airtime);
+			return;
+		}
+
+		tx_pending = atomic_sub_return(tx_airtime,
+					       &local->aql_bc_pending_airtime);
+		if (tx_pending < 0)
+			atomic_cmpxchg(&local->aql_bc_pending_airtime,
+				       tx_pending, 0);
+		return;
+	}
+
 	if (!tx_completed) {
 		if (sta)
 			atomic_add(tx_airtime,
@@ -2439,6 +2459,13 @@ static void sta_stats_decode_rate(struct ieee80211_local *local, u32 rate,
 
 		sband = local->hw.wiphy->bands[band];
 
+		if (!sband) {
+			wiphy_warn(local->hw.wiphy,
+				    "Invalid band %d\n",
+				    band);
+			break;
+		}
+
 		if (WARN_ON_ONCE(!sband->bitrates))
 			break;
 
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index 8b72ea7..d4fcd47 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -147,7 +147,8 @@ struct airtime_info {
 
 void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
 					  struct sta_info *sta, u8 ac,
-					  u16 tx_airtime, bool tx_completed);
+					  u16 tx_airtime, bool tx_completed,
+					  bool mcast);
 
 struct sta_info;
 
diff --git a/net/mac80211/status.c b/net/mac80211/status.c
index 1708b33..92c17f9 100644
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -717,7 +717,7 @@ static void ieee80211_report_used_skb(struct ieee80211_local *local,
 		ieee80211_sta_update_pending_airtime(local, sta,
 						     skb_get_queue_mapping(skb),
 						     tx_time_est,
-						     true);
+						     true, info->tx_time_mc);
 		rcu_read_unlock();
 	}
 
@@ -1138,10 +1138,11 @@ void ieee80211_tx_status_ext(struct ieee80211_hw *hw,
 		/* Do this here to avoid the expensive lookup of the sta
 		 * in ieee80211_report_used_skb().
 		 */
+		bool mcast = IEEE80211_SKB_CB(skb)->tx_time_mc;
 		ieee80211_sta_update_pending_airtime(local, sta,
 						     skb_get_queue_mapping(skb),
 						     tx_time_est,
-						     true);
+						     true, mcast);
 		ieee80211_info_set_tx_time_est(IEEE80211_SKB_CB(skb), 0);
 	}
 
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 042319c..50cb0d2 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2554,7 +2554,7 @@ static u16 ieee80211_store_ack_skb(struct ieee80211_local *local,
 
 		spin_lock_irqsave(&local->ack_status_lock, flags);
 		id = idr_alloc(&local->ack_status_frames, ack_skb,
-			       1, 0x2000, GFP_ATOMIC);
+			       1, 0x1000, GFP_ATOMIC);
 		spin_unlock_irqrestore(&local->ack_status_lock, flags);
 
 		if (id >= 0) {
@@ -3983,20 +3983,20 @@ begin:
 encap_out:
 	info->control.vif = vif;
 
-	if (tx.sta &&
-	    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
-		bool ampdu = txq->ac != IEEE80211_AC_VO;
+	if (wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
+		bool ampdu = txq->sta && txq->ac != IEEE80211_AC_VO;
 		u32 airtime;
 
 		airtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,
 							     skb->len, ampdu);
-		if (airtime) {
-			airtime = ieee80211_info_set_tx_time_est(info, airtime);
-			ieee80211_sta_update_pending_airtime(local, tx.sta,
-							     txq->ac,
-							     airtime,
-							     false);
-		}
+		if (!airtime)
+			return skb;
+
+		airtime = ieee80211_info_set_tx_time_est(info, airtime);
+		info->tx_time_mc = !tx.sta;
+		ieee80211_sta_update_pending_airtime(local, tx.sta, txq->ac,
+						     airtime, false,
+						     info->tx_time_mc);
 	}
 
 	return skb;
@@ -4048,6 +4048,7 @@ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
 	struct ieee80211_txq *ret = NULL;
 	struct txq_info *txqi = NULL, *head = NULL;
 	bool found_eligible_txq = false;
+	bool aql_check;
 
 	spin_lock_bh(&local->active_txq_lock[ac]);
 
@@ -4071,26 +4072,26 @@ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
 	if (!head)
 		head = txqi;
 
+	aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
+	if (aql_check)
+		found_eligible_txq = true;
+
 	if (txqi->txq.sta) {
 		struct sta_info *sta = container_of(txqi->txq.sta,
 						    struct sta_info, sta);
-		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
-		s32 deficit = ieee80211_sta_deficit(sta, txqi->txq.ac);
-
-		if (aql_check)
-			found_eligible_txq = true;
-
-		if (deficit < 0)
+		if (ieee80211_sta_deficit(sta, txqi->txq.ac) < 0) {
 			sta->airtime[txqi->txq.ac].deficit +=
-				sta->airtime_weight;
-
-		if (deficit < 0 || !aql_check) {
-			list_move_tail(&txqi->schedule_order,
-				       &local->active_txqs[txqi->txq.ac]);
-			goto begin;
+				sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
+			aql_check = false;
 		}
 	}
 
+	if (!aql_check) {
+		list_move_tail(&txqi->schedule_order,
+				   &local->active_txqs[txqi->txq.ac]);
+		goto begin;
+	}
+
 	if (txqi->schedule_round == local->schedule_round[ac])
 		goto out;
 
@@ -4155,7 +4156,8 @@ bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
 		return true;
 
 	if (!txq->sta)
-		return true;
+		return atomic_read(&local->aql_bc_pending_airtime) <
+		       local->aql_txq_limit_bc;
 
 	if (unlikely(txq->tid == IEEE80211_NUM_TIDS))
 		return true;
@@ -4204,15 +4206,15 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 
 	spin_lock_bh(&local->active_txq_lock[ac]);
 
-	if (!txqi->txq.sta)
-		goto out;
-
 	if (list_empty(&txqi->schedule_order))
 		goto out;
 
 	if (!ieee80211_txq_schedule_airtime_check(local, ac))
 		goto out;
 
+	if (!txqi->txq.sta)
+		goto out;
+
 	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
 				 schedule_order) {
 		if (iter == txqi)
@@ -4225,7 +4227,8 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 		}
 		sta = container_of(iter->txq.sta, struct sta_info, sta);
 		if (ieee80211_sta_deficit(sta, ac) < 0)
-			sta->airtime[ac].deficit += sta->airtime_weight;
+			sta->airtime[ac].deficit += sta->airtime_weight <<
+						    AIRTIME_QUANTUM_SHIFT;
 		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
 	}
 
@@ -4233,7 +4236,7 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 	if (sta->airtime[ac].deficit >= 0)
 		goto out;
 
-	sta->airtime[ac].deficit += sta->airtime_weight;
+	sta->airtime[ac].deficit += sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
 	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
 	spin_unlock_bh(&local->active_txq_lock[ac]);
 
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index 0da5f60..f0455e4 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -3918,19 +3918,103 @@ static u8 ieee80211_chanctx_radar_detect(struct ieee80211_local *local,
 	return radar_detect;
 }
 
+static u32
+__ieee80211_get_radio_mask(struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_bss_conf *link_conf;
+	struct ieee80211_chanctx_conf *conf;
+	unsigned int link_id;
+	u32 mask = 0;
+
+	for_each_vif_active_link(&sdata->vif, link_conf, link_id) {
+		conf = sdata_dereference(link_conf->chanctx_conf, sdata);
+		if (!conf || conf->radio_idx < 0)
+			continue;
+
+		mask |= BIT(conf->radio_idx);
+	}
+
+	return mask;
+}
+
+u32 ieee80211_get_radio_mask(struct wiphy *wiphy, struct net_device *dev)
+{
+	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+
+	return __ieee80211_get_radio_mask(sdata);
+}
+
+static bool
+ieee80211_sdata_uses_radio(struct ieee80211_sub_if_data *sdata, int radio_idx)
+{
+	if (radio_idx < 0)
+		return true;
+
+	return __ieee80211_get_radio_mask(sdata) & BIT(radio_idx);
+}
+
+static int
+ieee80211_fill_ifcomb_params(struct ieee80211_local *local,
+			     struct iface_combination_params *params,
+			     const struct cfg80211_chan_def *chandef,
+			     struct ieee80211_sub_if_data *sdata)
+{
+	struct ieee80211_sub_if_data *sdata_iter;
+	struct ieee80211_chanctx *ctx;
+	int total = !!sdata;
+
+	list_for_each_entry(ctx, &local->chanctx_list, list) {
+		if (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)
+			continue;
+
+		if (params->radio_idx >= 0 &&
+		    ctx->conf.radio_idx != params->radio_idx)
+			continue;
+
+		params->radar_detect |=
+			ieee80211_chanctx_radar_detect(local, ctx);
+
+		if (chandef && ctx->mode != IEEE80211_CHANCTX_EXCLUSIVE &&
+		    cfg80211_chandef_compatible(chandef, &ctx->conf.def))
+			continue;
+
+		params->num_different_channels++;
+	}
+
+	list_for_each_entry(sdata_iter, &local->interfaces, list) {
+		struct wireless_dev *wdev_iter;
+
+		wdev_iter = &sdata_iter->wdev;
+
+		if (sdata_iter == sdata ||
+		    !ieee80211_sdata_running(sdata_iter) ||
+		    cfg80211_iftype_allowed(local->hw.wiphy,
+					    wdev_iter->iftype, 0, 1))
+			continue;
+
+		if (!ieee80211_sdata_uses_radio(sdata_iter, params->radio_idx))
+			continue;
+
+		params->iftype_num[wdev_iter->iftype]++;
+		total++;
+	}
+
+	return total;
+}
+
 int ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,
 				 const struct cfg80211_chan_def *chandef,
 				 enum ieee80211_chanctx_mode chanmode,
-				 u8 radar_detect)
+				 u8 radar_detect, int radio_idx)
 {
+	bool shared = chanmode == IEEE80211_CHANCTX_SHARED;
 	struct ieee80211_local *local = sdata->local;
-	struct ieee80211_sub_if_data *sdata_iter;
 	enum nl80211_iftype iftype = sdata->wdev.iftype;
-	struct ieee80211_chanctx *ctx;
-	int total = 1;
 	struct iface_combination_params params = {
 		.radar_detect = radar_detect,
+		.radio_idx = radio_idx,
 	};
+	int total;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
@@ -3967,37 +4051,9 @@ int ieee80211_check_combinations(struct ieee80211_sub_if_data *sdata,
 	if (iftype != NL80211_IFTYPE_UNSPECIFIED)
 		params.iftype_num[iftype] = 1;
 
-	list_for_each_entry(ctx, &local->chanctx_list, list) {
-		if (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)
-			continue;
-		params.radar_detect |=
-			ieee80211_chanctx_radar_detect(local, ctx);
-		if (ctx->mode == IEEE80211_CHANCTX_EXCLUSIVE) {
-			params.num_different_channels++;
-			continue;
-		}
-		if (chandef && chanmode == IEEE80211_CHANCTX_SHARED &&
-		    cfg80211_chandef_compatible(chandef,
-						&ctx->conf.def))
-			continue;
-		params.num_different_channels++;
-	}
-
-	list_for_each_entry_rcu(sdata_iter, &local->interfaces, list) {
-		struct wireless_dev *wdev_iter;
-
-		wdev_iter = &sdata_iter->wdev;
-
-		if (sdata_iter == sdata ||
-		    !ieee80211_sdata_running(sdata_iter) ||
-		    cfg80211_iftype_allowed(local->hw.wiphy,
-					    wdev_iter->iftype, 0, 1))
-			continue;
-
-		params.iftype_num[wdev_iter->iftype]++;
-		total++;
-	}
-
+	total = ieee80211_fill_ifcomb_params(local, &params,
+					     shared ? chandef : NULL,
+					     sdata);
 	if (total == 1 && !params.radar_detect)
 		return 0;
 
@@ -4014,28 +4070,17 @@ ieee80211_iter_max_chans(const struct ieee80211_iface_combination *c,
 					  c->num_different_channels);
 }
 
-int ieee80211_max_num_channels(struct ieee80211_local *local)
+int ieee80211_max_num_channels(struct ieee80211_local *local, int radio_idx)
 {
-	struct ieee80211_sub_if_data *sdata;
-	struct ieee80211_chanctx *ctx;
 	u32 max_num_different_channels = 1;
 	int err;
-	struct iface_combination_params params = {0};
+	struct iface_combination_params params = {
+		.radio_idx = radio_idx,
+	};
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	list_for_each_entry(ctx, &local->chanctx_list, list) {
-		if (ctx->replace_state == IEEE80211_CHANCTX_WILL_BE_REPLACED)
-			continue;
-
-		params.num_different_channels++;
-
-		params.radar_detect |=
-			ieee80211_chanctx_radar_detect(local, ctx);
-	}
-
-	list_for_each_entry_rcu(sdata, &local->interfaces, list)
-		params.iftype_num[sdata->wdev.iftype]++;
+	ieee80211_fill_ifcomb_params(local, &params, NULL, NULL);
 
 	err = cfg80211_iter_combinations(local->hw.wiphy, &params,
 					 ieee80211_iter_max_chans,
diff --git a/net/mac80211/wpa.c b/net/mac80211/wpa.c
index e40529b..047a337 100644
--- a/net/mac80211/wpa.c
+++ b/net/mac80211/wpa.c
@@ -895,7 +895,8 @@ ieee80211_crypto_aes_cmac_256_encrypt(struct ieee80211_tx_data *tx)
 
 	info = IEEE80211_SKB_CB(skb);
 
-	if (info->control.hw_key)
+	if (info->control.hw_key &&
+	    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIE))
 		return TX_CONTINUE;
 
 	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
@@ -911,6 +912,9 @@ ieee80211_crypto_aes_cmac_256_encrypt(struct ieee80211_tx_data *tx)
 
 	bip_ipn_set64(mmie->sequence_number, pn64);
 
+	if (info->control.hw_key)
+		return TX_CONTINUE;
+
 	bip_aad(skb, aad);
 
 	/* MIC = AES-256-CMAC(IGTK, AAD || Management Frame Body || MMIE, 128)
@@ -1040,7 +1044,8 @@ ieee80211_crypto_aes_gmac_encrypt(struct ieee80211_tx_data *tx)
 
 	info = IEEE80211_SKB_CB(skb);
 
-	if (info->control.hw_key)
+	if (info->control.hw_key &&
+	    !(key->conf.flags & IEEE80211_KEY_FLAG_GENERATE_MMIE))
 		return TX_CONTINUE;
 
 	if (WARN_ON(skb_tailroom(skb) < sizeof(*mmie)))
@@ -1056,6 +1061,9 @@ ieee80211_crypto_aes_gmac_encrypt(struct ieee80211_tx_data *tx)
 
 	bip_ipn_set64(mmie->sequence_number, pn64);
 
+	if (info->control.hw_key)
+		return TX_CONTINUE;
+
 	bip_aad(skb, aad);
 
 	hdr = (struct ieee80211_hdr *)skb->data;
diff --git a/net/wireless/ap.c b/net/wireless/ap.c
index 9a9a870..9cd0ab4 100644
--- a/net/wireless/ap.c
+++ b/net/wireless/ap.c
@@ -30,6 +30,9 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 	if (!wdev->links[link_id].ap.beacon_interval)
 		return -ENOENT;
 
+	cfg80211_update_last_available(wdev->wiphy,
+				       &wdev->links[link_id].ap.chandef);
+
 	err = rdev_stop_ap(rdev, dev, link_id);
 	if (!err) {
 		wdev->conn_owner_nlportid = 0;
@@ -41,9 +44,6 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		if (notify)
 			nl80211_send_ap_stopped(wdev, link_id);
 
-		/* Should we apply the grace period during beaconing interface
-		 * shutdown also?
-		 */
 		cfg80211_sched_dfs_chan_update(rdev);
 	}
 
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index 14c27bc..4bac395 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -560,6 +560,8 @@ static void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,
 
 		c->dfs_state = dfs_state;
 		c->dfs_state_entered = jiffies;
+		if (dfs_state == NL80211_DFS_AVAILABLE)
+			c->dfs_state_last_available = jiffies;
 	}
 }
 
@@ -1049,6 +1051,49 @@ static bool cfg80211_get_chans_dfs_available(struct wiphy *wiphy,
 	return true;
 }
 
+static void
+__cfg80211_update_last_available(struct wiphy *wiphy,
+					 u32 center_freq,
+					 u32 bandwidth)
+{
+	struct ieee80211_channel *c;
+	u32 freq, start_freq, end_freq;
+
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+	/*
+	 * Check entire range of channels for the bandwidth.
+	 * If any channel in between is disabled or has not
+	 * had gone through CAC return false
+	 */
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
+		c = ieee80211_get_channel_khz(wiphy, freq);
+		if (!c)
+			return;
+
+		c->dfs_state_last_available = jiffies;
+	}
+}
+
+void cfg80211_update_last_available(struct wiphy *wiphy,
+				    const struct cfg80211_chan_def *chandef)
+{
+	int width;
+
+	width = cfg80211_chandef_get_width(chandef);
+	if (width < 0)
+		return;
+
+	__cfg80211_update_last_available(wiphy, MHZ_TO_KHZ(chandef->center_freq1),
+						 width);
+	if (chandef->width != NL80211_CHAN_WIDTH_80P80)
+	    return;
+
+	__cfg80211_update_last_available(wiphy, MHZ_TO_KHZ(chandef->center_freq2),
+						 width);
+}
+
 static bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,
 				const struct cfg80211_chan_def *chandef)
 {
diff --git a/net/wireless/core.c b/net/wireless/core.c
index e5dba40..6dd52bc 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -651,21 +651,6 @@ static int wiphy_verify_combinations(struct wiphy *wiphy)
 				    c->limits[j].max > 1))
 				return -EINVAL;
 
-			/*
-			 * This isn't well-defined right now. If you have an
-			 * IBSS interface, then its beacon interval may change
-			 * by joining other networks, and nothing prevents it
-			 * from doing that.
-			 * So technically we probably shouldn't even allow AP
-			 * and IBSS in the same interface, but it seems that
-			 * some drivers support that, possibly only with fixed
-			 * beacon intervals for IBSS.
-			 */
-			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
-				    c->beacon_int_min_gcd)) {
-				return -EINVAL;
-			}
-
 			cnt += c->limits[j].max;
 			/*
 			 * Don't advertise an unsupported type
diff --git a/net/wireless/core.h b/net/wireless/core.h
index 2e19279..7bef6b0 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -467,6 +467,8 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 			    enum nl80211_dfs_state dfs_state);
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work);
+void cfg80211_update_last_available(struct wiphy *wiphy,
+				    const struct cfg80211_chan_def *chandef);
 
 void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
 
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index 3b0fe7c..c7e62eb 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -1037,6 +1037,8 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
 			if (c->dfs_state == NL80211_DFS_UNAVAILABLE) {
 				time_dfs_update = IEEE80211_DFS_MIN_NOP_TIME_MS;
 				radar_event = NL80211_RADAR_NOP_FINISHED;
+				timeout = c->dfs_state_entered +
+					  msecs_to_jiffies(time_dfs_update);
 			} else {
 				if (regulatory_pre_cac_allowed(wiphy) ||
 				    cfg80211_any_wiphy_oper_chan(wiphy, c))
@@ -1044,11 +1046,10 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
 
 				time_dfs_update = REG_PRE_CAC_EXPIRY_GRACE_MS;
 				radar_event = NL80211_RADAR_PRE_CAC_EXPIRED;
+				timeout = c->dfs_state_last_available +
+					  msecs_to_jiffies(time_dfs_update);
 			}
 
-			timeout = c->dfs_state_entered +
-				  msecs_to_jiffies(time_dfs_update);
-
 			if (time_after_eq(jiffies, timeout)) {
 				c->dfs_state = NL80211_DFS_USABLE;
 				c->dfs_state_entered = jiffies;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index e84f978..1332dfd 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -1620,71 +1620,87 @@ nla_put_failure:
 	return -ENOBUFS;
 }
 
-static int nl80211_put_iface_combinations(struct wiphy *wiphy,
-					  struct sk_buff *msg,
-					  bool large)
+static int nl80211_put_ifcomb_data(struct sk_buff *msg, bool large, int idx,
+				   const struct ieee80211_iface_combination *c,
+				   u16 nested)
 {
-	struct nlattr *nl_combis;
-	int i, j;
+	struct nlattr *nl_combi, *nl_limits;
+	int i;
 
-	nl_combis = nla_nest_start_noflag(msg,
-					  NL80211_ATTR_INTERFACE_COMBINATIONS);
-	if (!nl_combis)
+	nl_combi = nla_nest_start_noflag(msg, idx | nested);
+	if (!nl_combi)
 		goto nla_put_failure;
 
-	for (i = 0; i < wiphy->n_iface_combinations; i++) {
-		const struct ieee80211_iface_combination *c;
-		struct nlattr *nl_combi, *nl_limits;
+	nl_limits = nla_nest_start_noflag(msg, NL80211_IFACE_COMB_LIMITS |
+					       nested);
+	if (!nl_limits)
+		goto nla_put_failure;
 
-		c = &wiphy->iface_combinations[i];
+	for (i = 0; i < c->n_limits; i++) {
+		struct nlattr *nl_limit;
 
-		nl_combi = nla_nest_start_noflag(msg, i + 1);
-		if (!nl_combi)
+		nl_limit = nla_nest_start_noflag(msg, i + 1);
+		if (!nl_limit)
 			goto nla_put_failure;
-
-		nl_limits = nla_nest_start_noflag(msg,
-						  NL80211_IFACE_COMB_LIMITS);
-		if (!nl_limits)
+		if (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX, c->limits[i].max))
+			goto nla_put_failure;
+		if (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,
+					c->limits[i].types))
 			goto nla_put_failure;
+		nla_nest_end(msg, nl_limit);
+	}
 
-		for (j = 0; j < c->n_limits; j++) {
-			struct nlattr *nl_limit;
+	nla_nest_end(msg, nl_limits);
 
-			nl_limit = nla_nest_start_noflag(msg, j + 1);
-			if (!nl_limit)
-				goto nla_put_failure;
-			if (nla_put_u32(msg, NL80211_IFACE_LIMIT_MAX,
-					c->limits[j].max))
-				goto nla_put_failure;
-			if (nl80211_put_iftypes(msg, NL80211_IFACE_LIMIT_TYPES,
-						c->limits[j].types))
-				goto nla_put_failure;
-			nla_nest_end(msg, nl_limit);
-		}
+	if (c->beacon_int_infra_match &&
+	    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))
+		goto nla_put_failure;
+	if (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,
+			c->num_different_channels) ||
+	    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,
+			c->max_interfaces))
+		goto nla_put_failure;
+	if (large &&
+	    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
+			c->radar_detect_widths) ||
+	     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
+			c->radar_detect_regions)))
+		goto nla_put_failure;
+	if (c->beacon_int_min_gcd &&
+	    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,
+			c->beacon_int_min_gcd))
+		goto nla_put_failure;
 
-		nla_nest_end(msg, nl_limits);
+	nla_nest_end(msg, nl_combi);
 
-		if (c->beacon_int_infra_match &&
-		    nla_put_flag(msg, NL80211_IFACE_COMB_STA_AP_BI_MATCH))
-			goto nla_put_failure;
-		if (nla_put_u32(msg, NL80211_IFACE_COMB_NUM_CHANNELS,
-				c->num_different_channels) ||
-		    nla_put_u32(msg, NL80211_IFACE_COMB_MAXNUM,
-				c->max_interfaces))
-			goto nla_put_failure;
-		if (large &&
-		    (nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_WIDTHS,
-				c->radar_detect_widths) ||
-		     nla_put_u32(msg, NL80211_IFACE_COMB_RADAR_DETECT_REGIONS,
-				c->radar_detect_regions)))
-			goto nla_put_failure;
-		if (c->beacon_int_min_gcd &&
-		    nla_put_u32(msg, NL80211_IFACE_COMB_BI_MIN_GCD,
-				c->beacon_int_min_gcd))
-			goto nla_put_failure;
+	return 0;
+nla_put_failure:
+	return -ENOBUFS;
+}
+
+static int nl80211_put_iface_combinations(struct wiphy *wiphy,
+					  struct sk_buff *msg,
+					  int attr, int radio,
+					  bool large, u16 nested)
+{
+	const struct ieee80211_iface_combination *c;
+	struct nlattr *nl_combis;
+	int i, n;
+
+	nl_combis = nla_nest_start_noflag(msg, attr | nested);
+	if (!nl_combis)
+		goto nla_put_failure;
 
-		nla_nest_end(msg, nl_combi);
+	if (radio >= 0) {
+		c = wiphy->radio[0].iface_combinations;
+		n = wiphy->radio[0].n_iface_combinations;
+	} else {
+		c = wiphy->iface_combinations;
+		n = wiphy->n_iface_combinations;
 	}
+	for (i = 0; i < n; i++)
+		if (nl80211_put_ifcomb_data(msg, large, i + 1, &c[i], nested))
+			goto nla_put_failure;
 
 	nla_nest_end(msg, nl_combis);
 
@@ -2390,6 +2406,80 @@ fail:
 	return -ENOBUFS;
 }
 
+static int nl80211_put_radio(struct wiphy *wiphy, struct sk_buff *msg, int idx)
+{
+	const struct wiphy_radio *r = &wiphy->radio[idx];
+	struct nlattr *radio, *freq;
+	int i;
+
+	radio = nla_nest_start(msg, idx);
+	if (!radio)
+		return -ENOBUFS;
+
+	if (nla_put_u32(msg, NL80211_WIPHY_RADIO_ATTR_INDEX, idx))
+		goto nla_put_failure;
+
+	for (i = 0; i < r->n_freq_range; i++) {
+		const struct wiphy_radio_freq_range *range = &r->freq_range[i];
+
+		freq = nla_nest_start(msg, NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE);
+		if (!freq)
+			goto nla_put_failure;
+
+		if (nla_put_u32(msg, NL80211_WIPHY_RADIO_FREQ_ATTR_START,
+				range->start_freq) ||
+		    nla_put_u32(msg, NL80211_WIPHY_RADIO_FREQ_ATTR_END,
+				range->end_freq))
+			goto nla_put_failure;
+
+		nla_nest_end(msg, freq);
+	}
+
+	for (i = 0; i < r->n_iface_combinations; i++)
+		if (nl80211_put_ifcomb_data(msg, true,
+					    NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION,
+					    &r->iface_combinations[i],
+					    NLA_F_NESTED))
+			goto nla_put_failure;
+
+	nla_nest_end(msg, radio);
+
+	return 0;
+
+nla_put_failure:
+	return -ENOBUFS;
+}
+
+static int nl80211_put_radios(struct wiphy *wiphy, struct sk_buff *msg)
+{
+	struct nlattr *radios;
+	int i;
+
+	if (!wiphy->n_radio)
+		return 0;
+
+	radios = nla_nest_start(msg, NL80211_ATTR_WIPHY_RADIOS);
+	if (!radios)
+		return -ENOBUFS;
+
+	for (i = 0; i < wiphy->n_radio; i++)
+		if (nl80211_put_radio(wiphy, msg, i))
+			goto fail;
+
+	nla_nest_end(msg, radios);
+
+	if (nl80211_put_iface_combinations(wiphy, msg,
+					   NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS,
+					   -1, true, NLA_F_NESTED))
+		return -ENOBUFS;
+
+	return 0;
+
+fail:
+	nla_nest_cancel(msg, radios);
+	return -ENOBUFS;
+}
+
 struct nl80211_dump_wiphy_state {
 	s64 filter_wiphy;
 	long start;
@@ -2685,7 +2775,9 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 			goto nla_put_failure;
 
 		if (nl80211_put_iface_combinations(&rdev->wiphy, msg,
-						   state->split))
+						   NL80211_ATTR_INTERFACE_COMBINATIONS,
+						   rdev->wiphy.n_radio ? 0 : -1,
+						   state->split, 0))
 			goto nla_put_failure;
 
 		state->split_start++;
@@ -2999,6 +3091,12 @@ static int nl80211_send_wiphy(struct cfg80211_registered_device *rdev,
 				rdev->wiphy.hw_timestamp_max_peers))
 			goto nla_put_failure;
 
+		state->split_start++;
+		break;
+	case 17:
+		if (nl80211_put_radios(&rdev->wiphy, msg))
+			goto nla_put_failure;
+
 		/* done */
 		state->split_start = 0;
 		break;
@@ -16383,9 +16481,14 @@ static u32 nl80211_internal_flags[] = {
 #undef SELECTOR
 };
 
+#if LINUX_VERSION_IS_LESS(6,2,0)
+static int nl80211_pre_doit(const struct genl_ops *ops, struct sk_buff *skb,
+			    struct genl_info *info)
+#else
 static int nl80211_pre_doit(const struct genl_split_ops *ops,
 			    struct sk_buff *skb,
 			    struct genl_info *info)
+#endif
 {
 	struct cfg80211_registered_device *rdev = NULL;
 	struct wireless_dev *wdev = NULL;
@@ -16485,9 +16588,14 @@ out_unlock:
 	return err;
 }
 
+#if LINUX_VERSION_IS_LESS(6,2,0)
+static void nl80211_post_doit(const struct genl_ops *ops, struct sk_buff *skb,
+			      struct genl_info *info)
+#else
 static void nl80211_post_doit(const struct genl_split_ops *ops,
 			      struct sk_buff *skb,
 			      struct genl_info *info)
+#endif
 {
 	u32 internal_flags = nl80211_internal_flags[ops->internal_flags];
 
diff --git a/net/wireless/rdev-ops.h b/net/wireless/rdev-ops.h
index 466828f..897e29d 100644
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@ -1542,4 +1542,16 @@ rdev_set_ttlm(struct cfg80211_registered_device *rdev,
 
 	return ret;
 }
+
+static inline u32
+rdev_get_radio_mask(struct cfg80211_registered_device *rdev,
+		    struct net_device *dev)
+{
+	struct wiphy *wiphy = &rdev->wiphy;
+
+	if (!rdev->ops->get_radio_mask)
+		return 0;
+
+	return rdev->ops->get_radio_mask(wiphy, dev);
+}
 #endif /* __CFG80211_RDEV_OPS */
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index f43123a..0962530 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -3364,6 +3364,8 @@ void regulatory_hint_country_ie(struct wiphy *wiphy, enum nl80211_band band,
 	enum environment_cap env = ENVIRON_ANY;
 	struct regulatory_request *request = NULL, *lr;
 
+	return;
+
 	/* IE len must be evenly divisible by 2 */
 	if (country_ie_len & 0x01)
 		return;
@@ -3615,6 +3617,7 @@ static bool is_wiphy_all_set_reg_flag(enum ieee80211_regulatory_flags flag)
 
 void regulatory_hint_disconnect(void)
 {
+	return;
 	/* Restore of regulatory settings is not required when wiphy(s)
 	 * ignore IE from connected access point but clearance of beacon hints
 	 * is required when wiphy(s) supports beacon hints.
diff --git a/net/wireless/sysfs.c b/net/wireless/sysfs.c
index 62f2661..7d0cca8 100644
--- a/net/wireless/sysfs.c
+++ b/net/wireless/sysfs.c
@@ -24,18 +24,35 @@ static inline struct cfg80211_registered_device *dev_to_rdev(
 	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
 }
 
-#define SHOW_FMT(name, fmt, member)					\
+#define SHOW_FMT(name, fmt, member, mode)				\
 static ssize_t name ## _show(struct device *dev,			\
 			      struct device_attribute *attr,		\
 			      char *buf)				\
 {									\
 	return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member);	\
 }									\
-static DEVICE_ATTR_RO(name)
+static DEVICE_ATTR_##mode(name)
 
-SHOW_FMT(index, "%d", wiphy_idx);
-SHOW_FMT(macaddress, "%pM", wiphy.perm_addr);
-SHOW_FMT(address_mask, "%pM", wiphy.addr_mask);
+static ssize_t macaddress_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	u8 mac[ETH_ALEN];
+
+	if (!mac_pton(buf, mac))
+		return -EINVAL;
+
+	if (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')
+		return -EINVAL;
+
+	memcpy(dev_to_rdev(dev)->wiphy.perm_addr, mac, ETH_ALEN);
+
+	return strnlen(buf, len);
+}
+
+SHOW_FMT(index, "%d", wiphy_idx, RO);
+SHOW_FMT(macaddress, "%pM", wiphy.perm_addr, RW);
+SHOW_FMT(address_mask, "%pM", wiphy.addr_mask, RO);
 
 static ssize_t name_show(struct device *dev,
 			 struct device_attribute *attr,
@@ -154,7 +171,11 @@ static SIMPLE_DEV_PM_OPS(wiphy_pm_ops, wiphy_suspend, wiphy_resume);
 #define WIPHY_PM_OPS NULL
 #endif
 
+#if LINUX_VERSION_IS_GEQ(6,2,0)
 static const void *wiphy_namespace(const struct device *d)
+#else
+static const void *wiphy_namespace(struct device *d)
+#endif
 {
 	struct wiphy *wiphy = container_of(d, struct wiphy, dev);
 
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 082c6f9..280f6fd 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -2305,13 +2305,16 @@ static int cfg80211_wdev_bi(struct wireless_dev *wdev)
 
 static void cfg80211_calculate_bi_data(struct wiphy *wiphy, u32 new_beacon_int,
 				       u32 *beacon_int_gcd,
-				       bool *beacon_int_different)
+				       bool *beacon_int_different,
+				       int radio_idx)
 {
+	struct cfg80211_registered_device *rdev;
 	struct wireless_dev *wdev;
 
 	*beacon_int_gcd = 0;
 	*beacon_int_different = false;
 
+	rdev = wiphy_to_rdev(wiphy);
 	list_for_each_entry(wdev, &wiphy->wdev_list, list) {
 		int wdev_bi;
 
@@ -2319,6 +2322,11 @@ static void cfg80211_calculate_bi_data(struct wiphy *wiphy, u32 new_beacon_int,
 		if (wdev->valid_links)
 			continue;
 
+		/* skip wdevs not active on the given wiphy radio */
+		if (radio_idx >= 0 &&
+		    !(rdev_get_radio_mask(rdev, wdev->netdev) & BIT(radio_idx)))
+			continue;
+
 		wdev_bi = cfg80211_wdev_bi(wdev);
 
 		if (!wdev_bi)
@@ -2366,14 +2374,19 @@ int cfg80211_iter_combinations(struct wiphy *wiphy,
 					    void *data),
 			       void *data)
 {
+	const struct wiphy_radio *radio = NULL;
+	const struct ieee80211_iface_combination *c, *cs;
 	const struct ieee80211_regdomain *regdom;
 	enum nl80211_dfs_regions region = 0;
-	int i, j, iftype;
+	int i, j, n, iftype;
 	int num_interfaces = 0;
 	u32 used_iftypes = 0;
 	u32 beacon_int_gcd;
 	bool beacon_int_different;
 
+	if (params->radio_idx >= 0)
+		radio = &wiphy->radio[params->radio_idx];
+
 	/*
 	 * This is a bit strange, since the iteration used to rely only on
 	 * the data given by the driver, but here it now relies on context,
@@ -2385,7 +2398,8 @@ int cfg80211_iter_combinations(struct wiphy *wiphy,
 	 * interfaces (while being brought up) and channel/radar data.
 	 */
 	cfg80211_calculate_bi_data(wiphy, params->new_beacon_int,
-				   &beacon_int_gcd, &beacon_int_different);
+				   &beacon_int_gcd, &beacon_int_different,
+				   params->radio_idx);
 
 	if (params->radar_detect) {
 		rcu_read_lock();
@@ -2402,13 +2416,18 @@ int cfg80211_iter_combinations(struct wiphy *wiphy,
 			used_iftypes |= BIT(iftype);
 	}
 
-	for (i = 0; i < wiphy->n_iface_combinations; i++) {
-		const struct ieee80211_iface_combination *c;
+	if (radio) {
+		cs = radio->iface_combinations;
+		n = radio->n_iface_combinations;
+	} else {
+		cs = wiphy->iface_combinations;
+		n = wiphy->n_iface_combinations;
+	}
+	for (i = 0; i < n; i++) {
 		struct ieee80211_iface_limit *limits;
 		u32 all_iftypes = 0;
 
-		c = &wiphy->iface_combinations[i];
-
+		c = &cs[i];
 		if (num_interfaces > c->max_interfaces)
 			continue;
 		if (params->num_different_channels > c->num_different_channels)
@@ -2865,3 +2884,38 @@ cfg80211_get_iftype_ext_capa(struct wiphy *wiphy, enum nl80211_iftype type)
 	return NULL;
 }
 EXPORT_SYMBOL(cfg80211_get_iftype_ext_capa);
+
+static bool
+ieee80211_radio_freq_range_valid(const struct wiphy_radio *radio,
+				 u32 freq, u32 width)
+{
+	const struct wiphy_radio_freq_range *r;
+	int i;
+
+	for (i = 0; i < radio->n_freq_range; i++) {
+		r = &radio->freq_range[i];
+		if (freq - width / 2 >= r->start_freq &&
+		    freq + width / 2 <= r->end_freq)
+			return true;
+	}
+
+	return false;
+}
+
+bool cfg80211_radio_chandef_valid(const struct wiphy_radio *radio,
+				  const struct cfg80211_chan_def *chandef)
+{
+	u32 freq, width;
+
+	freq = ieee80211_chandef_to_khz(chandef);
+	width = nl80211_chan_width_to_mhz(chandef->width);
+	if (!ieee80211_radio_freq_range_valid(radio, freq, width))
+		return false;
+
+	freq = MHZ_TO_KHZ(chandef->center_freq2);
+	if (freq && !ieee80211_radio_freq_range_valid(radio, freq, width))
+		return false;
+
+	return true;
+}
+EXPORT_SYMBOL(cfg80211_radio_chandef_valid);
-- 
2.39.2

