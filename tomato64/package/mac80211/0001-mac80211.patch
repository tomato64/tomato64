From 705ae5cf8e6c17c10befb4048804274e16d5a5d8 Mon Sep 17 00:00:00 2001
From: lancethepants <lancethepants@gmail.com>
Date: Mon, 14 Apr 2025 14:19:05 -0600
Subject: [PATCH] mac80211

---
 Kconfig.sources                               |   2 -
 Makefile                                      | 115 +--
 Makefile.kernel                               |   2 -
 Makefile.real                                 |  29 +-
 backport-include/net/genetlink.h              |  11 +
 compat/Makefile                               |   3 +-
 compat/Makefile.orig                          |  23 +
 compat/backport-genetlink.c                   |  61 ++
 compat/main.c                                 |  25 -
 compat_version                                |   1 +
 drivers/bus/mhi/host/trace.h                  |  12 +-
 drivers/net/wireless/ath/Kconfig              |   5 +-
 drivers/net/wireless/ath/Makefile             |   2 +-
 drivers/net/wireless/ath/ath.h                |   7 -
 drivers/net/wireless/ath/ath10k/Kconfig       |   6 +
 drivers/net/wireless/ath/ath10k/Makefile      |   2 +-
 drivers/net/wireless/ath/ath10k/core.c        |  13 +
 drivers/net/wireless/ath/ath10k/core.h        |   4 +
 drivers/net/wireless/ath/ath10k/htt.h         |   4 +
 drivers/net/wireless/ath/ath10k/leds.c        |   2 +-
 drivers/net/wireless/ath/ath10k/mac.c         |  65 +-
 drivers/net/wireless/ath/ath10k/pci.c         |  16 +
 drivers/net/wireless/ath/ath10k/snoc.c        |   6 +-
 drivers/net/wireless/ath/ath10k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath10k/trace.h       |  64 +-
 drivers/net/wireless/ath/ath11k/Kconfig       |  13 +-
 drivers/net/wireless/ath/ath11k/Makefile      |   2 +-
 drivers/net/wireless/ath/ath11k/ahb.c         |   6 +-
 drivers/net/wireless/ath/ath11k/core.c        |  33 +-
 drivers/net/wireless/ath/ath11k/dp.c          |  35 +-
 drivers/net/wireless/ath/ath11k/dp.h          |   6 +-
 drivers/net/wireless/ath/ath11k/dp_rx.c       | 117 ++-
 drivers/net/wireless/ath/ath11k/mhi.c         |  49 +-
 drivers/net/wireless/ath/ath11k/mhi.h         |   3 +
 drivers/net/wireless/ath/ath11k/pci.c         |   9 +-
 drivers/net/wireless/ath/ath11k/reg.c         | 201 +----
 drivers/net/wireless/ath/ath11k/reg.h         |   2 +-
 drivers/net/wireless/ath/ath11k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath11k/trace.h       |  44 +-
 drivers/net/wireless/ath/ath12k/trace.h       |  16 +-
 drivers/net/wireless/ath/ath5k/ath5k.h        |   1 +
 drivers/net/wireless/ath/ath5k/base.c         |   8 +-
 drivers/net/wireless/ath/ath5k/debug.c        |  93 ++
 drivers/net/wireless/ath/ath5k/dma.c          |   8 +
 drivers/net/wireless/ath/ath5k/initvals.c     |   6 +
 drivers/net/wireless/ath/ath5k/mac80211-ops.c |   9 +-
 drivers/net/wireless/ath/ath5k/pci.c          |  26 +-
 drivers/net/wireless/ath/ath5k/reset.c        |   2 +
 drivers/net/wireless/ath/ath6kl/trace.h       |   4 +-
 drivers/net/wireless/ath/regd.c               |  72 +-
 drivers/net/wireless/ath/regd_common.h        |   3 +
 drivers/net/wireless/ath/trace.h              |   4 +-
 drivers/net/wireless/ath/wil6210/cfg80211.c   |   1 +
 drivers/net/wireless/broadcom/b43/Kconfig     |   2 +-
 drivers/net/wireless/broadcom/b43/Makefile    |   2 +-
 drivers/net/wireless/broadcom/b43/b43.h       |   3 +
 drivers/net/wireless/broadcom/b43/dma.h       |   2 +-
 drivers/net/wireless/broadcom/b43/main.c      |  82 +-
 drivers/net/wireless/broadcom/b43/pio.h       |  34 +-
 .../net/wireless/broadcom/brcm80211/Kconfig   |   2 +-
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    |  36 +
 .../broadcom/brcm80211/brcmfmac/common.c      |   4 +
 .../wireless/broadcom/brcm80211/brcmfmac/of.c |  32 +
 .../broadcom/brcm80211/brcmfmac/tracepoint.h  |   4 +-
 .../broadcom/brcm80211/brcmfmac/usb.c         |   4 +
 .../brcm80211/brcmsmac/brcms_trace_brcmsmac.h |   2 +-
 .../brcmsmac/brcms_trace_brcmsmac_msg.h       |   2 +-
 .../brcmsmac/brcms_trace_brcmsmac_tx.h        |   6 +-
 .../broadcom/brcm80211/brcmsmac/channel.c     |  19 +-
 .../wireless/intel/iwlwifi/iwl-devtrace-msg.h |   2 +-
 .../net/wireless/intel/iwlwifi/iwl-devtrace.h |   2 +-
 drivers/net/wireless/intel/iwlwifi/mvm/tt.c   |  15 +
 drivers/net/wireless/marvell/libertas/cfg.c   |   5 +
 drivers/net/wireless/marvell/libertas/main.c  |   1 +
 drivers/net/wireless/marvell/mwifiex/cmdevt.c |  96 +-
 drivers/net/wireless/marvell/mwifiex/decl.h   |   4 +-
 drivers/net/wireless/marvell/mwifiex/main.h   |   2 +
 .../wireless/marvell/mwifiex/sta_cmdresp.c    |   5 +-
 .../net/wireless/marvell/mwifiex/uap_cmd.c    |   3 +-
 drivers/net/wireless/marvell/mwl8k.c          |   5 +-
 drivers/net/wireless/mediatek/mt7601u/usb.h   |   2 +-
 .../wireless/microchip/wilc1000/cfg80211.c    |   3 +-
 drivers/net/wireless/ralink/rt2x00/Kconfig    |  23 +-
 drivers/net/wireless/ralink/rt2x00/Makefile   |   1 +
 drivers/net/wireless/ralink/rt2x00/rt2800.h   |  29 +-
 .../net/wireless/ralink/rt2x00/rt2800lib.c    | 642 ++++++++------
 .../net/wireless/ralink/rt2x00/rt2800lib.h    |  33 +
 .../net/wireless/ralink/rt2x00/rt2800mmio.c   |  38 +-
 .../net/wireless/ralink/rt2x00/rt2800pci.c    |  10 +
 .../net/wireless/ralink/rt2x00/rt2800soc.c    |  52 +-
 .../net/wireless/ralink/rt2x00/rt2800usb.c    |   7 +
 drivers/net/wireless/ralink/rt2x00/rt2x00.h   |   9 +
 .../net/wireless/ralink/rt2x00/rt2x00dev.c    |  34 +-
 .../net/wireless/ralink/rt2x00/rt2x00eeprom.c | 233 +++++
 .../net/wireless/ralink/rt2x00/rt2x00leds.c   |   3 +
 .../net/wireless/ralink/rt2x00/rt2x00queue.h  |  20 +
 .../net/wireless/ralink/rt2x00/rt2x00soc.c    |  16 +
 drivers/net/wireless/virtual/mac80211_hwsim.c |  14 +
 include/linux/ath5k_platform.h                |  30 +
 include/linux/mhi.h                           | 830 ------------------
 include/linux/rt2x00_platform.h               |  23 +
 include/net/cfg80211.h                        |  25 +
 include/net/mac80211.h                        |  17 +-
 include/trace/events/qrtr.h                   |   2 +-
 include/uapi/linux/nl80211.h                  |  10 +
 kconf/Makefile                                |   6 +-
 kconf/conf.c                                  |  46 +-
 kconf/confdata.c                              |   4 +-
 local-symbols                                 |  12 +-
 local-symbols.orig                            | 492 +++++++++++
 net/mac80211/cfg.c                            |  53 +-
 net/mac80211/chan.c                           |  27 +-
 net/mac80211/debugfs.c                        |  14 +-
 net/mac80211/driver-ops.c                     |   1 +
 net/mac80211/ieee80211_i.h                    |   6 +-
 net/mac80211/iface.c                          |  17 +-
 net/mac80211/main.c                           |  19 +-
 net/mac80211/rc80211_minstrel_ht.c            |  75 +-
 net/mac80211/rc80211_minstrel_ht.h            |   2 +-
 net/mac80211/rx.c                             |  71 +-
 net/mac80211/scan.c                           |  22 +-
 net/mac80211/sta_info.c                       |  25 +-
 net/mac80211/sta_info.h                       |   3 +-
 net/mac80211/status.c                         |  10 +-
 net/mac80211/trace.h                          |   2 +-
 net/mac80211/tx.c                             |  69 +-
 net/mac80211/util.c                           |  14 +-
 net/wireless/ap.c                             |   6 +-
 net/wireless/chan.c                           |  48 +-
 net/wireless/core.c                           |  27 +-
 net/wireless/core.h                           |   3 +
 net/wireless/mlme.c                           |   7 +-
 net/wireless/nl80211.c                        |  68 +-
 net/wireless/rdev-ops.h                       |   5 +-
 net/wireless/reg.c                            |   3 +
 net/wireless/scan.c                           |  10 +-
 net/wireless/sysfs.c                          |  27 +-
 net/wireless/trace.h                          |  12 +-
 net/wireless/util.c                           |  29 +
 net/wireless/wext-compat.c                    |   2 +-
 140 files changed, 2963 insertions(+), 2013 deletions(-)
 create mode 100644 compat/Makefile.orig
 create mode 100644 compat_version
 create mode 100644 drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
 create mode 100644 include/linux/ath5k_platform.h
 delete mode 100644 include/linux/mhi.h
 create mode 100644 include/linux/rt2x00_platform.h
 create mode 100644 local-symbols.orig

diff --git a/Kconfig.sources b/Kconfig.sources
index 0aa62a3..d74affd 100644
--- a/Kconfig.sources
+++ b/Kconfig.sources
@@ -4,8 +4,6 @@ source "$BACKPORT_DIR/compat/Kconfig"
 # these are copied from the kernel
 source "$BACKPORT_DIR/net/wireless/Kconfig"
 source "$BACKPORT_DIR/net/mac80211/Kconfig"
-source "$BACKPORT_DIR/net/qrtr/Kconfig"
-source "$BACKPORT_DIR/drivers/bus/mhi/Kconfig"
 source "$BACKPORT_DIR/drivers/soc/qcom/Kconfig"
 source "$BACKPORT_DIR/drivers/net/wireless/Kconfig"
 source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
diff --git a/Makefile b/Makefile
index 548d813..989faff 100644
--- a/Makefile
+++ b/Makefile
@@ -2,10 +2,10 @@
 # Makefile for the output source package
 #
 
-ifeq ($(KERNELRELEASE),)
+ifeq ($(KERNELVERSION),)
 
 MAKEFLAGS += --no-print-directory
-SHELL := /bin/bash
+SHELL := /usr/bin/env bash
 BACKPORT_DIR := $(shell pwd)
 
 KMODDIR ?= updates
@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
 KERNEL_CONFIG := $(KLIB_BUILD)/.config
 KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
 CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
 
 export KLIB KLIB_BUILD BACKPORT_DIR KMODDIR KMODPATH_ARG
 
@@ -36,7 +37,8 @@ mrproper:
 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
 	@rm -f backport-include/backport/autoconf.h
 
-.DEFAULT:
+.SILENT: $(STAMP_KERNEL_CONFIG)
+$(STAMP_KERNEL_CONFIG):
 	@set -e ; test -f local-symbols || (						\
 	echo "/--------------"								;\
 	echo "| You shouldn't run make in the backports tree, but only in"		;\
@@ -60,57 +62,62 @@ mrproper:
 	echo "| (that isn't currently running.)"					;\
 	echo "\\--"									;\
 	false)
-	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
-	then 										\
-		echo -n "Generating local configuration database from kernel ..."	;\
-		grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
-			while read l ; do						\
-				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-					continue					;\
-				fi							;\
-				l=$${l:7}						;\
-				n=$${l%%=*}						;\
-				v=$${l#*=}						;\
-				if [ "$$v" = "m" ] ; then				\
-					echo config $$n					;\
-					echo '    tristate' 				;\
-				elif [ "$$v" = "y" ] ; then				\
-					echo config $$n					;\
-					echo '    bool'					;\
-				else							\
-					continue					;\
-				fi							;\
-				echo "    default $$v"					;\
-				echo ""							;\
-			done								\
-		) > Kconfig.kernel							;\
-		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
-			kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
-		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-		test "$$kver" != ""							;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
-		kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
-		print=0									;\
-		for v in $$kvers ; do							\
-			if [ "$$print" = "1" ] ; then					\
-				echo config KERNEL_$$(echo $$v | tr . _)	;\
-				echo "    def_bool y"					;\
-			fi								;\
-			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-		done > Kconfig.versions							;\
-		# RHEL as well, sadly we need to grep for it				;\
-		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-			echo "    def_bool y"						;\
-		done >> Kconfig.versions						;\
-		echo " done."								;\
-	fi										;\
-	echo "$(CONFIG_MD5)" > .kernel_config_md5
+	@rm -f .kernel_config_md5_*
+	@touch $@
+
+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) local-symbols
+	@printf "Generating local configuration database from kernel ..."
+	@grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
+		while read l ; do						\
+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
+				continue					;\
+			fi							;\
+			l=$${l:7}						;\
+			n=$${l%%=*}						;\
+			v=$${l#*=}						;\
+			if [ "$$v" = "m" ] ; then				\
+				echo config $$n					;\
+				echo '    tristate' 				;\
+			elif [ "$$v" = "y" ] ; then				\
+				echo config $$n					;\
+				echo '    bool'					;\
+			else							\
+				continue					;\
+			fi							;\
+			echo "    default $$v"					;\
+			echo ""							;\
+		done								\
+	) > $@
+	@echo " done."
+
+Kconfig.versions: Kconfig.kernel
+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
+		kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
+	test "$$kver" != ""							;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
+	kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
+	print=0									;\
+	for v in $$kvers ; do							\
+		if [ "$$print" = "1" ] ; then					\
+			echo config KERNEL_$$(echo $$v | tr . _)	;\
+			echo "    def_bool y"					;\
+		fi								;\
+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
+	done > Kconfig.versions							;\
+	# RHEL as well, sadly we need to grep for it				;\
+	RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
+		echo "    def_bool y"						;\
+	done >> $@
+
+.DEFAULT:
+	@$(MAKE) Kconfig.versions
 	@$(MAKE) -f Makefile.real "$@"
 
 .PHONY: defconfig-help
diff --git a/Makefile.kernel b/Makefile.kernel
index 1437560..495c1c3 100644
--- a/Makefile.kernel
+++ b/Makefile.kernel
@@ -38,9 +38,7 @@ obj-y += compat/
 
 obj-$(CPTCFG_CFG80211) += net/wireless/
 obj-$(CPTCFG_MAC80211) += net/mac80211/
-obj-$(CPTCFG_QRTR) += net/qrtr/
 obj-$(CPTCFG_QCOM_QMI_HELPERS) += drivers/soc/qcom/
-obj-$(CPTCFG_MHI_BUS) += drivers/bus/mhi/
 obj-$(CPTCFG_WLAN) += drivers/net/wireless/
 obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
 
diff --git a/Makefile.real b/Makefile.real
index 6550802..971a543 100644
--- a/Makefile.real
+++ b/Makefile.real
@@ -6,6 +6,18 @@ else
 export BACKPORTS_GIT_TRACKER_DEF=
 endif
 
+ifneq ($(LLVM),)
+ifneq ($(filter %/,$(LLVM)),)
+LLVM_PREFIX := $(LLVM)
+else ifneq ($(filter -%,$(LLVM)),)
+LLVM_SUFFIX := $(LLVM)
+endif
+
+HOSTCC	= $(LLVM_PREFIX)clang$(LLVM_SUFFIX)
+else
+HOSTCC	= gcc
+endif
+
 # disable built-in rules for this file
 .SUFFIXES:
 
@@ -24,21 +36,21 @@ listnewconfig oldaskconfig oldconfig \
 silentoldconfig olddefconfig oldnoconfig \
 allnoconfig allyesconfig allmodconfig \
 alldefconfig randconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --$@ Kconfig
 
 .PHONY: usedefconfig
 usedefconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --defconfig=defconfig Kconfig
 
 .PHONY: savedefconfig
 savedefconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --savedefconfig=defconfig Kconfig
 
 defconfig-%::
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --defconfig=defconfigs/$(@:defconfig-%=%) Kconfig
 
 .config:
@@ -59,7 +71,7 @@ defconfig-%::
 
 backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 	@$(MAKE) oldconfig
-	@echo -n "Building backport-include/backport/autoconf.h ..."
+	@printf "Building backport-include/backport/autoconf.h ..."
 	@grep -f local-symbols .config | (				\
 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
@@ -80,7 +92,12 @@ backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 			esac						;\
 		done							;\
 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
-	) > backport-include/backport/autoconf.h
+	) > $@.new
+	@if cmp -s $@ $@.new; then \
+		rm -f $@.new; \
+	else \
+		mv $@.new $@; \
+	fi
 	@echo " done."
 
 .PHONY: modules
diff --git a/backport-include/net/genetlink.h b/backport-include/net/genetlink.h
index e8157e9..979cc3f 100644
--- a/backport-include/net/genetlink.h
+++ b/backport-include/net/genetlink.h
@@ -172,4 +172,15 @@ static inline int genlmsg_parse(const struct nlmsghdr *nlh,
 }
 #endif /* LINUX_VERSION_IS_LESS(5,2,0) */
 
+#if LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) || \
+    LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) || \
+    LINUX_VERSION_IN_RANGE(6,6,0,6,6,58)
+#define genlmsg_multicast_allns LINUX_BACKPORT(genlmsg_multicast_allns)
+int backport_genlmsg_multicast_allns(const struct genl_family *family,
+				     struct sk_buff *skb, u32 portid,
+				     unsigned int group);
+#endif /* LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) ||
+	  LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) ||
+	  LINUX_VERSION_IN_RANGE(6,6,0,6,6,58) */
+
 #endif /* __BACKPORT_NET_GENETLINK_H */
diff --git a/compat/Makefile b/compat/Makefile
index c705150..06fa855 100644
--- a/compat/Makefile
+++ b/compat/Makefile
@@ -16,7 +16,8 @@ compat-$(CPTCFG_KERNEL_5_9) += backport-5.9.o
 compat-$(CPTCFG_KERNEL_5_10) += backport-5.10.o
 compat-$(CPTCFG_KERNEL_5_11) += backport-5.11.o
 compat-$(CPTCFG_KERNEL_5_13) += backport-5.13.o
-compat-$(CPTCFG_KERNEL_5_15) += backport-5.15.o
+compat-$(CPTCFG_KERNEL_5_15) += backport-5.15.o backport-genetlink.o
+compat-$(CPTCFG_KERNEL_6_1) += backport-genetlink.o
 compat-$(CPTCFG_KERNEL_6_4) += backport-6.4.o
 compat-$(CPTCFG_KERNEL_6_11) += backport-6.11.o
 
diff --git a/compat/Makefile.orig b/compat/Makefile.orig
new file mode 100644
index 0000000..c705150
--- /dev/null
+++ b/compat/Makefile.orig
@@ -0,0 +1,23 @@
+ccflags-y += -I$(src) -Wframe-larger-than=1280
+ifeq ($(CONFIG_BACKPORT_INTEGRATE),)
+obj-m += compat.o
+else
+obj-y += compat.o
+endif
+compat-y += main.o
+
+# Kernel backport compatibility code
+compat-$(CPTCFG_KERNEL_4_18) += backport-4.18.o
+compat-$(CPTCFG_KERNEL_4_19) += backport-4.19.o
+compat-$(CPTCFG_KERNEL_5_2) += backport-5.2.o backport-genetlink.o
+compat-$(CPTCFG_KERNEL_5_3) += backport-5.3.o
+compat-$(CPTCFG_KERNEL_5_5) += backport-5.5.o
+compat-$(CPTCFG_KERNEL_5_9) += backport-5.9.o
+compat-$(CPTCFG_KERNEL_5_10) += backport-5.10.o
+compat-$(CPTCFG_KERNEL_5_11) += backport-5.11.o
+compat-$(CPTCFG_KERNEL_5_13) += backport-5.13.o
+compat-$(CPTCFG_KERNEL_5_15) += backport-5.15.o
+compat-$(CPTCFG_KERNEL_6_4) += backport-6.4.o
+compat-$(CPTCFG_KERNEL_6_11) += backport-6.11.o
+
+compat-$(CPTCFG_BPAUTO_BUILD_CRYPTO_LIB_ARC4) += lib-crypto-arc4.o
diff --git a/compat/backport-genetlink.c b/compat/backport-genetlink.c
index a630e2a..57a5c36 100644
--- a/compat/backport-genetlink.c
+++ b/compat/backport-genetlink.c
@@ -17,6 +17,7 @@
 #include <net/netlink.h>
 #include <net/sock.h>
 
+#if LINUX_VERSION_IS_LESS(5,2,0)
 static const struct genl_family *find_family_real_ops(const struct genl_ops **ops)
 {
 	const struct genl_family *family;
@@ -249,3 +250,63 @@ int backport_genlmsg_multicast_allns(const struct genl_family *family,
 	return genlmsg_mcast(skb, portid, group);
 }
 EXPORT_SYMBOL_GPL(backport_genlmsg_multicast_allns);
+#endif /* LINUX_VERSION_IS_LESS(5,2,0) */
+
+#if LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) || \
+    LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) || \
+    LINUX_VERSION_IN_RANGE(6,6,0,6,6,58)
+static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group)
+{
+	struct sk_buff *tmp;
+	struct net *net, *prev = NULL;
+	bool delivered = false;
+	int err;
+
+	rcu_read_lock();
+	for_each_net_rcu(net) {
+		if (prev) {
+			tmp = skb_clone(skb, GFP_ATOMIC);
+			if (!tmp) {
+				err = -ENOMEM;
+				goto error;
+			}
+			err = nlmsg_multicast(prev->genl_sock, tmp,
+					      portid, group, GFP_ATOMIC);
+			if (!err)
+				delivered = true;
+			else if (err != -ESRCH)
+				goto error;
+		}
+
+		prev = net;
+	}
+	err = nlmsg_multicast(prev->genl_sock, skb, portid, group, GFP_ATOMIC);
+
+	rcu_read_unlock();
+
+	if (!err)
+		delivered = true;
+	else if (err != -ESRCH)
+		return err;
+	return delivered ? 0 : -ESRCH;
+ error:
+	rcu_read_unlock();
+
+	kfree_skb(skb);
+	return err;
+}
+
+int backport_genlmsg_multicast_allns(const struct genl_family *family,
+				     struct sk_buff *skb, u32 portid,
+				     unsigned int group)
+{
+	if (WARN_ON_ONCE(group >= family->n_mcgrps))
+		return -EINVAL;
+
+	group = family->mcgrp_offset + group;
+	return genlmsg_mcast(skb, portid, group);
+}
+EXPORT_SYMBOL_GPL(backport_genlmsg_multicast_allns);
+#endif /* LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) ||
+	  LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) ||
+	  LINUX_VERSION_IN_RANGE(6,6,0,6,6,58) */
diff --git a/compat/main.c b/compat/main.c
index d4f3340..651ab63 100644
--- a/compat/main.c
+++ b/compat/main.c
@@ -19,31 +19,6 @@ MODULE_LICENSE("GPL");
 #error "You need a CPTCFG_VERSION"
 #endif
 
-static char *backported_kernel_name = CPTCFG_KERNEL_NAME;
-
-module_param(backported_kernel_name, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_name,
-		 "The kernel tree name that was used for this backport (" CPTCFG_KERNEL_NAME ")");
-
-#ifdef BACKPORTS_GIT_TRACKED
-static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
-module_param(backports_tracker_id, charp, 0400);
-MODULE_PARM_DESC(backports_tracker_id,
-		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
-#else
-static char *backported_kernel_version = CPTCFG_KERNEL_VERSION;
-static char *backports_version = CPTCFG_VERSION;
-
-module_param(backported_kernel_version, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_version,
-		 "The kernel version that was used for this backport (" CPTCFG_KERNEL_VERSION ")");
-
-module_param(backports_version, charp, 0400);
-MODULE_PARM_DESC(backports_version,
-		 "The git version of the backports tree used to generate this backport (" CPTCFG_VERSION ")");
-
-#endif
-
 void backport_dependency_symbol(void)
 {
 }
diff --git a/compat_version b/compat_version
new file mode 100644
index 0000000..6804cfd
--- /dev/null
+++ b/compat_version
@@ -0,0 +1 @@
+compat-wireless-6.9.9-1-r27299-66559946ac
diff --git a/drivers/bus/mhi/host/trace.h b/drivers/bus/mhi/host/trace.h
index 3e0c417..502e2ff 100644
--- a/drivers/bus/mhi/host/trace.h
+++ b/drivers/bus/mhi/host/trace.h
@@ -104,7 +104,7 @@ TRACE_EVENT(mhi_gen_tre,
 	),
 
 	TP_fast_assign(
-		__assign_str(name);
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
 		__entry->ch_num = mhi_chan->chan;
 		__entry->wp = mhi_tre;
 		__entry->tre_ptr = le64_to_cpu(mhi_tre->ptr);
@@ -132,7 +132,7 @@ TRACE_EVENT(mhi_intvec_states,
 	),
 
 	TP_fast_assign(
-		__assign_str(name);
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
 		__entry->local_ee = mhi_cntrl->ee;
 		__entry->state = mhi_cntrl->dev_state;
 		__entry->dev_ee = dev_ee;
@@ -159,7 +159,7 @@ TRACE_EVENT(mhi_tryset_pm_state,
 	),
 
 	TP_fast_assign(
-		__assign_str(name);
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
 		if (pm_state)
 			pm_state = __fls(pm_state);
 		__entry->pm_state = pm_state;
@@ -185,7 +185,7 @@ DECLARE_EVENT_CLASS(mhi_process_event_ring,
 	),
 
 	TP_fast_assign(
-		__assign_str(name);
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
 		__entry->rp = rp;
 		__entry->ptr = le64_to_cpu(rp->ptr);
 		__entry->dword0 = le32_to_cpu(rp->dword[0]);
@@ -227,7 +227,7 @@ DECLARE_EVENT_CLASS(mhi_update_channel_state,
 	),
 
 	TP_fast_assign(
-		__assign_str(name);
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
 		__entry->ch_num = mhi_chan->chan;
 		__entry->state = state;
 		__entry->reason = reason;
@@ -266,7 +266,7 @@ TRACE_EVENT(mhi_pm_st_transition,
 	),
 
 	TP_fast_assign(
-		__assign_str(name);
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
 		__entry->state = state;
 	),
 
diff --git a/drivers/net/wireless/ath/Kconfig b/drivers/net/wireless/ath/Kconfig
index 9ef8d46..bd576b4 100644
--- a/drivers/net/wireless/ath/Kconfig
+++ b/drivers/net/wireless/ath/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: ISC
 config ATH_COMMON
-	tristate
+	tristate "ath.ko"
 	depends on m
 
 config WLAN_VENDOR_ATH
@@ -24,6 +24,9 @@ config WLAN_VENDOR_ATH
 
 if WLAN_VENDOR_ATH
 
+config ATH_USER_REGD
+	bool "Do not enforce EEPROM regulatory restrictions"
+
 config ATH_DEBUG
 	bool "Atheros wireless debugging"
 	help
diff --git a/drivers/net/wireless/ath/Makefile b/drivers/net/wireless/ath/Makefile
index 7432d87..adea25c 100644
--- a/drivers/net/wireless/ath/Makefile
+++ b/drivers/net/wireless/ath/Makefile
@@ -16,10 +16,10 @@ ath-objs :=	main.o \
 		regd.o \
 		hw.o \
 		key.o \
+		debug.o \
 		dfs_pattern_detector.o \
 		dfs_pri_detector.o
 
-ath-$(CPTCFG_ATH_DEBUG) += debug.o
 ath-$(CPTCFG_ATH_TRACEPOINTS) += trace.o
 
 CFLAGS_trace.o := -I$(src)
diff --git a/drivers/net/wireless/ath/ath.h b/drivers/net/wireless/ath/ath.h
index 1bfd992..eb63efd 100644
--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -321,14 +321,7 @@ void _ath_dbg(struct ath_common *common, enum ATH_DEBUG dbg_mask,
 #endif /* CPTCFG_ATH_DEBUG */
 
 /** Returns string describing opmode, or NULL if unknown mode. */
-#ifdef CPTCFG_ATH_DEBUG
 const char *ath_opmode_to_string(enum nl80211_iftype opmode);
-#else
-static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
-{
-	return "UNKNOWN";
-}
-#endif
 
 extern const char *ath_bus_type_strings[];
 static inline const char *ath_bus_type_to_string(enum ath_bus_type bustype)
diff --git a/drivers/net/wireless/ath/ath10k/Kconfig b/drivers/net/wireless/ath/ath10k/Kconfig
index 57c3be9..d8f919c 100644
--- a/drivers/net/wireless/ath/ath10k/Kconfig
+++ b/drivers/net/wireless/ath/ath10k/Kconfig
@@ -94,6 +94,12 @@ config ATH10K_TRACING
 	help
 	  Select this to ath10k use tracing infrastructure.
 
+config ATH10K_THERMAL
+	bool "Atheros ath10k thermal monitoring support"
+	depends on THERMAL
+	---help---
+	  Select this to ath10k use hwmon for thermal measurement.
+
 config ATH10K_DFS_CERTIFIED
 	bool "Atheros DFS support for certified platforms"
 	depends on ATH10K && CFG80211_CERTIFICATION_ONUS
diff --git a/drivers/net/wireless/ath/ath10k/Makefile b/drivers/net/wireless/ath/ath10k/Makefile
index 6bc1261..e040d84 100644
--- a/drivers/net/wireless/ath/ath10k/Makefile
+++ b/drivers/net/wireless/ath/ath10k/Makefile
@@ -18,7 +18,7 @@ ath10k_core-y += mac.o \
 ath10k_core-$(CPTCFG_ATH10K_SPECTRAL) += spectral.o
 ath10k_core-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath10k_core-$(CPTCFG_ATH10K_TRACING) += trace.o
-ath10k_core-$(CONFIG_THERMAL) += thermal.o
+ath10k_core-$(CPTCFG_ATH10K_THERMAL) += thermal.o
 ath10k_core-$(CPTCFG_ATH10K_LEDS) += leds.o
 ath10k_core-$(CPTCFG_MAC80211_DEBUGFS) += debugfs_sta.o
 ath10k_core-$(CONFIG_PM) += wow.o
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index b329428..ff87580 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -9,6 +9,7 @@
 #include <linux/module.h>
 #include <linux/firmware.h>
 #include <linux/of.h>
+#include <linux/of_net.h>
 #include <linux/property.h>
 #include <linux/dmi.h>
 #include <linux/ctype.h>
@@ -3411,6 +3412,8 @@ static int ath10k_core_probe_fw(struct ath10k *ar)
 
 	device_get_mac_address(ar->dev, ar->mac_addr);
 
+	of_get_mac_address(ar->dev->of_node, ar->mac_addr);
+
 	ret = ath10k_core_init_firmware_features(ar);
 	if (ret) {
 		ath10k_err(ar, "fatal problem with firmware features: %d\n",
@@ -3539,6 +3542,16 @@ int ath10k_core_register(struct ath10k *ar,
 
 	queue_work(ar->workqueue, &ar->register_work);
 
+	/* OpenWrt requires all PHYs to be initialized to create the
+	 * configuration files during bootup. ath10k violates this
+	 * because it delays the creation of the PHY to a not well defined
+	 * point in the future.
+	 *
+	 * Forcing the work to be done immediately works around this problem
+	 * but may also delay the boot when firmware images cannot be found.
+	 */
+	flush_workqueue(ar->workqueue);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath10k_core_register);
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index b893c43..394c978 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -1315,6 +1315,10 @@ struct ath10k {
 	s32 tx_power_2g_limit;
 	s32 tx_power_5g_limit;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	const char *led_default_trigger;
+#endif
+
 	/* must be last */
 	u8 drv_priv[] __aligned(sizeof(void *));
 };
diff --git a/drivers/net/wireless/ath/ath10k/htt.h b/drivers/net/wireless/ath/ath10k/htt.h
index 603f6de..bea1d16 100644
--- a/drivers/net/wireless/ath/ath10k/htt.h
+++ b/drivers/net/wireless/ath/ath10k/htt.h
@@ -236,7 +236,11 @@ enum htt_rx_ring_flags {
 };
 
 #define HTT_RX_RING_SIZE_MIN 128
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 #define HTT_RX_RING_SIZE_MAX 2048
+#else
+#define HTT_RX_RING_SIZE_MAX 512
+#endif
 #define HTT_RX_RING_SIZE HTT_RX_RING_SIZE_MAX
 #define HTT_RX_RING_FILL_LEVEL (((HTT_RX_RING_SIZE) / 2) - 1)
 #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
diff --git a/drivers/net/wireless/ath/ath10k/leds.c b/drivers/net/wireless/ath/ath10k/leds.c
index 9b1d04e..b82033b 100644
--- a/drivers/net/wireless/ath/ath10k/leds.c
+++ b/drivers/net/wireless/ath/ath10k/leds.c
@@ -70,7 +70,7 @@ int ath10k_leds_register(struct ath10k *ar)
 
 	ar->leds.cdev.name = ar->leds.label;
 	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
-	ar->leds.cdev.default_trigger = ar->leds.wifi_led.default_trigger;
+	ar->leds.cdev.default_trigger = ar->led_default_trigger;
 
 	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
 	if (ret)
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index cff046f..79b44ff 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -1022,6 +1022,40 @@ static inline int ath10k_vdev_setup_sync(struct ath10k *ar)
 	return ar->last_wmi_vdev_start_status;
 }
 
+static u32 ath10k_get_max_antenna_gain(struct ath10k *ar,
+				       u32 ch_max_antenna_gain)
+{
+	u32 max_antenna_gain;
+
+	if (ar->dfs_detector && ar->dfs_detector->region == NL80211_DFS_FCC) {
+		/* FCC allows maximum antenna gain of 6 dBi. 15.247(b)(4):
+		 *
+		 * > (4) The conducted output power limit
+		 * > specified in paragraph (b) of this section
+		 * > is based on the use of antennas
+		 * > with directional gains that do not exceed
+		 * > 6 dBi. Except as shown in paragraph
+		 * > (c) of this section, if transmitting
+		 * > antennas of directional gain greater
+		 * > than 6 dBi are used, the conducted
+		 * > output power from the intentional radiator
+		 * > shall be reduced below the stated
+		 * > values in paragraphs (b)(1), (b)(2),
+		 * > and (b)(3) of this section, as appropriate,
+		 * > by the amount in dB that the
+		 * > directional gain of the antenna exceeds
+		 * > 6 dBi.
+		 *
+		 * https://www.gpo.gov/fdsys/pkg/CFR-2013-title47-vol1/pdf/CFR-2013-title47-vol1-sec15-247.pdf
+		 */
+		max_antenna_gain = 6;
+	} else {
+		max_antenna_gain = 0;
+	}
+
+	return max(ch_max_antenna_gain, max_antenna_gain);
+}
+
 static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 {
 	struct cfg80211_chan_def *chandef = NULL;
@@ -1054,7 +1088,8 @@ static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 	arg.channel.min_power = 0;
 	arg.channel.max_power = channel->max_power * 2;
 	arg.channel.max_reg_power = channel->max_reg_power * 2;
-	arg.channel.max_antenna_gain = channel->max_antenna_gain;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 
 	reinit_completion(&ar->vdev_setup_done);
 	reinit_completion(&ar->vdev_delete_done);
@@ -1500,7 +1535,8 @@ static int ath10k_vdev_start_restart(struct ath10k_vif *arvif,
 	arg.channel.min_power = 0;
 	arg.channel.max_power = chandef->chan->max_power * 2;
 	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
-	arg.channel.max_antenna_gain = chandef->chan->max_antenna_gain;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+					chandef->chan->max_antenna_gain);
 
 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		arg.ssid = arvif->u.ap.ssid;
@@ -3431,7 +3467,8 @@ static int ath10k_update_channel_list(struct ath10k *ar)
 			ch->min_power = 0;
 			ch->max_power = channel->max_power * 2;
 			ch->max_reg_power = channel->max_reg_power * 2;
-			ch->max_antenna_gain = channel->max_antenna_gain;
+			ch->max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 			ch->reg_class_id = 0; /* FIXME */
 
 			/* FIXME: why use only legacy modes, why not any
@@ -9919,6 +9956,21 @@ static int ath10k_mac_init_rd(struct ath10k *ar)
 	return 0;
 }
 
+#ifdef CPTCFG_MAC80211_LEDS
+static const struct ieee80211_tpt_blink ath10k_tpt_blink[] = {
+	{ .throughput = 0 * 1024, .blink_time = 334 },
+	{ .throughput = 1 * 1024, .blink_time = 260 },
+	{ .throughput = 2 * 1024, .blink_time = 220 },
+	{ .throughput = 5 * 1024, .blink_time = 190 },
+	{ .throughput = 10 * 1024, .blink_time = 170 },
+	{ .throughput = 25 * 1024, .blink_time = 150 },
+	{ .throughput = 54 * 1024, .blink_time = 130 },
+	{ .throughput = 120 * 1024, .blink_time = 110 },
+	{ .throughput = 265 * 1024, .blink_time = 80 },
+	{ .throughput = 586 * 1024, .blink_time = 50 },
+};
+#endif
+
 int ath10k_mac_register(struct ath10k *ar)
 {
 	static const u32 cipher_suites[] = {
@@ -10037,7 +10089,6 @@ int ath10k_mac_register(struct ath10k *ar)
 	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
 	ieee80211_hw_set(ar->hw, QUEUE_CONTROL);
 	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
-	ieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);
 
 	if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))
 		ieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);
@@ -10281,6 +10332,12 @@ int ath10k_mac_register(struct ath10k *ar)
 
 	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	ar->led_default_trigger = ieee80211_create_tpt_led_trigger(ar->hw,
+		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath10k_tpt_blink,
+		ARRAY_SIZE(ath10k_tpt_blink));
+#endif
+
 	ret = ieee80211_register_hw(ar->hw);
 	if (ret) {
 		ath10k_err(ar, "failed to register ieee80211: %d\n", ret);
diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
index 36ac452..3c5164c 100644
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -132,7 +132,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 512,
+#else
+		.dest_nentries = 128,
+#endif
 		.recv_cb = ath10k_pci_htt_htc_rx_cb,
 	},
 
@@ -141,7 +145,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 128,
+#else
+		.dest_nentries = 64,
+#endif
 		.recv_cb = ath10k_pci_htc_rx_cb,
 	},
 
@@ -168,7 +176,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 512,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 512,
+#else
+		.dest_nentries = 128,
+#endif
 		.recv_cb = ath10k_pci_htt_rx_cb,
 	},
 
@@ -193,7 +205,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 128,
+#else
+		.dest_nentries = 96,
+#endif
 		.recv_cb = ath10k_pci_pktlog_rx_cb,
 	},
 
diff --git a/drivers/net/wireless/ath/ath10k/snoc.c b/drivers/net/wireless/ath/ath10k/snoc.c
index 0fe47d5..8530550 100644
--- a/drivers/net/wireless/ath/ath10k/snoc.c
+++ b/drivers/net/wireless/ath/ath10k/snoc.c
@@ -1635,10 +1635,10 @@ static int ath10k_fw_init(struct ath10k *ar)
 
 	ar_snoc->fw.dev = &pdev->dev;
 
-	iommu_dom = iommu_paging_domain_alloc(ar_snoc->fw.dev);
-	if (IS_ERR(iommu_dom)) {
+	iommu_dom = iommu_domain_alloc(&platform_bus_type);
+	if (!iommu_dom) {
 		ath10k_err(ar, "failed to allocate iommu domain\n");
-		ret = PTR_ERR(iommu_dom);
+		ret = -ENOMEM;
 		goto err_unregister;
 	}
 
diff --git a/drivers/net/wireless/ath/ath10k/thermal.h b/drivers/net/wireless/ath/ath10k/thermal.h
index 1f4de9f..fcfa3c2 100644
--- a/drivers/net/wireless/ath/ath10k/thermal.h
+++ b/drivers/net/wireless/ath/ath10k/thermal.h
@@ -25,7 +25,7 @@ struct ath10k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH10K_THERMAL)
 int ath10k_thermal_register(struct ath10k *ar);
 void ath10k_thermal_unregister(struct ath10k *ar);
 void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
diff --git a/drivers/net/wireless/ath/ath10k/trace.h b/drivers/net/wireless/ath/ath10k/trace.h
index db8fcbe..52e502c 100644
--- a/drivers/net/wireless/ath/ath10k/trace.h
+++ b/drivers/net/wireless/ath/ath10k/trace.h
@@ -55,8 +55,8 @@ DECLARE_EVENT_CLASS(ath10k_log_event,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk(
@@ -92,8 +92,8 @@ TRACE_EVENT(ath10k_log_dbg,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->level = level;
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
@@ -121,10 +121,10 @@ TRACE_EVENT(ath10k_log_dbg_dump,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
-		__assign_str(msg);
-		__assign_str(prefix);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+		__assign_str(msg, msg);
+		__assign_str(prefix, prefix);
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
@@ -152,8 +152,8 @@ TRACE_EVENT(ath10k_wmi_cmd,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -182,8 +182,8 @@ TRACE_EVENT(ath10k_wmi_event,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -211,8 +211,8 @@ TRACE_EVENT(ath10k_htt_stats,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
@@ -239,8 +239,8 @@ TRACE_EVENT(ath10k_wmi_dbglog,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->hw_type = ar->hw_rev;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -269,8 +269,8 @@ TRACE_EVENT(ath10k_htt_pktlog,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->hw_type = ar->hw_rev;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
@@ -301,8 +301,8 @@ TRACE_EVENT(ath10k_htt_tx,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->msdu_id = msdu_id;
 		__entry->msdu_len = msdu_len;
 		__entry->vdev_id = vdev_id;
@@ -332,8 +332,8 @@ TRACE_EVENT(ath10k_txrx_tx_unref,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->msdu_id = msdu_id;
 	),
 
@@ -358,8 +358,8 @@ DECLARE_EVENT_CLASS(ath10k_hdr_event,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->len = ath10k_frm_hdr_len(data, len);
 		memcpy(__get_dynamic_array(data), data, __entry->len);
 	),
@@ -386,8 +386,8 @@ DECLARE_EVENT_CLASS(ath10k_payload_event,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->len = len - ath10k_frm_hdr_len(data, len);
 		memcpy(__get_dynamic_array(payload),
 		       data + ath10k_frm_hdr_len(data, len), __entry->len);
@@ -435,8 +435,8 @@ TRACE_EVENT(ath10k_htt_rx_desc,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->hw_type = ar->hw_rev;
 		__entry->len = len;
 		memcpy(__get_dynamic_array(rxdesc), data, len);
@@ -472,8 +472,8 @@ TRACE_EVENT(ath10k_wmi_diag_container,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->type = type;
 		__entry->timestamp = timestamp;
 		__entry->code = code;
@@ -505,8 +505,8 @@ TRACE_EVENT(ath10k_wmi_diag,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
 		__entry->len = len;
 		memcpy(__get_dynamic_array(data), data, len);
 	),
diff --git a/drivers/net/wireless/ath/ath11k/Kconfig b/drivers/net/wireless/ath/ath11k/Kconfig
index da6352f..b420e46 100644
--- a/drivers/net/wireless/ath/ath11k/Kconfig
+++ b/drivers/net/wireless/ath/ath11k/Kconfig
@@ -25,9 +25,9 @@ config ATH11K_PCI
 	tristate "Atheros ath11k PCI support"
 	depends on m
 	depends on ATH11K && PCI
-	select MHI_BUS
-	select QRTR
-	select QRTR_MHI
+	depends on MHI_BUS
+	depends on QRTR
+	depends on QRTR_MHI
 	select PCI_PWRCTL_PWRSEQ if HAVE_PWRCTL
 	help
 	  This module adds support for PCIE bus
@@ -62,3 +62,10 @@ config ATH11K_SPECTRAL
 	  Enable ath11k spectral scan support
 
 	  Say Y to enable access to the FFT/spectral data via debugfs.
+
+config ATH11K_THERMAL
+	bool "ath11k thermal sensors and throttling support"
+	depends on ATH11K
+	depends on THERMAL
+	help
+	  Enable ath11k thermal sensors and throttling support.
diff --git a/drivers/net/wireless/ath/ath11k/Makefile b/drivers/net/wireless/ath/ath11k/Makefile
index 307d153..f6249a1 100644
--- a/drivers/net/wireless/ath/ath11k/Makefile
+++ b/drivers/net/wireless/ath/ath11k/Makefile
@@ -24,7 +24,7 @@ ath11k-y += core.o \
 ath11k-$(CPTCFG_ATH11K_DEBUGFS) += debugfs.o debugfs_htt_stats.o debugfs_sta.o
 ath11k-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath11k-$(CPTCFG_ATH11K_TRACING) += trace.o
-ath11k-$(CONFIG_THERMAL) += thermal.o
+ath11k-$(CPTCFG_ATH11K_THERMAL) += thermal.o
 ath11k-$(CPTCFG_ATH11K_SPECTRAL) += spectral.o
 ath11k-$(CONFIG_PM) += wow.o
 
diff --git a/drivers/net/wireless/ath/ath11k/ahb.c b/drivers/net/wireless/ath/ath11k/ahb.c
index 97b12f5..926e51e 100644
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -1031,10 +1031,10 @@ static int ath11k_ahb_fw_resources_init(struct ath11k_base *ab)
 
 	ab_ahb->fw.dev = &pdev->dev;
 
-	iommu_dom = iommu_paging_domain_alloc(ab_ahb->fw.dev);
-	if (IS_ERR(iommu_dom)) {
+	iommu_dom = iommu_domain_alloc(&platform_bus_type);
+	if (!iommu_dom) {
 		ath11k_err(ab, "failed to allocate iommu domain\n");
-		ret = PTR_ERR(iommu_dom);
+		ret = -ENOMEM;
 		goto err_unregister;
 	}
 
diff --git a/drivers/net/wireless/ath/ath11k/core.c b/drivers/net/wireless/ath/ath11k/core.c
index ccf4ad3..01d7f60 100644
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -37,7 +37,7 @@ bool ath11k_ftm_mode;
 module_param_named(ftm_mode, ath11k_ftm_mode, bool, 0444);
 MODULE_PARM_DESC(ftm_mode, "Boots up in factory test mode");
 
-static const struct ath11k_hw_params ath11k_hw_params[] = {
+static struct ath11k_hw_params ath11k_hw_params[] = {
 	{
 		.hw_rev = ATH11K_HW_IPQ8074,
 		.name = "ipq8074 hw2.0",
@@ -170,8 +170,8 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.supports_shadow_regs = false,
 		.idle_ps = false,
 		.supports_sta_ps = false,
-		.coldboot_cal_mm = true,
-		.coldboot_cal_ftm = true,
+		.coldboot_cal_mm = false,
+		.coldboot_cal_ftm = false,
 		.cbcal_restart_fw = true,
 		.fw_mem_mode = 0,
 		.num_vdevs = 16 + 1,
@@ -2147,7 +2147,8 @@ static void ath11k_core_reset(struct work_struct *work)
 static int ath11k_init_hw_params(struct ath11k_base *ab)
 {
 	const struct ath11k_hw_params *hw_params = NULL;
-	int i;
+	u32 fw_mem_mode;
+	int i, ret;
 
 	for (i = 0; i < ARRAY_SIZE(ath11k_hw_params); i++) {
 		hw_params = &ath11k_hw_params[i];
@@ -2163,7 +2164,31 @@ static int ath11k_init_hw_params(struct ath11k_base *ab)
 
 	ab->hw_params = *hw_params;
 
+	ret = of_property_read_u32(ab->dev->of_node,
+				   "qcom,ath11k-fw-memory-mode",
+				   &fw_mem_mode);
+	if (!ret) {
+		if (fw_mem_mode == 0) {
+			ab->hw_params.fw_mem_mode = 0;
+			ab->hw_params.num_vdevs = 16 + 1;
+			ab->hw_params.num_peers = 512;
+		}
+		else if (fw_mem_mode == 1) {
+			ab->hw_params.fw_mem_mode = 1;
+			ab->hw_params.num_vdevs = 8;
+			ab->hw_params.num_peers = 128;
+		} else if (fw_mem_mode == 2) {
+			ab->hw_params.fw_mem_mode = 2;
+			ab->hw_params.num_vdevs = 8;
+			ab->hw_params.num_peers = 128;
+			ab->hw_params.coldboot_cal_mm = false;
+			ab->hw_params.coldboot_cal_ftm = false;
+		} else
+			ath11k_info(ab, "Unsupported FW memory mode: %u\n", fw_mem_mode);
+	}
+
 	ath11k_info(ab, "%s\n", ab->hw_params.name);
+	ath11k_info(ab, "FW memory mode: %d\n", ab->hw_params.fw_mem_mode);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath11k/dp.c b/drivers/net/wireless/ath/ath11k/dp.c
index fbf666d..f124b73 100644
--- a/drivers/net/wireless/ath/ath11k/dp.c
+++ b/drivers/net/wireless/ath/ath11k/dp.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: BSD-3-Clause-Clear
 /*
  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
- * Copyright (c) 2021-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2021-2025 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <crypto/hash.h>
@@ -104,14 +104,12 @@ void ath11k_dp_srng_cleanup(struct ath11k_base *ab, struct dp_srng *ring)
 	if (!ring->vaddr_unaligned)
 		return;
 
-	if (ring->cached) {
-		dma_unmap_single(ab->dev, ring->paddr_unaligned, ring->size,
-				 DMA_FROM_DEVICE);
-		kfree(ring->vaddr_unaligned);
-	} else {
+	if (ring->cached)
+		dma_free_noncoherent(ab->dev, ring->size, ring->vaddr_unaligned,
+				     ring->paddr_unaligned, DMA_FROM_DEVICE);
+	else
 		dma_free_coherent(ab->dev, ring->size, ring->vaddr_unaligned,
 				  ring->paddr_unaligned);
-	}
 
 	ring->vaddr_unaligned = NULL;
 }
@@ -249,25 +247,14 @@ int ath11k_dp_srng_setup(struct ath11k_base *ab, struct dp_srng *ring,
 		default:
 			cached = false;
 		}
-
-		if (cached) {
-			ring->vaddr_unaligned = kzalloc(ring->size, GFP_KERNEL);
-			if (!ring->vaddr_unaligned)
-				return -ENOMEM;
-
-			ring->paddr_unaligned = dma_map_single(ab->dev,
-							       ring->vaddr_unaligned,
-							       ring->size,
-							       DMA_FROM_DEVICE);
-			if (dma_mapping_error(ab->dev, ring->paddr_unaligned)) {
-				kfree(ring->vaddr_unaligned);
-				ring->vaddr_unaligned = NULL;
-				return -ENOMEM;
-			}
-		}
 	}
 
-	if (!cached)
+	if (cached)
+		ring->vaddr_unaligned = dma_alloc_noncoherent(ab->dev, ring->size,
+							      &ring->paddr_unaligned,
+							      DMA_FROM_DEVICE,
+							      GFP_KERNEL);
+	else
 		ring->vaddr_unaligned = dma_alloc_coherent(ab->dev, ring->size,
 							   &ring->paddr_unaligned,
 							   GFP_KERNEL);
diff --git a/drivers/net/wireless/ath/ath11k/dp.h b/drivers/net/wireless/ath/ath11k/dp.h
index 65d2bc0..eaf902c 100644
--- a/drivers/net/wireless/ath/ath11k/dp.h
+++ b/drivers/net/wireless/ath/ath11k/dp.h
@@ -1,7 +1,7 @@
 /* SPDX-License-Identifier: BSD-3-Clause-Clear */
 /*
  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
- * Copyright (c) 2021-2023 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2021-2023, 2025 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #ifndef ATH11K_DP_H
@@ -20,7 +20,6 @@ struct ath11k_ext_irq_grp;
 
 struct dp_rx_tid {
 	u8 tid;
-	u32 *vaddr;
 	dma_addr_t paddr;
 	u32 size;
 	u32 ba_win_sz;
@@ -37,6 +36,9 @@ struct dp_rx_tid {
 	/* Timer info related to fragments */
 	struct timer_list frag_timer;
 	struct ath11k_base *ab;
+	u32 *vaddr_unaligned;
+	dma_addr_t paddr_unaligned;
+	u32 unaligned_size;
 };
 
 #define DP_REO_DESC_FREE_THRESHOLD  64
diff --git a/drivers/net/wireless/ath/ath11k/dp_rx.c b/drivers/net/wireless/ath/ath11k/dp_rx.c
index 40088e6..9c1f594 100644
--- a/drivers/net/wireless/ath/ath11k/dp_rx.c
+++ b/drivers/net/wireless/ath/ath11k/dp_rx.c
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: BSD-3-Clause-Clear
 /*
  * Copyright (c) 2018-2019 The Linux Foundation. All rights reserved.
- * Copyright (c) 2021-2024 Qualcomm Innovation Center, Inc. All rights reserved.
+ * Copyright (c) 2021-2025 Qualcomm Innovation Center, Inc. All rights reserved.
  */
 
 #include <linux/ieee80211.h>
@@ -675,11 +675,11 @@ void ath11k_dp_reo_cmd_list_cleanup(struct ath11k_base *ab)
 	list_for_each_entry_safe(cmd, tmp, &dp->reo_cmd_list, list) {
 		list_del(&cmd->list);
 		rx_tid = &cmd->data;
-		if (rx_tid->vaddr) {
-			dma_unmap_single(ab->dev, rx_tid->paddr,
-					 rx_tid->size, DMA_BIDIRECTIONAL);
-			kfree(rx_tid->vaddr);
-			rx_tid->vaddr = NULL;
+		if (rx_tid->vaddr_unaligned) {
+			dma_free_noncoherent(ab->dev, rx_tid->unaligned_size,
+					     rx_tid->vaddr_unaligned,
+					     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+			rx_tid->vaddr_unaligned = NULL;
 		}
 		kfree(cmd);
 	}
@@ -689,11 +689,11 @@ void ath11k_dp_reo_cmd_list_cleanup(struct ath11k_base *ab)
 		list_del(&cmd_cache->list);
 		dp->reo_cmd_cache_flush_count--;
 		rx_tid = &cmd_cache->data;
-		if (rx_tid->vaddr) {
-			dma_unmap_single(ab->dev, rx_tid->paddr,
-					 rx_tid->size, DMA_BIDIRECTIONAL);
-			kfree(rx_tid->vaddr);
-			rx_tid->vaddr = NULL;
+		if (rx_tid->vaddr_unaligned) {
+			dma_free_noncoherent(ab->dev, rx_tid->unaligned_size,
+					     rx_tid->vaddr_unaligned,
+					     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+			rx_tid->vaddr_unaligned = NULL;
 		}
 		kfree(cmd_cache);
 	}
@@ -708,11 +708,11 @@ static void ath11k_dp_reo_cmd_free(struct ath11k_dp *dp, void *ctx,
 	if (status != HAL_REO_CMD_SUCCESS)
 		ath11k_warn(dp->ab, "failed to flush rx tid hw desc, tid %d status %d\n",
 			    rx_tid->tid, status);
-	if (rx_tid->vaddr) {
-		dma_unmap_single(dp->ab->dev, rx_tid->paddr, rx_tid->size,
-				 DMA_BIDIRECTIONAL);
-		kfree(rx_tid->vaddr);
-		rx_tid->vaddr = NULL;
+	if (rx_tid->vaddr_unaligned) {
+		dma_free_noncoherent(dp->ab->dev, rx_tid->unaligned_size,
+				     rx_tid->vaddr_unaligned,
+				     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+		rx_tid->vaddr_unaligned = NULL;
 	}
 }
 
@@ -749,10 +749,10 @@ static void ath11k_dp_reo_cache_flush(struct ath11k_base *ab,
 	if (ret) {
 		ath11k_err(ab, "failed to send HAL_REO_CMD_FLUSH_CACHE cmd, tid %d (%d)\n",
 			   rx_tid->tid, ret);
-		dma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,
-				 DMA_BIDIRECTIONAL);
-		kfree(rx_tid->vaddr);
-		rx_tid->vaddr = NULL;
+		dma_free_noncoherent(ab->dev, rx_tid->unaligned_size,
+				     rx_tid->vaddr_unaligned,
+				     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+		rx_tid->vaddr_unaligned = NULL;
 	}
 }
 
@@ -802,10 +802,10 @@ static void ath11k_dp_rx_tid_del_func(struct ath11k_dp *dp, void *ctx,
 
 	return;
 free_desc:
-	dma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,
-			 DMA_BIDIRECTIONAL);
-	kfree(rx_tid->vaddr);
-	rx_tid->vaddr = NULL;
+	dma_free_noncoherent(ab->dev, rx_tid->unaligned_size,
+			     rx_tid->vaddr_unaligned,
+			     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+	rx_tid->vaddr_unaligned = NULL;
 }
 
 void ath11k_peer_rx_tid_delete(struct ath11k *ar,
@@ -831,14 +831,16 @@ void ath11k_peer_rx_tid_delete(struct ath11k *ar,
 		if (ret != -ESHUTDOWN)
 			ath11k_err(ar->ab, "failed to send HAL_REO_CMD_UPDATE_RX_QUEUE cmd, tid %d (%d)\n",
 				   tid, ret);
-		dma_unmap_single(ar->ab->dev, rx_tid->paddr, rx_tid->size,
-				 DMA_BIDIRECTIONAL);
-		kfree(rx_tid->vaddr);
-		rx_tid->vaddr = NULL;
+		dma_free_noncoherent(ar->ab->dev, rx_tid->unaligned_size,
+				     rx_tid->vaddr_unaligned,
+				     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+		rx_tid->vaddr_unaligned = NULL;
 	}
 
 	rx_tid->paddr = 0;
+	rx_tid->paddr_unaligned = 0;
 	rx_tid->size = 0;
+	rx_tid->unaligned_size = 0;
 }
 
 static int ath11k_dp_rx_link_desc_return(struct ath11k_base *ab,
@@ -982,10 +984,9 @@ static void ath11k_dp_rx_tid_mem_free(struct ath11k_base *ab,
 	if (!rx_tid->active)
 		goto unlock_exit;
 
-	dma_unmap_single(ab->dev, rx_tid->paddr, rx_tid->size,
-			 DMA_BIDIRECTIONAL);
-	kfree(rx_tid->vaddr);
-	rx_tid->vaddr = NULL;
+	dma_free_noncoherent(ab->dev, rx_tid->unaligned_size, rx_tid->vaddr_unaligned,
+			     rx_tid->paddr_unaligned, DMA_BIDIRECTIONAL);
+	rx_tid->vaddr_unaligned = NULL;
 
 	rx_tid->active = false;
 
@@ -1000,9 +1001,8 @@ int ath11k_peer_rx_tid_setup(struct ath11k *ar, const u8 *peer_mac, int vdev_id,
 	struct ath11k_base *ab = ar->ab;
 	struct ath11k_peer *peer;
 	struct dp_rx_tid *rx_tid;
-	u32 hw_desc_sz;
-	u32 *addr_aligned;
-	void *vaddr;
+	u32 hw_desc_sz, *vaddr;
+	void *vaddr_unaligned;
 	dma_addr_t paddr;
 	int ret;
 
@@ -1050,49 +1050,40 @@ int ath11k_peer_rx_tid_setup(struct ath11k *ar, const u8 *peer_mac, int vdev_id,
 	else
 		hw_desc_sz = ath11k_hal_reo_qdesc_size(DP_BA_WIN_SZ_MAX, tid);
 
-	vaddr = kzalloc(hw_desc_sz + HAL_LINK_DESC_ALIGN - 1, GFP_ATOMIC);
-	if (!vaddr) {
+	rx_tid->unaligned_size = hw_desc_sz + HAL_LINK_DESC_ALIGN - 1;
+	vaddr_unaligned = dma_alloc_noncoherent(ab->dev, rx_tid->unaligned_size, &paddr,
+						DMA_BIDIRECTIONAL, GFP_ATOMIC);
+	if (!vaddr_unaligned) {
 		spin_unlock_bh(&ab->base_lock);
 		return -ENOMEM;
 	}
 
-	addr_aligned = PTR_ALIGN(vaddr, HAL_LINK_DESC_ALIGN);
-
-	ath11k_hal_reo_qdesc_setup(addr_aligned, tid, ba_win_sz,
-				   ssn, pn_type);
-
-	paddr = dma_map_single(ab->dev, addr_aligned, hw_desc_sz,
-			       DMA_BIDIRECTIONAL);
-
-	ret = dma_mapping_error(ab->dev, paddr);
-	if (ret) {
-		spin_unlock_bh(&ab->base_lock);
-		ath11k_warn(ab, "failed to setup dma map for peer %pM rx tid %d: %d\n",
-			    peer_mac, tid, ret);
-		goto err_mem_free;
-	}
-
-	rx_tid->vaddr = vaddr;
-	rx_tid->paddr = paddr;
+	rx_tid->vaddr_unaligned = vaddr_unaligned;
+	vaddr = PTR_ALIGN(vaddr_unaligned, HAL_LINK_DESC_ALIGN);
+	rx_tid->paddr_unaligned = paddr;
+	rx_tid->paddr = rx_tid->paddr_unaligned + ((unsigned long)vaddr -
+			(unsigned long)rx_tid->vaddr_unaligned);
+	ath11k_hal_reo_qdesc_setup(vaddr, tid, ba_win_sz, ssn, pn_type);
 	rx_tid->size = hw_desc_sz;
 	rx_tid->active = true;
 
+	/* After dma_alloc_noncoherent, vaddr is being modified for reo qdesc setup.
+	 * Since these changes are not reflected in the device, driver now needs to
+	 * explicitly call dma_sync_single_for_device.
+	 */
+	dma_sync_single_for_device(ab->dev, rx_tid->paddr,
+				   rx_tid->size,
+				   DMA_TO_DEVICE);
 	spin_unlock_bh(&ab->base_lock);
 
-	ret = ath11k_wmi_peer_rx_reorder_queue_setup(ar, vdev_id, peer_mac,
-						     paddr, tid, 1, ba_win_sz);
+	ret = ath11k_wmi_peer_rx_reorder_queue_setup(ar, vdev_id, peer_mac, rx_tid->paddr,
+						     tid, 1, ba_win_sz);
 	if (ret) {
 		ath11k_warn(ar->ab, "failed to setup rx reorder queue for peer %pM tid %d: %d\n",
 			    peer_mac, tid, ret);
 		ath11k_dp_rx_tid_mem_free(ab, peer_mac, vdev_id, tid);
 	}
 
-	return ret;
-
-err_mem_free:
-	kfree(rx_tid->vaddr);
-	rx_tid->vaddr = NULL;
-
 	return ret;
 }
 
diff --git a/drivers/net/wireless/ath/ath11k/mhi.c b/drivers/net/wireless/ath/ath11k/mhi.c
index e907a40..8791e57 100644
--- a/drivers/net/wireless/ath/ath11k/mhi.c
+++ b/drivers/net/wireless/ath/ath11k/mhi.c
@@ -239,6 +239,34 @@ static void ath11k_mhi_op_runtime_put(struct mhi_controller *mhi_cntrl)
 {
 }
 
+static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
+				  void __iomem *addr,
+				  u32 *out)
+{
+	*out = readl(addr);
+
+	return 0;
+}
+
+static void ath11k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,
+				    void __iomem *addr,
+				    u32 val)
+{
+	writel(val, addr);
+}
+
+static void ath11k_mhi_qrtr_instance_set(struct mhi_controller *mhi_cntrl)
+{
+	struct ath11k_base *ab = dev_get_drvdata(mhi_cntrl->cntrl_dev);
+
+	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
+		ath11k_mhi_op_write_reg(mhi_cntrl,
+					mhi_cntrl->bhi + BHI_ERRDBG2,
+					FIELD_PREP(QRTR_INSTANCE_MASK,
+					ab->qmi.service_ins_id - ab->hw_params.qmi_service_ins_id));
+	}
+}
+
 static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
 {
 	switch (reason) {
@@ -260,6 +288,8 @@ static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
 		return "MHI_CB_FATAL_ERROR";
 	case MHI_CB_BW_REQ:
 		return "MHI_CB_BW_REQ";
+	case MHI_CB_EE_SBL_MODE:
+		return "MHI_CB_EE_SBL_MODE";
 	default:
 		return "UNKNOWN";
 	}
@@ -289,6 +319,9 @@ static void ath11k_mhi_op_status_cb(struct mhi_controller *mhi_cntrl,
 		if (!(test_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags)))
 			queue_work(ab->workqueue_aux, &ab->reset_work);
 
+		break;
+	case MHI_CB_EE_SBL_MODE:
+		ath11k_mhi_qrtr_instance_set(mhi_cntrl);
 		break;
 	default:
 		break;
@@ -297,22 +330,6 @@ static void ath11k_mhi_op_status_cb(struct mhi_controller *mhi_cntrl,
 	ab_pci->mhi_pre_cb = cb;
 }
 
-static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
-				  void __iomem *addr,
-				  u32 *out)
-{
-	*out = readl(addr);
-
-	return 0;
-}
-
-static void ath11k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,
-				    void __iomem *addr,
-				    u32 val)
-{
-	writel(val, addr);
-}
-
 static int ath11k_mhi_read_addr_from_dt(struct mhi_controller *mhi_ctrl)
 {
 	struct device_node *np;
diff --git a/drivers/net/wireless/ath/ath11k/mhi.h b/drivers/net/wireless/ath/ath11k/mhi.h
index a682aad..8dc6955 100644
--- a/drivers/net/wireless/ath/ath11k/mhi.h
+++ b/drivers/net/wireless/ath/ath11k/mhi.h
@@ -17,6 +17,9 @@
 #define MHICTRL					0x38
 #define MHICTRL_RESET_MASK			0x2
 
+#define BHI_ERRDBG2				0x38
+#define QRTR_INSTANCE_MASK			GENMASK(7, 0)
+
 int ath11k_mhi_start(struct ath11k_pci *ar_pci);
 void ath11k_mhi_stop(struct ath11k_pci *ar_pci);
 int ath11k_mhi_register(struct ath11k_pci *ar_pci);
diff --git a/drivers/net/wireless/ath/ath11k/pci.c b/drivers/net/wireless/ath/ath11k/pci.c
index 548e41b..e5474e6 100644
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -374,13 +374,20 @@ static void ath11k_pci_sw_reset(struct ath11k_base *ab, bool power_on)
 static void ath11k_pci_init_qmi_ce_config(struct ath11k_base *ab)
 {
 	struct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;
+	struct ath11k_pci *ab_pci = ath11k_pci_priv(ab);
+	struct pci_bus *bus = ab_pci->pdev->bus;
 
 	cfg->tgt_ce = ab->hw_params.target_ce_config;
 	cfg->tgt_ce_len = ab->hw_params.target_ce_count;
 
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
-	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+
+	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
+		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id +
+		(((pci_domain_nr(bus) & 0xF) << 4) | (bus->number & 0xF));
+	} else
+		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
 
 	ath11k_ce_get_shadow_config(ab, &cfg->shadow_reg_v2,
 				    &cfg->shadow_reg_v2_len);
diff --git a/drivers/net/wireless/ath/ath11k/reg.c b/drivers/net/wireless/ath/ath11k/reg.c
index 0ba409a..bdf1848 100644
--- a/drivers/net/wireless/ath/ath11k/reg.c
+++ b/drivers/net/wireless/ath/ath11k/reg.c
@@ -361,134 +361,6 @@ static u32 ath11k_map_fw_phy_flags(u32 phy_flags)
 	return flags;
 }
 
-static bool
-ath11k_reg_can_intersect(struct ieee80211_reg_rule *rule1,
-			 struct ieee80211_reg_rule *rule2)
-{
-	u32 start_freq1, end_freq1;
-	u32 start_freq2, end_freq2;
-
-	start_freq1 = rule1->freq_range.start_freq_khz;
-	start_freq2 = rule2->freq_range.start_freq_khz;
-
-	end_freq1 = rule1->freq_range.end_freq_khz;
-	end_freq2 = rule2->freq_range.end_freq_khz;
-
-	if ((start_freq1 >= start_freq2 &&
-	     start_freq1 < end_freq2) ||
-	    (start_freq2 > start_freq1 &&
-	     start_freq2 < end_freq1))
-		return true;
-
-	/* TODO: Should we restrict intersection feasibility
-	 *  based on min bandwidth of the intersected region also,
-	 *  say the intersected rule should have a  min bandwidth
-	 * of 20MHz?
-	 */
-
-	return false;
-}
-
-static void ath11k_reg_intersect_rules(struct ieee80211_reg_rule *rule1,
-				       struct ieee80211_reg_rule *rule2,
-				       struct ieee80211_reg_rule *new_rule)
-{
-	u32 start_freq1, end_freq1;
-	u32 start_freq2, end_freq2;
-	u32 freq_diff, max_bw;
-
-	start_freq1 = rule1->freq_range.start_freq_khz;
-	start_freq2 = rule2->freq_range.start_freq_khz;
-
-	end_freq1 = rule1->freq_range.end_freq_khz;
-	end_freq2 = rule2->freq_range.end_freq_khz;
-
-	new_rule->freq_range.start_freq_khz = max_t(u32, start_freq1,
-						    start_freq2);
-	new_rule->freq_range.end_freq_khz = min_t(u32, end_freq1, end_freq2);
-
-	freq_diff = new_rule->freq_range.end_freq_khz -
-			new_rule->freq_range.start_freq_khz;
-	max_bw = min_t(u32, rule1->freq_range.max_bandwidth_khz,
-		       rule2->freq_range.max_bandwidth_khz);
-	new_rule->freq_range.max_bandwidth_khz = min_t(u32, max_bw, freq_diff);
-
-	new_rule->power_rule.max_antenna_gain =
-		min_t(u32, rule1->power_rule.max_antenna_gain,
-		      rule2->power_rule.max_antenna_gain);
-
-	new_rule->power_rule.max_eirp = min_t(u32, rule1->power_rule.max_eirp,
-					      rule2->power_rule.max_eirp);
-
-	/* Use the flags of both the rules */
-	new_rule->flags = rule1->flags | rule2->flags;
-
-	if ((rule1->flags & NL80211_RRF_PSD) && (rule2->flags & NL80211_RRF_PSD))
-		new_rule->psd = min_t(s8, rule1->psd, rule2->psd);
-	else
-		new_rule->flags &= ~NL80211_RRF_PSD;
-
-	/* To be safe, lts use the max cac timeout of both rules */
-	new_rule->dfs_cac_ms = max_t(u32, rule1->dfs_cac_ms,
-				     rule2->dfs_cac_ms);
-}
-
-static struct ieee80211_regdomain *
-ath11k_regd_intersect(struct ieee80211_regdomain *default_regd,
-		      struct ieee80211_regdomain *curr_regd)
-{
-	u8 num_old_regd_rules, num_curr_regd_rules, num_new_regd_rules;
-	struct ieee80211_reg_rule *old_rule, *curr_rule, *new_rule;
-	struct ieee80211_regdomain *new_regd = NULL;
-	u8 i, j, k;
-
-	num_old_regd_rules = default_regd->n_reg_rules;
-	num_curr_regd_rules = curr_regd->n_reg_rules;
-	num_new_regd_rules = 0;
-
-	/* Find the number of intersecting rules to allocate new regd memory */
-	for (i = 0; i < num_old_regd_rules; i++) {
-		old_rule = default_regd->reg_rules + i;
-		for (j = 0; j < num_curr_regd_rules; j++) {
-			curr_rule = curr_regd->reg_rules + j;
-
-			if (ath11k_reg_can_intersect(old_rule, curr_rule))
-				num_new_regd_rules++;
-		}
-	}
-
-	if (!num_new_regd_rules)
-		return NULL;
-
-	new_regd = kzalloc(sizeof(*new_regd) + (num_new_regd_rules *
-			sizeof(struct ieee80211_reg_rule)),
-			GFP_ATOMIC);
-
-	if (!new_regd)
-		return NULL;
-
-	/* We set the new country and dfs region directly and only trim
-	 * the freq, power, antenna gain by intersecting with the
-	 * default regdomain. Also MAX of the dfs cac timeout is selected.
-	 */
-	new_regd->n_reg_rules = num_new_regd_rules;
-	memcpy(new_regd->alpha2, curr_regd->alpha2, sizeof(new_regd->alpha2));
-	new_regd->dfs_region = curr_regd->dfs_region;
-	new_rule = new_regd->reg_rules;
-
-	for (i = 0, k = 0; i < num_old_regd_rules; i++) {
-		old_rule = default_regd->reg_rules + i;
-		for (j = 0; j < num_curr_regd_rules; j++) {
-			curr_rule = curr_regd->reg_rules + j;
-
-			if (ath11k_reg_can_intersect(old_rule, curr_rule))
-				ath11k_reg_intersect_rules(old_rule, curr_rule,
-							   (new_rule + k++));
-		}
-	}
-	return new_regd;
-}
-
 static const char *
 ath11k_reg_get_regdom_str(enum nl80211_dfs_regions dfs_region)
 {
@@ -639,11 +511,11 @@ ath11k_reg_ap_pwr_convert(enum ieee80211_ap_reg_power power_type)
 
 struct ieee80211_regdomain *
 ath11k_reg_build_regd(struct ath11k_base *ab,
-		      struct cur_regulatory_info *reg_info, bool intersect,
+		      struct cur_regulatory_info *reg_info,
 		      enum wmi_vdev_type vdev_type,
 		      enum ieee80211_ap_reg_power power_type)
 {
-	struct ieee80211_regdomain *tmp_regd, *default_regd, *new_regd = NULL;
+	struct ieee80211_regdomain *new_regd = NULL;
 	struct cur_reg_rule *reg_rule, *reg_rule_6ghz;
 	u8 i = 0, j = 0, k = 0;
 	u8 num_rules;
@@ -686,26 +558,26 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 	}
 
 	if (!num_rules)
-		goto ret;
+		return new_regd;
 
 	/* Add max additional rules to accommodate weather radar band */
 	if (reg_info->dfs_region == ATH11K_DFS_REG_ETSI)
 		num_rules += 2;
 
-	tmp_regd =  kzalloc(sizeof(*tmp_regd) +
+	new_regd =  kzalloc(sizeof(*new_regd) +
 			(num_rules * sizeof(struct ieee80211_reg_rule)),
 			GFP_ATOMIC);
-	if (!tmp_regd)
-		goto ret;
+	if (!new_regd)
+		return new_regd;
 
-	memcpy(tmp_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
+	memcpy(new_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
 	memcpy(alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
 	alpha2[2] = '\0';
-	tmp_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
+	new_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
 
 	ath11k_dbg(ab, ATH11K_DBG_REG,
 		   "Country %s, CFG Regdomain %s FW Regdomain %d, num_reg_rules %d\n",
-		   alpha2, ath11k_reg_get_regdom_str(tmp_regd->dfs_region),
+		   alpha2, ath11k_reg_get_regdom_str(new_regd->dfs_region),
 		   reg_info->dfs_region, num_rules);
 	/* Update reg_rules[] below. Firmware is expected to
 	 * send these rules in order(2 GHz rules first and then 5 GHz)
@@ -744,7 +616,7 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 		flags |= ath11k_map_fw_reg_flags(reg_rule->flags);
 		flags |= ath11k_map_fw_phy_flags(reg_info->phybitmap);
 
-		ath11k_reg_update_rule(tmp_regd->reg_rules + i,
+		ath11k_reg_update_rule(new_regd->reg_rules + i,
 				       reg_rule->start_freq,
 				       reg_rule->end_freq, max_bw,
 				       reg_rule->ant_gain, reg_rule->reg_power,
@@ -759,7 +631,7 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 		    reg_info->dfs_region == ATH11K_DFS_REG_ETSI &&
 		    (reg_rule->end_freq > ETSI_WEATHER_RADAR_BAND_LOW &&
 		    reg_rule->start_freq < ETSI_WEATHER_RADAR_BAND_HIGH)){
-			ath11k_reg_update_weather_radar_band(ab, tmp_regd,
+			ath11k_reg_update_weather_radar_band(ab, new_regd,
 							     reg_rule, &i,
 							     flags, max_bw);
 			continue;
@@ -770,51 +642,23 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d) (%d, %d)\n",
 				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
 				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-				   tmp_regd->reg_rules[i].dfs_cac_ms, flags,
+				   new_regd->reg_rules[i].dfs_cac_ms, flags,
 				   reg_rule->psd_flag, reg_rule->psd_eirp);
 		} else {
 			ath11k_dbg(ab, ATH11K_DBG_REG,
 				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\n",
 				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
 				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-				   tmp_regd->reg_rules[i].dfs_cac_ms,
+				   new_regd->reg_rules[i].dfs_cac_ms,
 				   flags);
 		}
 	}
 
-	tmp_regd->n_reg_rules = i;
-
-	if (intersect) {
-		default_regd = ab->default_regd[reg_info->phy_id];
+	new_regd->n_reg_rules = i;
 
-		/* Get a new regd by intersecting the received regd with
-		 * our default regd.
-		 */
-		new_regd = ath11k_regd_intersect(default_regd, tmp_regd);
-		kfree(tmp_regd);
-		if (!new_regd) {
-			ath11k_warn(ab, "Unable to create intersected regdomain\n");
-			goto ret;
-		}
-	} else {
-		new_regd = tmp_regd;
-	}
-
-ret:
 	return new_regd;
 }
 
-static bool ath11k_reg_is_world_alpha(char *alpha)
-{
-	if (alpha[0] == '0' && alpha[1] == '0')
-		return true;
-
-	if (alpha[0] == 'n' && alpha[1] == 'a')
-		return true;
-
-	return false;
-}
-
 static enum wmi_vdev_type ath11k_reg_get_ar_vdev_type(struct ath11k *ar)
 {
 	struct ath11k_vif *arvif;
@@ -837,7 +681,6 @@ int ath11k_reg_handle_chan_list(struct ath11k_base *ab,
 				enum ieee80211_ap_reg_power power_type)
 {
 	struct ieee80211_regdomain *regd;
-	bool intersect = false;
 	int pdev_idx;
 	struct ath11k *ar;
 	enum wmi_vdev_type vdev_type;
@@ -889,24 +732,14 @@ int ath11k_reg_handle_chan_list(struct ath11k_base *ab,
 		    (char *)reg_info->alpha2, 2))
 		goto retfail;
 
-	/* Intersect new rules with default regd if a new country setting was
-	 * requested, i.e a default regd was already set during initialization
-	 * and the regd coming from this event has a valid country info.
-	 */
-	if (ab->default_regd[pdev_idx] &&
-	    !ath11k_reg_is_world_alpha((char *)
-		ab->default_regd[pdev_idx]->alpha2) &&
-	    !ath11k_reg_is_world_alpha((char *)reg_info->alpha2))
-		intersect = true;
-
 	ar = ab->pdevs[pdev_idx].ar;
 	vdev_type = ath11k_reg_get_ar_vdev_type(ar);
 
 	ath11k_dbg(ab, ATH11K_DBG_WMI,
-		   "wmi handle chan list power type %d vdev type %d intersect %d\n",
-		   power_type, vdev_type, intersect);
+		   "wmi handle chan list power type %d vdev type %d\n",
+		   power_type, vdev_type);
 
-	regd = ath11k_reg_build_regd(ab, reg_info, intersect, vdev_type, power_type);
+	regd = ath11k_reg_build_regd(ab, reg_info, vdev_type, power_type);
 	if (!regd) {
 		ath11k_warn(ab, "failed to build regd from reg_info\n");
 		goto fallback;
diff --git a/drivers/net/wireless/ath/ath11k/reg.h b/drivers/net/wireless/ath/ath11k/reg.h
index 263ea90..bc38dc9 100644
--- a/drivers/net/wireless/ath/ath11k/reg.h
+++ b/drivers/net/wireless/ath/ath11k/reg.h
@@ -35,7 +35,7 @@ void ath11k_reg_free(struct ath11k_base *ab);
 void ath11k_regd_update_work(struct work_struct *work);
 struct ieee80211_regdomain *
 ath11k_reg_build_regd(struct ath11k_base *ab,
-		      struct cur_regulatory_info *reg_info, bool intersect,
+		      struct cur_regulatory_info *reg_info,
 		      enum wmi_vdev_type vdev_type,
 		      enum ieee80211_ap_reg_power power_type);
 int ath11k_regd_update(struct ath11k *ar);
diff --git a/drivers/net/wireless/ath/ath11k/thermal.h b/drivers/net/wireless/ath/ath11k/thermal.h
index cdaf4e0..be102bc 100644
--- a/drivers/net/wireless/ath/ath11k/thermal.h
+++ b/drivers/net/wireless/ath/ath11k/thermal.h
@@ -26,7 +26,7 @@ struct ath11k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH11K_THERMAL)
 int ath11k_thermal_register(struct ath11k_base *ab);
 void ath11k_thermal_unregister(struct ath11k_base *ab);
 int ath11k_thermal_set_throttling(struct ath11k *ar, u32 throttle_state);
diff --git a/drivers/net/wireless/ath/ath11k/trace.h b/drivers/net/wireless/ath/ath11k/trace.h
index 7e7b25d..46ac67b 100644
--- a/drivers/net/wireless/ath/ath11k/trace.h
+++ b/drivers/net/wireless/ath/ath11k/trace.h
@@ -48,8 +48,8 @@ TRACE_EVENT(ath11k_htt_pktlog,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
 		__entry->buf_len = buf_len;
 		__entry->pktlog_checksum = pktlog_checksum;
 		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
@@ -77,8 +77,8 @@ TRACE_EVENT(ath11k_htt_ppdu_stats,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
 		__entry->len = len;
 		memcpy(__get_dynamic_array(ppdu), data, len);
 	),
@@ -105,8 +105,8 @@ TRACE_EVENT(ath11k_htt_rxdesc,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
 		__entry->len = len;
 		__entry->log_type = log_type;
 		memcpy(__get_dynamic_array(rxdesc), data, len);
@@ -130,8 +130,8 @@ DECLARE_EVENT_CLASS(ath11k_log_event,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk(
@@ -171,8 +171,8 @@ TRACE_EVENT(ath11k_wmi_cmd,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -201,8 +201,8 @@ TRACE_EVENT(ath11k_wmi_event,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -230,8 +230,8 @@ TRACE_EVENT(ath11k_log_dbg,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
 		__entry->level = level;
 		WARN_ON_ONCE(vsnprintf(__get_dynamic_array(msg),
 				       ATH11K_MSG_MAX, vaf->fmt,
@@ -262,10 +262,10 @@ TRACE_EVENT(ath11k_log_dbg_dump,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
-		__assign_str(msg);
-		__assign_str(prefix);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+		__assign_str(msg, msg);
+		__assign_str(prefix, prefix);
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
@@ -292,8 +292,8 @@ TRACE_EVENT(ath11k_wmi_diag,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
 		__entry->len = len;
 		memcpy(__get_dynamic_array(data), data, len);
 	),
@@ -318,8 +318,8 @@ TRACE_EVENT(ath11k_ps_timekeeper,
 			 __field(u32, peer_ps_timestamp)
 	),
 
-	TP_fast_assign(__assign_str(device);
-		       __assign_str(driver);
+	TP_fast_assign(__assign_str(device, dev_name(ar->ab->dev));
+		       __assign_str(driver, dev_driver_string(ar->ab->dev));
 		       memcpy(__get_dynamic_array(peer_addr), peer_addr,
 			      ETH_ALEN);
 		       __entry->peer_ps_state = peer_ps_state;
diff --git a/drivers/net/wireless/ath/ath12k/trace.h b/drivers/net/wireless/ath/ath12k/trace.h
index 8f3aef2..142ab30 100644
--- a/drivers/net/wireless/ath/ath12k/trace.h
+++ b/drivers/net/wireless/ath/ath12k/trace.h
@@ -36,8 +36,8 @@ TRACE_EVENT(ath12k_htt_pktlog,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
 		__entry->buf_len = buf_len;
 		__entry->pktlog_checksum = pktlog_checksum;
 		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
@@ -73,8 +73,8 @@ TRACE_EVENT(ath12k_htt_ppdu_stats,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
 		__entry->len = len;
 		__entry->info = ar->pdev->timestamp.info;
 		__entry->sync_tstmp_lo_us = ar->pdev->timestamp.sync_timestamp_hi_us;
@@ -117,8 +117,8 @@ TRACE_EVENT(ath12k_htt_rxdesc,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
 		__entry->len = len;
 		__entry->type = type;
 		__entry->info = ar->pdev->timestamp.info;
@@ -153,8 +153,8 @@ TRACE_EVENT(ath12k_wmi_diag,
 	),
 
 	TP_fast_assign(
-		__assign_str(device);
-		__assign_str(driver);
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
 		__entry->len = len;
 		memcpy(__get_dynamic_array(data), data, len);
 	),
diff --git a/drivers/net/wireless/ath/ath5k/ath5k.h b/drivers/net/wireless/ath/ath5k/ath5k.h
index 308a429..0e6d184 100644
--- a/drivers/net/wireless/ath/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
@@ -1372,6 +1372,7 @@ struct ath5k_hw {
 	u8			ah_coverage_class;
 	bool			ah_ack_bitrate_high;
 	u8			ah_bwmode;
+	u8			ah_bwmode_debug;
 	bool			ah_short_slot;
 
 	/* Antenna Control */
diff --git a/drivers/net/wireless/ath/ath5k/base.c b/drivers/net/wireless/ath/ath5k/base.c
index a9cb132..1e76790 100644
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -465,6 +465,9 @@ ath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef)
 		return -EINVAL;
 	}
 
+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
+		ah->ah_bwmode = ah->ah_bwmode_debug;
+
 	/*
 	 * To switch channels clear any pending DMA operations;
 	 * wait long enough for the RX fifo to drain, reset the
@@ -2009,7 +2012,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
 	}
 
 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
-			ah->num_mesh_vifs > 1) ||
+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
 		u64 tsf = ath5k_hw_get_tsf64(ah);
 		u32 tsftu = TSF_TO_TU(tsf);
@@ -2095,7 +2098,7 @@ ath5k_beacon_update_timers(struct ath5k_hw *ah, u64 bc_tsf)
 
 	intval = ah->bintval & AR5K_BEACON_PERIOD;
 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
-		+ ah->num_mesh_vifs > 1) {
+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
 		if (intval < 15)
 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
@@ -2561,6 +2564,7 @@ static const struct ieee80211_iface_limit if_limits[] = {
 				 BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
 				 BIT(NL80211_IFTYPE_AP) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 static const struct ieee80211_iface_combination if_comb = {
diff --git a/drivers/net/wireless/ath/ath5k/debug.c b/drivers/net/wireless/ath/ath5k/debug.c
index ec13051..239d789 100644
--- a/drivers/net/wireless/ath/ath5k/debug.c
+++ b/drivers/net/wireless/ath/ath5k/debug.c
@@ -803,6 +803,97 @@ static const struct file_operations fops_ani = {
 	.llseek = default_llseek,
 };
 
+/* debugfs: bwmode */
+
+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[15];
+	unsigned int len = 0;
+
+	int cur_ah_bwmode = ah->ah_bwmode_debug;
+
+#define print_selected(MODE, LABEL) \
+	if (cur_ah_bwmode == MODE) \
+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
+	else \
+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
+	len += snprintf(buf+len, sizeof(buf)-len, " ");
+
+	print_selected(AR5K_BWMODE_5MHZ, "5");
+	print_selected(AR5K_BWMODE_10MHZ, "10");
+	print_selected(AR5K_BWMODE_DEFAULT, "20");
+	print_selected(AR5K_BWMODE_40MHZ, "40");
+#undef print_selected
+
+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_bwmode(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[3];
+	int bw = 20;
+	int tobwmode = AR5K_BWMODE_DEFAULT;
+
+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+		return -EFAULT;
+
+	/* TODO: Add check for active interface */
+
+	if(strncmp(buf, "5", 1) == 0 ) {
+		tobwmode = AR5K_BWMODE_5MHZ;
+		bw = 5;
+	} else if ( strncmp(buf, "10", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_10MHZ;
+		bw = 10;
+	} else if ( strncmp(buf, "20", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_DEFAULT;
+		bw = 20;
+	} else if ( strncmp(buf, "40", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_40MHZ;
+		bw = 40;
+	} else
+		return -EINVAL;
+
+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
+		bw, tobwmode);
+
+	switch (ah->ah_radio) {
+	/* TODO: only define radios that actually support 5/10mhz channels */
+	case AR5K_RF5413:
+	case AR5K_RF5110:
+	case AR5K_RF5111:
+	case AR5K_RF5112:
+	case AR5K_RF2413:
+	case AR5K_RF2316:
+	case AR5K_RF2317:
+	case AR5K_RF2425:
+		if(ah->ah_bwmode_debug != tobwmode) {
+			mutex_lock(&ah->lock);
+			ah->ah_bwmode = tobwmode;
+			ah->ah_bwmode_debug = tobwmode;
+			mutex_unlock(&ah->lock);
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return count;
+}
+
+static const struct file_operations fops_bwmode = {
+	.read = read_file_bwmode,
+	.write = write_file_bwmode,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 /* debugfs: queues etc */
 
@@ -995,6 +1086,8 @@ ath5k_debug_init_device(struct ath5k_hw *ah)
 	debugfs_create_file("queue", 0600, phydir, ah, &fops_queue);
 	debugfs_create_bool("32khz_clock", 0600, phydir,
 			    &ah->ah_use_32khz_clock);
+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
+			    &fops_bwmode);
 }
 
 /* functions used in other places */
diff --git a/drivers/net/wireless/ath/ath5k/dma.c b/drivers/net/wireless/ath/ath5k/dma.c
index d9e376e..db06ff8 100644
--- a/drivers/net/wireless/ath/ath5k/dma.c
+++ b/drivers/net/wireless/ath/ath5k/dma.c
@@ -854,10 +854,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
 	 * guess we can tweak it and see how it goes ;-)
 	 */
 	if (ah->ah_version != AR5K_AR5210) {
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
+#else
+		/* WAR for AR71xx PCI bug */
+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
+#endif
 	}
 
 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/drivers/net/wireless/ath/ath5k/initvals.c b/drivers/net/wireless/ath/ath5k/initvals.c
index ee1c2fa..122fe1c 100644
--- a/drivers/net/wireless/ath/ath5k/initvals.c
+++ b/drivers/net/wireless/ath/ath5k/initvals.c
@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini[] = {
 	{ AR5K_IMR,		0 },
 	{ AR5K_IER,		AR5K_IER_DISABLE },
 	{ AR5K_BSR,		0, AR5K_INI_READ },
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
+#else
+	/* WAR for AR71xx PCI bug */
+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
+#endif
 	{ AR5K_CFG,		AR5K_INIT_CFG },
 	{ AR5K_TOPS,		8 },
 	{ AR5K_RXNOFRM,		8 },
diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
index d81b2ad..dd77062 100644
--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		goto end;
 	}
 
-	/* Don't allow other interfaces if one ad-hoc is configured.
-	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
-	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
-	 * for the IBSS, but this breaks with additional AP or STA interfaces
-	 * at the moment. */
-	if (ah->num_adhoc_vifs ||
-	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
+	/* Don't allow more than one ad-hoc interface */
+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
 		ret = -ELNRNG;
 		goto end;
diff --git a/drivers/net/wireless/ath/ath5k/pci.c b/drivers/net/wireless/ath/ath5k/pci.c
index f5ca2fe..111d2d4 100644
--- a/drivers/net/wireless/ath/ath5k/pci.c
+++ b/drivers/net/wireless/ath/ath5k/pci.c
@@ -20,6 +20,7 @@
 #include <linux/pci.h>
 #include <linux/etherdevice.h>
 #include <linux/module.h>
+#include <linux/ath5k_platform.h>
 #include "../ath.h"
 #include "ath5k.h"
 #include "debug.h"
@@ -73,7 +74,7 @@ static void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)
 }
 
 /*
- * Read from eeprom
+ * Read from eeprom or platform_data
  */
 static bool
 ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
@@ -81,6 +82,19 @@ ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
 	struct ath5k_hw *ah = common->ah;
 	u32 status, timeout;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS)
+			return false;
+
+		*data = pdata->eeprom_data[offset];
+		return true;
+	}
+
 	/*
 	 * Initialize EEPROM access
 	 */
@@ -124,6 +138,16 @@ static int ath5k_pci_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)
 	u16 data;
 	int octet;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->macaddr) {
+		memcpy(mac, pdata->macaddr, ETH_ALEN);
+		return 0;
+	}
+
 	AR5K_EEPROM_READ(0x20, data);
 
 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/drivers/net/wireless/ath/ath5k/reset.c b/drivers/net/wireless/ath/ath5k/reset.c
index c67f163..9e1aeee 100644
--- a/drivers/net/wireless/ath/ath5k/reset.c
+++ b/drivers/net/wireless/ath/ath5k/reset.c
@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	tsf_lo = 0;
 	mode = 0;
 
+#if 0
 	/*
 	 * Sanity check for fast flag
 	 * Fast channel change only available
@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	 */
 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
 	(ah->ah_radio != AR5K_RF5413))
+#endif
 		fast = false;
 
 	/* Disable sleep clock operation
diff --git a/drivers/net/wireless/ath/ath6kl/trace.h b/drivers/net/wireless/ath/ath6kl/trace.h
index def9c1d..73da293 100644
--- a/drivers/net/wireless/ath/ath6kl/trace.h
+++ b/drivers/net/wireless/ath/ath6kl/trace.h
@@ -304,8 +304,8 @@ TRACE_EVENT(ath6kl_log_dbg_dump,
 	),
 
 	TP_fast_assign(
-		__assign_str(msg);
-		__assign_str(prefix);
+		__assign_str(msg, msg);
+		__assign_str(prefix, prefix);
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 2afdebf..3ba9fc3 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -24,6 +24,7 @@
 #include "regd_common.h"
 
 static int __ath_regd_init(struct ath_regulatory *reg);
+static struct reg_dmn_pair_mapping *ath_get_regpair(int regdmn);
 
 /*
  * This is a set of common rules used by our world regulatory domains.
@@ -43,7 +44,8 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 #define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
@@ -61,64 +63,79 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 #define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
 				ATH_5GHZ_5725_5850
 
+#define REGD_RULES(...) \
+	.reg_rules = { __VA_ARGS__ }, \
+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
+
 /* Can be used for:
  * 0x60, 0x61, 0x62 */
 static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
-	.n_reg_rules = 5,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_ALL,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x63 and 0x65 */
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x64 only */
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x66 and 0x69 */
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
+{
+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
+}
+
+static bool is_default_regd(struct ath_regulatory *reg)
+{
+	return ath_regd_get_eepromRD(reg) == CTRY_DEFAULT;
+}
+
 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
+
 	if (IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;
 
+	if (is_default_regd(reg))
+		return true;
+
 	switch (reg->country_code) {
 	case CTRY_UNITED_STATES:
 	case CTRY_JAPAN1:
@@ -188,6 +205,8 @@ static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 
 static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
 	if (!IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
 	if (!dynamic_country_user_possible(reg))
@@ -202,11 +221,6 @@ static inline bool is_wwr_sku(u16 regd)
 		(regd == WORLD));
 }
 
-static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
-{
-	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
-}
-
 bool ath_is_world_regd(struct ath_regulatory *reg)
 {
 	return is_wwr_sku(ath_regd_get_eepromRD(reg));
@@ -345,6 +359,9 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
@@ -379,6 +396,9 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 {
 	struct ieee80211_supported_band *sband;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
@@ -408,6 +428,9 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;
 
@@ -640,6 +663,13 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
+
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return 0;
+
+	if (is_default_regd(reg))
+		return 0;
+
 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
 				   REGULATORY_CUSTOM_REG;
 
diff --git a/drivers/net/wireless/ath/regd_common.h b/drivers/net/wireless/ath/regd_common.h
index cdb1e9a..2574f80 100644
--- a/drivers/net/wireless/ath/regd_common.h
+++ b/drivers/net/wireless/ath/regd_common.h
@@ -32,6 +32,7 @@ enum EnumRd {
 	FCC2_WORLD = 0x21,
 	FCC2_ETSIC = 0x22,
 	FCC6_WORLD = 0x23,
+	FCC3_FCCA_2 = 0x2A,
 	FRANCE_RES = 0x31,
 	FCC3_FCCA = 0x3A,
 	FCC3_WORLD = 0x3B,
@@ -173,6 +174,7 @@ static struct reg_dmn_pair_mapping regDomainPairs[] = {
 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC3_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
@@ -486,6 +488,7 @@ static struct country_code_to_enum_rd allCountries[] = {
 	{CTRY_UAE, NULL1_WORLD, "AE"},
 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
 	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
 	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
 	/* This "PS" is for US public safety actually... to support this we
diff --git a/drivers/net/wireless/ath/trace.h b/drivers/net/wireless/ath/trace.h
index 070e61d..956ce6a 100644
--- a/drivers/net/wireless/ath/trace.h
+++ b/drivers/net/wireless/ath/trace.h
@@ -44,8 +44,8 @@ TRACE_EVENT(ath_log,
 	    ),
 
 	    TP_fast_assign(
-		    __assign_str(device);
-		    __assign_str(driver);
+		    __assign_str(device, wiphy_name(wiphy));
+		    __assign_str(driver, KBUILD_MODNAME);
 		    __assign_vstr(msg, vaf->fmt, vaf->va);
 	    ),
 
diff --git a/drivers/net/wireless/ath/wil6210/cfg80211.c b/drivers/net/wireless/ath/wil6210/cfg80211.c
index e8f1d30..a1a0a92 100644
--- a/drivers/net/wireless/ath/wil6210/cfg80211.c
+++ b/drivers/net/wireless/ath/wil6210/cfg80211.c
@@ -1493,6 +1493,7 @@ out:
 }
 
 static int wil_cfg80211_set_channel(struct wiphy *wiphy,
+				    struct net_device *dev,
 				    struct cfg80211_chan_def *chandef)
 {
 	struct wil6210_priv *wil = wiphy_to_wil(wiphy);
diff --git a/drivers/net/wireless/broadcom/b43/Kconfig b/drivers/net/wireless/broadcom/b43/Kconfig
index 84cbe38..5f008b4 100644
--- a/drivers/net/wireless/broadcom/b43/Kconfig
+++ b/drivers/net/wireless/broadcom/b43/Kconfig
@@ -100,7 +100,7 @@ config B43_BCMA_PIO
 	default y
 
 config B43_PIO
-	bool
+	bool "Broadcom 43xx PIO support"
 	depends on B43 && B43_SSB
 	depends on SSB_BLOCKIO
 	default y
diff --git a/drivers/net/wireless/broadcom/b43/Makefile b/drivers/net/wireless/broadcom/b43/Makefile
index f20b692..48589b5 100644
--- a/drivers/net/wireless/broadcom/b43/Makefile
+++ b/drivers/net/wireless/broadcom/b43/Makefile
@@ -18,7 +18,7 @@ b43-$(CPTCFG_B43_PHY_AC)	+= phy_ac.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= dma.o
-b43-y				+= pio.o
+b43-$(CPTCFG_B43_PIO)		+= pio.o
 b43-y				+= rfkill.o
 b43-y				+= ppr.o
 b43-$(CPTCFG_B43_LEDS)		+= leds.o
diff --git a/drivers/net/wireless/broadcom/b43/b43.h b/drivers/net/wireless/broadcom/b43/b43.h
index 0e4ea13..946cfe5 100644
--- a/drivers/net/wireless/broadcom/b43/b43.h
+++ b/drivers/net/wireless/broadcom/b43/b43.h
@@ -840,6 +840,9 @@ struct b43_wldev {
 	bool qos_enabled;		/* TRUE, if QoS is used. */
 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
 	bool use_pio;			/* TRUE if next init should use PIO */
+	int gpiomask;			/* GPIO LED mask as a module parameter */
+	int rx_antenna;			/* Used RX antenna (B43_ANTENNAxxx) */
+	int tx_antenna;			/* Used TX antenna (B43_ANTENNAxxx) */
 
 	/* PHY/Radio device. */
 	struct b43_phy phy;
diff --git a/drivers/net/wireless/broadcom/b43/dma.h b/drivers/net/wireless/broadcom/b43/dma.h
index dfebc64..ec72414 100644
--- a/drivers/net/wireless/broadcom/b43/dma.h
+++ b/drivers/net/wireless/broadcom/b43/dma.h
@@ -170,7 +170,7 @@ struct b43_dmadesc_generic {
 
 /* DMA engine tuning knobs */
 #define B43_TXRING_SLOTS		256
-#define B43_RXRING_SLOTS		256
+#define B43_RXRING_SLOTS		32
 #define B43_DMA0_RX_FW598_BUFSIZE	(B43_DMA0_RX_FW598_FO + IEEE80211_MAX_FRAME_LEN)
 #define B43_DMA0_RX_FW351_BUFSIZE	(B43_DMA0_RX_FW351_FO + IEEE80211_MAX_FRAME_LEN)
 
diff --git a/drivers/net/wireless/broadcom/b43/main.c b/drivers/net/wireless/broadcom/b43/main.c
index 98f5824..baa0755 100644
--- a/drivers/net/wireless/broadcom/b43/main.c
+++ b/drivers/net/wireless/broadcom/b43/main.c
@@ -72,6 +72,11 @@ MODULE_FIRMWARE("b43/ucode40.fw");
 MODULE_FIRMWARE("b43/ucode42.fw");
 MODULE_FIRMWARE("b43/ucode9.fw");
 
+static int modparam_gpiomask = 0x000F;
+module_param_named(gpiomask, modparam_gpiomask, int, 0444);
+MODULE_PARM_DESC(gpiomask,
+         "GPIO mask for LED control (default 0x000F)");
+
 static int modparam_bad_frames_preempt;
 module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
 MODULE_PARM_DESC(bad_frames_preempt,
@@ -109,7 +114,7 @@ static int b43_modparam_pio;
 module_param_named(pio, b43_modparam_pio, int, 0644);
 MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
 
-static int modparam_allhwsupport = !IS_ENABLED(CPTCFG_BRCMSMAC);
+static int modparam_allhwsupport = 1;
 module_param_named(allhwsupport, modparam_allhwsupport, int, 0444);
 MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
 
@@ -1638,7 +1643,7 @@ static void b43_write_beacon_template(struct b43_wldev *dev,
 				  len, ram_offset, shm_size_offset, rate);
 
 	/* Write the PHY TX control parameters. */
-	antenna = B43_ANTENNA_DEFAULT;
+	antenna = dev->tx_antenna;
 	antenna = b43_antenna_to_phyctl(antenna);
 	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
 	/* We can't send beacons with short preamble. Would get PHY errors. */
@@ -1996,10 +2001,12 @@ static void b43_do_interrupt_thread(struct b43_wldev *dev)
 			dma_reason[0], dma_reason[1],
 			dma_reason[2], dma_reason[3],
 			dma_reason[4], dma_reason[5]);
+#ifdef CPTCFG_B43_PIO
 		b43err(dev->wl, "This device does not support DMA "
 			       "on your system. It will now be switched to PIO.\n");
 		/* Fall back to PIO transfers if we get fatal DMA errors! */
 		dev->use_pio = true;
+#endif
 		b43_controller_restart(dev, "DMA error");
 		return;
 	}
@@ -2870,16 +2877,24 @@ static int b43_gpio_init(struct b43_wldev *dev)
 	u32 mask, set;
 
 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
-	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
+	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
 
 	mask = 0x0000001F;
-	set = 0x0000000F;
+	set = modparam_gpiomask;
 	if (dev->dev->chip_id == 0x4301) {
 		mask |= 0x0060;
 		set |= 0x0060;
 	} else if (dev->dev->chip_id == 0x5354) {
 		/* Don't allow overtaking buttons GPIOs */
 		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
+	} else if (dev->dev->chip_id == BCMA_CHIP_ID_BCM4716 || 
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM47162 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5356 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5357 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM53572) {
+		/* just use gpio 0 and 1 for 2.4 GHz wifi led */
+		set &= 0x3;
+		mask &= 0x3;
 	}
 
 	if (0 /* FIXME: conditional unknown */ ) {
@@ -3278,8 +3293,8 @@ static int b43_chip_init(struct b43_wldev *dev)
 
 	/* Select the antennae */
 	if (phy->ops->set_rx_antenna)
-		phy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);
-	b43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);
+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
 
 	if (phy->type == B43_PHYTYPE_B) {
 		value16 = b43_read16(dev, 0x005E);
@@ -3981,7 +3996,6 @@ static int b43_op_config(struct ieee80211_hw *hw, u32 changed)
 	struct b43_wldev *dev = wl->current_dev;
 	struct b43_phy *phy = &dev->phy;
 	struct ieee80211_conf *conf = &hw->conf;
-	int antenna;
 	int err = 0;
 
 	mutex_lock(&wl->mutex);
@@ -4024,11 +4038,9 @@ static int b43_op_config(struct ieee80211_hw *hw, u32 changed)
 	}
 
 	/* Antennas for RX and management frame TX. */
-	antenna = B43_ANTENNA_DEFAULT;
-	b43_mgmtframe_txantenna(dev, antenna);
-	antenna = B43_ANTENNA_DEFAULT;
+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
 	if (phy->ops->set_rx_antenna)
-		phy->ops->set_rx_antenna(dev, antenna);
+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
 
 	if (wl->radio_enabled != phy->radio_on) {
 		if (wl->radio_enabled) {
@@ -5171,6 +5183,47 @@ static int b43_op_get_survey(struct ieee80211_hw *hw, int idx,
 	return 0;
 }
 
+static int b43_op_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev = wl->current_dev;
+
+	if (tx_ant == 1 && rx_ant == 1) {
+		dev->tx_antenna = B43_ANTENNA0;
+		dev->rx_antenna = B43_ANTENNA0;
+	}
+	else if (tx_ant == 2 && rx_ant == 2) {
+		dev->tx_antenna = B43_ANTENNA1;
+		dev->rx_antenna = B43_ANTENNA1;
+	}
+	else if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3) {
+		dev->tx_antenna = B43_ANTENNA_DEFAULT;
+		dev->rx_antenna = B43_ANTENNA_DEFAULT;
+	}
+	else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int b43_op_get_antenna(struct ieee80211_hw *hw, u32 *tx_ant, u32 *rx_ant)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev = wl->current_dev;
+
+	switch (dev->tx_antenna) {
+	case B43_ANTENNA0:
+		*tx_ant = 1; *rx_ant = 1; break;
+	case B43_ANTENNA1:
+		*tx_ant = 2; *rx_ant = 2; break;
+	case B43_ANTENNA_DEFAULT:
+		*tx_ant = 3; *rx_ant = 3; break;
+	}
+	return 0;
+}
+
 static const struct ieee80211_ops b43_hw_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -5197,6 +5250,8 @@ static const struct ieee80211_ops b43_hw_ops = {
 	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
 	.get_survey		= b43_op_get_survey,
 	.rfkill_poll		= b43_rfkill_poll,
+	.set_antenna		= b43_op_set_antenna,
+	.get_antenna		= b43_op_get_antenna,
 };
 
 /* Hard-reset the chip. Do not call this directly.
@@ -5498,6 +5553,8 @@ static int b43_one_core_attach(struct b43_bus_dev *dev, struct b43_wl *wl)
 	if (!wldev)
 		goto out;
 
+	wldev->rx_antenna = B43_ANTENNA_DEFAULT;
+	wldev->tx_antenna = B43_ANTENNA_DEFAULT;
 	wldev->use_pio = b43_modparam_pio;
 	wldev->dev = dev;
 	wldev->wl = wl;
@@ -5589,6 +5646,9 @@ static struct b43_wl *b43_wireless_init(struct b43_bus_dev *dev)
 
 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
 
+	hw->wiphy->available_antennas_rx = 0x3;
+	hw->wiphy->available_antennas_tx = 0x3;
+
 	wl->hw_registered = false;
 	hw->max_rates = 2;
 	SET_IEEE80211_DEV(hw, dev->dev);
diff --git a/drivers/net/wireless/broadcom/b43/pio.h b/drivers/net/wireless/broadcom/b43/pio.h
index ffbfec6..a3742b7 100644
--- a/drivers/net/wireless/broadcom/b43/pio.h
+++ b/drivers/net/wireless/broadcom/b43/pio.h
@@ -151,7 +151,7 @@ static inline void b43_piorx_write32(struct b43_pio_rxqueue *q,
 	b43_write32(q->dev, q->mmio_base + offset, value);
 }
 
-
+#ifdef CPTCFG_B43_PIO
 int b43_pio_init(struct b43_wldev *dev);
 void b43_pio_free(struct b43_wldev *dev);
 
@@ -162,5 +162,37 @@ void b43_pio_rx(struct b43_pio_rxqueue *q);
 
 void b43_pio_tx_suspend(struct b43_wldev *dev);
 void b43_pio_tx_resume(struct b43_wldev *dev);
+#else
+static inline int b43_pio_init(struct b43_wldev *dev)
+{
+	return 0;
+}
+
+static inline void b43_pio_free(struct b43_wldev *dev)
+{
+}
+
+static inline int b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static inline void b43_pio_handle_txstatus(struct b43_wldev *dev,
+					   const struct b43_txstatus *status)
+{
+}
+
+static inline void b43_pio_rx(struct b43_pio_rxqueue *q)
+{
+}
+
+static inline void b43_pio_tx_suspend(struct b43_wldev *dev)
+{
+}
+
+static inline void b43_pio_tx_resume(struct b43_wldev *dev)
+{
+}
+#endif /* CPTCFG_B43_PIO */
 
 #endif /* B43_PIO_H_ */
diff --git a/drivers/net/wireless/broadcom/brcm80211/Kconfig b/drivers/net/wireless/broadcom/brcm80211/Kconfig
index a86ad74..195ceee 100644
--- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
+++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config BRCMUTIL
-	tristate
+	tristate "Broadcom 802.11 driver utility functions"
 	depends on m
 
 config BRCMSMAC
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index 349aa34..87f3298 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -980,8 +980,36 @@ static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
 	struct brcmf_pub *drvr = cfg->pub;
 	struct wireless_dev *wdev;
+	struct net_device *dev;
 	int err;
 
+	/*
+	 * There is a bug with in-firmware BSS management. When adding virtual
+	 * interface brcmfmac first tells firmware to create new BSS and then
+	 * it creates new struct net_device.
+	 *
+	 * If creating/registering netdev(ice) fails, BSS remains in some bugged
+	 * state. It conflicts with existing BSSes by overtaking their auth
+	 * requests.
+	 *
+	 * It results in one BSS (addresss X) sending beacons and another BSS
+	 * (address Y) replying to authentication requests. This makes interface
+	 * unusable as AP.
+	 *
+	 * To workaround this bug we may try to guess if register_netdev(ice)
+	 * will fail. The most obvious case is using interface name that already
+	 * exists. This is actually quite likely with brcmfmac & some user space
+	 * scripts as brcmfmac doesn't allow deleting virtual interfaces.
+	 * So this bug can be triggered even by something trivial like:
+	 * iw dev wlan0 delete
+	 * iw phy phy0 interface add wlan0 type __ap
+	 */
+	dev = dev_get_by_name(&init_net, name);
+	if (dev) {
+		dev_put(dev);
+		return ERR_PTR(-ENFILE);
+	}
+
 	brcmf_dbg(TRACE, "enter: %s type %d\n", name, type);
 	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
 	if (err) {
@@ -3286,6 +3314,10 @@ brcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
 	 * preference in cfg struct to apply this to
 	 * FW later while initializing the dongle
 	 */
+#if defined(CONFIG_ARCH_BCM2835)
+	brcmf_dbg(INFO, "power management disabled\n");
+	enabled = false;
+#endif
 	cfg->pwr_save = enabled;
 	if (!check_vif_up(ifp->vif)) {
 
@@ -7954,6 +7986,7 @@ static s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char alpha2[2],
 	return 0;
 }
 
+#if !defined(CONFIG_ARCH_BCM2835)
 static int
 brcmf_parse_dump_obss(char *buf, struct brcmf_dump_survey *survey)
 {
@@ -8176,6 +8209,7 @@ exit:
 		brcmf_set_mpc(ifp, 1);
 	return err;
 }
+#endif /* CONFIG_ARCH_BCM2835 */
 
 static void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,
 					struct regulatory_request *req)
@@ -8328,8 +8362,10 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))
 		ops->set_rekey_data = brcmf_cfg80211_set_rekey_data;
 #endif
+#if !defined(CONFIG_ARCH_BCM2835)
 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_DUMP_OBSS))
 		ops->dump_survey = brcmf_cfg80211_dump_survey;
+#endif /* CONFIG_ARCH_BCM2835 */
 
 	err = wiphy_register(wiphy);
 	if (err < 0) {
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
index dff464d..d051555 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
@@ -59,7 +59,11 @@ static int brcmf_fcmode;
 module_param_named(fcmode, brcmf_fcmode, int, 0);
 MODULE_PARM_DESC(fcmode, "Mode of firmware signalled flow control");
 
+#if defined(CONFIG_ARCH_BCM2835)
+static int brcmf_roamoff = 1;
+#else
 static int brcmf_roamoff;
+#endif
 module_param_named(roamoff, brcmf_roamoff, int, 0400);
 MODULE_PARM_DESC(roamoff, "Do not use internal roaming engine");
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
index af930e3..287b832 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/of.c
@@ -65,6 +65,36 @@ static int brcmf_of_get_country_codes(struct device *dev,
 	return 0;
 }
 
+/* TODO: FIXME: Use DT */
+static void brcmf_of_probe_cc(struct device *dev,
+			      struct brcmf_mp_device *settings)
+{
+	static struct brcmfmac_pd_cc_entry netgear_r8000_cc_ent[] = {
+		{ "JP", "JP", 78 },
+		{ "US", "Q2", 86 },
+	};
+	struct brcmfmac_pd_cc_entry *cc_ent = NULL;
+	int table_size = 0;
+
+	if (of_machine_is_compatible("netgear,r8000")) {
+		cc_ent = netgear_r8000_cc_ent;
+		table_size = ARRAY_SIZE(netgear_r8000_cc_ent);
+	}
+
+	if (cc_ent && table_size) {
+		struct brcmfmac_pd_cc *cc;
+		size_t memsize;
+
+		memsize = table_size * sizeof(struct brcmfmac_pd_cc_entry);
+		cc = devm_kzalloc(dev, sizeof(*cc) + memsize, GFP_KERNEL);
+		if (!cc)
+			return;
+		cc->table_size = table_size;
+		memcpy(cc->table, cc_ent, memsize);
+		settings->country_codes = cc;
+	}
+}
+
 void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
 		    struct brcmf_mp_device *settings)
 {
@@ -113,6 +143,8 @@ void brcmf_of_probe(struct device *dev, enum brcmf_bus_type bus_type,
 	}
 	of_node_put(root);
 
+	brcmf_of_probe_cc(dev, settings);
+
 	if (!np || !of_device_is_compatible(np, "brcm,bcm4329-fmac"))
 		return;
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
index 23cd5e2..ad09f2d 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
@@ -41,7 +41,7 @@ TRACE_EVENT(brcmf_err,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
-		__assign_str(func);
+		__assign_str(func, func);
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s: %s", __get_str(func), __get_str(msg))
@@ -57,7 +57,7 @@ TRACE_EVENT(brcmf_dbg,
 	),
 	TP_fast_assign(
 		__entry->level = level;
-		__assign_str(func);
+		__assign_str(func, func);
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s: %s", __get_str(func), __get_str(msg))
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
index 8afbf52..2a2831b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
@@ -1574,7 +1574,11 @@ static int brcmf_usb_reset_device(struct device *dev, void *notused)
 
 void brcmf_usb_exit(void)
 {
+#if LINUX_VERSION_IS_GEQ(6,8,0)
 	struct device_driver *drv = &brcmf_usbdrvr.driver;
+#else
+	struct device_driver *drv = &brcmf_usbdrvr.drvwrap.driver;
+#endif
 	int ret;
 
 	brcmf_dbg(USB, "Enter\n");
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
index bf8510b..b896800 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
@@ -81,7 +81,7 @@ TRACE_EVENT(brcms_macintstatus,
 		__field(u32, mask)
 	),
 	TP_fast_assign(
-		__assign_str(dev);
+		__assign_str(dev, dev_name(dev));
 		__entry->in_isr = in_isr;
 		__entry->macintstatus = macintstatus;
 		__entry->mask = mask;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
index e31bd3c..e58ba75 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
@@ -71,7 +71,7 @@ TRACE_EVENT(brcms_dbg,
 	),
 	TP_fast_assign(
 		__entry->level = level;
-		__assign_str(func);
+		__assign_str(func, func);
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s: %s", __get_str(func), __get_str(msg))
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
index c1ea40e..10660f6 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
@@ -31,7 +31,7 @@ TRACE_EVENT(brcms_txdesc,
 		__dynamic_array(u8, txh, txh_len)
 	),
 	TP_fast_assign(
-		__assign_str(dev);
+		__assign_str(dev, dev_name(dev));
 		memcpy(__get_dynamic_array(txh), txh, txh_len);
 	),
 	TP_printk("[%s] txdesc", __get_str(dev))
@@ -54,7 +54,7 @@ TRACE_EVENT(brcms_txstatus,
 		__field(u16, ackphyrxsh)
 	),
 	TP_fast_assign(
-		__assign_str(dev);
+		__assign_str(dev, dev_name(dev));
 		__entry->framelen = framelen;
 		__entry->frameid = frameid;
 		__entry->status = status;
@@ -85,7 +85,7 @@ TRACE_EVENT(brcms_ampdu_session,
 		__field(u16, dma_len)
 	),
 	TP_fast_assign(
-		__assign_str(dev);
+		__assign_str(dev, dev_name(dev));
 		__entry->max_ampdu_len = max_ampdu_len;
 		__entry->max_ampdu_frames = max_ampdu_frames;
 		__entry->ampdu_len = ampdu_len;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
index d1b9a18..bd6a833 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
@@ -58,19 +58,12 @@
 				 (((c) < 149) ? 3 : 4))))
 
 #define BRCM_2GHZ_2412_2462	REG_RULE(2412-10, 2462+10, 40, 0, 19, 0)
-#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, \
-					 NL80211_RRF_NO_IR)
-
-#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, \
-					 NL80211_RRF_DFS | \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, \
-					 NL80211_RRF_DFS | \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, \
-					 NL80211_RRF_NO_IR)
+#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, 0)
+
+#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, 0)
 
 static const struct ieee80211_regdomain brcms_regdom_x2 = {
 	.n_reg_rules = 6,
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
index 0db1fa5..1d6c292 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
@@ -57,7 +57,7 @@ TRACE_EVENT(iwlwifi_dbg,
 	),
 	TP_fast_assign(
 		__entry->level = level;
-		__assign_str(function);
+		__assign_str(function, function);
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s", __get_str(msg))
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
index e83158f..c24e264 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
@@ -87,7 +87,7 @@ static inline void trace_ ## name(proto) {}
 #endif
 
 #define DEV_ENTRY	__string(dev, dev_name(dev))
-#define DEV_ASSIGN	__assign_str(dev)
+#define DEV_ASSIGN	__assign_str(dev, dev_name(dev))
 
 #include "iwl-devtrace-io.h"
 #include "iwl-devtrace-ucode.h"
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
index d924709..cb12a88 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
@@ -638,8 +638,13 @@ static int iwl_mvm_tzone_get_temp(struct thermal_zone_device *device,
 	return 0;
 }
 
+#if LINUX_VERSION_IS_GEQ(6,11,0)
 static int iwl_mvm_tzone_set_trip_temp(struct thermal_zone_device *device,
 				       const struct thermal_trip *trip, int temp)
+#else
+static int iwl_mvm_tzone_set_trip_temp(struct thermal_zone_device *device,
+				       int trip, int temp)
+#endif
 {
 	struct iwl_mvm *mvm = thermal_zone_device_priv(device);
 
@@ -682,13 +687,23 @@ static void iwl_mvm_thermal_zone_register(struct iwl_mvm *mvm)
 	for (i = 0 ; i < IWL_MAX_DTS_TRIPS; i++) {
 		mvm->tz_device.trips[i].temperature = THERMAL_TEMP_INVALID;
 		mvm->tz_device.trips[i].type = THERMAL_TRIP_PASSIVE;
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 		mvm->tz_device.trips[i].flags = THERMAL_TRIP_FLAG_RW_TEMP;
+#endif
 	}
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 	mvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,
 							mvm->tz_device.trips,
 							IWL_MAX_DTS_TRIPS,
 							mvm, &tzone_ops,
 							NULL, 0, 0);
+#else
+	mvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,
+							mvm->tz_device.trips,
+							IWL_MAX_DTS_TRIPS, 0,
+							mvm, &tzone_ops,
+							NULL, 0, 0);
+#endif
 	if (IS_ERR(mvm->tz_device.tzone)) {
 		IWL_DEBUG_TEMP(mvm,
 			       "Failed to register to thermal zone (err = %ld)\n",
diff --git a/drivers/net/wireless/marvell/libertas/cfg.c b/drivers/net/wireless/marvell/libertas/cfg.c
index afe9bcd..d20753c 100644
--- a/drivers/net/wireless/marvell/libertas/cfg.c
+++ b/drivers/net/wireless/marvell/libertas/cfg.c
@@ -486,6 +486,7 @@ static int lbs_add_wps_enrollee_tlv(u8 *tlv, const u8 *ie, size_t ie_len)
  */
 
 static int lbs_cfg_set_monitor_channel(struct wiphy *wiphy,
+				       struct net_device *dev,
 				       struct cfg80211_chan_def *chandef)
 {
 	struct lbs_private *priv = wiphy_priv(wiphy);
@@ -2101,6 +2102,8 @@ struct wireless_dev *lbs_cfg_alloc(struct device *dev)
 		goto err_wiphy_new;
 	}
 
+	set_wiphy_dev(wdev->wiphy, dev);
+
 	return wdev;
 
  err_wiphy_new:
@@ -2176,6 +2179,8 @@ int lbs_cfg_register(struct lbs_private *priv)
 	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
 	wdev->wiphy->reg_notifier = lbs_reg_notifier;
 
+	memcpy(wdev->wiphy->perm_addr, priv->current_addr, ETH_ALEN);
+
 	ret = wiphy_register(wdev->wiphy);
 	if (ret < 0)
 		pr_err("cannot register wiphy device\n");
diff --git a/drivers/net/wireless/marvell/libertas/main.c b/drivers/net/wireless/marvell/libertas/main.c
index 78e8b5a..b56a495 100644
--- a/drivers/net/wireless/marvell/libertas/main.c
+++ b/drivers/net/wireless/marvell/libertas/main.c
@@ -935,6 +935,7 @@ struct lbs_private *lbs_add_card(void *card, struct device *dmdev)
 		goto err_adapter;
 	}
 
+	dev_net_set(dev, wiphy_net(wdev->wiphy));
 	dev->ieee80211_ptr = wdev;
 	dev->ml_priv = priv;
 	SET_NETDEV_DEV(dev, dmdev);
diff --git a/drivers/net/wireless/marvell/mwifiex/cmdevt.c b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
index b30ed32..476b8bb 100644
--- a/drivers/net/wireless/marvell/mwifiex/cmdevt.c
+++ b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
@@ -16,6 +16,85 @@
 
 static void mwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter);
 
+const char *
+mwifiex_cmd_to_str(u16 command)
+{
+	switch (command) {
+	case HostCmd_CMD_GET_HW_SPEC:			return "GET_HW_SPEC";
+	case HostCmd_CMD_802_11_SCAN:			return "SCAN";
+	case HostCmd_CMD_802_11_GET_LOG:		return "GET_LOG";
+	case HostCmd_CMD_MAC_MULTICAST_ADR:		return "MAC_MULTICAST_ADR";
+	case HostCmd_CMD_802_11_EEPROM_ACCESS:		return "EEPROM_ACCESS";
+	case HostCmd_CMD_802_11_ASSOCIATE:		return "ASSOCIATE";
+	case HostCmd_CMD_802_11_SNMP_MIB:		return "SNMP_MIB";
+	case HostCmd_CMD_MAC_REG_ACCESS:		return "MAC_REG_ACCESS";
+	case HostCmd_CMD_BBP_REG_ACCESS:		return "BBP_REG_ACCESS";
+	case HostCmd_CMD_RF_REG_ACCESS:			return "RF_REG_ACCESS";
+	case HostCmd_CMD_PMIC_REG_ACCESS:		return "PMIC_REG_ACCESS";
+	case HostCmd_CMD_RF_TX_PWR:			return "RF_TX_PWR";
+	case HostCmd_CMD_RF_ANTENNA:			return "RF_ANTENNA";
+	case HostCmd_CMD_802_11_DEAUTHENTICATE:		return "DEAUTHENTICATE";
+	case HostCmd_CMD_MAC_CONTROL:			return "MAC_CONTROL";
+	case HostCmd_CMD_802_11_AD_HOC_START:		return "AD_HOC_START";
+	case HostCmd_CMD_802_11_AD_HOC_JOIN:		return "AD_HOC_JOIN";
+	case HostCmd_CMD_802_11_AD_HOC_STOP:		return "AD_HOC_STOP";
+	case HostCmd_CMD_802_11_MAC_ADDRESS:		return "MAC_ADDRESS";
+	case HostCmd_CMD_802_11D_DOMAIN_INFO:		return "DOMAIN_INFO";
+	case HostCmd_CMD_802_11_KEY_MATERIAL:		return "KEY_MATERIAL";
+	case HostCmd_CMD_802_11_BG_SCAN_CONFIG:		return "BG_SCAN_CONFIG";
+	case HostCmd_CMD_802_11_BG_SCAN_QUERY:		return "BG_SCAN_QUERY";
+	case HostCmd_CMD_WMM_GET_STATUS:		return "WMM_GET_STATUS";
+	case HostCmd_CMD_802_11_SUBSCRIBE_EVENT:	return "SUBSCRIBE_EVENT";
+	case HostCmd_CMD_802_11_TX_RATE_QUERY:		return "TX_RATE_QUERY";
+	case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:	return "IBSS_COALESCING_STATUS";
+	case HostCmd_CMD_MEM_ACCESS:			return "MEM_ACCESS";
+	case HostCmd_CMD_CFG_DATA:			return "CFG_DATA";
+	case HostCmd_CMD_VERSION_EXT:			return "VERSION_EXT";
+	case HostCmd_CMD_MEF_CFG:			return "MEF_CFG";
+	case HostCmd_CMD_RSSI_INFO:			return "RSSI_INFO";
+	case HostCmd_CMD_FUNC_INIT:			return "FUNC_INIT";
+	case HostCmd_CMD_FUNC_SHUTDOWN:			return "FUNC_SHUTDOWN";
+	case HOST_CMD_APCMD_SYS_RESET:			return "SYS_RESET";
+	case HostCmd_CMD_UAP_SYS_CONFIG:		return "UAP_SYS_CONFIG";
+	case HostCmd_CMD_UAP_BSS_START:			return "UAP_BSS_START";
+	case HostCmd_CMD_UAP_BSS_STOP:			return "UAP_BSS_STOP";
+	case HOST_CMD_APCMD_STA_LIST:			return "STA_LIST";
+	case HostCmd_CMD_UAP_STA_DEAUTH:		return "UAP_STA_DEAUTH";
+	case HostCmd_CMD_11N_CFG:			return "11N_CFG";
+	case HostCmd_CMD_11N_ADDBA_REQ:			return "ADDBA_REQ";
+	case HostCmd_CMD_11N_ADDBA_RSP:			return "ADDBA_RSP";
+	case HostCmd_CMD_11N_DELBA:			return "DELBA";
+	case HostCmd_CMD_RECONFIGURE_TX_BUFF:		return "RECONFIGURE_TX_BUFF";
+	case HostCmd_CMD_CHAN_REPORT_REQUEST:		return "CHAN_REPORT_REQUEST";
+	case HostCmd_CMD_AMSDU_AGGR_CTRL:		return "AMSDU_AGGR_CTRL";
+	case HostCmd_CMD_TXPWR_CFG:			return "TXPWR_CFG";
+	case HostCmd_CMD_TX_RATE_CFG:			return "TX_RATE_CFG";
+	case HostCmd_CMD_ROBUST_COEX:			return "ROBUST_COEX";
+	case HostCmd_CMD_802_11_PS_MODE_ENH:		return "PS_MODE_ENH";
+	case HostCmd_CMD_802_11_HS_CFG_ENH:		return "HS_CFG_ENH";
+	case HostCmd_CMD_P2P_MODE_CFG:			return "P2P_MODE_CFG";
+	case HostCmd_CMD_CAU_REG_ACCESS:		return "CAU_REG_ACCESS";
+	case HostCmd_CMD_SET_BSS_MODE:			return "SET_BSS_MODE";
+	case HostCmd_CMD_PCIE_DESC_DETAILS:		return "PCIE_DESC_DETAILS";
+	case HostCmd_CMD_802_11_SCAN_EXT:		return "SCAN_EXT";
+	case HostCmd_CMD_COALESCE_CFG:			return "COALESCE_CFG";
+	case HostCmd_CMD_MGMT_FRAME_REG:		return "MGMT_FRAME_REG";
+	case HostCmd_CMD_REMAIN_ON_CHAN:		return "REMAIN_ON_CHAN";
+	case HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:		return "GTK_REKEY_OFFLOAD_CFG";
+	case HostCmd_CMD_11AC_CFG:			return "11AC_CFG";
+	case HostCmd_CMD_HS_WAKEUP_REASON:		return "HS_WAKEUP_REASON";
+	case HostCmd_CMD_TDLS_CONFIG:			return "TDLS_CONFIG";
+	case HostCmd_CMD_MC_POLICY:			return "MC_POLICY";
+	case HostCmd_CMD_TDLS_OPER:			return "TDLS_OPER";
+	case HostCmd_CMD_FW_DUMP_EVENT:			return "FW_DUMP_EVENT";
+	case HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:		return "SDIO_SP_RX_AGGR_CFG";
+	case HostCmd_CMD_STA_CONFIGURE:			return "STA_CONFIGURE";
+	case HostCmd_CMD_CHAN_REGION_CFG:		return "CHAN_REGION_CFG";
+	case HostCmd_CMD_PACKET_AGGR_CTRL:		return "PACKET_AGGR_CTRL";
+	default:					return "UNKNOWN";
+	}
+}
+
 /*
  * This function initializes a command node.
  *
@@ -193,8 +272,8 @@ static int mwifiex_dnld_cmd_to_fw(struct mwifiex_private *priv,
 	    cmd_code != HostCmd_CMD_FUNC_SHUTDOWN &&
 	    cmd_code != HostCmd_CMD_FUNC_INIT) {
 		mwifiex_dbg(adapter, ERROR,
-			    "DNLD_CMD: FW in reset state, ignore cmd %#x\n",
-			cmd_code);
+			    "DNLD_CMD: FW in reset state, ignore cmd %s (%#x)\n",
+			    mwifiex_cmd_to_str(cmd_code), cmd_code);
 		mwifiex_recycle_cmd_node(adapter, cmd_node);
 		queue_work(adapter->workqueue, &adapter->main_work);
 		return -1;
@@ -655,8 +734,8 @@ int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,
 	/* Return error, since the command preparation failed */
 	if (ret) {
 		mwifiex_dbg(adapter, ERROR,
-			    "PREP_CMD: cmd %#x preparation failed\n",
-			cmd_no);
+			    "PREP_CMD: cmd %s (%#x) preparation failed\n",
+			    mwifiex_cmd_to_str(cmd_no), cmd_no);
 		mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
 		return -1;
 	}
@@ -904,8 +983,9 @@ int mwifiex_process_cmdresp(struct mwifiex_adapter *adapter)
 	if (adapter->hw_status == MWIFIEX_HW_STATUS_INITIALIZING) {
 		if (ret) {
 			mwifiex_dbg(adapter, ERROR,
-				    "%s: cmd %#x failed during\t"
-				    "initialization\n", __func__, cmdresp_no);
+				    "%s: cmd %s (%#x) failed during\t"
+				    "initialization\n", __func__,
+				    mwifiex_cmd_to_str(cmdresp_no), cmdresp_no);
 			mwifiex_init_fw_complete(adapter);
 			return -1;
 		} else if (adapter->last_init_cmd == cmdresp_no)
@@ -1287,8 +1367,8 @@ mwifiex_process_sleep_confirm_resp(struct mwifiex_adapter *adapter,
 
 	if (command != HostCmd_CMD_802_11_PS_MODE_ENH) {
 		mwifiex_dbg(adapter, ERROR,
-			    "%s: rcvd unexpected resp for cmd %#x, result = %x\n",
-			    __func__, command, result);
+			    "%s: rcvd unexpected resp for cmd %s (%#x), result = %x\n",
+			    __func__, mwifiex_cmd_to_str(command), command, result);
 		return;
 	}
 
diff --git a/drivers/net/wireless/marvell/mwifiex/decl.h b/drivers/net/wireless/marvell/mwifiex/decl.h
index 84603f1..80e4410 100644
--- a/drivers/net/wireless/marvell/mwifiex/decl.h
+++ b/drivers/net/wireless/marvell/mwifiex/decl.h
@@ -18,7 +18,7 @@
 #include <net/cfg80211.h>
 
 #define MWIFIEX_BSS_COEX_COUNT	     2
-#define MWIFIEX_MAX_BSS_NUM         (3)
+#define MWIFIEX_MAX_BSS_NUM         (4)
 
 #define MWIFIEX_DMA_ALIGN_SZ	    64
 #define MWIFIEX_RX_HEADROOM	    64
@@ -123,7 +123,7 @@
 #define MWIFIEX_RATE_INDEX_OFDM0   4
 
 #define MWIFIEX_MAX_STA_NUM		3
-#define MWIFIEX_MAX_UAP_NUM		3
+#define MWIFIEX_MAX_UAP_NUM		4
 #define MWIFIEX_MAX_P2P_NUM		3
 
 #define MWIFIEX_A_BAND_START_FREQ	5000
diff --git a/drivers/net/wireless/marvell/mwifiex/main.h b/drivers/net/wireless/marvell/mwifiex/main.h
index 566adce..8e0b30e 100644
--- a/drivers/net/wireless/marvell/mwifiex/main.h
+++ b/drivers/net/wireless/marvell/mwifiex/main.h
@@ -1100,6 +1100,8 @@ void mwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter);
 void mwifiex_cancel_pending_scan_cmd(struct mwifiex_adapter *adapter);
 void mwifiex_cancel_scan(struct mwifiex_adapter *adapter);
 
+const char *mwifiex_cmd_to_str(u16 command);
+
 void mwifiex_recycle_cmd_node(struct mwifiex_adapter *adapter,
 			      struct cmd_ctrl_node *cmd_node);
 
diff --git a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
index 9c53825..5808060 100644
--- a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
+++ b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
@@ -36,8 +36,9 @@ mwifiex_process_cmdresp_error(struct mwifiex_private *priv,
 	struct host_cmd_ds_802_11_ps_mode_enh *pm;
 
 	mwifiex_dbg(adapter, ERROR,
-		    "CMD_RESP: cmd %#x error, result=%#x\n",
-		    resp->command, resp->result);
+		    "CMD_RESP: cmd %s (%#x) error, result=%#x\n",
+		    mwifiex_cmd_to_str(le16_to_cpu(resp->command)),
+		    le16_to_cpu(resp->command), le16_to_cpu(resp->result));
 
 	if (adapter->curr_cmd->wait_q_enabled)
 		adapter->cmd_wait_q.status = -1;
diff --git a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
index 1c0ceac..4444d2c 100644
--- a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
+++ b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
@@ -964,7 +964,8 @@ int mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,
 		break;
 	default:
 		mwifiex_dbg(priv->adapter, ERROR,
-			    "PREP_CMD: unknown cmd %#x\n", cmd_no);
+			    "PREP_CMD: unknown cmd (%s) %#x\n",
+			    mwifiex_cmd_to_str(cmd_no), cmd_no);
 		return -1;
 	}
 
diff --git a/drivers/net/wireless/marvell/mwl8k.c b/drivers/net/wireless/marvell/mwl8k.c
index bab9ef3..e3bc11e 100644
--- a/drivers/net/wireless/marvell/mwl8k.c
+++ b/drivers/net/wireless/marvell/mwl8k.c
@@ -5712,6 +5712,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw");
 MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
 
 static const struct pci_device_id mwl8k_pci_id_table[] = {
+	{ PCI_VDEVICE(MARVELL, 0x2a02), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },
@@ -6297,6 +6298,8 @@ static int mwl8k_probe(struct pci_dev *pdev,
 
 	priv->running_bsses = 0;
 
+	wait_for_completion(&priv->firmware_loading_complete);
+
 	return rc;
 
 err_stop_firmware:
@@ -6330,8 +6333,6 @@ static void mwl8k_remove(struct pci_dev *pdev)
 		return;
 	priv = hw->priv;
 
-	wait_for_completion(&priv->firmware_loading_complete);
-
 	if (priv->fw_state == FW_STATE_ERROR) {
 		mwl8k_hw_reset(priv);
 		goto unmap;
diff --git a/drivers/net/wireless/mediatek/mt7601u/usb.h b/drivers/net/wireless/mediatek/mt7601u/usb.h
index 9fdf359..66481b7 100644
--- a/drivers/net/wireless/mediatek/mt7601u/usb.h
+++ b/drivers/net/wireless/mediatek/mt7601u/usb.h
@@ -8,7 +8,7 @@
 
 #include "mt7601u.h"
 
-#define MT7601U_FIRMWARE	"mt7601u.bin"
+#define MT7601U_FIRMWARE	"mediatek/mt7601u.bin"
 
 #define MT_VEND_REQ_MAX_RETRY	10
 #define MT_VEND_REQ_TOUT_MS	300
diff --git a/drivers/net/wireless/microchip/wilc1000/cfg80211.c b/drivers/net/wireless/microchip/wilc1000/cfg80211.c
index eb37b22..9977be0 100644
--- a/drivers/net/wireless/microchip/wilc1000/cfg80211.c
+++ b/drivers/net/wireless/microchip/wilc1000/cfg80211.c
@@ -231,6 +231,7 @@ struct wilc_vif *wilc_get_wl_to_vif(struct wilc *wl)
 }
 
 static int set_channel(struct wiphy *wiphy,
+		       struct net_device *dev,
 		       struct cfg80211_chan_def *chandef)
 {
 	struct wilc *wl = wiphy_priv(wiphy);
@@ -1424,7 +1425,7 @@ static int start_ap(struct wiphy *wiphy, struct net_device *dev,
 	struct wilc_vif *vif = netdev_priv(dev);
 	int ret;
 
-	ret = set_channel(wiphy, &settings->chandef);
+	ret = set_channel(wiphy, dev, &settings->chandef);
 	if (ret != 0)
 		netdev_err(dev, "Error in setting channel\n");
 
diff --git a/drivers/net/wireless/ralink/rt2x00/Kconfig b/drivers/net/wireless/ralink/rt2x00/Kconfig
index 8f6e3d2..abaa51b 100644
--- a/drivers/net/wireless/ralink/rt2x00/Kconfig
+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
@@ -70,6 +70,7 @@ config RT2800PCI
 	select RT2X00_LIB_MMIO
 	select RT2X00_LIB_PCI
 	select RT2X00_LIB_FIRMWARE
+	select RT2X00_LIB_EEPROM
 	select RT2X00_LIB_CRYPTO
 	depends on CRC_CCITT
 	depends on EEPROM_93CX6
@@ -211,13 +212,15 @@ endif
 config RT2800SOC
 	tristate "Ralink WiSoC support"
 	depends on m
-	depends on SOC_RT288X || SOC_RT305X || SOC_MT7620
+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620
 	select RT2X00_LIB_SOC
 	select RT2X00_LIB_MMIO
 	select RT2X00_LIB_CRYPTO
 	select RT2X00_LIB_FIRMWARE
+	select RT2X00_LIB_EEPROM
 	select RT2800_LIB
 	select RT2800_LIB_MMIO
+	select MTD if SOC_RT288X || SOC_RT305X
 	help
 	  This adds support for Ralink WiSoC devices.
 	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
@@ -226,36 +229,37 @@ config RT2800SOC
 
 
 config RT2800_LIB
-	tristate
+	tristate "RT2800 USB/PCI support"
 	depends on m
 
 config RT2800_LIB_MMIO
-	tristate
+	tristate "RT2800 MMIO support"
 	depends on m
 	select RT2X00_LIB_MMIO
 	select RT2800_LIB
 
 config RT2X00_LIB_MMIO
-	tristate
+	tristate "RT2x00 MMIO support"
 	depends on m
 
 config RT2X00_LIB_PCI
-	tristate
+	tristate "RT2x00 PCI support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB_SOC
-	tristate
+	tristate "RT2x00 SoC support"
+	depends on SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB_USB
-	tristate
+	tristate "RT2x00 USB support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB
-	tristate
+	tristate "RT2x00 support"
 	depends on m
 
 config RT2X00_LIB_FIRMWARE
@@ -265,6 +269,9 @@ config RT2X00_LIB_FIRMWARE
 config RT2X00_LIB_CRYPTO
 	bool
 
+config RT2X00_LIB_EEPROM
+	bool
+
 config RT2X00_LIB_LEDS
 	bool
 	default y if (RT2X00_LIB=y && LEDS_CLASS=y) || (RT2X00_LIB=m && LEDS_CLASS!=n)
diff --git a/drivers/net/wireless/ralink/rt2x00/Makefile b/drivers/net/wireless/ralink/rt2x00/Makefile
index 4a2156b..94335ec 100644
--- a/drivers/net/wireless/ralink/rt2x00/Makefile
+++ b/drivers/net/wireless/ralink/rt2x00/Makefile
@@ -8,6 +8,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+= rt2x00debug.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
 
 obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
 obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800.h b/drivers/net/wireless/ralink/rt2x00/rt2800.h
index 8930589..fbb791c 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
@@ -379,10 +379,10 @@
 
 /*
  * WMM_AIFSN_CFG: Aifsn for each EDCA AC
- * AIFSN0: AC_VO
- * AIFSN1: AC_VI
- * AIFSN2: AC_BE
- * AIFSN3: AC_BK
+ * AIFSN0: AC_BE
+ * AIFSN1: AC_BK
+ * AIFSN2: AC_VI
+ * AIFSN3: AC_VO
  */
 #define WMM_AIFSN_CFG			0x0214
 #define WMM_AIFSN_CFG_AIFSN0		FIELD32(0x0000000f)
@@ -392,10 +392,10 @@
 
 /*
  * WMM_CWMIN_CSR: CWmin for each EDCA AC
- * CWMIN0: AC_VO
- * CWMIN1: AC_VI
- * CWMIN2: AC_BE
- * CWMIN3: AC_BK
+ * CWMIN0: AC_BE
+ * CWMIN1: AC_BK
+ * CWMIN2: AC_VI
+ * CWMIN3: AC_VO
  */
 #define WMM_CWMIN_CFG			0x0218
 #define WMM_CWMIN_CFG_CWMIN0		FIELD32(0x0000000f)
@@ -405,10 +405,10 @@
 
 /*
  * WMM_CWMAX_CSR: CWmax for each EDCA AC
- * CWMAX0: AC_VO
- * CWMAX1: AC_VI
- * CWMAX2: AC_BE
- * CWMAX3: AC_BK
+ * CWMAX0: AC_BE
+ * CWMAX1: AC_BK
+ * CWMAX2: AC_VI
+ * CWMAX3: AC_VO
  */
 #define WMM_CWMAX_CFG			0x021c
 #define WMM_CWMAX_CFG_CWMAX0		FIELD32(0x0000000f)
@@ -1056,6 +1056,11 @@
 #define MIMO_PS_CFG_RX_STBY_POL		FIELD32(0x00000010)
 #define MIMO_PS_CFG_RX_RX_STBY0		FIELD32(0x00000020)
 
+#define BB_PA_MODE_CFG0			0x1214
+#define BB_PA_MODE_CFG1			0x1218
+#define RF_PA_MODE_CFG0			0x121C
+#define RF_PA_MODE_CFG1			0x1220
+
 /*
  * EDCA_AC0_CFG:
  */
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
index d2ab374..71b937d 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
@@ -25,6 +25,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 #include "rt2x00.h"
 #include "rt2800lib.h"
@@ -304,6 +305,24 @@ static void rt2800_rf_write(struct rt2x00_dev *rt2x00dev,
 	mutex_unlock(&rt2x00dev->csr_mutex);
 }
 
+void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
+{
+	if (!rt2x00dev->pinctrl)
+		return;
+
+	if (enable) {
+		if (!rt2x00dev->pins_default)
+			return;
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_default);
+	} else {
+		if (!rt2x00dev->pins_pa_gpio)
+			return;
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_pa_gpio);
+	}
+}
+
 static const unsigned int rt2800_eeprom_map[EEPROM_WORD_COUNT] = {
 	[EEPROM_CHIP_ID]		= 0x0000,
 	[EEPROM_VERSION]		= 0x0001,
@@ -834,7 +853,8 @@ void rt2800_write_tx_data(struct queue_entry *entry,
 			   txdesc->key_idx : txdesc->u.ht.wcid);
 	rt2x00_set_field32(&word, TXWI_W1_MPDU_TOTAL_BYTE_COUNT,
 			   txdesc->length);
-	rt2x00_set_field32(&word, TXWI_W1_PACKETID_QUEUE, entry->queue->qid);
+	rt2x00_set_field32(&word, TXWI_W1_PACKETID_QUEUE,
+			   rt2x00_ac_to_hwq(entry->queue->qid));
 	rt2x00_set_field32(&word, TXWI_W1_PACKETID_ENTRY, (entry->entry_idx % 3) + 1);
 	rt2x00_desc_write(txwi, 1, word);
 
@@ -1124,6 +1144,12 @@ void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota)
 	u32 reg;
 	u8 qid;
 	bool match;
+	static const u8 rt2ac[] = {
+		IEEE80211_AC_BE,
+		IEEE80211_AC_BK,
+		IEEE80211_AC_VI,
+		IEEE80211_AC_VO,
+	};
 
 	while (quota-- > 0 && kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
 		/*
@@ -1131,6 +1157,8 @@ void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota)
 		 * guaranteed to be one of the TX QIDs .
 		 */
 		qid = rt2x00_get_field32(reg, TX_STA_FIFO_PID_QUEUE);
+		/* Convert Ralink hardware queue index to IEEE80211 queue id. */
+		qid = rt2ac[qid];
 		queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
 
 		if (unlikely(rt2x00queue_empty(queue))) {
@@ -1310,26 +1338,45 @@ static bool rt2800_watchdog_hung(struct rt2x00_dev *rt2x00dev)
 	return true;
 }
 
+static inline bool check_dma_busy_rx(u32 reg_cfg, u32 reg_int)
+{
+	return (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_RX_DMA_BUSY) &&
+		rt2x00_get_field32(reg_int, INT_SOURCE_CSR_RX_COHERENT));
+}
+
+static inline bool check_dma_busy_tx(u32 reg_cfg, u32 reg_int)
+{
+	return (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_TX_DMA_BUSY) &&
+		rt2x00_get_field32(reg_int, INT_SOURCE_CSR_TX_COHERENT));
+}
+
 static bool rt2800_watchdog_dma_busy(struct rt2x00_dev *rt2x00dev)
 {
 	bool busy_rx, busy_tx;
 	u32 reg_cfg = rt2800_register_read(rt2x00dev, WPDMA_GLO_CFG);
 	u32 reg_int = rt2800_register_read(rt2x00dev, INT_SOURCE_CSR);
 
-	if (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_RX_DMA_BUSY) &&
-	    rt2x00_get_field32(reg_int, INT_SOURCE_CSR_RX_COHERENT))
-		rt2x00dev->rxdma_busy++;
-	else
-		rt2x00dev->rxdma_busy = 0;
-
-	if (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_TX_DMA_BUSY) &&
-	    rt2x00_get_field32(reg_int, INT_SOURCE_CSR_TX_COHERENT))
-		rt2x00dev->txdma_busy++;
-	else
-		rt2x00dev->txdma_busy = 0;
+	rt2x00dev->rxdma_busy = check_dma_busy_rx(reg_cfg, reg_int) ?
+				rt2x00dev->rxdma_busy + 1 : 0;
+	rt2x00dev->txdma_busy = check_dma_busy_tx(reg_cfg, reg_int) ?
+				rt2x00dev->txdma_busy + 1 : 0;
+
+	if (rt2x00dev->rxdma_busy > 25 || rt2x00dev->txdma_busy > 25) {
+		int cnt;
+		for (cnt = 0; cnt < 10; cnt++) {
+			msleep(5);
+			reg_cfg = rt2800_register_read(rt2x00dev, WPDMA_GLO_CFG);
+			reg_int = rt2800_register_read(rt2x00dev, INT_SOURCE_CSR);
+
+			if (!check_dma_busy_rx(reg_cfg, reg_int))
+				rt2x00dev->rxdma_busy = 0;
+			if (!check_dma_busy_tx(reg_cfg, reg_int))
+				rt2x00dev->txdma_busy = 0;
+		}
+	}
 
-	busy_rx = rt2x00dev->rxdma_busy > 30;
-	busy_tx = rt2x00dev->txdma_busy > 30;
+	busy_rx = rt2x00dev->rxdma_busy > 40;
+	busy_tx = rt2x00dev->txdma_busy > 40;
 
 	if (!busy_rx && !busy_tx)
 		return false;
@@ -3547,9 +3594,8 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 
 		/* TODO RF27 <- tssi */
 
-		rfcsr = rf->channel <= 10 ? 0x07 : 0x06;
-		rt2800_rfcsr_write(rt2x00dev, 23, rfcsr);
-		rt2800_rfcsr_write(rt2x00dev, 59, rfcsr);
+		rt2800_rfcsr_write(rt2x00dev, 23, rf->channel <= 10 ? 0x08 : 0x07);
+		rt2800_rfcsr_write(rt2x00dev, 59, rf->channel <= 4 ? 0x06 : 0x04);
 
 		if (is_11b) {
 			/* CCK */
@@ -3570,7 +3616,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		power_bound = POWER_BOUND;
 		ep_reg = 0x2;
 	} else {
-		rt2800_rfcsr_write(rt2x00dev, 10, 0x97);
+		rt2800_rfcsr_write(rt2x00dev, 10, 0x95);
 		/* FIMXE: RF11 overwrite */
 		rt2800_rfcsr_write(rt2x00dev, 11, 0x40);
 		rt2800_rfcsr_write(rt2x00dev, 25, 0xBF);
@@ -3579,13 +3625,15 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		rt2800_rfcsr_write(rt2x00dev, 37, 0x04);
 		rt2800_rfcsr_write(rt2x00dev, 38, 0x85);
 		rt2800_rfcsr_write(rt2x00dev, 40, 0x42);
-		rt2800_rfcsr_write(rt2x00dev, 41, 0xBB);
+		rt2800_rfcsr_write(rt2x00dev, 41, 0xAB);
 		rt2800_rfcsr_write(rt2x00dev, 42, 0xD7);
-		rt2800_rfcsr_write(rt2x00dev, 45, 0x41);
+		rt2800_rfcsr_write(rt2x00dev, 45, 0x01);
 		rt2800_rfcsr_write(rt2x00dev, 48, 0x00);
 		rt2800_rfcsr_write(rt2x00dev, 57, 0x77);
+		rt2800_rfcsr_write(rt2x00dev, 58, 0x19);
 		rt2800_rfcsr_write(rt2x00dev, 60, 0x05);
 		rt2800_rfcsr_write(rt2x00dev, 61, 0x01);
+		rt2800_rfcsr_write(rt2x00dev, 62, 0x19);
 
 		/* TODO RF27 <- tssi */
 
@@ -3594,82 +3642,59 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 			rt2800_rfcsr_write(rt2x00dev, 12, 0x2E);
 			rt2800_rfcsr_write(rt2x00dev, 13, 0x22);
 			rt2800_rfcsr_write(rt2x00dev, 22, 0x60);
-			rt2800_rfcsr_write(rt2x00dev, 23, 0x7F);
-			if (rf->channel <= 50)
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x09);
-			else if (rf->channel >= 52)
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x07);
+			rt2800_rfcsr_write(rt2x00dev, 23, 0x7E);
+			rt2800_rfcsr_write(rt2x00dev, 24, 0x07);
 			rt2800_rfcsr_write(rt2x00dev, 39, 0x1C);
 			rt2800_rfcsr_write(rt2x00dev, 43, 0x5B);
-			rt2800_rfcsr_write(rt2x00dev, 44, 0X40);
 			rt2800_rfcsr_write(rt2x00dev, 46, 0X00);
-			rt2800_rfcsr_write(rt2x00dev, 51, 0xFE);
-			rt2800_rfcsr_write(rt2x00dev, 52, 0x0C);
-			rt2800_rfcsr_write(rt2x00dev, 54, 0xF8);
+			rt2800_rfcsr_write(rt2x00dev, 51, 0xFD);
+			rt2800_rfcsr_write(rt2x00dev, 52, 0x0E);
+			rt2800_rfcsr_write(rt2x00dev, 55, 0x04);
+			rt2800_rfcsr_write(rt2x00dev, 56, 0xBB);
+			rt2800_rfcsr_write(rt2x00dev, 59, 0x7C);
+
 			if (rf->channel <= 50) {
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x06),
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xD3);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0X32);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xF9);
 			} else if (rf->channel >= 52) {
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x04);
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xBB);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0X2A);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xF8);
 			}
-
-			rt2800_rfcsr_write(rt2x00dev, 58, 0x15);
-			rt2800_rfcsr_write(rt2x00dev, 59, 0x7F);
-			rt2800_rfcsr_write(rt2x00dev, 62, 0x15);
-
 		} else if (rf->channel >= 100 && rf->channel <= 165) {
-
 			rt2800_rfcsr_write(rt2x00dev, 12, 0x0E);
 			rt2800_rfcsr_write(rt2x00dev, 13, 0x42);
 			rt2800_rfcsr_write(rt2x00dev, 22, 0x40);
-			if (rf->channel <= 153) {
-				rt2800_rfcsr_write(rt2x00dev, 23, 0x3C);
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x06);
-			} else if (rf->channel >= 155) {
-				rt2800_rfcsr_write(rt2x00dev, 23, 0x38);
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x05);
-			}
+			rt2800_rfcsr_write(rt2x00dev, 52, 0x06);
+			rt2800_rfcsr_write(rt2x00dev, 55, 0x01);
+
 			if (rf->channel <= 138) {
+				rt2800_rfcsr_write(rt2x00dev, 23, 0x7C);
 				rt2800_rfcsr_write(rt2x00dev, 39, 0x1A);
 				rt2800_rfcsr_write(rt2x00dev, 43, 0x3B);
-				rt2800_rfcsr_write(rt2x00dev, 44, 0x20);
 				rt2800_rfcsr_write(rt2x00dev, 46, 0x18);
-			} else if (rf->channel >= 140) {
+			} else {
+				rt2800_rfcsr_write(rt2x00dev, 23, 0x78);
 				rt2800_rfcsr_write(rt2x00dev, 39, 0x18);
 				rt2800_rfcsr_write(rt2x00dev, 43, 0x1B);
-				rt2800_rfcsr_write(rt2x00dev, 44, 0x10);
 				rt2800_rfcsr_write(rt2x00dev, 46, 0X08);
 			}
-			if (rf->channel <= 124)
-				rt2800_rfcsr_write(rt2x00dev, 51, 0xFC);
-			else if (rf->channel >= 126)
-				rt2800_rfcsr_write(rt2x00dev, 51, 0xEC);
-			if (rf->channel <= 138)
-				rt2800_rfcsr_write(rt2x00dev, 52, 0x06);
-			else if (rf->channel >= 140)
-				rt2800_rfcsr_write(rt2x00dev, 52, 0x06);
-			rt2800_rfcsr_write(rt2x00dev, 54, 0xEB);
-			if (rf->channel <= 138)
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x01);
-			else if (rf->channel >= 140)
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x00);
-			if (rf->channel <= 128)
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xBB);
-			else if (rf->channel >= 130)
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xAB);
-			if (rf->channel <= 116)
-				rt2800_rfcsr_write(rt2x00dev, 58, 0x1D);
-			else if (rf->channel >= 118)
-				rt2800_rfcsr_write(rt2x00dev, 58, 0x15);
-			if (rf->channel <= 138)
-				rt2800_rfcsr_write(rt2x00dev, 59, 0x3F);
-			else if (rf->channel >= 140)
-				rt2800_rfcsr_write(rt2x00dev, 59, 0x7C);
-			if (rf->channel <= 116)
-				rt2800_rfcsr_write(rt2x00dev, 62, 0x1D);
-			else if (rf->channel >= 118)
-				rt2800_rfcsr_write(rt2x00dev, 62, 0x15);
+
+			if (rf->channel <= 114) {
+				rt2800_rfcsr_write(rt2x00dev, 24, 0x02);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0x1A);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xEA);
+				rt2800_rfcsr_write(rt2x00dev, 56, 0xB3);
+			} else {
+				rt2800_rfcsr_write(rt2x00dev, 24, 0x03);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0x0A);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xF9);
+				rt2800_rfcsr_write(rt2x00dev, 56, 0x9B);
+			}
+
+			rt2800_rfcsr_write(rt2x00dev, 51, rf->channel <= 124 ? 0xFC : 0xEC);
+			rt2800_rfcsr_write(rt2x00dev, 58, rf->channel <= 116 ? 0x1D : 0x15);
+			rfcsr = (rf->channel >= 116 && rf->channel <= 138) ? 0x7E : 0x7C;
+			rt2800_rfcsr_write(rt2x00dev, 59, rfcsr);
 		}
 
 		power_bound = POWER_BOUND_5G;
@@ -3681,7 +3706,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		rt2x00_set_field8(&rfcsr, RFCSR49_TX, power_bound);
 	else
 		rt2x00_set_field8(&rfcsr, RFCSR49_TX, info->default_power1);
-	if (is_type_ep)
+	if (!is_type_ep)
 		rt2x00_set_field8(&rfcsr, RFCSR49_EP, ep_reg);
 	rt2800_rfcsr_write(rt2x00dev, 49, rfcsr);
 
@@ -3690,7 +3715,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		rt2x00_set_field8(&rfcsr, RFCSR50_TX, power_bound);
 	else
 		rt2x00_set_field8(&rfcsr, RFCSR50_TX, info->default_power2);
-	if (is_type_ep)
+	if (!is_type_ep)
 		rt2x00_set_field8(&rfcsr, RFCSR50_EP, ep_reg);
 	rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
 
@@ -3711,7 +3736,6 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 	rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
 
 	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
-	rt2800_rfcsr_write(rt2x00dev, 6, 0xe4);
 
 	if (conf_is_ht40(conf))
 		rt2800_rfcsr_write(rt2x00dev, 30, 0x16);
@@ -3740,6 +3764,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 	rt2800_bbp_write(rt2x00dev, 80, (rf->channel <= 14) ? 0x0E : 0x08);
 	rt2800_bbp_write(rt2x00dev, 81, (rf->channel <= 14) ? 0x3A : 0x38);
 	rt2800_bbp_write(rt2x00dev, 82, (rf->channel <= 14) ? 0x62 : 0x92);
+	rt2800_bbp_write(rt2x00dev, 95, (rf->channel <= 14) ? 0x9A : 0x1A);
 
 	/* GLRT band configuration */
 	rt2800_bbp_write(rt2x00dev, 195, 128);
@@ -3752,7 +3777,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x32 : 0x20);
 	rt2800_bbp_write(rt2x00dev, 195, 133);
 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x28 : 0x7F);
-	rt2800_bbp_write(rt2x00dev, 195, 124);
+	rt2800_bbp_write(rt2x00dev, 195, 134);
 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x19 : 0x7F);
 }
 
@@ -3817,14 +3842,16 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 	rt2x00_set_field8(&rfcsr, RFCSR19_K, rf->rf4);
 	rt2800_rfcsr_write(rt2x00dev, 19, rfcsr);
 
-	/* Default: XO=20MHz , SDM mode */
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
-	rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 0x80);
-	rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		/* Default: XO=20MHz , SDM mode */
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
+		rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 4);
+		rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
 
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
-	rt2x00_set_field8(&rfcsr, RFCSR21_BIT8, 1);
-	rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
+		rt2x00_set_field8(&rfcsr, RFCSR21_BIT8, 1);
+		rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
+	}
 
 	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
 	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_EN_MT7620,
@@ -3858,18 +3885,23 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x20);
 	}
 
-	if (conf_is_ht40(conf)) {
-		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
-		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
-	} else {
-		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
-		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		if (conf_is_ht40(conf)) {
+			rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
+			rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
+		} else {
+			rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
+			rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
+		}
 	}
 
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 28);
-	rt2x00_set_field8(&rfcsr, RFCSR28_CH11_HT40,
-			  conf_is_ht40(conf) && (rf->channel == 11));
-	rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) == 2) {
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 28);
+		rt2x00_set_field8(&rfcsr, RFCSR28_CH11_HT40,
+				  conf_is_ht40(conf) && (rf->channel == 11));
+		rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
+	}
 
 	if (!test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags)) {
 		if (conf_is_ht40(conf)) {
@@ -3983,25 +4015,29 @@ static void rt2800_config_alc_rt6352(struct rt2x00_dev *rt2x00dev,
 	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
 		rt2x00_warn(rt2x00dev, "RF busy while configuring ALC\n");
 
-	if (chan->center_freq > 2457) {
-		bbp = rt2800_bbp_read(rt2x00dev, 30);
-		bbp = 0x40;
-		rt2800_bbp_write(rt2x00dev, 30, bbp);
-		rt2800_rfcsr_write(rt2x00dev, 39, 0);
-		if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
-			rt2800_rfcsr_write(rt2x00dev, 42, 0xfb);
-		else
-			rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
-	} else {
-		bbp = rt2800_bbp_read(rt2x00dev, 30);
-		bbp = 0x1f;
-		rt2800_bbp_write(rt2x00dev, 30, bbp);
-		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
-		if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
-			rt2800_rfcsr_write(rt2x00dev, 42, 0xdb);
-		else
-			rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		if (chan->center_freq > 2457) {
+			bbp = rt2800_bbp_read(rt2x00dev, 30);
+			bbp = 0x40;
+			rt2800_bbp_write(rt2x00dev, 30, bbp);
+			rt2800_rfcsr_write(rt2x00dev, 39, 0);
+			if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
+				rt2800_rfcsr_write(rt2x00dev, 42, 0xfb);
+			else
+				rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
+		} else {
+			bbp = rt2800_bbp_read(rt2x00dev, 30);
+			bbp = 0x1f;
+			rt2800_bbp_write(rt2x00dev, 30, bbp);
+			rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+			if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
+				rt2800_rfcsr_write(rt2x00dev, 42, 0xdb);
+			else
+				rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
+		}
 	}
+
 	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, mac_sys_ctrl);
 
 	rt2800_vco_calibration(rt2x00dev);
@@ -4298,7 +4334,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
 		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
-		if (rt2x00_rt(rt2x00dev, RT6352))
+		if (rt2x00_rt(rt2x00dev, RT5592) ||
+		    rt2x00_rt(rt2x00dev, RT6352))
 			rt2800_bbp_write(rt2x00dev, 86, 0x38);
 		else
 			rt2800_bbp_write(rt2x00dev, 86, 0);
@@ -4307,6 +4344,7 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 	if (rf->channel <= 14) {
 		if (!rt2x00_rt(rt2x00dev, RT5390) &&
 		    !rt2x00_rt(rt2x00dev, RT5392) &&
+		    !rt2x00_rt(rt2x00dev, RT5592) &&
 		    !rt2x00_rt(rt2x00dev, RT6352)) {
 			if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 				rt2800_bbp_write(rt2x00dev, 82, 0x62);
@@ -4330,17 +4368,20 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 		else if (rt2x00_rt(rt2x00dev, RT3593) ||
 			 rt2x00_rt(rt2x00dev, RT3883))
 			rt2800_bbp_write(rt2x00dev, 82, 0x82);
-		else if (!rt2x00_rt(rt2x00dev, RT6352))
+		else if (!rt2x00_rt(rt2x00dev, RT5592) &&
+			 !rt2x00_rt(rt2x00dev, RT6352))
 			rt2800_bbp_write(rt2x00dev, 82, 0xf2);
 
 		if (rt2x00_rt(rt2x00dev, RT3593) ||
 		    rt2x00_rt(rt2x00dev, RT3883))
 			rt2800_bbp_write(rt2x00dev, 83, 0x9a);
 
-		if (rt2x00_has_cap_external_lna_a(rt2x00dev))
-			rt2800_bbp_write(rt2x00dev, 75, 0x46);
-		else
-			rt2800_bbp_write(rt2x00dev, 75, 0x50);
+		if (!rt2x00_rt(rt2x00dev, RT5592)) {
+			if (rt2x00_has_cap_external_lna_a(rt2x00dev))
+				rt2800_bbp_write(rt2x00dev, 75, 0x46);
+			else
+				rt2800_bbp_write(rt2x00dev, 75, 0x50);
+		}
 	}
 
 	reg = rt2800_register_read(rt2x00dev, TX_BAND_CFG);
@@ -4494,7 +4535,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 	if (rt2x00_rt(rt2x00dev, RT6352)) {
 		/* BBP for GLRT BW */
 		bbp = conf_is_ht40(conf) ?
-		      0x10 : rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
+		      0x10 : !rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
+		      0x1a : rt2800_hw_get_chippkg(rt2x00dev) == 1 ?
 		      0x15 : 0x1a;
 		rt2800_bbp_glrt_write(rt2x00dev, 141, bbp);
 
@@ -5532,6 +5574,9 @@ static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
 
 void rt2800_gain_calibration(struct rt2x00_dev *rt2x00dev)
 {
+	if (rt2x00_rt(rt2x00dev, RT6352))
+		return;
+
 	rt2800_config_txpower(rt2x00dev, rt2x00dev->hw->conf.chandef.chan,
 			      rt2x00dev->tx_power);
 }
@@ -5675,6 +5720,9 @@ static void rt2800_config_ps(struct rt2x00_dev *rt2x00dev,
 	}
 }
 
+static void rt2800_calibration_rt6352_stage1(struct rt2x00_dev *rt2x00dev);
+static void rt2800_calibration_rt6352_stage2(struct rt2x00_dev *rt2x00dev);
+
 void rt2800_config(struct rt2x00_dev *rt2x00dev,
 		   struct rt2x00lib_conf *libconf,
 		   const unsigned int flags)
@@ -5689,10 +5737,18 @@ void rt2800_config(struct rt2x00_dev *rt2x00dev,
 		 */
 		rt2800_update_survey(rt2x00dev);
 
+		if (rt2x00_rt(rt2x00dev, RT6352) &&
+		    !test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
+			rt2800_calibration_rt6352_stage1(rt2x00dev);
+
 		rt2800_config_channel(rt2x00dev, libconf->conf,
 				      &libconf->rf, &libconf->channel);
 		rt2800_config_txpower(rt2x00dev, libconf->conf->chandef.chan,
 				      libconf->conf->power_level);
+
+		if (rt2x00_rt(rt2x00dev, RT6352) &&
+		    !test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
+			rt2800_calibration_rt6352_stage2(rt2x00dev);
 	}
 	if (flags & IEEE80211_CONF_CHANGE_POWER)
 		rt2800_config_txpower(rt2x00dev, libconf->conf->chandef.chan,
@@ -5733,9 +5789,10 @@ static u8 rt2800_get_default_vgc(struct rt2x00_dev *rt2x00dev)
 		    rt2x00_rt(rt2x00dev, RT3593) ||
 		    rt2x00_rt(rt2x00dev, RT5390) ||
 		    rt2x00_rt(rt2x00dev, RT5392) ||
-		    rt2x00_rt(rt2x00dev, RT5592) ||
-		    rt2x00_rt(rt2x00dev, RT6352))
+		    rt2x00_rt(rt2x00dev, RT5592))
 			vgc = 0x1c + (2 * rt2x00dev->lna_gain);
+		else if(rt2x00_rt(rt2x00dev, RT6352))
+			vgc = 0x04 + (2 * rt2x00dev->lna_gain);
 		else
 			vgc = 0x2e + rt2x00dev->lna_gain;
 	} else { /* 5GHZ band */
@@ -5762,12 +5819,10 @@ static inline void rt2800_set_vgc(struct rt2x00_dev *rt2x00dev,
 		if (rt2x00_rt(rt2x00dev, RT3572) ||
 		    rt2x00_rt(rt2x00dev, RT3593) ||
 		    rt2x00_rt(rt2x00dev, RT3883) ||
+		    rt2x00_rt(rt2x00dev, RT5592) ||
 		    rt2x00_rt(rt2x00dev, RT6352)) {
 			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
 						       vgc_level);
-		} else if (rt2x00_rt(rt2x00dev, RT5592)) {
-			rt2800_bbp_write(rt2x00dev, 83, qual->rssi > -65 ? 0x4a : 0x7a);
-			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, vgc_level);
 		} else {
 			rt2800_bbp_write(rt2x00dev, 66, vgc_level);
 		}
@@ -5788,7 +5843,8 @@ void rt2800_link_tuner(struct rt2x00_dev *rt2x00dev, struct link_qual *qual,
 {
 	u8 vgc;
 
-	if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C))
+	if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C) ||
+	    rt2x00_rt(rt2x00dev, RT6352))
 		return;
 
 	/* When RSSI is better than a certain threshold, increase VGC
@@ -5998,18 +6054,34 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
 	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
 	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
-		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
-		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
-		rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
-		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN, 0x6C6C666C);
-		rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN, 0x6C6C666C);
-		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
-				      0x3630363A);
-		rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
-				      0x3630363A);
+		if (rt2800_hw_get_chipver(rt2x00dev) <= 1) {
+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3,
+					      0x00000000);
+			rt2800_register_write(rt2x00dev, BB_PA_MODE_CFG0,
+					      0x000055FF);
+			rt2800_register_write(rt2x00dev, BB_PA_MODE_CFG1,
+					      0x00550055);
+			rt2800_register_write(rt2x00dev, RF_PA_MODE_CFG0,
+					      0x000055FF);
+			rt2800_register_write(rt2x00dev, RF_PA_MODE_CFG1,
+					      0x00550055);
+		} else {
+			rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
+			rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
+			rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+			rt2800_register_write(rt2x00dev, TX_PIN_CFG, 0x00150f0f);
+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x06060606);
+			rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
+			rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN,
+					      0x6C6C666C);
+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
+					      0x6C6C666C);
+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
+					      0x3630363A);
+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
+					      0x3630363A);
+		}
 		reg = rt2800_register_read(rt2x00dev, TX_ALC_CFG_1);
 		rt2x00_set_field32(&reg, TX_ALC_CFG_1_ROS_BUSY_EN, 0);
 		rt2800_register_write(rt2x00dev, TX_ALC_CFG_1, reg);
@@ -6994,7 +7066,6 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 88, 0x90);
 	rt2800_bbp_write(rt2x00dev, 91, 0x04);
 	rt2800_bbp_write(rt2x00dev, 92, 0x02);
-	rt2800_bbp_write(rt2x00dev, 95, 0x9a);
 	rt2800_bbp_write(rt2x00dev, 98, 0x12);
 	rt2800_bbp_write(rt2x00dev, 103, 0xC0);
 	rt2800_bbp_write(rt2x00dev, 104, 0x92);
@@ -7005,6 +7076,7 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 134, 0xD0);
 	rt2800_bbp_write(rt2x00dev, 135, 0xF6);
 	rt2800_bbp_write(rt2x00dev, 137, 0x0F);
+	rt2800_bbp_write(rt2x00dev, 148, 0x84);
 
 	/* Initialize GLRT (Generalized Likehood Radio Test) */
 	rt2800_init_bbp_5592_glrt(rt2x00dev);
@@ -7029,12 +7101,6 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 		rt2x00_set_field8(&value, BBP254_BIT7, 1);
 		rt2800_bbp_write(rt2x00dev, 254, value);
 	}
-
-	rt2800_init_freq_calibration(rt2x00dev);
-
-	rt2800_bbp_write(rt2x00dev, 84, 0x19);
-	if (rt2x00_rt_rev_gte(rt2x00dev, RT5592, REV_RT5592C))
-		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
 }
 
 static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
@@ -7122,14 +7188,16 @@ static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 188, 0x00);
 	rt2800_bbp_write(rt2x00dev, 189, 0x00);
 
-	rt2800_bbp_write(rt2x00dev, 91, 0x06);
-	rt2800_bbp_write(rt2x00dev, 92, 0x04);
-	rt2800_bbp_write(rt2x00dev, 93, 0x54);
-	rt2800_bbp_write(rt2x00dev, 99, 0x50);
-	rt2800_bbp_write(rt2x00dev, 148, 0x84);
-	rt2800_bbp_write(rt2x00dev, 167, 0x80);
-	rt2800_bbp_write(rt2x00dev, 178, 0xFF);
-	rt2800_bbp_write(rt2x00dev, 106, 0x13);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_bbp_write(rt2x00dev, 91, 0x06);
+		rt2800_bbp_write(rt2x00dev, 92, 0x04);
+		rt2800_bbp_write(rt2x00dev, 93, 0x54);
+		rt2800_bbp_write(rt2x00dev, 99, 0x50);
+		rt2800_bbp_write(rt2x00dev, 148, 0x84);
+		rt2800_bbp_write(rt2x00dev, 167, 0x80);
+		rt2800_bbp_write(rt2x00dev, 178, 0xFF);
+		rt2800_bbp_write(rt2x00dev, 106, 0x13);
+	}
 
 	/* BBP for G band GLRT function (BBP_128 ~ BBP_221) */
 	rt2800_bbp_glrt_write(rt2x00dev, 0, 0x00);
@@ -8460,12 +8528,15 @@ static void rt2800_init_rfcsr_5392(struct rt2x00_dev *rt2x00dev)
 
 static void rt2800_init_rfcsr_5592(struct rt2x00_dev *rt2x00dev)
 {
+	u16 eeprom;
+
 	rt2800_rf_init_calibration(rt2x00dev, 30);
 
 	rt2800_rfcsr_write(rt2x00dev, 1, 0x3F);
+	rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
 	rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
 	rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
-	rt2800_rfcsr_write(rt2x00dev, 6, 0xE4);
+	rt2800_rfcsr_write(rt2x00dev, 6, 0xE0);
 	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
 	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
 	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
@@ -8481,9 +8552,13 @@ static void rt2800_init_rfcsr_5592(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write(rt2x00dev, 34, 0x07);
 	rt2800_rfcsr_write(rt2x00dev, 35, 0x12);
 	rt2800_rfcsr_write(rt2x00dev, 47, 0x0C);
-	rt2800_rfcsr_write(rt2x00dev, 53, 0x22);
+	rt2800_rfcsr_write(rt2x00dev, 53, 0x44);
 	rt2800_rfcsr_write(rt2x00dev, 63, 0x07);
 
+	eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF2);
+	if (!rt2x00_get_field16(eeprom, EEPROM_NIC_CONF2_CRYSTAL))
+		rt2800_rfcsr_write(rt2x00dev, 6, 0xE4);
+
 	rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
 	msleep(1);
 
@@ -8801,7 +8876,7 @@ static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev)
 		rt2x00_warn(rt2x00dev, "Timeout waiting for MAC status in RXIQ calibration\n");
 
 	bbpval = bbp4 & (~0x18);
-	bbpval = bbp4 | 0x00;
+	bbpval = bbpval | 0x00;
 	rt2800_bbp_write(rt2x00dev, 4, bbpval);
 
 	bbpval = rt2800_bbp_read(rt2x00dev, 21);
@@ -8883,13 +8958,13 @@ static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev)
 	for (ch_idx = 0; ch_idx < 2; ch_idx = ch_idx + 1) {
 		if (ch_idx == 0) {
 			rfval = rfb0r1 & (~0x3);
-			rfval = rfb0r1 | 0x1;
+			rfval = rfval | 0x1;
 			rt2800_rfcsr_write_bank(rt2x00dev, 0, 1, rfval);
 			rfval = rfb0r2 & (~0x33);
-			rfval = rfb0r2 | 0x11;
+			rfval = rfval | 0x11;
 			rt2800_rfcsr_write_bank(rt2x00dev, 0, 2, rfval);
 			rfval = rfb0r42 & (~0x50);
-			rfval = rfb0r42 | 0x10;
+			rfval = rfval | 0x10;
 			rt2800_rfcsr_write_bank(rt2x00dev, 0, 42, rfval);
 
 			rt2800_register_write(rt2x00dev, RF_CONTROL0, 0x00001006);
@@ -8902,13 +8977,13 @@ static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev)
 			rt2800_bbp_dcoc_write(rt2x00dev, 1, 0x00);
 		} else {
 			rfval = rfb0r1 & (~0x3);
-			rfval = rfb0r1 | 0x2;
+			rfval = rfval | 0x2;
 			rt2800_rfcsr_write_bank(rt2x00dev, 0, 1, rfval);
 			rfval = rfb0r2 & (~0x33);
-			rfval = rfb0r2 | 0x22;
+			rfval = rfval | 0x22;
 			rt2800_rfcsr_write_bank(rt2x00dev, 0, 2, rfval);
 			rfval = rfb0r42 & (~0x50);
-			rfval = rfb0r42 | 0x40;
+			rfval = rfval | 0x40;
 			rt2800_rfcsr_write_bank(rt2x00dev, 0, 42, rfval);
 
 			rt2800_register_write(rt2x00dev, RF_CONTROL0, 0x00002006);
@@ -10359,6 +10434,9 @@ static void rt2800_restore_rf_bbp_rt6352(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, RF_BYPASS3, 0x0);
 	}
 
+	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
+		return;
+
 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
@@ -10398,15 +10476,21 @@ static void rt2800_restore_rf_bbp_rt6352(struct rt2x00_dev *rt2x00dev)
 	}
 }
 
-static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
+static void rt2800_calibration_rt6352_stage1(struct rt2x00_dev *rt2x00dev)
 {
-	u32 reg;
-
 	if (rt2x00_has_cap_external_pa(rt2x00dev) ||
-	    rt2x00_has_cap_external_lna_bg(rt2x00dev))
+	    rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
+		rt6352_enable_pa_pin(rt2x00dev, 0);
 		rt2800_restore_rf_bbp_rt6352(rt2x00dev);
+	}
 
 	rt2800_r_calibration(rt2x00dev);
+}
+
+static void rt2800_calibration_rt6352_stage2(struct rt2x00_dev *rt2x00dev)
+{
+	u32 reg;
+
 	rt2800_rf_self_txdc_cal(rt2x00dev);
 	rt2800_rxdcoc_calibration(rt2x00dev);
 	rt2800_bw_filter_calibration(rt2x00dev, true);
@@ -10422,6 +10506,8 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 	    !rt2x00_has_cap_external_lna_bg(rt2x00dev))
 		return;
 
+	rt6352_enable_pa_pin(rt2x00dev, 1);
+
 	if (rt2x00_has_cap_external_pa(rt2x00dev)) {
 		reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
 		reg |= 0x00000101;
@@ -10432,6 +10518,9 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
 	}
 
+	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
+		return;
+
 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
@@ -10522,31 +10611,36 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
 	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
 
-	rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
-	if (rt2800_clk_is_20mhz(rt2x00dev))
-		rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
-	else
-		rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
-	rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
-	rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
-	rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
-	rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
-	rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
-	rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
-	rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
-	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
-	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
-	rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
-	rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
+		if (rt2800_clk_is_20mhz(rt2x00dev))
+			rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
+		else
+			rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
+		rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
+		rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
+		rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
+		rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
+		rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
+		rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
+		rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
+		rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
+		rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
+		rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
+		rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
+	}
 
-	rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
-	rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
-	rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
+		rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
+		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+	}
 
 	/* Initialize RF channel register to default value */
 	rt2800_rfcsr_write_chanreg(rt2x00dev, 0, 0x03);
@@ -10612,63 +10706,71 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 
 	rt2800_rfcsr_write_bank(rt2x00dev, 6, 45, 0xC5);
 
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
-	rt2800_rfcsr_write_bank(rt2x00dev, 4, 47, 0x67);
-	rt2800_rfcsr_write_bank(rt2x00dev, 6, 47, 0x69);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
-	rt2800_rfcsr_write_bank(rt2x00dev, 4, 54, 0x27);
-	rt2800_rfcsr_write_bank(rt2x00dev, 6, 54, 0x20);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
-
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
-
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-
-	/* Initialize RF channel register for DRQFN */
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
+		rt2800_rfcsr_write_bank(rt2x00dev, 4, 47, 0x67);
+		rt2800_rfcsr_write_bank(rt2x00dev, 6, 47, 0x69);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
+		rt2800_rfcsr_write_bank(rt2x00dev, 4, 54, 0x27);
+		rt2800_rfcsr_write_bank(rt2x00dev, 6, 54, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
+	}
+
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
+
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+	}
+
+	if (rt2800_hw_get_chippkg(rt2x00dev) == 0 &&
+	    rt2800_hw_get_chipver(rt2x00dev) == 1) {
+		/* Initialize RF channel register for DRQFN */
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
+	}
 
 	/* Initialize RF DC calibration register to default value */
 	rt2800_rfcsr_write_dccal(rt2x00dev, 0, 0x47);
@@ -10731,15 +10833,17 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write_dccal(rt2x00dev, 62, 0x00);
 	rt2800_rfcsr_write_dccal(rt2x00dev, 63, 0x00);
 
-	rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
-
-	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
+	}
 
-	/* Do calibration and init PA/LNA */
-	rt2800_calibration_rt6352(rt2x00dev);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+	}
 }
 
 static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
@@ -11282,6 +11386,17 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
 
+	{
+		struct device_node *np = rt2x00dev->dev->of_node;
+		unsigned int led_polarity;
+
+		/* Allow overriding polarity from OF */
+		if (!of_property_read_u32(np, "ralink,led-polarity",
+					  &led_polarity))
+			rt2x00_set_field16(&eeprom, EEPROM_FREQ_LED_POLARITY,
+					   led_polarity);
+	}
+
 	rt2x00dev->led_mcu_reg = eeprom;
 #endif /* CPTCFG_RT2X00_LIB_LEDS */
 
@@ -12176,8 +12291,9 @@ int rt2800_conf_tx(struct ieee80211_hw *hw,
 	queue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);
 
 	/* Update WMM TXOP register */
-	offset = WMM_TXOP0_CFG + (sizeof(u32) * (!!(queue_idx & 2)));
-	field.bit_offset = (queue_idx & 1) * 16;
+	offset = WMM_TXOP0_CFG +
+		 (sizeof(u32) * (!!(rt2x00_ac_to_hwq(queue_idx) & 2)));
+	field.bit_offset = (rt2x00_ac_to_hwq(queue_idx) & 1) * 16;
 	field.bit_mask = 0xffff << field.bit_offset;
 
 	reg = rt2800_register_read(rt2x00dev, offset);
@@ -12185,7 +12301,7 @@ int rt2800_conf_tx(struct ieee80211_hw *hw,
 	rt2800_register_write(rt2x00dev, offset, reg);
 
 	/* Update WMM registers */
-	field.bit_offset = queue_idx * 4;
+	field.bit_offset = rt2x00_ac_to_hwq(queue_idx) * 4;
 	field.bit_mask = 0xf << field.bit_offset;
 
 	reg = rt2800_register_read(rt2x00dev, WMM_AIFSN_CFG);
@@ -12201,7 +12317,7 @@ int rt2800_conf_tx(struct ieee80211_hw *hw,
 	rt2800_register_write(rt2x00dev, WMM_CWMAX_CFG, reg);
 
 	/* Update EDCA registers */
-	offset = EDCA_AC0_CFG + (sizeof(u32) * queue_idx);
+	offset = EDCA_AC0_CFG + (sizeof(u32) * rt2x00_ac_to_hwq(queue_idx));
 
 	reg = rt2800_register_read(rt2x00dev, offset);
 	rt2x00_set_field32(&reg, EDCA_AC0_CFG_TX_OP, queue->txop);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
index 194de67..59b29f2 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
@@ -76,6 +76,9 @@ struct rt2800_ops {
 	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
 	unsigned int (*drv_get_dma_done)(struct data_queue *queue);
+	int (*hw_get_chippkg)(void);
+	int (*hw_get_chipver)(void);
+	int (*hw_get_chipeco)(void);
 };
 
 static inline u32 rt2800_register_read(struct rt2x00_dev *rt2x00dev,
@@ -184,6 +187,27 @@ static inline unsigned int rt2800_drv_get_dma_done(struct data_queue *queue)
 	return rt2800ops->drv_get_dma_done(queue);
 }
 
+static inline int rt2800_hw_get_chippkg(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chippkg();
+}
+
+static inline int rt2800_hw_get_chipver(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chipver();
+}
+
+static inline int rt2800_hw_get_chipeco(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chipeco();
+}
+
 void rt2800_mcu_request(struct rt2x00_dev *rt2x00dev,
 			const u8 command, const u8 token,
 			const u8 arg0, const u8 arg1);
@@ -270,4 +294,13 @@ void rt2800_get_txwi_rxwi_size(struct rt2x00_dev *rt2x00dev,
 			       unsigned short *rxwi_size);
 void rt2800_pre_reset_hw(struct rt2x00_dev *rt2x00dev);
 
+/*
+ * EEPROM file handlers.
+ */
+#ifdef CPTCFG_RT2X00_LIB_EEPROM
+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev);
+#else
+#define rt2x00lib_read_eeprom	NULL
+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
+
 #endif /* RT2800LIB_H */
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
index 5323acf..e55666f 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
@@ -35,7 +35,7 @@ unsigned int rt2800mmio_get_dma_done(struct data_queue *queue)
 	case QID_AC_VI:
 	case QID_AC_BE:
 	case QID_AC_BK:
-		qid = queue->qid;
+		qid = rt2x00_ac_to_hwq(queue->qid);
 		idx = rt2x00mmio_register_read(rt2x00dev, TX_DTX_IDX(qid));
 		break;
 	case QID_MGMT:
@@ -456,6 +456,7 @@ void rt2800mmio_kick_queue(struct data_queue *queue)
 {
 	struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
 	struct queue_entry *entry;
+	u8 qid;
 
 	switch (queue->qid) {
 	case QID_AC_VO:
@@ -464,7 +465,8 @@ void rt2800mmio_kick_queue(struct data_queue *queue)
 	case QID_AC_BK:
 		WARN_ON_ONCE(rt2x00queue_empty(queue));
 		entry = rt2x00queue_get_entry(queue, Q_INDEX);
-		rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),
+		qid = rt2x00_ac_to_hwq(queue->qid);
+		rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(qid),
 					  entry->entry_idx);
 		hrtimer_start(&rt2x00dev->txstatus_timer,
 			      TXSTATUS_TIMEOUT, HRTIMER_MODE_REL);
@@ -666,36 +668,36 @@ int rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev)
 	 * Initialize registers.
 	 */
 	entry_priv = rt2x00dev->tx[0].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,
 				  rt2x00dev->tx[0].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);
 
 	entry_priv = rt2x00dev->tx[1].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,
 				  rt2x00dev->tx[1].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);
 
 	entry_priv = rt2x00dev->tx[2].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,
 				  rt2x00dev->tx[2].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);
 
 	entry_priv = rt2x00dev->tx[3].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,
 				  rt2x00dev->tx[3].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);
 
 	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR4, 0);
 	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT4, 0);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
index c891043..c1002bc 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
@@ -278,6 +278,9 @@ static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
 {
 	int retval;
 
+	if (!rt2x00lib_read_eeprom(rt2x00dev))
+		return 0;
+
 	if (rt2800pci_efuse_detect(rt2x00dev))
 		retval = rt2800pci_read_eeprom_efuse(rt2x00dev);
 	else
@@ -286,6 +289,10 @@ static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
 	return retval;
 }
 
+static int rt2800pci_get_chippkg(void) { return 0; }
+static int rt2800pci_get_chipver(void) { return 0; }
+static int rt2800pci_get_chipeco(void) { return 0; }
+
 static const struct ieee80211_ops rt2800pci_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -333,6 +340,9 @@ static const struct rt2800_ops rt2800pci_rt2800_ops = {
 	.drv_init_registers	= rt2800mmio_init_registers,
 	.drv_get_txwi		= rt2800mmio_get_txwi,
 	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+	.hw_get_chippkg		= rt2800pci_get_chippkg,
+	.hw_get_chipver		= rt2800pci_get_chipver,
+	.hw_get_chipeco		= rt2800pci_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
index 787dbf0..e0d7893 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
@@ -27,6 +27,12 @@
 #include "rt2800lib.h"
 #include "rt2800mmio.h"
 
+/* Needed to probe CHIP_VER register on MT7620 */
+#ifdef CONFIG_SOC_MT7620
+#include <asm/mach-ralink/ralink_regs.h>
+#include <asm/mach-ralink/mt7620.h>
+#endif
+
 /* Allow hardware encryption to be disabled. */
 static bool modparam_nohwcrypt;
 module_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);
@@ -90,19 +96,6 @@ static int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,
 	return retval;
 }
 
-static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
-{
-	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
-
-	if (!base_addr)
-		return -ENOMEM;
-
-	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
-
-	iounmap(base_addr);
-	return 0;
-}
-
 /* Firmware functions */
 static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
 {
@@ -131,6 +124,27 @@ static int rt2800soc_write_firmware(struct rt2x00_dev *rt2x00dev,
 	return 0;
 }
 
+#ifdef CONFIG_SOC_MT7620
+static int rt2800soc_get_chippkg(void)
+{
+	return mt7620_get_pkg();
+}
+
+static int rt2800soc_get_chipver(void)
+{
+	return mt7620_get_chipver();
+}
+
+static int rt2800soc_get_chipeco(void)
+{
+	return mt7620_get_eco();
+}
+#else
+static int rt2800soc_get_chippkg(void) { return 0; }
+static int rt2800soc_get_chipver(void) { return 0; }
+static int rt2800soc_get_chipeco(void) { return 0; }
+#endif
+
 static const struct ieee80211_ops rt2800soc_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -172,12 +186,15 @@ static const struct rt2800_ops rt2800soc_rt2800_ops = {
 	.register_multiread	= rt2x00mmio_register_multiread,
 	.register_multiwrite	= rt2x00mmio_register_multiwrite,
 	.regbusy_read		= rt2x00mmio_regbusy_read,
-	.read_eeprom		= rt2800soc_read_eeprom,
+	.read_eeprom		= rt2x00lib_read_eeprom,
 	.hwcrypt_disabled	= rt2800soc_hwcrypt_disabled,
 	.drv_write_firmware	= rt2800soc_write_firmware,
 	.drv_init_registers	= rt2800mmio_init_registers,
 	.drv_get_txwi		= rt2800mmio_get_txwi,
 	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+	.hw_get_chippkg		= rt2800soc_get_chippkg,
+	.hw_get_chipver		= rt2800soc_get_chipver,
+	.hw_get_chipeco		= rt2800soc_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {
@@ -243,10 +260,17 @@ static int rt2800soc_probe(struct platform_device *pdev)
 	return rt2x00soc_probe(pdev, &rt2800soc_ops);
 }
 
+static const struct of_device_id rt2880_wmac_match[] = {
+	{ .compatible = "ralink,rt2880-wmac" },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rt2880_wmac_match);
+
 static struct platform_driver rt2800soc_driver = {
 	.driver		= {
 		.name		= "rt2800_wmac",
 		.mod_name	= KBUILD_MODNAME,
+		.of_match_table	= rt2880_wmac_match,
 	},
 	.probe		= rt2800soc_probe,
 	.remove		= rt2x00soc_remove,
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
index a37f8ea..2663447 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
@@ -628,6 +628,10 @@ static int rt2800usb_probe_hw(struct rt2x00_dev *rt2x00dev)
 	return 0;
 }
 
+static int rt2800usb_get_chippkg(void) { return 0; }
+static int rt2800usb_get_chipver(void) { return 0; }
+static int rt2800usb_get_chipeco(void) { return 0; }
+
 static const struct ieee80211_ops rt2800usb_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -676,6 +680,9 @@ static const struct rt2800_ops rt2800usb_rt2800_ops = {
 	.drv_init_registers	= rt2800usb_init_registers,
 	.drv_get_txwi		= rt2800usb_get_txwi,
 	.drv_get_dma_done	= rt2800usb_get_dma_done,
+	.hw_get_chippkg		= rt2800usb_get_chippkg,
+	.hw_get_chipver		= rt2800usb_get_chipver,
+	.hw_get_chipeco		= rt2800usb_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00.h b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
index 4e1ef18..b4b8b89 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
@@ -28,6 +28,8 @@
 #include <linux/average.h>
 #include <linux/usb.h>
 #include <linux/clk.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/rt2x00_platform.h>
 
 #include <net/mac80211.h>
 
@@ -397,6 +399,7 @@ struct hw_mode_spec {
 	unsigned int supported_bands;
 #define SUPPORT_BAND_2GHZ	0x00000001
 #define SUPPORT_BAND_5GHZ	0x00000002
+#define SUPPORT_BAND_BOTH	(SUPPORT_BAND_2GHZ | SUPPORT_BAND_5GHZ)
 
 	unsigned int supported_rates;
 #define SUPPORT_RATE_CCK	0x00000001
@@ -692,6 +695,7 @@ enum rt2x00_capability_flags {
 	REQUIRE_HT_TX_DESC,
 	REQUIRE_PS_AUTOWAKE,
 	REQUIRE_DELAYED_RFKILL,
+	REQUIRE_EEPROM_FILE,
 
 	/*
 	 * Capabilities
@@ -1014,6 +1018,11 @@ struct rt2x00_dev {
 
 	/* Clock for System On Chip devices. */
 	struct clk *clk;
+
+	/* pinctrl and states for System On Chip devices with PA/LNA. */
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_pa_gpio;
 };
 
 struct rt2x00_bar_list_entry {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
index 274524e..69f8d5a 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
@@ -990,6 +990,12 @@ static void rt2x00lib_rate(struct ieee80211_rate *entry,
 
 void rt2x00lib_set_mac_address(struct rt2x00_dev *rt2x00dev, u8 *eeprom_mac_addr)
 {
+	struct rt2x00_platform_data *pdata;
+
+	pdata = rt2x00dev->dev->platform_data;
+	if (pdata && pdata->mac_address)
+		ether_addr_copy(eeprom_mac_addr, pdata->mac_address);
+
 	of_get_mac_address(rt2x00dev->dev->of_node, eeprom_mac_addr);
 
 	if (!is_valid_ether_addr(eeprom_mac_addr)) {
@@ -1007,6 +1013,32 @@ static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
 	struct ieee80211_rate *rates;
 	unsigned int num_rates;
 	unsigned int i;
+#ifdef CONFIG_OF
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int enabled;
+	if (!of_property_read_u32(np, "ralink,2ghz",
+                                          &enabled) && !enabled)
+		spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
+	if (!of_property_read_u32(np, "ralink,5ghz",
+                                          &enabled) && !enabled)
+		spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
+#endif /* CONFIG_OF */
+
+	if (rt2x00dev->dev->platform_data) {
+		struct rt2x00_platform_data *pdata;
+
+		pdata = rt2x00dev->dev->platform_data;
+		if (pdata->disable_2ghz)
+			spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
+		if (pdata->disable_5ghz)
+			spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
+	}
+
+	if ((spec->supported_bands & SUPPORT_BAND_BOTH) == 0) {
+		rt2x00_err(rt2x00dev, "No supported bands\n");
+		return -EINVAL;
+	}
+
 
 	num_rates = 0;
 	if (spec->supported_rates & SUPPORT_RATE_CCK)
@@ -1330,7 +1362,7 @@ static inline void rt2x00lib_set_if_combinations(struct rt2x00_dev *rt2x00dev)
 	 */
 	if_limit = &rt2x00dev->if_limits_ap;
 	if_limit->max = rt2x00dev->ops->max_ap_intf;
-	if_limit->types = BIT(NL80211_IFTYPE_AP);
+	if_limit->types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_STATION);
 #ifdef CPTCFG_MAC80211_MESH
 	if_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);
 #endif
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
new file mode 100644
index 0000000..f87a56e
--- /dev/null
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
+ *	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
+ *	<http://rt2x00.serialmonkey.com>
+ */
+
+/*	Module: rt2x00lib
+ *	Abstract: rt2x00 eeprom file loading routines.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#if IS_ENABLED(CONFIG_MTD)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#endif
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+
+#include "rt2x00.h"
+#include "rt2x00soc.h"
+
+static void rt2800lib_eeprom_swap(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	size_t len = rt2x00dev->ops->eeprom_size;
+	int i;
+
+	if (!of_find_property(np, "ralink,eeprom-swap", NULL))
+		return;
+
+	for (i = 0; i < len / sizeof(u16); i++)
+		rt2x00dev->eeprom[i] = swab16(rt2x00dev->eeprom[i]);
+}
+
+static int rt2800lib_read_eeprom_data(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int len = rt2x00dev->ops->eeprom_size;
+	const void *data;
+	int size;
+
+	data = of_get_property(np, "ralink,eeprom-data", &size);
+	if (!data)
+		return -ENOENT;
+
+	if (size != len) {
+		dev_err(rt2x00dev->dev, "invalid eeprom size, required: 0x%04x\n", len);
+		return -EINVAL;
+	}
+
+	memcpy(rt2x00dev->eeprom, data, size);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_MTD)
+static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
+{
+	int ret = -EINVAL;
+#ifdef CONFIG_OF
+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
+	int size, offset = 0;
+	struct mtd_info *mtd;
+	const char *part;
+	const __be32 *list;
+	phandle phandle;
+	size_t retlen;
+
+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
+	if (!list)
+		return -ENOENT;
+
+	phandle = be32_to_cpup(list++);
+	if (phandle)
+		mtd_np = of_find_node_by_phandle(phandle);
+	if (!mtd_np) {
+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
+		return -EINVAL;
+	}
+
+	part = of_get_property(mtd_np, "label", NULL);
+	if (!part)
+		part = mtd_np->name;
+
+	mtd = get_mtd_device_nm(part);
+	if (IS_ERR(mtd)) {
+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
+		return PTR_ERR(mtd);
+	}
+
+	if (size > sizeof(*list))
+		offset = be32_to_cpup(list);
+
+	ret = mtd_read(mtd, offset, rt2x00dev->ops->eeprom_size,
+		       &retlen, (u_char *)rt2x00dev->eeprom);
+	put_mtd_device(mtd);
+
+	if (retlen != rt2x00dev->ops->eeprom_size || ret) {
+		dev_err(rt2x00dev->dev, "failed to load eeprom from device \"%s\"\n", part);
+		return ret;
+	}
+
+	rt2800lib_eeprom_swap(rt2x00dev);
+
+	dev_info(rt2x00dev->dev, "loaded eeprom from mtd device \"%s\"\n", part);
+#endif
+
+	return ret;
+}
+#endif
+
+static int rt2800lib_read_eeprom_nvmem(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int len = rt2x00dev->ops->eeprom_size;
+	struct nvmem_cell *cell;
+	const void *data;
+	size_t retlen;
+	int ret = 0;
+
+	cell = of_nvmem_cell_get(np, "eeprom");
+	if (IS_ERR(cell))
+		return PTR_ERR(cell);
+
+	data = nvmem_cell_read(cell, &retlen);
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	if (retlen != len) {
+		dev_err(rt2x00dev->dev, "invalid eeprom size, required: 0x%04x\n", len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	memcpy(rt2x00dev->eeprom, data, len);
+
+	rt2800lib_eeprom_swap(rt2x00dev);
+
+exit:
+	kfree(data);
+	return ret;
+}
+
+static const char *
+rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
+{
+	struct rt2x00_platform_data *pdata = rt2x00dev->dev->platform_data;
+#ifdef CONFIG_OF
+	struct device_node *np;
+	const char *eep;
+#endif
+
+	if (pdata && pdata->eeprom_file_name)
+		return pdata->eeprom_file_name;
+
+#ifdef CONFIG_OF
+	np = rt2x00dev->dev->of_node;
+	if (np && !of_property_read_string(np, "ralink,eeprom", &eep))
+		return eep;
+#endif
+
+	return NULL;
+}
+
+static int rt2x00lib_read_eeprom_file(struct rt2x00_dev *rt2x00dev)
+{
+	const struct firmware *ee;
+	const char *ee_name;
+	int retval;
+
+	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
+	if (!ee_name && test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags)) {
+		rt2x00_err(rt2x00dev, "Required EEPROM name is missing.");
+		return -EINVAL;
+	}
+
+	if (!ee_name)
+		return -ENOENT;
+
+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
+
+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
+	if (retval) {
+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
+		return retval;
+	}
+
+	if (!ee || !ee->size || !ee->data) {
+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
+		retval = -ENOENT;
+		goto err_exit;
+	}
+
+	if (ee->size != rt2x00dev->ops->eeprom_size) {
+		rt2x00_err(rt2x00dev,
+			   "EEPROM file size is invalid, it should be %d bytes\n",
+			   rt2x00dev->ops->eeprom_size);
+		retval = -EINVAL;
+		goto err_release_ee;
+	}
+
+	memcpy(rt2x00dev->eeprom, ee->data, rt2x00dev->ops->eeprom_size);
+
+err_release_ee:
+	release_firmware(ee);
+err_exit:
+	return retval;
+}
+
+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev)
+{
+	int ret;
+
+	ret = rt2800lib_read_eeprom_data(rt2x00dev);
+	if (!ret)
+		return 0;
+
+#if IS_ENABLED(CONFIG_MTD)
+	ret = rt2800lib_read_eeprom_mtd(rt2x00dev);
+	if (!ret)
+		return 0;
+#endif
+
+	ret = rt2800lib_read_eeprom_nvmem(rt2x00dev);
+	if (!ret)
+		return 0;
+
+	return rt2x00lib_read_eeprom_file(rt2x00dev);
+}
+EXPORT_SYMBOL_GPL(rt2x00lib_read_eeprom);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
index f5361d5..bad5ce2 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
@@ -98,6 +98,9 @@ static int rt2x00leds_register_led(struct rt2x00_dev *rt2x00dev,
 	led->led_dev.name = name;
 	led->led_dev.brightness = LED_OFF;
 
+	if (rt2x00_is_soc(rt2x00dev))
+		led->led_dev.brightness_set(&led->led_dev, LED_OFF);
+
 	retval = led_classdev_register(device, &led->led_dev);
 	if (retval) {
 		rt2x00_err(rt2x00dev, "Failed to register led handler\n");
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
index 23739dd..fe9102e 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
@@ -56,6 +56,26 @@ enum data_queue_qid {
 	QID_ATIM,
 };
 
+/**
+ * rt2x00_ac_to_hwq - Convert IEEE80211 queue id to Ralink hardware
+ * queue register index.
+ * @ac: TX queue id.
+ */
+static inline u8 rt2x00_ac_to_hwq(enum data_queue_qid ac)
+{
+	static const u8 ralink_queue_map[] = {
+		[IEEE80211_AC_BE] = 0,
+		[IEEE80211_AC_BK] = 1,
+		[IEEE80211_AC_VI] = 2,
+		[IEEE80211_AC_VO] = 3,
+	};
+
+	if (unlikely(ac >= IEEE80211_NUM_ACS))
+		return ac;
+
+	return ralink_queue_map[ac];
+}
+
 /**
  * enum skb_frame_desc_flags: Flags for &struct skb_frame_desc
  *
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
index eface61..541b718 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00soc.c
@@ -86,6 +86,7 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)
 	if (IS_ERR(rt2x00dev->clk))
 		rt2x00dev->clk = NULL;
 
+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
 
 	retval = rt2x00soc_alloc_reg(rt2x00dev);
@@ -96,6 +97,21 @@ int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops *ops)
 	if (retval)
 		goto exit_free_reg;
 
+	rt2x00dev->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(rt2x00dev->pinctrl)) {
+		rt2x00dev->pinctrl = NULL;
+		rt2x00dev->pins_default = NULL;
+		rt2x00dev->pins_pa_gpio = NULL;
+	} else {
+		rt2x00dev->pins_default = pinctrl_lookup_state(rt2x00dev->pinctrl, "default");
+		if (IS_ERR(rt2x00dev->pins_default))
+			rt2x00dev->pins_default = NULL;
+
+		rt2x00dev->pins_pa_gpio = pinctrl_lookup_state(rt2x00dev->pinctrl, "pa_gpio");
+		if (IS_ERR(rt2x00dev->pins_pa_gpio))
+			rt2x00dev->pins_pa_gpio = NULL;
+	}
+
 	return 0;
 
 exit_free_reg:
diff --git a/drivers/net/wireless/virtual/mac80211_hwsim.c b/drivers/net/wireless/virtual/mac80211_hwsim.c
index 48387e0..66d9272 100644
--- a/drivers/net/wireless/virtual/mac80211_hwsim.c
+++ b/drivers/net/wireless/virtual/mac80211_hwsim.c
@@ -6629,6 +6629,7 @@ static void hwsim_virtio_rx_done(struct virtqueue *vq)
 
 static int init_vqs(struct virtio_device *vdev)
 {
+#if LINUX_VERSION_IS_GEQ(6,11,0)
 	struct virtqueue_info vqs_info[HWSIM_NUM_VQS] = {
 		[HWSIM_VQ_TX] = { "tx", hwsim_virtio_tx_done },
 		[HWSIM_VQ_RX] = { "rx", hwsim_virtio_rx_done },
@@ -6636,6 +6637,19 @@ static int init_vqs(struct virtio_device *vdev)
 
 	return virtio_find_vqs(vdev, HWSIM_NUM_VQS,
 			       hwsim_vqs, vqs_info, NULL);
+#else /* Using the old ABI, copied from kernel 6.6 */
+	vq_callback_t *callbacks[HWSIM_NUM_VQS] = {
+		[HWSIM_VQ_TX] = hwsim_virtio_tx_done,
+		[HWSIM_VQ_RX] = hwsim_virtio_rx_done,
+	};
+	const char *names[HWSIM_NUM_VQS] = {
+		[HWSIM_VQ_TX] = "tx",
+		[HWSIM_VQ_RX] = "rx",
+	};
+
+	return virtio_find_vqs(vdev, HWSIM_NUM_VQS,
+			       hwsim_vqs, callbacks, names, NULL);
+#endif
 }
 
 static int fill_vq(struct virtqueue *vq)
diff --git a/include/linux/ath5k_platform.h b/include/linux/ath5k_platform.h
new file mode 100644
index 0000000..ec85224
--- /dev/null
+++ b/include/linux/ath5k_platform.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2008 Atheros Communications Inc.
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LINUX_ATH5K_PLATFORM_H
+#define _LINUX_ATH5K_PLATFORM_H
+
+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
+
+struct ath5k_platform_data {
+	u16 *eeprom_data;
+	u8 *macaddr;
+};
+
+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/include/linux/mhi.h b/include/linux/mhi.h
deleted file mode 100644
index 059dc94..0000000
--- a/include/linux/mhi.h
+++ /dev/null
@@ -1,830 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- *
- */
-#ifndef _MHI_H_
-#define _MHI_H_
-
-#include <linux/device.h>
-#include <linux/dma-direction.h>
-#include <linux/mutex.h>
-#include <linux/skbuff.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-#include <linux/workqueue.h>
-
-#define MHI_MAX_OEM_PK_HASH_SEGMENTS 16
-
-struct mhi_chan;
-struct mhi_event;
-struct mhi_ctxt;
-struct mhi_cmd;
-struct mhi_buf_info;
-
-/**
- * enum mhi_callback - MHI callback
- * @MHI_CB_IDLE: MHI entered idle state
- * @MHI_CB_PENDING_DATA: New data available for client to process
- * @MHI_CB_LPM_ENTER: MHI host entered low power mode
- * @MHI_CB_LPM_EXIT: MHI host about to exit low power mode
- * @MHI_CB_EE_RDDM: MHI device entered RDDM exec env
- * @MHI_CB_EE_MISSION_MODE: MHI device entered Mission Mode exec env
- * @MHI_CB_SYS_ERROR: MHI device entered error state (may recover)
- * @MHI_CB_FATAL_ERROR: MHI device entered fatal error state
- * @MHI_CB_BW_REQ: Received a bandwidth switch request from device
- */
-enum mhi_callback {
-	MHI_CB_IDLE,
-	MHI_CB_PENDING_DATA,
-	MHI_CB_LPM_ENTER,
-	MHI_CB_LPM_EXIT,
-	MHI_CB_EE_RDDM,
-	MHI_CB_EE_MISSION_MODE,
-	MHI_CB_SYS_ERROR,
-	MHI_CB_FATAL_ERROR,
-	MHI_CB_BW_REQ,
-};
-
-/**
- * enum mhi_flags - Transfer flags
- * @MHI_EOB: End of buffer for bulk transfer
- * @MHI_EOT: End of transfer
- * @MHI_CHAIN: Linked transfer
- */
-enum mhi_flags {
-	MHI_EOB = BIT(0),
-	MHI_EOT = BIT(1),
-	MHI_CHAIN = BIT(2),
-};
-
-/**
- * enum mhi_device_type - Device types
- * @MHI_DEVICE_XFER: Handles data transfer
- * @MHI_DEVICE_CONTROLLER: Control device
- */
-enum mhi_device_type {
-	MHI_DEVICE_XFER,
-	MHI_DEVICE_CONTROLLER,
-};
-
-/**
- * enum mhi_ch_type - Channel types
- * @MHI_CH_TYPE_INVALID: Invalid channel type
- * @MHI_CH_TYPE_OUTBOUND: Outbound channel to the device
- * @MHI_CH_TYPE_INBOUND: Inbound channel from the device
- * @MHI_CH_TYPE_INBOUND_COALESCED: Coalesced channel for the device to combine
- *				   multiple packets and send them as a single
- *				   large packet to reduce CPU consumption
- */
-enum mhi_ch_type {
-	MHI_CH_TYPE_INVALID = 0,
-	MHI_CH_TYPE_OUTBOUND = DMA_TO_DEVICE,
-	MHI_CH_TYPE_INBOUND = DMA_FROM_DEVICE,
-	MHI_CH_TYPE_INBOUND_COALESCED = 3,
-};
-
-/**
- * struct image_info - Firmware and RDDM table
- * @mhi_buf: Buffer for firmware and RDDM table
- * @entries: # of entries in table
- */
-struct image_info {
-	struct mhi_buf *mhi_buf;
-	/* private: from internal.h */
-	struct bhi_vec_entry *bhi_vec;
-	/* public: */
-	u32 entries;
-};
-
-/**
- * struct mhi_link_info - BW requirement
- * target_link_speed - Link speed as defined by TLS bits in LinkControl reg
- * target_link_width - Link width as defined by NLW bits in LinkStatus reg
- */
-struct mhi_link_info {
-	unsigned int target_link_speed;
-	unsigned int target_link_width;
-};
-
-/**
- * enum mhi_ee_type - Execution environment types
- * @MHI_EE_PBL: Primary Bootloader
- * @MHI_EE_SBL: Secondary Bootloader
- * @MHI_EE_AMSS: Modem, aka the primary runtime EE
- * @MHI_EE_RDDM: Ram dump download mode
- * @MHI_EE_WFW: WLAN firmware mode
- * @MHI_EE_PTHRU: Passthrough
- * @MHI_EE_EDL: Embedded downloader
- * @MHI_EE_FP: Flash Programmer Environment
- */
-enum mhi_ee_type {
-	MHI_EE_PBL,
-	MHI_EE_SBL,
-	MHI_EE_AMSS,
-	MHI_EE_RDDM,
-	MHI_EE_WFW,
-	MHI_EE_PTHRU,
-	MHI_EE_EDL,
-	MHI_EE_FP,
-	MHI_EE_MAX_SUPPORTED = MHI_EE_FP,
-	MHI_EE_DISABLE_TRANSITION, /* local EE, not related to mhi spec */
-	MHI_EE_NOT_SUPPORTED,
-	MHI_EE_MAX,
-};
-
-/**
- * enum mhi_state - MHI states
- * @MHI_STATE_RESET: Reset state
- * @MHI_STATE_READY: Ready state
- * @MHI_STATE_M0: M0 state
- * @MHI_STATE_M1: M1 state
- * @MHI_STATE_M2: M2 state
- * @MHI_STATE_M3: M3 state
- * @MHI_STATE_M3_FAST: M3 Fast state
- * @MHI_STATE_BHI: BHI state
- * @MHI_STATE_SYS_ERR: System Error state
- */
-enum mhi_state {
-	MHI_STATE_RESET = 0x0,
-	MHI_STATE_READY = 0x1,
-	MHI_STATE_M0 = 0x2,
-	MHI_STATE_M1 = 0x3,
-	MHI_STATE_M2 = 0x4,
-	MHI_STATE_M3 = 0x5,
-	MHI_STATE_M3_FAST = 0x6,
-	MHI_STATE_BHI = 0x7,
-	MHI_STATE_SYS_ERR = 0xFF,
-	MHI_STATE_MAX,
-};
-
-/**
- * enum mhi_ch_ee_mask - Execution environment mask for channel
- * @MHI_CH_EE_PBL: Allow channel to be used in PBL EE
- * @MHI_CH_EE_SBL: Allow channel to be used in SBL EE
- * @MHI_CH_EE_AMSS: Allow channel to be used in AMSS EE
- * @MHI_CH_EE_RDDM: Allow channel to be used in RDDM EE
- * @MHI_CH_EE_PTHRU: Allow channel to be used in PTHRU EE
- * @MHI_CH_EE_WFW: Allow channel to be used in WFW EE
- * @MHI_CH_EE_EDL: Allow channel to be used in EDL EE
- */
-enum mhi_ch_ee_mask {
-	MHI_CH_EE_PBL = BIT(MHI_EE_PBL),
-	MHI_CH_EE_SBL = BIT(MHI_EE_SBL),
-	MHI_CH_EE_AMSS = BIT(MHI_EE_AMSS),
-	MHI_CH_EE_RDDM = BIT(MHI_EE_RDDM),
-	MHI_CH_EE_PTHRU = BIT(MHI_EE_PTHRU),
-	MHI_CH_EE_WFW = BIT(MHI_EE_WFW),
-	MHI_CH_EE_EDL = BIT(MHI_EE_EDL),
-};
-
-/**
- * enum mhi_er_data_type - Event ring data types
- * @MHI_ER_DATA: Only client data over this ring
- * @MHI_ER_CTRL: MHI control data and client data
- */
-enum mhi_er_data_type {
-	MHI_ER_DATA,
-	MHI_ER_CTRL,
-};
-
-/**
- * enum mhi_db_brst_mode - Doorbell mode
- * @MHI_DB_BRST_DISABLE: Burst mode disable
- * @MHI_DB_BRST_ENABLE: Burst mode enable
- */
-enum mhi_db_brst_mode {
-	MHI_DB_BRST_DISABLE = 0x2,
-	MHI_DB_BRST_ENABLE = 0x3,
-};
-
-/**
- * struct mhi_channel_config - Channel configuration structure for controller
- * @name: The name of this channel
- * @num: The number assigned to this channel
- * @num_elements: The number of elements that can be queued to this channel
- * @local_elements: The local ring length of the channel
- * @event_ring: The event ring index that services this channel
- * @dir: Direction that data may flow on this channel
- * @type: Channel type
- * @ee_mask: Execution Environment mask for this channel
- * @pollcfg: Polling configuration for burst mode.  0 is default.  milliseconds
-	     for UL channels, multiple of 8 ring elements for DL channels
- * @doorbell: Doorbell mode
- * @lpm_notify: The channel master requires low power mode notifications
- * @offload_channel: The client manages the channel completely
- * @doorbell_mode_switch: Channel switches to doorbell mode on M0 transition
- * @auto_queue: Framework will automatically queue buffers for DL traffic
- * @wake-capable: Channel capable of waking up the system
- */
-struct mhi_channel_config {
-	char *name;
-	u32 num;
-	u32 num_elements;
-	u32 local_elements;
-	u32 event_ring;
-	enum dma_data_direction dir;
-	enum mhi_ch_type type;
-	u32 ee_mask;
-	u32 pollcfg;
-	enum mhi_db_brst_mode doorbell;
-	bool lpm_notify;
-	bool offload_channel;
-	bool doorbell_mode_switch;
-	bool auto_queue;
-	bool wake_capable;
-};
-
-/**
- * struct mhi_event_config - Event ring configuration structure for controller
- * @num_elements: The number of elements that can be queued to this ring
- * @irq_moderation_ms: Delay irq for additional events to be aggregated
- * @irq: IRQ associated with this ring
- * @channel: Dedicated channel number. U32_MAX indicates a non-dedicated ring
- * @priority: Priority of this ring. Use 1 for now
- * @mode: Doorbell mode
- * @data_type: Type of data this ring will process
- * @hardware_event: This ring is associated with hardware channels
- * @client_managed: This ring is client managed
- * @offload_channel: This ring is associated with an offloaded channel
- */
-struct mhi_event_config {
-	u32 num_elements;
-	u32 irq_moderation_ms;
-	u32 irq;
-	u32 channel;
-	u32 priority;
-	enum mhi_db_brst_mode mode;
-	enum mhi_er_data_type data_type;
-	bool hardware_event;
-	bool client_managed;
-	bool offload_channel;
-};
-
-/**
- * struct mhi_controller_config - Root MHI controller configuration
- * @max_channels: Maximum number of channels supported
- * @timeout_ms: Timeout value for operations. 0 means use default
- * @ready_timeout_ms: Timeout value for waiting device to be ready (optional)
- * @buf_len: Size of automatically allocated buffers. 0 means use default
- * @num_channels: Number of channels defined in @ch_cfg
- * @ch_cfg: Array of defined channels
- * @num_events: Number of event rings defined in @event_cfg
- * @event_cfg: Array of defined event rings
- * @use_bounce_buf: Use a bounce buffer pool due to limited DDR access
- * @m2_no_db: Host is not allowed to ring DB in M2 state
- */
-struct mhi_controller_config {
-	u32 max_channels;
-	u32 timeout_ms;
-	u32 ready_timeout_ms;
-	u32 buf_len;
-	u32 num_channels;
-	const struct mhi_channel_config *ch_cfg;
-	u32 num_events;
-	struct mhi_event_config *event_cfg;
-	bool use_bounce_buf;
-	bool m2_no_db;
-};
-
-/**
- * struct mhi_controller - Master MHI controller structure
- * @name: Device name of the MHI controller
- * @cntrl_dev: Pointer to the struct device of physical bus acting as the MHI
- *            controller (required)
- * @mhi_dev: MHI device instance for the controller
- * @debugfs_dentry: MHI controller debugfs directory
- * @regs: Base address of MHI MMIO register space (required)
- * @bhi: Points to base of MHI BHI register space
- * @bhie: Points to base of MHI BHIe register space
- * @wake_db: MHI WAKE doorbell register address
- * @iova_start: IOMMU starting address for data (required)
- * @iova_stop: IOMMU stop address for data (required)
- * @fw_image: Firmware image name for normal booting (optional)
- * @fw_data: Firmware image data content for normal booting, used only
- *           if fw_image is NULL and fbc_download is true (optional)
- * @fw_sz: Firmware image data size for normal booting, used only if fw_image
- *         is NULL and fbc_download is true (optional)
- * @edl_image: Firmware image name for emergency download mode (optional)
- * @rddm_size: RAM dump size that host should allocate for debugging purpose
- * @sbl_size: SBL image size downloaded through BHIe (optional)
- * @seg_len: BHIe vector size (optional)
- * @reg_len: Length of the MHI MMIO region (required)
- * @fbc_image: Points to firmware image buffer
- * @rddm_image: Points to RAM dump buffer
- * @mhi_chan: Points to the channel configuration table
- * @lpm_chans: List of channels that require LPM notifications
- * @irq: base irq # to request (required)
- * @max_chan: Maximum number of channels the controller supports
- * @total_ev_rings: Total # of event rings allocated
- * @hw_ev_rings: Number of hardware event rings
- * @sw_ev_rings: Number of software event rings
- * @nr_irqs: Number of IRQ allocated by bus master (required)
- * @serial_number: MHI controller serial number obtained from BHI
- * @mhi_event: MHI event ring configurations table
- * @mhi_cmd: MHI command ring configurations table
- * @mhi_ctxt: MHI device context, shared memory between host and device
- * @pm_mutex: Mutex for suspend/resume operation
- * @pm_lock: Lock for protecting MHI power management state
- * @timeout_ms: Timeout in ms for state transitions
- * @ready_timeout_ms: Timeout in ms for waiting device to be ready (optional)
- * @pm_state: MHI power management state
- * @db_access: DB access states
- * @ee: MHI device execution environment
- * @dev_state: MHI device state
- * @dev_wake: Device wakeup count
- * @pending_pkts: Pending packets for the controller
- * @M0, M2, M3: Counters to track number of device MHI state changes
- * @transition_list: List of MHI state transitions
- * @transition_lock: Lock for protecting MHI state transition list
- * @wlock: Lock for protecting device wakeup
- * @mhi_link_info: Device bandwidth info
- * @st_worker: State transition worker
- * @hiprio_wq: High priority workqueue for MHI work such as state transitions
- * @state_event: State change event
- * @status_cb: CB function to notify power states of the device (required)
- * @wake_get: CB function to assert device wake (optional)
- * @wake_put: CB function to de-assert device wake (optional)
- * @wake_toggle: CB function to assert and de-assert device wake (optional)
- * @runtime_get: CB function to controller runtime resume (required)
- * @runtime_put: CB function to decrement pm usage (required)
- * @map_single: CB function to create TRE buffer
- * @unmap_single: CB function to destroy TRE buffer
- * @read_reg: Read a MHI register via the physical link (required)
- * @write_reg: Write a MHI register via the physical link (required)
- * @reset: Controller specific reset function (optional)
- * @edl_trigger: CB function to trigger EDL mode (optional)
- * @buffer_len: Bounce buffer length
- * @index: Index of the MHI controller instance
- * @bounce_buf: Use of bounce buffer
- * @fbc_download: MHI host needs to do complete image transfer (optional)
- * @wake_set: Device wakeup set flag
- * @irq_flags: irq flags passed to request_irq (optional)
- * @mru: the default MRU for the MHI device
- *
- * Fields marked as (required) need to be populated by the controller driver
- * before calling mhi_register_controller(). For the fields marked as (optional)
- * they can be populated depending on the usecase.
- */
-struct mhi_controller {
-	const char *name;
-	struct device *cntrl_dev;
-	struct mhi_device *mhi_dev;
-	struct dentry *debugfs_dentry;
-	void __iomem *regs;
-	void __iomem *bhi;
-	void __iomem *bhie;
-	void __iomem *wake_db;
-
-	dma_addr_t iova_start;
-	dma_addr_t iova_stop;
-	const char *fw_image;
-	const u8 *fw_data;
-	size_t fw_sz;
-	const char *edl_image;
-	size_t rddm_size;
-	size_t sbl_size;
-	size_t seg_len;
-	size_t reg_len;
-	struct image_info *fbc_image;
-	struct image_info *rddm_image;
-	struct mhi_chan *mhi_chan;
-	struct list_head lpm_chans;
-	int *irq;
-	u32 max_chan;
-	u32 total_ev_rings;
-	u32 hw_ev_rings;
-	u32 sw_ev_rings;
-	u32 nr_irqs;
-	u32 serial_number;
-
-	struct mhi_event *mhi_event;
-	struct mhi_cmd *mhi_cmd;
-	struct mhi_ctxt *mhi_ctxt;
-
-	struct mutex pm_mutex;
-	rwlock_t pm_lock;
-	u32 timeout_ms;
-	u32 ready_timeout_ms;
-	u32 pm_state;
-	u32 db_access;
-	enum mhi_ee_type ee;
-	enum mhi_state dev_state;
-	atomic_t dev_wake;
-	atomic_t pending_pkts;
-	u32 M0, M2, M3;
-	struct list_head transition_list;
-	spinlock_t transition_lock;
-	spinlock_t wlock;
-	struct mhi_link_info mhi_link_info;
-	struct work_struct st_worker;
-	struct workqueue_struct *hiprio_wq;
-	wait_queue_head_t state_event;
-
-	void (*status_cb)(struct mhi_controller *mhi_cntrl,
-			  enum mhi_callback cb);
-	void (*wake_get)(struct mhi_controller *mhi_cntrl, bool override);
-	void (*wake_put)(struct mhi_controller *mhi_cntrl, bool override);
-	void (*wake_toggle)(struct mhi_controller *mhi_cntrl);
-	int (*runtime_get)(struct mhi_controller *mhi_cntrl);
-	void (*runtime_put)(struct mhi_controller *mhi_cntrl);
-	int (*map_single)(struct mhi_controller *mhi_cntrl,
-			  struct mhi_buf_info *buf);
-	void (*unmap_single)(struct mhi_controller *mhi_cntrl,
-			     struct mhi_buf_info *buf);
-	int (*read_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,
-			u32 *out);
-	void (*write_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,
-			  u32 val);
-	void (*reset)(struct mhi_controller *mhi_cntrl);
-	int (*edl_trigger)(struct mhi_controller *mhi_cntrl);
-
-	size_t buffer_len;
-	int index;
-	bool bounce_buf;
-	bool fbc_download;
-	bool wake_set;
-	unsigned long irq_flags;
-	u32 mru;
-};
-
-/**
- * struct mhi_device - Structure representing an MHI device which binds
- *                     to channels or is associated with controllers
- * @id: Pointer to MHI device ID struct
- * @name: Name of the associated MHI device
- * @mhi_cntrl: Controller the device belongs to
- * @ul_chan: UL channel for the device
- * @dl_chan: DL channel for the device
- * @dev: Driver model device node for the MHI device
- * @dev_type: MHI device type
- * @ul_chan_id: MHI channel id for UL transfer
- * @dl_chan_id: MHI channel id for DL transfer
- * @dev_wake: Device wakeup counter
- */
-struct mhi_device {
-	const struct mhi_device_id *id;
-	const char *name;
-	struct mhi_controller *mhi_cntrl;
-	struct mhi_chan *ul_chan;
-	struct mhi_chan *dl_chan;
-	struct device dev;
-	enum mhi_device_type dev_type;
-	int ul_chan_id;
-	int dl_chan_id;
-	u32 dev_wake;
-};
-
-/**
- * struct mhi_result - Completed buffer information
- * @buf_addr: Address of data buffer
- * @bytes_xferd: # of bytes transferred
- * @dir: Channel direction
- * @transaction_status: Status of last transaction
- */
-struct mhi_result {
-	void *buf_addr;
-	size_t bytes_xferd;
-	enum dma_data_direction dir;
-	int transaction_status;
-};
-
-/**
- * struct mhi_buf - MHI Buffer description
- * @buf: Virtual address of the buffer
- * @name: Buffer label. For offload channel, configurations name must be:
- *        ECA - Event context array data
- *        CCA - Channel context array data
- * @dma_addr: IOMMU address of the buffer
- * @len: # of bytes
- */
-struct mhi_buf {
-	void *buf;
-	const char *name;
-	dma_addr_t dma_addr;
-	size_t len;
-};
-
-/**
- * struct mhi_driver - Structure representing a MHI client driver
- * @probe: CB function for client driver probe function
- * @remove: CB function for client driver remove function
- * @ul_xfer_cb: CB function for UL data transfer
- * @dl_xfer_cb: CB function for DL data transfer
- * @status_cb: CB functions for asynchronous status
- * @driver: Device driver model driver
- */
-struct mhi_driver {
-	const struct mhi_device_id *id_table;
-	int (*probe)(struct mhi_device *mhi_dev,
-		     const struct mhi_device_id *id);
-	void (*remove)(struct mhi_device *mhi_dev);
-	void (*ul_xfer_cb)(struct mhi_device *mhi_dev,
-			   struct mhi_result *result);
-	void (*dl_xfer_cb)(struct mhi_device *mhi_dev,
-			   struct mhi_result *result);
-	void (*status_cb)(struct mhi_device *mhi_dev, enum mhi_callback mhi_cb);
-	struct device_driver driver;
-};
-
-#define to_mhi_driver(drv) container_of_const(drv, struct mhi_driver, driver)
-#define to_mhi_device(dev) container_of(dev, struct mhi_device, dev)
-
-/**
- * mhi_alloc_controller - Allocate the MHI Controller structure
- * Allocate the mhi_controller structure using zero initialized memory
- */
-struct mhi_controller *mhi_alloc_controller(void);
-
-/**
- * mhi_free_controller - Free the MHI Controller structure
- * Free the mhi_controller structure which was previously allocated
- */
-void mhi_free_controller(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_register_controller - Register MHI controller
- * @mhi_cntrl: MHI controller to register
- * @config: Configuration to use for the controller
- */
-int mhi_register_controller(struct mhi_controller *mhi_cntrl,
-			const struct mhi_controller_config *config);
-
-/**
- * mhi_unregister_controller - Unregister MHI controller
- * @mhi_cntrl: MHI controller to unregister
- */
-void mhi_unregister_controller(struct mhi_controller *mhi_cntrl);
-
-/*
- * module_mhi_driver() - Helper macro for drivers that don't do
- * anything special other than using default mhi_driver_register() and
- * mhi_driver_unregister().  This eliminates a lot of boilerplate.
- * Each module may only use this macro once.
- */
-#define module_mhi_driver(mhi_drv) \
-	module_driver(mhi_drv, mhi_driver_register, \
-		      mhi_driver_unregister)
-
-/*
- * Macro to avoid include chaining to get THIS_MODULE
- */
-#define mhi_driver_register(mhi_drv) \
-	__mhi_driver_register(mhi_drv, THIS_MODULE)
-
-/**
- * __mhi_driver_register - Register driver with MHI framework
- * @mhi_drv: Driver associated with the device
- * @owner: The module owner
- */
-int __mhi_driver_register(struct mhi_driver *mhi_drv, struct module *owner);
-
-/**
- * mhi_driver_unregister - Unregister a driver for mhi_devices
- * @mhi_drv: Driver associated with the device
- */
-void mhi_driver_unregister(struct mhi_driver *mhi_drv);
-
-/**
- * mhi_set_mhi_state - Set MHI device state
- * @mhi_cntrl: MHI controller
- * @state: State to set
- */
-void mhi_set_mhi_state(struct mhi_controller *mhi_cntrl,
-		       enum mhi_state state);
-
-/**
- * mhi_notify - Notify the MHI client driver about client device status
- * @mhi_dev: MHI device instance
- * @cb_reason: MHI callback reason
- */
-void mhi_notify(struct mhi_device *mhi_dev, enum mhi_callback cb_reason);
-
-/**
- * mhi_get_free_desc_count - Get transfer ring length
- * Get # of TD available to queue buffers
- * @mhi_dev: Device associated with the channels
- * @dir: Direction of the channel
- */
-int mhi_get_free_desc_count(struct mhi_device *mhi_dev,
-				enum dma_data_direction dir);
-
-/**
- * mhi_prepare_for_power_up - Do pre-initialization before power up.
- *                            This is optional, call this before power up if
- *                            the controller does not want bus framework to
- *                            automatically free any allocated memory during
- *                            shutdown process.
- * @mhi_cntrl: MHI controller
- */
-int mhi_prepare_for_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_async_power_up - Start MHI power up sequence
- * @mhi_cntrl: MHI controller
- */
-int mhi_async_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_sync_power_up - Start MHI power up sequence and wait till the device
- *                     enters valid EE state
- * @mhi_cntrl: MHI controller
- */
-int mhi_sync_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_power_down - Power down the MHI device and also destroy the
- *                  'struct device' for the channels associated with it.
- *                  See also mhi_power_down_keep_dev() which is a variant
- *                  of this API that keeps the 'struct device' for channels
- *                  (useful during suspend/hibernation).
- * @mhi_cntrl: MHI controller
- * @graceful: Link is still accessible, so do a graceful shutdown process
- */
-void mhi_power_down(struct mhi_controller *mhi_cntrl, bool graceful);
-
-/**
- * mhi_power_down_keep_dev - Power down the MHI device but keep the 'struct
- *                           device' for the channels associated with it.
- *                           This is a variant of 'mhi_power_down()' and
- *                           useful in scenarios such as suspend/hibernation
- *                           where destroying of the 'struct device' is not
- *                           needed.
- * @mhi_cntrl: MHI controller
- * @graceful: Link is still accessible, so do a graceful shutdown process
- */
-void mhi_power_down_keep_dev(struct mhi_controller *mhi_cntrl, bool graceful);
-
-/**
- * mhi_unprepare_after_power_down - Free any allocated memory after power down
- * @mhi_cntrl: MHI controller
- */
-void mhi_unprepare_after_power_down(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_suspend - Move MHI into a suspended state
- * @mhi_cntrl: MHI controller
- */
-int mhi_pm_suspend(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_resume - Resume MHI from suspended state
- * @mhi_cntrl: MHI controller
- */
-int mhi_pm_resume(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_resume_force - Force resume MHI from suspended state
- * @mhi_cntrl: MHI controller
- *
- * Resume the device irrespective of its MHI state. As per the MHI spec, devices
- * has to be in M3 state during resume. But some devices seem to be in a
- * different MHI state other than M3 but they continue working fine if allowed.
- * This API is intented to be used for such devices.
- *
- * Return: 0 if the resume succeeds, a negative error code otherwise
- */
-int mhi_pm_resume_force(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_download_rddm_image - Download ramdump image from device for
- *                           debugging purpose.
- * @mhi_cntrl: MHI controller
- * @in_panic: Download rddm image during kernel panic
- */
-int mhi_download_rddm_image(struct mhi_controller *mhi_cntrl, bool in_panic);
-
-/**
- * mhi_force_rddm_mode - Force device into rddm mode
- * @mhi_cntrl: MHI controller
- */
-int mhi_force_rddm_mode(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_get_exec_env - Get BHI execution environment of the device
- * @mhi_cntrl: MHI controller
- */
-enum mhi_ee_type mhi_get_exec_env(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_get_mhi_state - Get MHI state of the device
- * @mhi_cntrl: MHI controller
- */
-enum mhi_state mhi_get_mhi_state(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_soc_reset - Trigger a device reset. This can be used as a last resort
- *		   to reset and recover a device.
- * @mhi_cntrl: MHI controller
- */
-void mhi_soc_reset(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_device_get - Disable device low power mode
- * @mhi_dev: Device associated with the channel
- */
-void mhi_device_get(struct mhi_device *mhi_dev);
-
-/**
- * mhi_device_get_sync - Disable device low power mode. Synchronously
- *                       take the controller out of suspended state
- * @mhi_dev: Device associated with the channel
- */
-int mhi_device_get_sync(struct mhi_device *mhi_dev);
-
-/**
- * mhi_device_put - Re-enable device low power mode
- * @mhi_dev: Device associated with the channel
- */
-void mhi_device_put(struct mhi_device *mhi_dev);
-
-/**
- * mhi_prepare_for_transfer - Setup UL and DL channels for data transfer.
- * @mhi_dev: Device associated with the channels
- *
- * Allocate and initialize the channel context and also issue the START channel
- * command to both channels. Channels can be started only if both host and
- * device execution environments match and channels are in a DISABLED state.
- */
-int mhi_prepare_for_transfer(struct mhi_device *mhi_dev);
-
-/**
- * mhi_prepare_for_transfer_autoqueue - Setup UL and DL channels with auto queue
- *                                      buffers for DL traffic
- * @mhi_dev: Device associated with the channels
- *
- * Allocate and initialize the channel context and also issue the START channel
- * command to both channels. Channels can be started only if both host and
- * device execution environments match and channels are in a DISABLED state.
- * The MHI core will automatically allocate and queue buffers for the DL traffic.
- */
-int mhi_prepare_for_transfer_autoqueue(struct mhi_device *mhi_dev);
-
-/**
- * mhi_unprepare_from_transfer - Reset UL and DL channels for data transfer.
- *                               Issue the RESET channel command and let the
- *                               device clean-up the context so no incoming
- *                               transfers are seen on the host. Free memory
- *                               associated with the context on host. If device
- *                               is unresponsive, only perform a host side
- *                               clean-up. Channels can be reset only if both
- *                               host and device execution environments match
- *                               and channels are in an ENABLED, STOPPED or
- *                               SUSPENDED state.
- * @mhi_dev: Device associated with the channels
- */
-void mhi_unprepare_from_transfer(struct mhi_device *mhi_dev);
-
-/**
- * mhi_queue_dma - Send or receive DMA mapped buffers from client device
- *                 over MHI channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @mhi_buf: Buffer for holding the DMA mapped data
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_dma(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  struct mhi_buf *mhi_buf, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_buf - Send or receive raw buffers from client device over MHI
- *                 channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @buf: Buffer for holding the data
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_buf(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  void *buf, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_skb - Send or receive SKBs from client device over MHI channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @skb: Buffer for holding SKBs
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_skb(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  struct sk_buff *skb, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_is_full - Determine whether queueing new elements is possible
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- */
-bool mhi_queue_is_full(struct mhi_device *mhi_dev, enum dma_data_direction dir);
-
-/**
- * mhi_get_channel_doorbell_offset - Get the channel doorbell offset
- * @mhi_cntrl: MHI controller
- * @chdb_offset: Read channel doorbell offset
- *
- * Return: 0 if the read succeeds, a negative error code otherwise
- */
-int mhi_get_channel_doorbell_offset(struct mhi_controller *mhi_cntrl, u32 *chdb_offset);
-
-#endif /* _MHI_H_ */
diff --git a/include/linux/rt2x00_platform.h b/include/linux/rt2x00_platform.h
new file mode 100644
index 0000000..e10377e
--- /dev/null
+++ b/include/linux/rt2x00_platform.h
@@ -0,0 +1,23 @@
+/*
+ * Platform data definition for the rt2x00 driver
+ *
+ * Copyright (C) 2011 Gabor Juhos <juhosg@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published
+ * by the Free Software Foundation.
+ *
+ */
+
+#ifndef _RT2X00_PLATFORM_H
+#define _RT2X00_PLATFORM_H
+
+struct rt2x00_platform_data {
+	char *eeprom_file_name;
+	const u8 *mac_address;
+
+	int disable_2ghz;
+	int disable_5ghz;
+};
+
+#endif /* _RT2X00_PLATFORM_H */
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index f86af24..0d21316 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -187,6 +187,8 @@ enum ieee80211_channel_flags {
  * @dfs_state: current state of this channel. Only relevant if radar is required
  *	on this channel.
  * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.
+ * @dfs_state_last_available: timestamp (jiffies) of the last time when the
+ *	channel was available.
  * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.
  * @psd: power spectral density (in dBm)
  */
@@ -204,6 +206,7 @@ struct ieee80211_channel {
 	int orig_mag, orig_mpwr;
 	enum nl80211_dfs_state dfs_state;
 	unsigned long dfs_state_entered;
+	unsigned long dfs_state_last_available;
 	unsigned int dfs_cac_ms;
 	s8 psd;
 };
@@ -2269,6 +2272,7 @@ static inline int cfg80211_get_station(struct net_device *dev,
  * @MONITOR_FLAG_OTHER_BSS: disable BSSID filtering
  * @MONITOR_FLAG_COOK_FRAMES: report frames after processing
  * @MONITOR_FLAG_ACTIVE: active monitor, ACKs frames on its MAC address
+ * @MONITOR_FLAG_SKIP_TX: do not pass locally transmitted frames
  */
 enum monitor_flags {
 	MONITOR_FLAG_CHANGED		= BIT(__NL80211_MNTR_FLAG_INVALID),
@@ -2278,6 +2282,7 @@ enum monitor_flags {
 	MONITOR_FLAG_OTHER_BSS		= BIT(NL80211_MNTR_FLAG_OTHER_BSS),
 	MONITOR_FLAG_COOK_FRAMES	= BIT(NL80211_MNTR_FLAG_COOK_FRAMES),
 	MONITOR_FLAG_ACTIVE		= BIT(NL80211_MNTR_FLAG_ACTIVE),
+	MONITOR_FLAG_SKIP_TX		= BIT(NL80211_MNTR_FLAG_SKIP_TX),
 };
 
 /**
@@ -3420,6 +3425,7 @@ enum wiphy_params_flags {
 /* The per TXQ device queue limit in airtime */
 #define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L	5000
 #define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H	12000
+#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_BC	50000
 
 /* The per interface airtime threshold to switch to lower queue limit */
 #define IEEE80211_AQL_THRESHOLD			24000
@@ -4696,6 +4702,7 @@ struct cfg80211_ops {
 					     struct ieee80211_channel *chan);
 
 	int	(*set_monitor_channel)(struct wiphy *wiphy,
+				       struct net_device *dev,
 				       struct cfg80211_chan_def *chandef);
 
 	int	(*scan)(struct wiphy *wiphy,
@@ -5436,6 +5443,8 @@ struct wiphy_radio_freq_range {
  * @iface_combinations: Valid interface combinations array, should not
  *	list single interface types.
  * @n_iface_combinations: number of entries in @iface_combinations array.
+ *
+ * @antenna_mask: bitmask of antennas connected to this radio.
  */
 struct wiphy_radio {
 	const struct wiphy_radio_freq_range *freq_range;
@@ -5443,6 +5452,8 @@ struct wiphy_radio {
 
 	const struct ieee80211_iface_combination *iface_combinations;
 	int n_iface_combinations;
+
+	u32 antenna_mask;
 };
 
 #define CFG80211_HW_TIMESTAMP_ALL_PEERS	0xffff
@@ -6267,6 +6278,7 @@ enum ieee80211_ap_reg_power {
  *	entered.
  * @links.cac_time_ms: CAC time in ms
  * @valid_links: bitmap describing what elements of @links are valid
+ * @radio_mask: Bitmask of radios that this interface is allowed to operate on.
  */
 struct wireless_dev {
 	struct wiphy *wiphy;
@@ -6379,6 +6391,8 @@ struct wireless_dev {
 		unsigned int cac_time_ms;
 	} links[IEEE80211_MLD_MAX_NUM_LINKS];
 	u16 valid_links;
+
+	u32 radio_mask;
 };
 
 static inline const u8 *wdev_address(struct wireless_dev *wdev)
@@ -6564,6 +6578,17 @@ static inline bool cfg80211_channel_is_psc(struct ieee80211_channel *chan)
 bool cfg80211_radio_chandef_valid(const struct wiphy_radio *radio,
 				  const struct cfg80211_chan_def *chandef);
 
+/**
+ * cfg80211_wdev_channel_allowed - Check if the wdev may use the channel
+ *
+ * @wdev: the wireless device
+ * @chan: channel to check
+ *
+ * Return: whether or not the wdev may use the channel
+ */
+bool cfg80211_wdev_channel_allowed(struct wireless_dev *wdev,
+				   struct ieee80211_channel *chan);
+
 /**
  * ieee80211_get_response_rate - get basic rate for a given rate
  *
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 49e0741..408b642 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1222,8 +1222,8 @@ struct ieee80211_tx_info {
 	    status_data_idr:1,
 	    status_data:13,
 	    hw_queue:4,
+	    tx_time_mc:1,
 	    tx_time_est:10;
-	/* 1 free bit */
 
 	union {
 		struct {
@@ -1448,8 +1448,6 @@ ieee80211_tx_info_clear_status(struct ieee80211_tx_info *info)
  * @RX_FLAG_AMPDU_IS_LAST: this subframe is the last subframe of the A-MPDU
  * @RX_FLAG_AMPDU_DELIM_CRC_ERROR: A delimiter CRC error has been detected
  *	on this subframe
- * @RX_FLAG_AMPDU_DELIM_CRC_KNOWN: The delimiter CRC field is known (the CRC
- *	is stored in the @ampdu_delimiter_crc field)
  * @RX_FLAG_MIC_STRIPPED: The mic was stripped of this packet. Decryption was
  *	done by the hardware
  * @RX_FLAG_ONLY_MONITOR: Report frame only to monitor interfaces without
@@ -1521,7 +1519,7 @@ enum mac80211_rx_flags {
 	RX_FLAG_AMPDU_LAST_KNOWN	= BIT(12),
 	RX_FLAG_AMPDU_IS_LAST		= BIT(13),
 	RX_FLAG_AMPDU_DELIM_CRC_ERROR	= BIT(14),
-	RX_FLAG_AMPDU_DELIM_CRC_KNOWN	= BIT(15),
+	/* one free bit at 15 */
 	RX_FLAG_MACTIME			= BIT(16) | BIT(17),
 	RX_FLAG_MACTIME_PLCP_START	= 1 << 16,
 	RX_FLAG_MACTIME_START		= 2 << 16,
@@ -1618,7 +1616,6 @@ enum mac80211_rx_encoding {
  * @rx_flags: internal RX flags for mac80211
  * @ampdu_reference: A-MPDU reference number, must be a different value for
  *	each A-MPDU but the same for each subframe within one A-MPDU
- * @ampdu_delimiter_crc: A-MPDU delimiter CRC
  * @zero_length_psdu_type: radiotap type of the 0-length PSDU
  * @link_valid: if the link which is identified by @link_id is valid. This flag
  *	is set only when connection is MLO.
@@ -1656,7 +1653,6 @@ struct ieee80211_rx_status {
 	s8 signal;
 	u8 chains;
 	s8 chain_signal[IEEE80211_MAX_CHAINS];
-	u8 ampdu_delimiter_crc;
 	u8 zero_length_psdu_type;
 	u8 link_valid:1, link_id:4;
 };
@@ -1976,6 +1972,8 @@ enum ieee80211_neg_ttlm_res {
  * @neg_ttlm: negotiated TID to link mapping info.
  *	see &struct ieee80211_neg_ttlm.
  * @addr: address of this interface
+ * @addr_valid: indicates if the address is actively used. Set to false for
+ *	passive monitor interfaces, true in all other cases.
  * @p2p: indicates whether this AP or STA interface is a p2p
  *	interface, i.e. a GO or p2p-sta respectively
  * @netdev_features: tx netdev features supported by the hardware for this
@@ -2015,6 +2013,7 @@ struct ieee80211_vif {
 	u16 valid_links, active_links, dormant_links, suspended_links;
 	struct ieee80211_neg_ttlm neg_ttlm;
 	u8 addr[ETH_ALEN] __aligned(2);
+	bool addr_valid;
 	bool p2p;
 
 	u8 cab_queue;
@@ -2683,6 +2682,11 @@ struct ieee80211_txq {
  *	a virtual monitor interface when monitor interfaces are the only
  *	active interfaces.
  *
+ * @IEEE80211_HW_NO_VIRTUAL_MONITOR: The driver would like to be informed
+ *	of any monitor interface, as well as their configured channel.
+ *	This is useful for supporting multiple monitor interfaces on different
+ *	channels.
+ *
  * @IEEE80211_HW_NO_AUTO_VIF: The driver would like for no wlanX to
  *	be created.  It is expected user-space will create vifs as
  *	desired (and thus have them named as desired).
@@ -2842,6 +2846,7 @@ enum ieee80211_hw_flags {
 	IEEE80211_HW_SUPPORTS_DYNAMIC_PS,
 	IEEE80211_HW_MFP_CAPABLE,
 	IEEE80211_HW_WANT_MONITOR_VIF,
+	IEEE80211_HW_NO_VIRTUAL_MONITOR,
 	IEEE80211_HW_NO_AUTO_VIF,
 	IEEE80211_HW_SW_CRYPTO_CONTROL,
 	IEEE80211_HW_SUPPORT_FAST_XMIT,
diff --git a/include/trace/events/qrtr.h b/include/trace/events/qrtr.h
index 14f8229..441132c 100644
--- a/include/trace/events/qrtr.h
+++ b/include/trace/events/qrtr.h
@@ -102,7 +102,7 @@ TRACE_EVENT(qrtr_ns_message,
 	),
 
 	TP_fast_assign(
-		__assign_str(ctrl_pkt_str);
+		__assign_str(ctrl_pkt_str, ctrl_pkt_str);
 		__entry->sq_node = sq_node;
 		__entry->sq_port = sq_port;
 	),
diff --git a/include/uapi/linux/nl80211.h b/include/uapi/linux/nl80211.h
index f97f5ad..6d11437 100644
--- a/include/uapi/linux/nl80211.h
+++ b/include/uapi/linux/nl80211.h
@@ -2868,6 +2868,9 @@ enum nl80211_commands {
  *	nested item, it contains attributes defined in
  *	&enum nl80211_if_combination_attrs.
  *
+ * @NL80211_ATTR_VIF_RADIO_MASK: Bitmask of allowed radios (u32).
+ *	A value of 0 means all radios.
+ *
  * @NUM_NL80211_ATTR: total number of nl80211_attrs available
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
@@ -3416,6 +3419,8 @@ enum nl80211_attrs {
 	NL80211_ATTR_WIPHY_RADIOS,
 	NL80211_ATTR_WIPHY_INTERFACE_COMBINATIONS,
 
+	NL80211_ATTR_VIF_RADIO_MASK,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -4698,6 +4703,7 @@ enum nl80211_survey_info {
  *	overrides all other flags.
  * @NL80211_MNTR_FLAG_ACTIVE: use the configured MAC address
  *	and ACK incoming unicast packets.
+ * @NL80211_MNTR_FLAG_SKIP_TX: do not pass local tx packets
  *
  * @__NL80211_MNTR_FLAG_AFTER_LAST: internal use
  * @NL80211_MNTR_FLAG_MAX: highest possible monitor flag
@@ -4710,6 +4716,7 @@ enum nl80211_mntr_flags {
 	NL80211_MNTR_FLAG_OTHER_BSS,
 	NL80211_MNTR_FLAG_COOK_FRAMES,
 	NL80211_MNTR_FLAG_ACTIVE,
+	NL80211_MNTR_FLAG_SKIP_TX,
 
 	/* keep last */
 	__NL80211_MNTR_FLAG_AFTER_LAST,
@@ -8031,6 +8038,8 @@ enum nl80211_ap_settings_flags {
  * @NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION: Supported interface
  *	combination for this radio. Attribute may be present multiple times
  *	and contains attributes defined in &enum nl80211_if_combination_attrs.
+ * @NL80211_WIPHY_RADIO_ATTR_ANTENNA_MASK: bitmask (u32) of antennas
+ *	connected to this radio.
  *
  * @__NL80211_WIPHY_RADIO_ATTR_LAST: Internal
  * @NL80211_WIPHY_RADIO_ATTR_MAX: Highest attribute
@@ -8041,6 +8050,7 @@ enum nl80211_wiphy_radio_attrs {
 	NL80211_WIPHY_RADIO_ATTR_INDEX,
 	NL80211_WIPHY_RADIO_ATTR_FREQ_RANGE,
 	NL80211_WIPHY_RADIO_ATTR_INTERFACE_COMBINATION,
+	NL80211_WIPHY_RADIO_ATTR_ANTENNA_MASK,
 
 	/* keep last */
 	__NL80211_WIPHY_RADIO_ATTR_LAST,
diff --git a/kconf/Makefile b/kconf/Makefile
index 2004c44..c1bd620 100644
--- a/kconf/Makefile
+++ b/kconf/Makefile
@@ -1,9 +1,9 @@
-CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
 
 LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
 
 conf: conf.o zconf.tab.o
-mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags) -DLOCALE
+mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags)
 mconf_LDFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
 mconf: CFLAGS += $(mconf_CFLAGS)
 
@@ -17,7 +17,7 @@ clean:
 zconf.tab.c: zconf.lex.c
 
 %.tab.c: %.y
-	$(YACC) -o$@ -t -l $<
+	$(YACC) -Wno-yacc -o$@ -t -l $<
 
 %.lex.c: %.l
 	$(LEX) -o$@ -L $<
diff --git a/kconf/conf.c b/kconf/conf.c
index 283eeed..162fa6b 100644
--- a/kconf/conf.c
+++ b/kconf/conf.c
@@ -86,7 +86,7 @@ static int conf_askvalue(struct symbol *sym, const char *def)
 	enum symbol_type type = sym_get_type(sym);
 
 	if (!sym_has_value(sym))
-		printf(_("(NEW) "));
+		printf("%s", _("(NEW) "));
 
 	line[0] = '\n';
 	line[1] = 0;
@@ -282,7 +282,7 @@ static int conf_choice(struct menu *menu)
 			if (child->sym->name)
 				printf(" (%s)", child->sym->name);
 			if (!sym_has_value(child->sym))
-				printf(_(" (NEW)"));
+				printf("%s", _(" (NEW)"));
 			printf("\n");
 		}
 		printf(_("%*schoice"), indent - 1, "");
@@ -437,7 +437,7 @@ static void check_conf(struct menu *menu)
 				}
 			} else {
 				if (!conf_cnt++)
-					printf(_("*\n* Restart config...\n*\n"));
+					printf("%s", _("*\n* Restart config...\n*\n"));
 				rootEntry = menu_get_parent_menu(menu);
 				conf(rootEntry);
 			}
@@ -598,40 +598,12 @@ int main(int ac, char **av)
 	case oldconfig:
 	case listnewconfig:
 	case olddefconfig:
-		conf_read(NULL);
-		break;
 	case allnoconfig:
 	case allyesconfig:
 	case allmodconfig:
 	case alldefconfig:
 	case randconfig:
-		name = getenv("KCONFIG_ALLCONFIG");
-		if (!name)
-			break;
-		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
-			if (conf_read_simple(name, S_DEF_USER)) {
-				fprintf(stderr,
-					_("*** Can't read seed configuration \"%s\"!\n"),
-					name);
-				exit(1);
-			}
-			break;
-		}
-		switch (input_mode) {
-		case allnoconfig:	name = "allno.config"; break;
-		case allyesconfig:	name = "allyes.config"; break;
-		case allmodconfig:	name = "allmod.config"; break;
-		case alldefconfig:	name = "alldef.config"; break;
-		case randconfig:	name = "allrandom.config"; break;
-		default: break;
-		}
-		if (conf_read_simple(name, S_DEF_USER) &&
-		    conf_read_simple("all.config", S_DEF_USER)) {
-			fprintf(stderr,
-				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
-				name);
-			exit(1);
-		}
+		conf_read(NULL);
 		break;
 	default:
 		break;
@@ -642,7 +614,7 @@ int main(int ac, char **av)
 			name = getenv("KCONFIG_NOSILENTUPDATE");
 			if (name && *name) {
 				fprintf(stderr,
-					_("\n*** The configuration requires explicit update.\n\n"));
+					"%s", _("\n*** The configuration requires explicit update.\n\n"));
 				return 1;
 			}
 		}
@@ -694,22 +666,22 @@ int main(int ac, char **av)
 		 * All other commands are only used to generate a config.
 		 */
 		if (conf_get_changed() && conf_write(NULL)) {
-			fprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during writing of the configuration.\n\n"));
 			exit(1);
 		}
 		if (conf_write_autoconf()) {
-			fprintf(stderr, _("\n*** Error during update of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during update of the configuration.\n\n"));
 			return 1;
 		}
 	} else if (input_mode == savedefconfig) {
 		if (conf_write_defconfig(defconfig_file)) {
-			fprintf(stderr, _("n*** Error while saving defconfig to: %s\n\n"),
+			fprintf(stderr, _("\n*** Error while saving defconfig to: %s\n\n"),
 				defconfig_file);
 			return 1;
 		}
 	} else if (input_mode != listnewconfig) {
 		if (conf_write(NULL)) {
-			fprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during writing of the configuration.\n\n"));
 			exit(1);
 		}
 	}
diff --git a/kconf/confdata.c b/kconf/confdata.c
index df26c7b..1038c30 100644
--- a/kconf/confdata.c
+++ b/kconf/confdata.c
@@ -1170,6 +1170,8 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 	}
 	bool has_changed = false;
 
+	sym_clear_all_valid();
+
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
 			continue;
@@ -1213,8 +1215,6 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	}
 
-	sym_clear_all_valid();
-
 	/*
 	 * We have different type of choice blocks.
 	 * If curr.tri equals to mod then we can select several
diff --git a/local-symbols b/local-symbols
index 264645e..e725d00 100644
--- a/local-symbols
+++ b/local-symbols
@@ -59,14 +59,6 @@ MAC80211_MESH_PS_DEBUG=
 MAC80211_TDLS_DEBUG=
 MAC80211_DEBUG_COUNTERS=
 MAC80211_STA_HASH_MAX_SIZE=
-QRTR=
-QRTR_SMD=
-QRTR_TUN=
-QRTR_MHI=
-MHI_BUS=
-MHI_BUS_DEBUG=
-MHI_BUS_PCI_GENERIC=
-MHI_BUS_EP=
 QCOM_AOSS_QMP=
 QCOM_COMMAND_DB=
 QCOM_GENI_SE=
@@ -104,6 +96,7 @@ ADM8211=
 ATH_COMMON=
 WLAN_VENDOR_ATH=
 ATH_DEBUG=
+ATH_USER_REGD=
 ATH_TRACEPOINTS=
 ATH_REG_DYNAMIC_USER_REG_HINTS=
 ATH_REG_DYNAMIC_USER_CERT_TESTING=
@@ -162,6 +155,7 @@ ATH10K_DEBUG=
 ATH10K_DEBUGFS=
 ATH10K_LEDS=
 ATH10K_SPECTRAL=
+ATH10K_THERMAL=
 ATH10K_TRACING=
 ATH10K_DFS_CERTIFIED=
 WCN36XX=
@@ -173,6 +167,7 @@ ATH11K_DEBUG=
 ATH11K_DEBUGFS=
 ATH11K_TRACING=
 ATH11K_SPECTRAL=
+ATH11K_THERMAL=
 ATH12K=
 ATH12K_DEBUG=
 ATH12K_DEBUGFS=
@@ -343,6 +338,7 @@ RT2X00_LIB_FIRMWARE=
 RT2X00_LIB_CRYPTO=
 RT2X00_LIB_LEDS=
 RT2X00_LIB_DEBUGFS=
+RT2X00_LIB_EEPROM=
 RT2X00_DEBUG=
 WLAN_VENDOR_REALTEK=
 RTL8180=
diff --git a/local-symbols.orig b/local-symbols.orig
new file mode 100644
index 0000000..6ebe62b
--- /dev/null
+++ b/local-symbols.orig
@@ -0,0 +1,492 @@
+BACKPORT_DIR=
+BACKPORTS_VERSION=
+BACKPORTED_KERNEL_VERSION=
+BACKPORTED_KERNEL_NAME=
+WIRELESS=
+NET_CORE=
+EXPERT=
+BP_MODULES=
+BPAUTO_BUILD_NLATTR=
+BPAUTO_USERSEL_BUILD_ALL=
+BPAUTO_WANT_DEV_COREDUMP=
+BPAUTO_CRYPTO_LIB_ARC4=
+BPAUTO_BUILD_CRYPTO_LIB_ARC4=
+CFG80211=
+NL80211_TESTMODE=
+CFG80211_DEVELOPER_WARNINGS=
+CFG80211_CERTIFICATION_ONUS=
+CFG80211_REQUIRE_SIGNED_REGDB=
+CFG80211_USE_KERNEL_REGDB_KEYS=
+CFG80211_EXTRA_REGDB_KEYDIR=
+CFG80211_REG_CELLULAR_HINTS=
+CFG80211_REG_RELAX_NO_IR=
+CFG80211_DEFAULT_PS=
+CFG80211_DEBUGFS=
+CFG80211_CRDA_SUPPORT=
+CFG80211_WEXT=
+CFG80211_WEXT_EXPORT=
+CFG80211_KUNIT_TEST=
+LIB80211=
+LIB80211_CRYPT_WEP=
+LIB80211_CRYPT_CCMP=
+LIB80211_CRYPT_TKIP=
+LIB80211_DEBUG=
+MAC80211=
+MAC80211_HAS_RC=
+MAC80211_RC_MINSTREL=
+MAC80211_RC_DEFAULT_MINSTREL=
+MAC80211_RC_DEFAULT=
+MAC80211_KUNIT_TEST=
+MAC80211_MESH=
+MAC80211_LEDS=
+MAC80211_DEBUGFS=
+MAC80211_MESSAGE_TRACING=
+MAC80211_DEBUG_MENU=
+MAC80211_NOINLINE=
+MAC80211_VERBOSE_DEBUG=
+MAC80211_MLME_DEBUG=
+MAC80211_STA_DEBUG=
+MAC80211_HT_DEBUG=
+MAC80211_OCB_DEBUG=
+MAC80211_IBSS_DEBUG=
+MAC80211_PS_DEBUG=
+MAC80211_MPL_DEBUG=
+MAC80211_MPATH_DEBUG=
+MAC80211_MHWMP_DEBUG=
+MAC80211_MESH_SYNC_DEBUG=
+MAC80211_MESH_CSA_DEBUG=
+MAC80211_MESH_PS_DEBUG=
+MAC80211_TDLS_DEBUG=
+MAC80211_DEBUG_COUNTERS=
+MAC80211_STA_HASH_MAX_SIZE=
+QCOM_AOSS_QMP=
+QCOM_COMMAND_DB=
+QCOM_GENI_SE=
+QCOM_GSBI=
+QCOM_LLCC=
+QCOM_KRYO_L2_ACCESSORS=
+QCOM_MDT_LOADER=
+QCOM_OCMEM=
+QCOM_PD_MAPPER=
+QCOM_PDR_HELPERS=
+QCOM_PDR_MSG=
+QCOM_PMIC_PDCHARGER_ULOG=
+QCOM_PMIC_GLINK=
+QCOM_QMI_HELPERS=
+QCOM_RAMP_CTRL=
+QCOM_RMTFS_MEM=
+QCOM_RPM_MASTER_STATS=
+QCOM_RPMH=
+QCOM_SMEM=
+QCOM_SMD_RPM=
+QCOM_SMEM_STATE=
+QCOM_SMP2P=
+QCOM_SMSM=
+QCOM_SOCINFO=
+QCOM_SPM=
+QCOM_STATS=
+QCOM_WCNSS_CTRL=
+QCOM_APR=
+QCOM_ICC_BWMON=
+QCOM_INLINE_CRYPTO_ENGINE=
+QCOM_PBS=
+WLAN=
+WLAN_VENDOR_ADMTEK=
+ADM8211=
+ATH_COMMON=
+WLAN_VENDOR_ATH=
+ATH_DEBUG=
+ATH_USER_REGD=
+ATH_TRACEPOINTS=
+ATH_REG_DYNAMIC_USER_REG_HINTS=
+ATH_REG_DYNAMIC_USER_CERT_TESTING=
+ATH5K=
+ATH5K_DEBUG=
+ATH5K_TRACER=
+ATH5K_AHB=
+ATH5K_PCI=
+ATH5K_TEST_CHANNELS=
+ATH9K_HW=
+ATH9K_COMMON=
+ATH9K_COMMON_DEBUG=
+ATH9K_DFS_DEBUGFS=
+ATH9K_BTCOEX_SUPPORT=
+ATH9K=
+ATH9K_PCI=
+ATH9K_AHB=
+ATH9K_DEBUGFS=
+ATH9K_STATION_STATISTICS=
+ATH9K_TX99=
+ATH9K_DFS_CERTIFIED=
+ATH9K_DYNACK=
+ATH9K_WOW=
+ATH9K_RFKILL=
+ATH9K_CHANNEL_CONTEXT=
+ATH9K_PCOEM=
+ATH9K_PCI_NO_EEPROM=
+ATH9K_HTC=
+ATH9K_HTC_DEBUGFS=
+ATH9K_HWRNG=
+ATH9K_COMMON_SPECTRAL=
+CARL9170=
+CARL9170_LEDS=
+CARL9170_DEBUGFS=
+CARL9170_WPC=
+CARL9170_HWRNG=
+ATH6KL=
+ATH6KL_SDIO=
+ATH6KL_USB=
+ATH6KL_DEBUG=
+ATH6KL_TRACING=
+ATH6KL_REGDOMAIN=
+AR5523=
+WIL6210=
+WIL6210_ISR_COR=
+WIL6210_TRACING=
+WIL6210_DEBUGFS=
+ATH10K=
+ATH10K_CE=
+ATH10K_PCI=
+ATH10K_AHB=
+ATH10K_SDIO=
+ATH10K_USB=
+ATH10K_SNOC=
+ATH10K_DEBUG=
+ATH10K_DEBUGFS=
+ATH10K_LEDS=
+ATH10K_SPECTRAL=
+ATH10K_THERMAL=
+ATH10K_TRACING=
+ATH10K_DFS_CERTIFIED=
+WCN36XX=
+WCN36XX_DEBUGFS=
+ATH11K=
+ATH11K_AHB=
+ATH11K_PCI=
+ATH11K_DEBUG=
+ATH11K_DEBUGFS=
+ATH11K_TRACING=
+ATH11K_SPECTRAL=
+ATH11K_THERMAL=
+ATH12K=
+ATH12K_DEBUG=
+ATH12K_DEBUGFS=
+ATH12K_TRACING=
+WLAN_VENDOR_ATMEL=
+AT76C50X_USB=
+WLAN_VENDOR_BROADCOM=
+B43=
+B43_BCMA=
+B43_SSB=
+B43_BUSES_BCMA_AND_SSB=
+B43_BUSES_BCMA=
+B43_BUSES_SSB=
+B43_PCI_AUTOSELECT=
+B43_PCICORE_AUTOSELECT=
+B43_SDIO=
+B43_BCMA_PIO=
+B43_PIO=
+B43_PHY_G=
+B43_PHY_N=
+B43_PHY_LP=
+B43_PHY_HT=
+B43_PHY_LCN=
+B43_PHY_AC=
+B43_LEDS=
+B43_HWRNG=
+B43_DEBUG=
+B43LEGACY=
+B43LEGACY_PCI_AUTOSELECT=
+B43LEGACY_PCICORE_AUTOSELECT=
+B43LEGACY_LEDS=
+B43LEGACY_HWRNG=
+B43LEGACY_DEBUG=
+B43LEGACY_DMA=
+B43LEGACY_PIO=
+B43LEGACY_DMA_AND_PIO_MODE=
+B43LEGACY_DMA_MODE=
+B43LEGACY_PIO_MODE=
+BRCMUTIL=
+BRCMSMAC=
+BRCMSMAC_LEDS=
+BRCM_TRACING=
+BRCMDBG=
+BRCMFMAC=
+BRCMFMAC_PROTO_BCDC=
+BRCMFMAC_PROTO_MSGBUF=
+BRCMFMAC_SDIO=
+BRCMFMAC_USB=
+BRCMFMAC_PCIE=
+WLAN_VENDOR_INTEL=
+IPW2100=
+IPW2100_MONITOR=
+IPW2100_DEBUG=
+IPW2200=
+IPW2200_MONITOR=
+IPW2200_RADIOTAP=
+IPW2200_PROMISCUOUS=
+IPW2200_QOS=
+IPW2200_DEBUG=
+LIBIPW=
+LIBIPW_DEBUG=
+IWLEGACY=
+IWL4965=
+IWL3945=
+IWLEGACY_DEBUG=
+IWLEGACY_DEBUGFS=
+IWLWIFI=
+IWLWIFI_KUNIT_TESTS=
+IWLWIFI_LEDS=
+IWLDVM=
+IWLMVM=
+IWLWIFI_OPMODE_MODULAR=
+IWLWIFI_DEBUG=
+IWLWIFI_DEBUGFS=
+IWLWIFI_DEVICE_TRACING=
+IWLMEI=
+WLAN_VENDOR_INTERSIL=
+P54_COMMON=
+P54_USB=
+P54_PCI=
+P54_SPI=
+P54_SPI_DEFAULT_EEPROM=
+P54_LEDS=
+WLAN_VENDOR_MARVELL=
+MWL8K=
+LIBERTAS=
+LIBERTAS_USB=
+LIBERTAS_SDIO=
+LIBERTAS_SPI=
+LIBERTAS_DEBUG=
+LIBERTAS_MESH=
+LIBERTAS_THINFIRM=
+LIBERTAS_THINFIRM_DEBUG=
+LIBERTAS_THINFIRM_USB=
+MWIFIEX=
+MWIFIEX_SDIO=
+MWIFIEX_PCIE=
+MWIFIEX_USB=
+WLAN_VENDOR_MEDIATEK=
+MT7601U=
+MT76_CORE=
+MT76_LEDS=
+MT76_USB=
+MT76_SDIO=
+MT76x02_LIB=
+MT76x02_USB=
+MT76_CONNAC_LIB=
+MT792x_LIB=
+MT792x_USB=
+MT76x0_COMMON=
+MT76x0U=
+MT76x0E=
+MT76x2_COMMON=
+MT76x2E=
+MT76x2U=
+MT7603E=
+MT7615_COMMON=
+MT7615E=
+MT7622_WMAC=
+MT7663_USB_SDIO_COMMON=
+MT7663U=
+MT7663S=
+MT7915E=
+MT798X_WMAC=
+MT7921_COMMON=
+MT7921E=
+MT7921S=
+MT7921U=
+MT7996E=
+MT7925_COMMON=
+MT7925E=
+MT7925U=
+WLAN_VENDOR_MICROCHIP=
+WILC1000=
+WILC1000_SDIO=
+WILC1000_SPI=
+WILC1000_HW_OOB_INTR=
+WLAN_VENDOR_PURELIFI=
+PLFXLC=
+WLAN_VENDOR_RALINK=
+RT2X00=
+RT2400PCI=
+RT2500PCI=
+RT61PCI=
+RT2800PCI=
+RT2800PCI_RT33XX=
+RT2800PCI_RT35XX=
+RT2800PCI_RT53XX=
+RT2800PCI_RT3290=
+RT2500USB=
+RT73USB=
+RT2800USB=
+RT2800USB_RT33XX=
+RT2800USB_RT35XX=
+RT2800USB_RT3573=
+RT2800USB_RT53XX=
+RT2800USB_RT55XX=
+RT2800USB_UNKNOWN=
+RT2800SOC=
+RT2800_LIB=
+RT2800_LIB_MMIO=
+RT2X00_LIB_MMIO=
+RT2X00_LIB_PCI=
+RT2X00_LIB_SOC=
+RT2X00_LIB_USB=
+RT2X00_LIB=
+RT2X00_LIB_FIRMWARE=
+RT2X00_LIB_CRYPTO=
+RT2X00_LIB_LEDS=
+RT2X00_LIB_DEBUGFS=
+RT2X00_DEBUG=
+WLAN_VENDOR_REALTEK=
+RTL8180=
+RTL8187=
+RTL8187_LEDS=
+RTL_CARDS=
+RTL8192CE=
+RTL8192SE=
+RTL8192DE=
+RTL8723AE=
+RTL8723BE=
+RTL8188EE=
+RTL8192EE=
+RTL8821AE=
+RTL8192CU=
+RTL8192DU=
+RTLWIFI=
+RTLWIFI_PCI=
+RTLWIFI_USB=
+RTLWIFI_DEBUG=
+RTL8192C_COMMON=
+RTL8192D_COMMON=
+RTL8723_COMMON=
+RTLBTCOEXIST=
+RTL8XXXU=
+RTL8XXXU_UNTESTED=
+RTW88=
+RTW88_CORE=
+RTW88_PCI=
+RTW88_SDIO=
+RTW88_USB=
+RTW88_8822B=
+RTW88_8822C=
+RTW88_8723X=
+RTW88_8703B=
+RTW88_8723D=
+RTW88_8821C=
+RTW88_8822BE=
+RTW88_8822BS=
+RTW88_8822BU=
+RTW88_8822CE=
+RTW88_8822CS=
+RTW88_8822CU=
+RTW88_8723DE=
+RTW88_8723DS=
+RTW88_8723CS=
+RTW88_8723DU=
+RTW88_8821CE=
+RTW88_8821CS=
+RTW88_8821CU=
+RTW88_DEBUG=
+RTW88_DEBUGFS=
+RTW89=
+RTW89_CORE=
+RTW89_PCI=
+RTW89_8851B=
+RTW89_8852A=
+RTW89_8852B_COMMON=
+RTW89_8852B=
+RTW89_8852BT=
+RTW89_8852C=
+RTW89_8922A=
+RTW89_8851BE=
+RTW89_8852AE=
+RTW89_8852BE=
+RTW89_8852BTE=
+RTW89_8852CE=
+RTW89_8922AE=
+RTW89_DEBUG=
+RTW89_DEBUGMSG=
+RTW89_DEBUGFS=
+WLAN_VENDOR_RSI=
+RSI_91X=
+RSI_DEBUGFS=
+RSI_SDIO=
+RSI_USB=
+RSI_COEX=
+WLAN_VENDOR_SILABS=
+WFX=
+WLAN_VENDOR_ST=
+CW1200=
+CW1200_WLAN_SDIO=
+CW1200_WLAN_SPI=
+WLAN_VENDOR_TI=
+WL1251=
+WL1251_SPI=
+WL1251_SDIO=
+WL12XX=
+WL18XX=
+WLCORE=
+WLCORE_SPI=
+WLCORE_SDIO=
+WLAN_VENDOR_ZYDAS=
+ZD1211RW=
+ZD1211RW_DEBUG=
+WLAN_VENDOR_QUANTENNA=
+QTNFMAC=
+QTNFMAC_PCIE=
+MAC80211_HWSIM=
+VIRT_WIFI=
+USB_NET_DRIVERS=
+USB_CATC=
+USB_KAWETH=
+USB_PEGASUS=
+USB_RTL8150=
+USB_RTL8152=
+USB_LAN78XX=
+USB_USBNET=
+USB_NET_AX8817X=
+USB_NET_AX88179_178A=
+USB_NET_CDCETHER=
+USB_NET_CDC_EEM=
+USB_NET_CDC_NCM=
+USB_NET_HUAWEI_CDC_NCM=
+USB_NET_CDC_MBIM=
+USB_NET_DM9601=
+USB_NET_SR9700=
+USB_NET_SR9800=
+USB_NET_SMSC75XX=
+USB_NET_SMSC95XX=
+USB_NET_GL620A=
+USB_NET_NET1080=
+USB_NET_PLUSB=
+USB_NET_MCS7830=
+USB_NET_RNDIS_HOST=
+USB_NET_CDC_SUBSET_ENABLE=
+USB_NET_CDC_SUBSET=
+USB_ALI_M5632=
+USB_AN2720=
+USB_BELKIN=
+USB_ARMLINUX=
+USB_EPSON2888=
+USB_KC2190=
+USB_NET_ZAURUS=
+USB_NET_CX82310_ETH=
+USB_NET_KALMIA=
+USB_NET_QMI_WWAN=
+USB_HSO=
+USB_NET_INT51X1=
+USB_CDC_PHONET=
+USB_IPHETH=
+USB_SIERRA_NET=
+USB_VL600=
+USB_NET_CH9200=
+USB_NET_AQC111=
+USB_RTL8153_ECM=
+USB_ACM=
+USB_PRINTER=
+USB_WDM=
+USB_TMC=
+STAGING=
+RTL8723BS=
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index 4a594a8..1319f02 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -105,8 +105,11 @@ static int ieee80211_set_mon_options(struct ieee80211_sub_if_data *sdata,
 	}
 
 	/* also validate MU-MIMO change */
-	monitor_sdata = wiphy_dereference(local->hw.wiphy,
-					  local->monitor_sdata);
+	if (ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
+		monitor_sdata = sdata;
+	else
+		monitor_sdata = wiphy_dereference(local->hw.wiphy,
+						  local->monitor_sdata);
 
 	if (!monitor_sdata &&
 	    (params->vht_mumimo_groups || params->vht_mumimo_follow_addr))
@@ -114,7 +117,9 @@ static int ieee80211_set_mon_options(struct ieee80211_sub_if_data *sdata,
 
 	/* apply all changes now - no failures allowed */
 
-	if (monitor_sdata && ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF))
+	if (monitor_sdata &&
+		(ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF) ||
+		 ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)))
 		ieee80211_set_mu_mimo_follow(monitor_sdata, params);
 
 	if (params->flags) {
@@ -879,6 +884,7 @@ static int ieee80211_get_station(struct wiphy *wiphy, struct net_device *dev,
 }
 
 static int ieee80211_set_monitor_channel(struct wiphy *wiphy,
+					 struct net_device *dev,
 					 struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_local *local = wiphy_priv(wiphy);
@@ -888,22 +894,25 @@ static int ieee80211_set_monitor_channel(struct wiphy *wiphy,
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	if (cfg80211_chandef_identical(&local->monitor_chanreq.oper,
-				       &chanreq.oper))
-		return 0;
+	sdata = IEEE80211_DEV_TO_SUB_IF(dev);
+	if (!ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)) {
+		if (cfg80211_chandef_identical(&local->monitor_chanreq.oper,
+						   &chanreq.oper))
+			return 0;
 
-	sdata = wiphy_dereference(local->hw.wiphy,
-				  local->monitor_sdata);
-	if (!sdata)
-		goto done;
+		sdata = wiphy_dereference(wiphy, local->monitor_sdata);
+		if (!sdata)
+			goto done;
+	}
 
-	if (cfg80211_chandef_identical(&sdata->vif.bss_conf.chanreq.oper,
+	if (rcu_access_pointer(sdata->deflink.conf->chanctx_conf) &&
+		cfg80211_chandef_identical(&sdata->vif.bss_conf.chanreq.oper,
 				       &chanreq.oper))
 		return 0;
 
 	ieee80211_link_release_channel(&sdata->deflink);
 	ret = ieee80211_link_use_channel(&sdata->deflink, &chanreq,
-					 IEEE80211_CHANCTX_EXCLUSIVE);
+					 IEEE80211_CHANCTX_SHARED);
 	if (ret)
 		return ret;
 done:
@@ -1649,12 +1658,6 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
 
 	__sta_info_flush(sdata, true, link_id);
 
-	ieee80211_remove_link_keys(link, &keys);
-	if (!list_empty(&keys)) {
-		synchronize_net();
-		ieee80211_free_key_list(local, &keys);
-	}
-
 	link_conf->enable_beacon = false;
 	sdata->beacon_rate_set = false;
 	sdata->vif.cfg.ssid_len = 0;
@@ -2869,6 +2872,8 @@ static int ieee80211_scan(struct wiphy *wiphy,
 		 */
 		fallthrough;
 	case NL80211_IFTYPE_AP:
+		/* skip check */
+		break;
 		/*
 		 * If the scan has been forced (and the driver supports
 		 * forcing), don't care about being beaconing already.
@@ -3053,7 +3058,8 @@ static int ieee80211_set_tx_power(struct wiphy *wiphy,
 	if (wdev) {
 		sdata = IEEE80211_WDEV_TO_SUB_IF(wdev);
 
-		if (sdata->vif.type == NL80211_IFTYPE_MONITOR) {
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
+		    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)) {
 			if (!ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF))
 				return -EOPNOTSUPP;
 
@@ -3101,7 +3107,8 @@ static int ieee80211_set_tx_power(struct wiphy *wiphy,
 	}
 
 	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (sdata->vif.type == NL80211_IFTYPE_MONITOR) {
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
+		    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)) {
 			has_monitor = true;
 			continue;
 		}
@@ -3111,7 +3118,8 @@ static int ieee80211_set_tx_power(struct wiphy *wiphy,
 		sdata->vif.bss_conf.txpower_type = txp_type;
 	}
 	list_for_each_entry(sdata, &local->interfaces, list) {
-		if (sdata->vif.type == NL80211_IFTYPE_MONITOR)
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
+		    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
 			continue;
 		ieee80211_recalc_txpower(sdata, update_txp_type);
 	}
@@ -4306,7 +4314,8 @@ static int ieee80211_cfg_get_channel(struct wiphy *wiphy,
 	if (chanctx_conf) {
 		*chandef = link->conf->chanreq.oper;
 		ret = 0;
-	} else if (local->open_count > 0 &&
+	} else if (!ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR) &&
+		   local->open_count > 0 &&
 		   local->open_count == local->monitors &&
 		   sdata->vif.type == NL80211_IFTYPE_MONITOR) {
 		*chandef = local->monitor_chanreq.oper;
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index cca6d14..c375c86 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -339,6 +339,10 @@ ieee80211_get_chanctx_max_required_bw(struct ieee80211_local *local,
 		case NL80211_IFTYPE_P2P_DEVICE:
 		case NL80211_IFTYPE_NAN:
 			continue;
+		case NL80211_IFTYPE_MONITOR:
+			WARN_ON_ONCE(!ieee80211_hw_check(&local->hw,
+							 NO_VIRTUAL_MONITOR));
+			fallthrough;
 		case NL80211_IFTYPE_ADHOC:
 		case NL80211_IFTYPE_MESH_POINT:
 		case NL80211_IFTYPE_OCB:
@@ -347,7 +351,6 @@ ieee80211_get_chanctx_max_required_bw(struct ieee80211_local *local,
 		case NL80211_IFTYPE_WDS:
 		case NL80211_IFTYPE_UNSPECIFIED:
 		case NUM_NL80211_IFTYPES:
-		case NL80211_IFTYPE_MONITOR:
 		case NL80211_IFTYPE_P2P_CLIENT:
 		case NL80211_IFTYPE_P2P_GO:
 			WARN_ON_ONCE(1);
@@ -956,6 +959,10 @@ void ieee80211_recalc_smps_chanctx(struct ieee80211_local *local,
 			if (!link->sdata->u.mgd.associated)
 				continue;
 			break;
+		case NL80211_IFTYPE_MONITOR:
+			if (!ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
+				continue;
+			break;
 		case NL80211_IFTYPE_AP:
 		case NL80211_IFTYPE_ADHOC:
 		case NL80211_IFTYPE_MESH_POINT:
@@ -968,6 +975,11 @@ void ieee80211_recalc_smps_chanctx(struct ieee80211_local *local,
 		if (rcu_access_pointer(link->conf->chanctx_conf) != &chanctx->conf)
 			continue;
 
+		if (link->sdata->vif.type == NL80211_IFTYPE_MONITOR) {
+			rx_chains_dynamic = rx_chains_static = local->rx_chains;
+			break;
+		}
+
 		switch (link->smps_mode) {
 		default:
 			WARN_ONCE(1, "Invalid SMPS mode %d\n",
@@ -1169,7 +1181,7 @@ ieee80211_replace_chanctx(struct ieee80211_local *local,
 static bool
 ieee80211_find_available_radio(struct ieee80211_local *local,
 			       const struct ieee80211_chan_req *chanreq,
-			       int *radio_idx)
+			       u32 radio_mask, int *radio_idx)
 {
 	struct wiphy *wiphy = local->hw.wiphy;
 	const struct wiphy_radio *radio;
@@ -1180,6 +1192,9 @@ ieee80211_find_available_radio(struct ieee80211_local *local,
 		return true;
 
 	for (i = 0; i < wiphy->n_radio; i++) {
+		if (!(radio_mask & BIT(i)))
+			continue;
+
 		radio = &wiphy->radio[i];
 		if (!cfg80211_radio_chandef_valid(radio, &chanreq->oper))
 			continue;
@@ -1213,7 +1228,9 @@ int ieee80211_link_reserve_chanctx(struct ieee80211_link_data *link,
 	new_ctx = ieee80211_find_reservation_chanctx(local, chanreq, mode);
 	if (!new_ctx) {
 		if (ieee80211_can_create_new_chanctx(local, -1) &&
-		    ieee80211_find_available_radio(local, chanreq, &radio_idx))
+		    ieee80211_find_available_radio(local, chanreq,
+						   sdata->wdev.radio_mask,
+						   &radio_idx))
 			new_ctx = ieee80211_new_chanctx(local, chanreq, mode,
 							false, radio_idx);
 		else
@@ -1883,7 +1900,9 @@ int _ieee80211_link_use_channel(struct ieee80211_link_data *link,
 	/* Note: context is now reserved */
 	if (ctx)
 		reserved = true;
-	else if (!ieee80211_find_available_radio(local, chanreq, &radio_idx))
+	else if (!ieee80211_find_available_radio(local, chanreq,
+						 sdata->wdev.radio_mask,
+						 &radio_idx))
 		ctx = ERR_PTR(-EBUSY);
 	else
 		ctx = ieee80211_new_chanctx(local, chanreq, mode,
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index f9528ab..421476b 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -215,11 +215,13 @@ static ssize_t aql_pending_read(struct file *file,
 			"VI     %u us\n"
 			"BE     %u us\n"
 			"BK     %u us\n"
+			"BC/MC  %u us\n"
 			"total  %u us\n",
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VO]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VI]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BE]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BK]),
+			atomic_read(&local->aql_bc_pending_airtime),
 			atomic_read(&local->aql_total_pending_airtime));
 	return simple_read_from_buffer(user_buf, count, ppos,
 				       buf, len);
@@ -245,7 +247,8 @@ static ssize_t aql_txq_limit_read(struct file *file,
 			"VO	%u		%u\n"
 			"VI	%u		%u\n"
 			"BE	%u		%u\n"
-			"BK	%u		%u\n",
+			"BK	%u		%u\n"
+			"BC/MC	%u\n",
 			local->aql_txq_limit_low[IEEE80211_AC_VO],
 			local->aql_txq_limit_high[IEEE80211_AC_VO],
 			local->aql_txq_limit_low[IEEE80211_AC_VI],
@@ -253,7 +256,8 @@ static ssize_t aql_txq_limit_read(struct file *file,
 			local->aql_txq_limit_low[IEEE80211_AC_BE],
 			local->aql_txq_limit_high[IEEE80211_AC_BE],
 			local->aql_txq_limit_low[IEEE80211_AC_BK],
-			local->aql_txq_limit_high[IEEE80211_AC_BK]);
+			local->aql_txq_limit_high[IEEE80211_AC_BK],
+			local->aql_txq_limit_bc);
 	return simple_read_from_buffer(user_buf, count, ppos,
 				       buf, len);
 }
@@ -279,6 +283,11 @@ static ssize_t aql_txq_limit_write(struct file *file,
 	else
 		buf[count] = '\0';
 
+	if (sscanf(buf, "mcast %u", &q_limit_low) == 1) {
+		local->aql_txq_limit_bc = q_limit_low;
+		return count;
+	}
+
 	if (sscanf(buf, "%u %u %u", &ac, &q_limit_low, &q_limit_high) != 3)
 		return -EINVAL;
 
@@ -456,6 +465,7 @@ static const char *hw_flag_names[] = {
 	FLAG(SUPPORTS_DYNAMIC_PS),
 	FLAG(MFP_CAPABLE),
 	FLAG(WANT_MONITOR_VIF),
+	FLAG(NO_VIRTUAL_MONITOR),
 	FLAG(NO_AUTO_VIF),
 	FLAG(SW_CRYPTO_CONTROL),
 	FLAG(SUPPORT_FAST_XMIT),
diff --git a/net/mac80211/driver-ops.c b/net/mac80211/driver-ops.c
index fe868b5..8179310 100644
--- a/net/mac80211/driver-ops.c
+++ b/net/mac80211/driver-ops.c
@@ -65,6 +65,7 @@ int drv_add_interface(struct ieee80211_local *local,
 	if (WARN_ON(sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
 		    (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
 		     !ieee80211_hw_check(&local->hw, WANT_MONITOR_VIF) &&
+		     !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR) &&
 		     !(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))))
 		return -EINVAL;
 
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index 0b49364..6765bad 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -103,6 +103,8 @@ ieee80211_sta_keep_active(struct sta_info *sta, u8 ac)
 	return time_before_eq(jiffies, sta->airtime[ac].last_active + HZ / 10);
 }
 
+#define AIRTIME_QUANTUM_SHIFT	3
+
 struct ieee80211_bss {
 	u32 device_ts_beacon, device_ts_presp;
 
@@ -1349,10 +1351,12 @@ struct ieee80211_local {
 	spinlock_t handle_wake_tx_queue_lock;
 
 	u16 airtime_flags;
+	u32 aql_txq_limit_bc;
 	u32 aql_txq_limit_low[IEEE80211_NUM_ACS];
 	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
 	u32 aql_threshold;
 	atomic_t aql_total_pending_airtime;
+	atomic_t aql_bc_pending_airtime;
 	atomic_t aql_ac_pending_airtime[IEEE80211_NUM_ACS];
 
 	const struct ieee80211_ops *ops;
@@ -1369,7 +1373,7 @@ struct ieee80211_local {
 	spinlock_t queue_stop_reason_lock;
 
 	int open_count;
-	int monitors, cooked_mntrs;
+	int monitors, cooked_mntrs, tx_mntrs;
 	/* number of interfaces with corresponding FIF_ flags */
 	int fif_fcsfail, fif_plcpfail, fif_control, fif_other_bss, fif_pspoll,
 	    fif_probe_req;
diff --git a/net/mac80211/iface.c b/net/mac80211/iface.c
index af90552..6247947 100644
--- a/net/mac80211/iface.c
+++ b/net/mac80211/iface.c
@@ -699,9 +699,11 @@ static void ieee80211_do_stop(struct ieee80211_sub_if_data *sdata, bool going_do
 		ieee80211_recalc_idle(local);
 		ieee80211_recalc_offload(local);
 
-		if (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))
+		if (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) &&
+		    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
 			break;
 
+		ieee80211_link_release_channel(&sdata->deflink);
 		fallthrough;
 	default:
 		if (!going_down)
@@ -1087,6 +1089,8 @@ void ieee80211_adjust_monitor_flags(struct ieee80211_sub_if_data *sdata,
 	ADJUST(CONTROL, control);
 	ADJUST(CONTROL, pspoll);
 	ADJUST(OTHER_BSS, other_bss);
+	if (!(flags & MONITOR_FLAG_SKIP_TX))
+		local->tx_mntrs += offset;
 
 #undef ADJUST
 }
@@ -1131,7 +1135,8 @@ int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
 	ASSERT_RTNL();
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	if (local->monitor_sdata)
+	if (local->monitor_sdata ||
+	    ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
 		return 0;
 
 	sdata = kzalloc(sizeof(*sdata) + local->hw.vif_data_size, GFP_KERNEL);
@@ -1193,6 +1198,9 @@ void ieee80211_del_virtual_monitor(struct ieee80211_local *local)
 {
 	struct ieee80211_sub_if_data *sdata;
 
+	if (ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
+		return;
+
 	ASSERT_RTNL();
 	lockdep_assert_wiphy(local->hw.wiphy);
 
@@ -1311,6 +1319,8 @@ int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)
 		}
 	}
 
+	sdata->vif.addr_valid = sdata->vif.type != NL80211_IFTYPE_MONITOR ||
+				(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE);
 	switch (sdata->vif.type) {
 	case NL80211_IFTYPE_AP_VLAN:
 		/* no need to tell driver, but set carrier and chanctx */
@@ -1328,7 +1338,8 @@ int ieee80211_do_open(struct wireless_dev *wdev, bool coming_up)
 			break;
 		}
 
-		if (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {
+		if ((sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) ||
+		    ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)) {
 			res = drv_add_interface(local, sdata);
 			if (res)
 				goto err_stop;
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index 42c3a13..949c12b 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -954,6 +954,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 	spin_lock_init(&local->rx_path_lock);
 	spin_lock_init(&local->queue_stop_reason_lock);
 
+	local->aql_txq_limit_bc = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_BC;
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		INIT_LIST_HEAD(&local->active_txqs[i]);
 		spin_lock_init(&local->active_txq_lock[i]);
@@ -1583,24 +1584,6 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 
 	ieee80211_check_wbrf_support(local);
 
-	rtnl_lock();
-	wiphy_lock(hw->wiphy);
-
-	/* add one default STA interface if supported */
-	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION) &&
-	    !ieee80211_hw_check(hw, NO_AUTO_VIF)) {
-		struct vif_params params = {0};
-
-		result = ieee80211_if_add(local, "wlan%d", NET_NAME_ENUM, NULL,
-					  NL80211_IFTYPE_STATION, &params);
-		if (result)
-			wiphy_warn(local->hw.wiphy,
-				   "Failed to add default virtual iface\n");
-	}
-
-	wiphy_unlock(hw->wiphy);
-	rtnl_unlock();
-
 #ifdef CONFIG_INET
 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
 	result = register_inetaddr_notifier(&local->ifa_notifier);
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index b128191..802cd6c 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -580,6 +580,14 @@ minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
 	int cur_tp_avg, cur_group, cur_idx;
 	int max_gpr_group, max_gpr_idx;
 	int max_gpr_tp_avg, max_gpr_prob;
+	int min_dur;
+
+	min_dur = max(minstrel_get_duration(mi->max_tp_rate[0]),
+		      minstrel_get_duration(mi->max_tp_rate[1]));
+
+	/* make the rate at least 18% slower than max tp rates */
+	if (minstrel_get_duration(index) <= min_dur * 19 / 16)
+		return;
 
 	cur_group = MI_RATE_GROUP(index);
 	cur_idx = MI_RATE_IDX(index);
@@ -601,11 +609,6 @@ minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
 	    !minstrel_ht_is_legacy_group(max_tp_group))
 		return;
 
-	/* skip rates faster than max tp rate with lower prob */
-	if (minstrel_get_duration(mi->max_tp_rate[0]) > minstrel_get_duration(index) &&
-	    mrs->prob_avg < max_tp_prob)
-		return;
-
 	max_gpr_group = MI_RATE_GROUP(mg->max_group_prob_rate);
 	max_gpr_idx = MI_RATE_IDX(mg->max_group_prob_rate);
 	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
@@ -663,40 +666,6 @@ minstrel_ht_assign_best_tp_rates(struct minstrel_ht_sta *mi,
 
 }
 
-/*
- * Try to increase robustness of max_prob rate by decrease number of
- * streams if possible.
- */
-static inline void
-minstrel_ht_prob_rate_reduce_streams(struct minstrel_ht_sta *mi)
-{
-	struct minstrel_mcs_group_data *mg;
-	int tmp_max_streams, group, tmp_idx, tmp_prob;
-	int tmp_tp = 0;
-
-	if (!mi->sta->deflink.ht_cap.ht_supported)
-		return;
-
-	group = MI_RATE_GROUP(mi->max_tp_rate[0]);
-	tmp_max_streams = minstrel_mcs_groups[group].streams;
-	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
-		mg = &mi->groups[group];
-		if (!mi->supported[group] || group == MINSTREL_CCK_GROUP)
-			continue;
-
-		tmp_idx = MI_RATE_IDX(mg->max_group_prob_rate);
-		tmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;
-
-		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&
-		   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {
-				mi->max_prob_rate = mg->max_group_prob_rate;
-				tmp_tp = minstrel_ht_get_tp_avg(mi, group,
-								tmp_idx,
-								tmp_prob);
-		}
-	}
-}
-
 static u16
 __minstrel_ht_get_sample_rate(struct minstrel_ht_sta *mi,
 			      enum minstrel_sample_type type)
@@ -769,7 +738,8 @@ minstrel_ht_calc_rate_stats(struct minstrel_priv *mp,
 	unsigned int cur_prob;
 
 	if (unlikely(mrs->attempts > 0)) {
-		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
+		cur_prob = MINSTREL_FRAC(mrs->success + mrs->last_success,
+					 mrs->attempts + mrs->last_attempts);
 		minstrel_filter_avg_add(&mrs->prob_avg,
 					&mrs->prob_avg_1, cur_prob);
 		mrs->att_hist += mrs->attempts;
@@ -1175,8 +1145,6 @@ minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	/* Try to increase robustness of max_prob_rate*/
-	minstrel_ht_prob_rate_reduce_streams(mi);
 	minstrel_ht_refill_sample_rates(mi);
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
@@ -1255,7 +1223,7 @@ minstrel_ht_ri_txstat_valid(struct minstrel_priv *mp,
 }
 
 static void
-minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
+minstrel_downgrade_prob_rate(struct minstrel_ht_sta *mi, u16 *idx)
 {
 	int group, orig_group;
 
@@ -1270,11 +1238,7 @@ minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
 		    minstrel_mcs_groups[orig_group].streams)
 			continue;
 
-		if (primary)
-			*idx = mi->groups[group].max_group_tp_rate[0];
-		else
-			*idx = mi->groups[group].max_group_tp_rate[1];
-		break;
+		*idx = mi->groups[group].max_group_prob_rate;
 	}
 }
 
@@ -1285,7 +1249,7 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 	struct ieee80211_tx_info *info = st->info;
 	struct minstrel_ht_sta *mi = priv_sta;
 	struct ieee80211_tx_rate *ar = info->status.rates;
-	struct minstrel_rate_stats *rate, *rate2;
+	struct minstrel_rate_stats *rate;
 	struct minstrel_priv *mp = priv;
 	u32 update_interval = mp->update_interval;
 	bool last, update = false;
@@ -1353,18 +1317,13 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 		/*
 		 * check for sudden death of spatial multiplexing,
 		 * downgrade to a lower number of streams if necessary.
+		 * only do this for the max_prob_rate to prevent spurious
+		 * rate fluctuations when the link changes suddenly
 		 */
-		rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
+		rate = minstrel_get_ratestats(mi, mi->max_prob_rate);
 		if (rate->attempts > 30 &&
 		    rate->success < rate->attempts / 4) {
-			minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
-			update = true;
-		}
-
-		rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
-		if (rate2->attempts > 30 &&
-		    rate2->success < rate2->attempts / 4) {
-			minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
+			minstrel_downgrade_prob_rate(mi, &mi->max_prob_rate);
 			update = true;
 		}
 	}
diff --git a/net/mac80211/rc80211_minstrel_ht.h b/net/mac80211/rc80211_minstrel_ht.h
index f385cf6..1f78a94 100644
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -14,7 +14,7 @@
 
 /* scaled fraction values */
 #define MINSTREL_SCALE  12
-#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / div)
+#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / (div))
 #define MINSTREL_TRUNC(val) ((val) >> MINSTREL_SCALE)
 
 #define EWMA_LEVEL	96	/* ewma weighting factor [/EWMA_DIV] */
diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c
index 36551ba..30c8c5c 100644
--- a/net/mac80211/rx.c
+++ b/net/mac80211/rx.c
@@ -508,18 +508,13 @@ ieee80211_add_rx_radiotap_header(struct ieee80211_local *local,
 			flags |= IEEE80211_RADIOTAP_AMPDU_IS_LAST;
 		if (status->flag & RX_FLAG_AMPDU_DELIM_CRC_ERROR)
 			flags |= IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_ERR;
-		if (status->flag & RX_FLAG_AMPDU_DELIM_CRC_KNOWN)
-			flags |= IEEE80211_RADIOTAP_AMPDU_DELIM_CRC_KNOWN;
 		if (status->flag & RX_FLAG_AMPDU_EOF_BIT_KNOWN)
 			flags |= IEEE80211_RADIOTAP_AMPDU_EOF_KNOWN;
 		if (status->flag & RX_FLAG_AMPDU_EOF_BIT)
 			flags |= IEEE80211_RADIOTAP_AMPDU_EOF;
 		put_unaligned_le16(flags, pos);
 		pos += 2;
-		if (status->flag & RX_FLAG_AMPDU_DELIM_CRC_KNOWN)
-			*pos++ = status->ampdu_delimiter_crc;
-		else
-			*pos++ = 0;
+		*pos++ = 0;
 		*pos++ = 0;
 	}
 
@@ -767,8 +762,8 @@ ieee80211_rx_monitor(struct ieee80211_local *local, struct sk_buff *origskb,
 		     struct ieee80211_rate *rate)
 {
 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(origskb);
-	struct ieee80211_sub_if_data *sdata;
-	struct sk_buff *monskb = NULL;
+	struct ieee80211_sub_if_data *sdata, *prev_sdata = NULL;
+	struct sk_buff *skb, *monskb = NULL;
 	int present_fcs_len = 0;
 	unsigned int rtap_space = 0;
 	struct ieee80211_sub_if_data *monitor_sdata =
@@ -842,40 +837,52 @@ ieee80211_rx_monitor(struct ieee80211_local *local, struct sk_buff *origskb,
 	ieee80211_handle_mu_mimo_mon(monitor_sdata, origskb, rtap_space);
 
 	list_for_each_entry_rcu(sdata, &local->mon_list, u.mntr.list) {
-		bool last_monitor = list_is_last(&sdata->u.mntr.list,
-						 &local->mon_list);
+		struct cfg80211_chan_def *chandef;
+
+		chandef = &sdata->vif.bss_conf.chanreq.oper;
+		if (chandef->chan &&
+		    chandef->chan->center_freq != status->freq)
+			continue;
+
+		if (!prev_sdata) {
+			prev_sdata = sdata;
+			continue;
+		}
+
+		if (ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
+			ieee80211_handle_mu_mimo_mon(sdata, origskb, rtap_space);
 
 		if (!monskb)
 			monskb = ieee80211_make_monitor_skb(local, &origskb,
 							    rate, rtap_space,
-							    only_monitor &&
-							    last_monitor);
+							    false);
+		if (!monskb)
+			continue;
 
-		if (monskb) {
-			struct sk_buff *skb;
+		skb = skb_clone(monskb, GFP_ATOMIC);
+		if (!skb)
+			continue;
 
-			if (last_monitor) {
-				skb = monskb;
-				monskb = NULL;
-			} else {
-				skb = skb_clone(monskb, GFP_ATOMIC);
-			}
+		skb->dev = prev_sdata->dev;
+		dev_sw_netstats_rx_add(skb->dev, skb->len);
+		netif_receive_skb(skb);
+		prev_sdata = sdata;
+	}
 
-			if (skb) {
-				skb->dev = sdata->dev;
-				dev_sw_netstats_rx_add(skb->dev, skb->len);
-				netif_receive_skb(skb);
-			}
+	if (prev_sdata) {
+		if (monskb)
+			skb = monskb;
+		else
+			skb = ieee80211_make_monitor_skb(local, &origskb,
+							 rate, rtap_space,
+							 only_monitor);
+		if (skb) {
+			skb->dev = prev_sdata->dev;
+			dev_sw_netstats_rx_add(skb->dev, skb->len);
+			netif_receive_skb(skb);
 		}
-
-		if (last_monitor)
-			break;
 	}
 
-	/* this happens if last_monitor was erroneously false */
-	dev_kfree_skb(monskb);
-
-	/* ditto */
 	if (!origskb)
 		return NULL;
 
diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c
index adb88c0..cb70790 100644
--- a/net/mac80211/scan.c
+++ b/net/mac80211/scan.c
@@ -1176,14 +1176,14 @@ int ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,
 				unsigned int n_channels)
 {
 	struct ieee80211_local *local = sdata->local;
-	int ret = -EBUSY, i, n_ch = 0;
+	int i, n_ch = 0;
 	enum nl80211_band band;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
 	/* busy scanning */
 	if (local->scan_req)
-		goto unlock;
+		return -EBUSY;
 
 	/* fill internal scan request */
 	if (!channels) {
@@ -1200,7 +1200,9 @@ int ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,
 				    &local->hw.wiphy->bands[band]->channels[i];
 
 				if (tmp_ch->flags & (IEEE80211_CHAN_NO_IR |
-						     IEEE80211_CHAN_DISABLED))
+						     IEEE80211_CHAN_DISABLED) ||
+				    !cfg80211_wdev_channel_allowed(&sdata->wdev,
+								   tmp_ch))
 					continue;
 
 				local->int_scan_req->channels[n_ch] = tmp_ch;
@@ -1209,21 +1211,23 @@ int ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,
 		}
 
 		if (WARN_ON_ONCE(n_ch == 0))
-			goto unlock;
+			return -EINVAL;
 
 		local->int_scan_req->n_channels = n_ch;
 	} else {
 		for (i = 0; i < n_channels; i++) {
 			if (channels[i]->flags & (IEEE80211_CHAN_NO_IR |
-						  IEEE80211_CHAN_DISABLED))
+						  IEEE80211_CHAN_DISABLED) ||
+			    !cfg80211_wdev_channel_allowed(&sdata->wdev,
+							   channels[i]))
 				continue;
 
 			local->int_scan_req->channels[n_ch] = channels[i];
 			n_ch++;
 		}
 
-		if (WARN_ON_ONCE(n_ch == 0))
-			goto unlock;
+		if (n_ch == 0)
+			return -EINVAL;
 
 		local->int_scan_req->n_channels = n_ch;
 	}
@@ -1233,9 +1237,7 @@ int ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,
 	memcpy(local->int_scan_req->ssids[0].ssid, ssid, IEEE80211_MAX_SSID_LEN);
 	local->int_scan_req->ssids[0].ssid_len = ssid_len;
 
-	ret = __ieee80211_start_scan(sdata, sdata->local->int_scan_req);
- unlock:
-	return ret;
+	return __ieee80211_start_scan(sdata, sdata->local->int_scan_req);
 }
 
 void ieee80211_scan_cancel(struct ieee80211_local *local)
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index 16f28db..8bc63a3 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -565,6 +565,7 @@ __sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 	spin_lock_init(&sta->ps_lock);
 	INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);
 	wiphy_work_init(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
+	sta->ampdu_mlme.dialog_token_allocator = get_random_u32_below(U8_MAX);
 #ifdef CPTCFG_MAC80211_MESH
 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
 		sta->mesh = kzalloc(sizeof(*sta->mesh), gfp);
@@ -2352,13 +2353,28 @@ EXPORT_SYMBOL(ieee80211_sta_recalc_aggregates);
 
 void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
 					  struct sta_info *sta, u8 ac,
-					  u16 tx_airtime, bool tx_completed)
+					  u16 tx_airtime, bool tx_completed,
+					  bool mcast)
 {
 	int tx_pending;
 
 	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
 		return;
 
+	if (mcast) {
+		if (!tx_completed) {
+			atomic_add(tx_airtime, &local->aql_bc_pending_airtime);
+			return;
+		}
+
+		tx_pending = atomic_sub_return(tx_airtime,
+					       &local->aql_bc_pending_airtime);
+		if (tx_pending < 0)
+			atomic_cmpxchg(&local->aql_bc_pending_airtime,
+				       tx_pending, 0);
+		return;
+	}
+
 	if (!tx_completed) {
 		if (sta)
 			atomic_add(tx_airtime,
@@ -2439,6 +2455,13 @@ static void sta_stats_decode_rate(struct ieee80211_local *local, u32 rate,
 
 		sband = local->hw.wiphy->bands[band];
 
+		if (!sband) {
+			wiphy_warn(local->hw.wiphy,
+				    "Invalid band %d\n",
+				    band);
+			break;
+		}
+
 		if (WARN_ON_ONCE(!sband->bitrates))
 			break;
 
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index d1b3a61..40513d8 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -147,7 +147,8 @@ struct airtime_info {
 
 void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
 					  struct sta_info *sta, u8 ac,
-					  u16 tx_airtime, bool tx_completed);
+					  u16 tx_airtime, bool tx_completed,
+					  bool mcast);
 
 struct sta_info;
 
diff --git a/net/mac80211/status.c b/net/mac80211/status.c
index b41b867..fc34247 100644
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -734,7 +734,7 @@ static void ieee80211_report_used_skb(struct ieee80211_local *local,
 		ieee80211_sta_update_pending_airtime(local, sta,
 						     skb_get_queue_mapping(skb),
 						     tx_time_est,
-						     true);
+						     true, info->tx_time_mc);
 		rcu_read_unlock();
 	}
 
@@ -927,6 +927,9 @@ void ieee80211_tx_monitor(struct ieee80211_local *local, struct sk_buff *skb,
 			if (!ieee80211_sdata_running(sdata))
 				continue;
 
+			if (sdata->u.mntr.flags & MONITOR_FLAG_SKIP_TX)
+				continue;
+
 			if ((sdata->u.mntr.flags & MONITOR_FLAG_COOK_FRAMES) &&
 			    !send_to_cooked)
 				continue;
@@ -1099,7 +1102,7 @@ static void __ieee80211_tx_status(struct ieee80211_hw *hw,
 	 * This is a bit racy but we can avoid a lot of work
 	 * with this test...
 	 */
-	if (!local->monitors && (!send_to_cooked || !local->cooked_mntrs)) {
+	if (!local->tx_mntrs && (!send_to_cooked || !local->cooked_mntrs)) {
 		if (status->free_list)
 			list_add_tail(&skb->list, status->free_list);
 		else
@@ -1158,10 +1161,11 @@ void ieee80211_tx_status_ext(struct ieee80211_hw *hw,
 		/* Do this here to avoid the expensive lookup of the sta
 		 * in ieee80211_report_used_skb().
 		 */
+		bool mcast = IEEE80211_SKB_CB(skb)->tx_time_mc;
 		ieee80211_sta_update_pending_airtime(local, sta,
 						     skb_get_queue_mapping(skb),
 						     tx_time_est,
-						     true);
+						     true, mcast);
 		ieee80211_info_set_tx_time_est(IEEE80211_SKB_CB(skb), 0);
 	}
 
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index dc498cd..78ffd3b 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -33,7 +33,7 @@
 			__string(vif_name, sdata->name)
 #define VIF_ASSIGN	__entry->vif_type = sdata->vif.type; __entry->sdata = sdata;	\
 			__entry->p2p = sdata->vif.p2p;					\
-			__assign_str(vif_name)
+			__assign_str(vif_name, sdata->name)
 #define VIF_PR_FMT	" vif:%s(%d%s)"
 #define VIF_PR_ARG	__get_str(vif_name), __entry->vif_type, __entry->p2p ? "/p2p" : ""
 
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index 7cad769..bfea54d 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -1763,7 +1763,8 @@ static bool __ieee80211_tx(struct ieee80211_local *local,
 
 	switch (sdata->vif.type) {
 	case NL80211_IFTYPE_MONITOR:
-		if (sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {
+		if ((sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) ||
+		    ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)) {
 			vif = &sdata->vif;
 			break;
 		}
@@ -2554,7 +2555,7 @@ static u16 ieee80211_store_ack_skb(struct ieee80211_local *local,
 
 		spin_lock_irqsave(&local->ack_status_lock, flags);
 		id = idr_alloc(&local->ack_status_frames, ack_skb,
-			       1, 0x2000, GFP_ATOMIC);
+			       1, 0x1000, GFP_ATOMIC);
 		spin_unlock_irqrestore(&local->ack_status_lock, flags);
 
 		if (id >= 0) {
@@ -3952,7 +3953,8 @@ begin:
 
 	switch (tx.sdata->vif.type) {
 	case NL80211_IFTYPE_MONITOR:
-		if (tx.sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) {
+		if ((tx.sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) ||
+		    ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR)) {
 			vif = &tx.sdata->vif;
 			break;
 		}
@@ -3982,20 +3984,20 @@ begin:
 encap_out:
 	info->control.vif = vif;
 
-	if (tx.sta &&
-	    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
-		bool ampdu = txq->ac != IEEE80211_AC_VO;
+	if (wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
+		bool ampdu = txq->sta && txq->ac != IEEE80211_AC_VO;
 		u32 airtime;
 
 		airtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,
 							     skb->len, ampdu);
-		if (airtime) {
-			airtime = ieee80211_info_set_tx_time_est(info, airtime);
-			ieee80211_sta_update_pending_airtime(local, tx.sta,
-							     txq->ac,
-							     airtime,
-							     false);
-		}
+		if (!airtime)
+			return skb;
+
+		airtime = ieee80211_info_set_tx_time_est(info, airtime);
+		info->tx_time_mc = !tx.sta;
+		ieee80211_sta_update_pending_airtime(local, tx.sta, txq->ac,
+						     airtime, false,
+						     info->tx_time_mc);
 	}
 
 	return skb;
@@ -4047,6 +4049,7 @@ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
 	struct ieee80211_txq *ret = NULL;
 	struct txq_info *txqi = NULL, *head = NULL;
 	bool found_eligible_txq = false;
+	bool aql_check;
 
 	spin_lock_bh(&local->active_txq_lock[ac]);
 
@@ -4070,26 +4073,26 @@ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
 	if (!head)
 		head = txqi;
 
+	aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
+	if (aql_check)
+		found_eligible_txq = true;
+
 	if (txqi->txq.sta) {
 		struct sta_info *sta = container_of(txqi->txq.sta,
 						    struct sta_info, sta);
-		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
-		s32 deficit = ieee80211_sta_deficit(sta, txqi->txq.ac);
-
-		if (aql_check)
-			found_eligible_txq = true;
-
-		if (deficit < 0)
+		if (ieee80211_sta_deficit(sta, txqi->txq.ac) < 0) {
 			sta->airtime[txqi->txq.ac].deficit +=
-				sta->airtime_weight;
-
-		if (deficit < 0 || !aql_check) {
-			list_move_tail(&txqi->schedule_order,
-				       &local->active_txqs[txqi->txq.ac]);
-			goto begin;
+				sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
+			aql_check = false;
 		}
 	}
 
+	if (!aql_check) {
+		list_move_tail(&txqi->schedule_order,
+				   &local->active_txqs[txqi->txq.ac]);
+		goto begin;
+	}
+
 	if (txqi->schedule_round == local->schedule_round[ac])
 		goto out;
 
@@ -4154,7 +4157,8 @@ bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
 		return true;
 
 	if (!txq->sta)
-		return true;
+		return atomic_read(&local->aql_bc_pending_airtime) <
+		       local->aql_txq_limit_bc;
 
 	if (unlikely(txq->tid == IEEE80211_NUM_TIDS))
 		return true;
@@ -4203,15 +4207,15 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 
 	spin_lock_bh(&local->active_txq_lock[ac]);
 
-	if (!txqi->txq.sta)
-		goto out;
-
 	if (list_empty(&txqi->schedule_order))
 		goto out;
 
 	if (!ieee80211_txq_schedule_airtime_check(local, ac))
 		goto out;
 
+	if (!txqi->txq.sta)
+		goto out;
+
 	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
 				 schedule_order) {
 		if (iter == txqi)
@@ -4224,7 +4228,8 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 		}
 		sta = container_of(iter->txq.sta, struct sta_info, sta);
 		if (ieee80211_sta_deficit(sta, ac) < 0)
-			sta->airtime[ac].deficit += sta->airtime_weight;
+			sta->airtime[ac].deficit += sta->airtime_weight <<
+						    AIRTIME_QUANTUM_SHIFT;
 		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
 	}
 
@@ -4232,7 +4237,7 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 	if (sta->airtime[ac].deficit >= 0)
 		goto out;
 
-	sta->airtime[ac].deficit += sta->airtime_weight;
+	sta->airtime[ac].deficit += sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
 	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
 	spin_unlock_bh(&local->active_txq_lock[ac]);
 
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index b4814e9..6fc56ea 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -739,7 +739,8 @@ static void __iterate_interfaces(struct ieee80211_local *local,
 				lockdep_is_held(&local->hw.wiphy->mtx)) {
 		switch (sdata->vif.type) {
 		case NL80211_IFTYPE_MONITOR:
-			if (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE))
+			if (!(sdata->u.mntr.flags & MONITOR_FLAG_ACTIVE) &&
+			    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
 				continue;
 			break;
 		case NL80211_IFTYPE_AP_VLAN:
@@ -1856,8 +1857,10 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 	}
 
 	list_for_each_entry(sdata, &local->interfaces, list) {
+		if (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
+		    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
+			continue;
 		if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
-		    sdata->vif.type != NL80211_IFTYPE_MONITOR &&
 		    ieee80211_sdata_running(sdata)) {
 			res = drv_add_interface(local, sdata);
 			if (WARN_ON(res))
@@ -1870,11 +1873,14 @@ int ieee80211_reconfig(struct ieee80211_local *local)
 	 */
 	if (res) {
 		list_for_each_entry_continue_reverse(sdata, &local->interfaces,
-						     list)
+						     list) {
+			if (sdata->vif.type == NL80211_IFTYPE_MONITOR &&
+			    !ieee80211_hw_check(&local->hw, NO_VIRTUAL_MONITOR))
+				continue;
 			if (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
-			    sdata->vif.type != NL80211_IFTYPE_MONITOR &&
 			    ieee80211_sdata_running(sdata))
 				drv_remove_interface(local, sdata);
+		}
 		ieee80211_handle_reconfig_failure(local);
 		return res;
 	}
diff --git a/net/wireless/ap.c b/net/wireless/ap.c
index 9a9a870..9cd0ab4 100644
--- a/net/wireless/ap.c
+++ b/net/wireless/ap.c
@@ -30,6 +30,9 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 	if (!wdev->links[link_id].ap.beacon_interval)
 		return -ENOENT;
 
+	cfg80211_update_last_available(wdev->wiphy,
+				       &wdev->links[link_id].ap.chandef);
+
 	err = rdev_stop_ap(rdev, dev, link_id);
 	if (!err) {
 		wdev->conn_owner_nlportid = 0;
@@ -41,9 +44,6 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		if (notify)
 			nl80211_send_ap_stopped(wdev, link_id);
 
-		/* Should we apply the grace period during beaconing interface
-		 * shutdown also?
-		 */
 		cfg80211_sched_dfs_chan_update(rdev);
 	}
 
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index 138df3a..b8b8328 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -598,6 +598,8 @@ static void cfg80211_set_chans_dfs_state(struct wiphy *wiphy, u32 center_freq,
 
 		c->dfs_state = dfs_state;
 		c->dfs_state_entered = jiffies;
+		if (dfs_state == NL80211_DFS_AVAILABLE)
+			c->dfs_state_last_available = jiffies;
 	}
 }
 
@@ -1087,6 +1089,49 @@ static bool cfg80211_get_chans_dfs_available(struct wiphy *wiphy,
 	return true;
 }
 
+static void
+__cfg80211_update_last_available(struct wiphy *wiphy,
+					 u32 center_freq,
+					 u32 bandwidth)
+{
+	struct ieee80211_channel *c;
+	u32 freq, start_freq, end_freq;
+
+	start_freq = cfg80211_get_start_freq(center_freq, bandwidth);
+	end_freq = cfg80211_get_end_freq(center_freq, bandwidth);
+
+	/*
+	 * Check entire range of channels for the bandwidth.
+	 * If any channel in between is disabled or has not
+	 * had gone through CAC return false
+	 */
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
+		c = ieee80211_get_channel_khz(wiphy, freq);
+		if (!c)
+			return;
+
+		c->dfs_state_last_available = jiffies;
+	}
+}
+
+void cfg80211_update_last_available(struct wiphy *wiphy,
+				    const struct cfg80211_chan_def *chandef)
+{
+	int width;
+
+	width = cfg80211_chandef_get_width(chandef);
+	if (width < 0)
+		return;
+
+	__cfg80211_update_last_available(wiphy, MHZ_TO_KHZ(chandef->center_freq1),
+						 width);
+	if (chandef->width != NL80211_CHAN_WIDTH_80P80)
+	    return;
+
+	__cfg80211_update_last_available(wiphy, MHZ_TO_KHZ(chandef->center_freq2),
+						 width);
+}
+
 static bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,
 				const struct cfg80211_chan_def *chandef)
 {
@@ -1628,6 +1673,7 @@ bool cfg80211_reg_check_beaconing(struct wiphy *wiphy,
 EXPORT_SYMBOL(cfg80211_reg_check_beaconing);
 
 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
+				 struct net_device *dev,
 				 struct cfg80211_chan_def *chandef)
 {
 	if (!rdev->ops->set_monitor_channel)
@@ -1635,7 +1681,7 @@ int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
 	if (!cfg80211_has_monitors_only(rdev))
 		return -EBUSY;
 
-	return rdev_set_monitor_channel(rdev, chandef);
+	return rdev_set_monitor_channel(rdev, dev, chandef);
 }
 
 bool cfg80211_any_usable_channels(struct wiphy *wiphy,
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 5f9ac3a..5950534 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -165,11 +165,15 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
 		if (!wdev->netdev)
 			continue;
+#if LINUX_VERSION_IS_GEQ(6,12,0)
 		wdev->netdev->netns_local = false;
+#endif
 		err = dev_change_net_namespace(wdev->netdev, net, "wlan%d");
 		if (err)
 			break;
+#if LINUX_VERSION_IS_GEQ(6,12,0)
 		wdev->netdev->netns_local = true;
+#endif
 	}
 
 	if (err) {
@@ -181,11 +185,15 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 						     list) {
 			if (!wdev->netdev)
 				continue;
+#if LINUX_VERSION_IS_GEQ(6,12,0)
 			wdev->netdev->netns_local = false;
+#endif
 			err = dev_change_net_namespace(wdev->netdev, net,
 							"wlan%d");
 			WARN_ON(err);
+#if LINUX_VERSION_IS_GEQ(6,12,0)
 			wdev->netdev->netns_local = true;
+#endif
 		}
 
 		return err;
@@ -670,21 +678,6 @@ int wiphy_verify_iface_combinations(struct wiphy *wiphy,
 				    c->limits[j].max > 1))
 				return -EINVAL;
 
-			/*
-			 * This isn't well-defined right now. If you have an
-			 * IBSS interface, then its beacon interval may change
-			 * by joining other networks, and nothing prevents it
-			 * from doing that.
-			 * So technically we probably shouldn't even allow AP
-			 * and IBSS in the same interface, but it seems that
-			 * some drivers support that, possibly only with fixed
-			 * beacon intervals for IBSS.
-			 */
-			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
-				    c->beacon_int_min_gcd)) {
-				return -EINVAL;
-			}
-
 			cnt += c->limits[j].max;
 			/*
 			 * Don't advertise an unsupported type
@@ -1431,6 +1424,8 @@ void cfg80211_init_wdev(struct wireless_dev *wdev)
 	/* allow mac80211 to determine the timeout */
 	wdev->ps_timeout = -1;
 
+	wdev->radio_mask = BIT(wdev->wiphy->n_radio) - 1;
+
 	if ((wdev->iftype == NL80211_IFTYPE_STATION ||
 	     wdev->iftype == NL80211_IFTYPE_P2P_CLIENT ||
 	     wdev->iftype == NL80211_IFTYPE_ADHOC) && !wdev->use_4addr)
@@ -1518,7 +1513,9 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
 		SET_NETDEV_DEVTYPE(dev, &wiphy_type);
 		wdev->netdev = dev;
 		/* can only change netns with wiphy */
+#if LINUX_VERSION_IS_GEQ(6,12,0)
 		dev->netns_local = true;
+#endif
 
 		cfg80211_init_wdev(wdev);
 		break;
diff --git a/net/wireless/core.h b/net/wireless/core.h
index 59be642..d07cc22 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -475,6 +475,8 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 			    enum nl80211_dfs_state dfs_state);
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work);
+void cfg80211_update_last_available(struct wiphy *wiphy,
+				    const struct cfg80211_chan_def *chandef);
 
 void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
 
@@ -516,6 +518,7 @@ static inline unsigned int elapsed_jiffies_msecs(unsigned long start)
 }
 
 int cfg80211_set_monitor_channel(struct cfg80211_registered_device *rdev,
+				 struct net_device *dev,
 				 struct cfg80211_chan_def *chandef);
 
 int ieee80211_get_ratemask(struct ieee80211_supported_band *sband,
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index ec89885..bc457b5 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -1031,6 +1031,8 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
 			if (c->dfs_state == NL80211_DFS_UNAVAILABLE) {
 				time_dfs_update = IEEE80211_DFS_MIN_NOP_TIME_MS;
 				radar_event = NL80211_RADAR_NOP_FINISHED;
+				timeout = c->dfs_state_entered +
+					  msecs_to_jiffies(time_dfs_update);
 			} else {
 				if (regulatory_pre_cac_allowed(wiphy) ||
 				    cfg80211_any_wiphy_oper_chan(wiphy, c))
@@ -1038,11 +1040,10 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
 
 				time_dfs_update = REG_PRE_CAC_EXPIRY_GRACE_MS;
 				radar_event = NL80211_RADAR_PRE_CAC_EXPIRED;
+				timeout = c->dfs_state_last_available +
+					  msecs_to_jiffies(time_dfs_update);
 			}
 
-			timeout = c->dfs_state_entered +
-				  msecs_to_jiffies(time_dfs_update);
-
 			if (time_after_eq(jiffies, timeout)) {
 				c->dfs_state = NL80211_DFS_USABLE;
 				c->dfs_state_entered = jiffies;
diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c
index 5fde13e..10f657d 100644
--- a/net/wireless/nl80211.c
+++ b/net/wireless/nl80211.c
@@ -829,6 +829,7 @@ static const struct nla_policy nl80211_policy[NUM_NL80211_ATTR] = {
 	[NL80211_ATTR_MLO_TTLM_DLINK] = NLA_POLICY_EXACT_LEN(sizeof(u16) * 8),
 	[NL80211_ATTR_MLO_TTLM_ULINK] = NLA_POLICY_EXACT_LEN(sizeof(u16) * 8),
 	[NL80211_ATTR_ASSOC_SPP_AMSDU] = { .type = NLA_FLAG },
+	[NL80211_ATTR_VIF_RADIO_MASK] = { .type = NLA_U32 },
 };
 
 /* policy for the key attributes */
@@ -2430,6 +2431,11 @@ static int nl80211_put_radio(struct wiphy *wiphy, struct sk_buff *msg, int idx)
 	if (nla_put_u32(msg, NL80211_WIPHY_RADIO_ATTR_INDEX, idx))
 		goto nla_put_failure;
 
+	if (r->antenna_mask &&
+	    nla_put_u32(msg, NL80211_WIPHY_RADIO_ATTR_ANTENNA_MASK,
+			r->antenna_mask))
+		goto nla_put_failure;
+
 	for (i = 0; i < r->n_freq_range; i++) {
 		const struct wiphy_radio_freq_range *range = &r->freq_range[i];
 
@@ -3561,7 +3567,7 @@ static int __nl80211_set_channel(struct cfg80211_registered_device *rdev,
 	case NL80211_IFTYPE_MESH_POINT:
 		return cfg80211_set_mesh_channel(rdev, wdev, &chandef);
 	case NL80211_IFTYPE_MONITOR:
-		return cfg80211_set_monitor_channel(rdev, &chandef);
+		return cfg80211_set_monitor_channel(rdev, dev, &chandef);
 	default:
 		break;
 	}
@@ -3996,7 +4002,8 @@ static int nl80211_send_iface(struct sk_buff *msg, u32 portid, u32 seq, int flag
 	    nla_put_u32(msg, NL80211_ATTR_GENERATION,
 			rdev->devlist_generation ^
 			(cfg80211_rdev_list_generation << 2)) ||
-	    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr))
+	    nla_put_u8(msg, NL80211_ATTR_4ADDR, wdev->use_4addr) ||
+	    nla_put_u32(msg, NL80211_ATTR_VIF_RADIO_MASK, wdev->radio_mask))
 		goto nla_put_failure;
 
 	if (rdev->ops->get_channel && !wdev->valid_links) {
@@ -4199,6 +4206,7 @@ static const struct nla_policy mntr_flags_policy[NL80211_MNTR_FLAG_MAX + 1] = {
 	[NL80211_MNTR_FLAG_OTHER_BSS] = { .type = NLA_FLAG },
 	[NL80211_MNTR_FLAG_COOK_FRAMES] = { .type = NLA_FLAG },
 	[NL80211_MNTR_FLAG_ACTIVE] = { .type = NLA_FLAG },
+	[NL80211_MNTR_FLAG_SKIP_TX] = { .type = NLA_FLAG },
 };
 
 static int parse_monitor_flags(struct nlattr *nla, u32 *mntrflags)
@@ -4312,6 +4320,29 @@ static int nl80211_valid_4addr(struct cfg80211_registered_device *rdev,
 	return -EOPNOTSUPP;
 }
 
+static int nl80211_parse_vif_radio_mask(struct genl_info *info,
+					u32 *radio_mask)
+{
+	struct cfg80211_registered_device *rdev = info->user_ptr[0];
+	struct nlattr *attr = info->attrs[NL80211_ATTR_VIF_RADIO_MASK];
+	u32 mask, allowed;
+
+	if (!attr) {
+		*radio_mask = 0;
+		return 0;
+	}
+
+	allowed = BIT(rdev->wiphy.n_radio) - 1;
+	mask = nla_get_u32(attr);
+	if (mask & ~allowed)
+		return -EINVAL;
+	if (!mask)
+		mask = allowed;
+	*radio_mask = mask;
+
+	return 1;
+}
+
 static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 {
 	struct cfg80211_registered_device *rdev = info->user_ptr[0];
@@ -4319,6 +4350,8 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 	int err;
 	enum nl80211_iftype otype, ntype;
 	struct net_device *dev = info->user_ptr[1];
+	struct wireless_dev *wdev = dev->ieee80211_ptr;
+	u32 radio_mask = 0;
 	bool change = false;
 
 	memset(&params, 0, sizeof(params));
@@ -4332,8 +4365,6 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 	}
 
 	if (info->attrs[NL80211_ATTR_MESH_ID]) {
-		struct wireless_dev *wdev = dev->ieee80211_ptr;
-
 		if (ntype != NL80211_IFTYPE_MESH_POINT)
 			return -EINVAL;
 		if (otype != NL80211_IFTYPE_MESH_POINT)
@@ -4364,6 +4395,12 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 	if (err > 0)
 		change = true;
 
+	err = nl80211_parse_vif_radio_mask(info, &radio_mask);
+	if (err < 0)
+		return err;
+	if (err && netif_running(dev))
+		return -EBUSY;
+
 	if (change)
 		err = cfg80211_change_iface(rdev, dev, ntype, &params);
 	else
@@ -4372,11 +4409,11 @@ static int nl80211_set_interface(struct sk_buff *skb, struct genl_info *info)
 	if (!err && params.use_4addr != -1)
 		dev->ieee80211_ptr->use_4addr = params.use_4addr;
 
-	if (change && !err) {
-		struct wireless_dev *wdev = dev->ieee80211_ptr;
+	if (radio_mask)
+		wdev->radio_mask = radio_mask;
 
+	if (change && !err)
 		nl80211_notify_iface(rdev, wdev, NL80211_CMD_SET_INTERFACE);
-	}
 
 	return err;
 }
@@ -4387,6 +4424,7 @@ static int _nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 	struct vif_params params;
 	struct wireless_dev *wdev;
 	struct sk_buff *msg;
+	u32 radio_mask;
 	int err;
 	enum nl80211_iftype type = NL80211_IFTYPE_UNSPECIFIED;
 
@@ -4424,6 +4462,10 @@ static int _nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 	if (err < 0)
 		return err;
 
+	err = nl80211_parse_vif_radio_mask(info, &radio_mask);
+	if (err < 0)
+		return err;
+
 	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
 	if (!msg)
 		return -ENOMEM;
@@ -4465,6 +4507,9 @@ static int _nl80211_new_interface(struct sk_buff *skb, struct genl_info *info)
 		break;
 	}
 
+	if (radio_mask)
+		wdev->radio_mask = radio_mask;
+
 	if (nl80211_send_iface(msg, info->snd_portid, info->snd_seq, 0,
 			       rdev, wdev, NL80211_CMD_NEW_INTERFACE) < 0) {
 		nlmsg_free(msg);
@@ -9180,6 +9225,9 @@ static bool cfg80211_off_channel_oper_allowed(struct wireless_dev *wdev,
 
 	lockdep_assert_wiphy(wdev->wiphy);
 
+	if (!cfg80211_wdev_channel_allowed(wdev, chan))
+		return false;
+
 	if (!cfg80211_beaconing_iface_active(wdev))
 		return true;
 
@@ -9392,7 +9440,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 			}
 
 			/* ignore disabled channels */
-			if (chan->flags & IEEE80211_CHAN_DISABLED)
+			if (chan->flags & IEEE80211_CHAN_DISABLED ||
+			    !cfg80211_wdev_channel_allowed(wdev, chan))
 				continue;
 
 			request->channels[i] = chan;
@@ -9412,7 +9461,8 @@ static int nl80211_trigger_scan(struct sk_buff *skb, struct genl_info *info)
 
 				chan = &wiphy->bands[band]->channels[j];
 
-				if (chan->flags & IEEE80211_CHAN_DISABLED)
+				if (chan->flags & IEEE80211_CHAN_DISABLED ||
+				    !cfg80211_wdev_channel_allowed(wdev, chan))
 					continue;
 
 				request->channels[i] = chan;
diff --git a/net/wireless/rdev-ops.h b/net/wireless/rdev-ops.h
index 4e8c895..12eefbd 100644
--- a/net/wireless/rdev-ops.h
+++ b/net/wireless/rdev-ops.h
@@ -445,11 +445,12 @@ rdev_libertas_set_mesh_channel(struct cfg80211_registered_device *rdev,
 
 static inline int
 rdev_set_monitor_channel(struct cfg80211_registered_device *rdev,
+			 struct net_device *dev,
 			 struct cfg80211_chan_def *chandef)
 {
 	int ret;
-	trace_rdev_set_monitor_channel(&rdev->wiphy, chandef);
-	ret = rdev->ops->set_monitor_channel(&rdev->wiphy, chandef);
+	trace_rdev_set_monitor_channel(&rdev->wiphy, dev, chandef);
+	ret = rdev->ops->set_monitor_channel(&rdev->wiphy, dev, chandef);
 	trace_rdev_return_int(&rdev->wiphy, ret);
 	return ret;
 }
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index 8dfb610..cf8c38c 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -3364,6 +3364,8 @@ void regulatory_hint_country_ie(struct wiphy *wiphy, enum nl80211_band band,
 	enum environment_cap env = ENVIRON_ANY;
 	struct regulatory_request *request = NULL, *lr;
 
+	return;
+
 	/* IE len must be evenly divisible by 2 */
 	if (country_ie_len & 0x01)
 		return;
@@ -3615,6 +3617,7 @@ static bool is_wiphy_all_set_reg_flag(enum ieee80211_regulatory_flags flag)
 
 void regulatory_hint_disconnect(void)
 {
+	return;
 	/* Restore of regulatory settings is not required when wiphy(s)
 	 * ignore IE from connected access point but clearance of beacon hints
 	 * is required when wiphy(s) supports beacon hints.
diff --git a/net/wireless/scan.c b/net/wireless/scan.c
index 330140a..0c9a01d 100644
--- a/net/wireless/scan.c
+++ b/net/wireless/scan.c
@@ -956,7 +956,8 @@ static int cfg80211_scan_6ghz(struct cfg80211_registered_device *rdev)
 		struct ieee80211_channel *chan =
 			ieee80211_get_channel(&rdev->wiphy, ap->center_freq);
 
-		if (!chan || chan->flags & IEEE80211_CHAN_DISABLED)
+		if (!chan || chan->flags & IEEE80211_CHAN_DISABLED ||
+		    !cfg80211_wdev_channel_allowed(rdev_req->wdev, chan))
 			continue;
 
 		for (i = 0; i < rdev_req->n_channels; i++) {
@@ -3519,9 +3520,12 @@ int cfg80211_wext_siwscan(struct net_device *dev,
 			continue;
 
 		for (j = 0; j < wiphy->bands[band]->n_channels; j++) {
+			struct ieee80211_channel *chan;
+
 			/* ignore disabled channels */
-			if (wiphy->bands[band]->channels[j].flags &
-						IEEE80211_CHAN_DISABLED)
+			chan = &wiphy->bands[band]->channels[j];
+			if (chan->flags & IEEE80211_CHAN_DISABLED ||
+			    !cfg80211_wdev_channel_allowed(creq->wdev, chan))
 				continue;
 
 			/* If we have a wireless request structure and the
diff --git a/net/wireless/sysfs.c b/net/wireless/sysfs.c
index 62f2661..4e7644f 100644
--- a/net/wireless/sysfs.c
+++ b/net/wireless/sysfs.c
@@ -24,18 +24,35 @@ static inline struct cfg80211_registered_device *dev_to_rdev(
 	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
 }
 
-#define SHOW_FMT(name, fmt, member)					\
+#define SHOW_FMT(name, fmt, member, mode)				\
 static ssize_t name ## _show(struct device *dev,			\
 			      struct device_attribute *attr,		\
 			      char *buf)				\
 {									\
 	return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member);	\
 }									\
-static DEVICE_ATTR_RO(name)
+static DEVICE_ATTR_##mode(name)
 
-SHOW_FMT(index, "%d", wiphy_idx);
-SHOW_FMT(macaddress, "%pM", wiphy.perm_addr);
-SHOW_FMT(address_mask, "%pM", wiphy.addr_mask);
+static ssize_t macaddress_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	u8 mac[ETH_ALEN];
+
+	if (!mac_pton(buf, mac))
+		return -EINVAL;
+
+	if (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')
+		return -EINVAL;
+
+	memcpy(dev_to_rdev(dev)->wiphy.perm_addr, mac, ETH_ALEN);
+
+	return strnlen(buf, len);
+}
+
+SHOW_FMT(index, "%d", wiphy_idx, RO);
+SHOW_FMT(macaddress, "%pM", wiphy.perm_addr, RW);
+SHOW_FMT(address_mask, "%pM", wiphy.addr_mask, RO);
 
 static ssize_t name_show(struct device *dev,
 			 struct device_attribute *attr,
diff --git a/net/wireless/trace.h b/net/wireless/trace.h
index 74e9911..3119412 100644
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -446,7 +446,7 @@ TRACE_EVENT(rdev_add_virtual_intf,
 	),
 	TP_fast_assign(
 		WIPHY_ASSIGN;
-		__assign_str(vir_intf_name);
+		__assign_str(vir_intf_name, name ? name : "<noname>");
 		__entry->type = type;
 	),
 	TP_printk(WIPHY_PR_FMT ", virtual intf name: %s, type: %d",
@@ -1318,19 +1318,21 @@ TRACE_EVENT(rdev_libertas_set_mesh_channel,
 );
 
 TRACE_EVENT(rdev_set_monitor_channel,
-	TP_PROTO(struct wiphy *wiphy,
+	TP_PROTO(struct wiphy *wiphy, struct net_device *netdev,
 		 struct cfg80211_chan_def *chandef),
-	TP_ARGS(wiphy, chandef),
+	TP_ARGS(wiphy, netdev, chandef),
 	TP_STRUCT__entry(
 		WIPHY_ENTRY
+		NETDEV_ENTRY
 		CHAN_DEF_ENTRY
 	),
 	TP_fast_assign(
 		WIPHY_ASSIGN;
+		NETDEV_ASSIGN;
 		CHAN_DEF_ASSIGN(chandef);
 	),
-	TP_printk(WIPHY_PR_FMT ", " CHAN_DEF_PR_FMT,
-		  WIPHY_PR_ARG, CHAN_DEF_PR_ARG)
+	TP_printk(WIPHY_PR_FMT ", " NETDEV_PR_FMT ", " CHAN_DEF_PR_FMT,
+		  WIPHY_PR_ARG, NETDEV_PR_ARG, CHAN_DEF_PR_ARG)
 );
 
 TRACE_EVENT(rdev_auth,
diff --git a/net/wireless/util.c b/net/wireless/util.c
index f49b557..9ccc960 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -2923,3 +2923,32 @@ bool cfg80211_radio_chandef_valid(const struct wiphy_radio *radio,
 	return true;
 }
 EXPORT_SYMBOL(cfg80211_radio_chandef_valid);
+
+bool cfg80211_wdev_channel_allowed(struct wireless_dev *wdev,
+				   struct ieee80211_channel *chan)
+{
+	struct wiphy *wiphy = wdev->wiphy;
+	const struct wiphy_radio *radio;
+	struct cfg80211_chan_def chandef;
+	u32 radio_mask;
+	int i;
+
+	radio_mask = wdev->radio_mask;
+	if (!wiphy->n_radio || radio_mask == BIT(wiphy->n_radio) - 1)
+		return true;
+
+	cfg80211_chandef_create(&chandef, chan, NL80211_CHAN_HT20);
+	for (i = 0; i < wiphy->n_radio; i++) {
+		if (!(radio_mask & BIT(i)))
+			continue;
+
+		radio = &wiphy->radio[i];
+		if (!cfg80211_radio_chandef_valid(radio, &chandef))
+			continue;
+
+		return true;
+	}
+
+	return false;
+}
+EXPORT_SYMBOL(cfg80211_wdev_channel_allowed);
diff --git a/net/wireless/wext-compat.c b/net/wireless/wext-compat.c
index 2371069..fd3d013 100644
--- a/net/wireless/wext-compat.c
+++ b/net/wireless/wext-compat.c
@@ -830,7 +830,7 @@ static int cfg80211_wext_siwfreq(struct net_device *dev,
 			ret = -EINVAL;
 			break;
 		}
-		ret = cfg80211_set_monitor_channel(rdev, &chandef);
+		ret = cfg80211_set_monitor_channel(rdev, dev, &chandef);
 		break;
 	case NL80211_IFTYPE_MESH_POINT:
 		freq = cfg80211_wext_freq(wextfreq);
-- 
2.39.5

