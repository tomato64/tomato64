From 08b69a689fdc80304b38f04fc403945686b41882 Mon Sep 17 00:00:00 2001
From: lancethepants <lancethepants@gmail.com>
Date: Fri, 2 Jan 2026 12:14:15 -0700
Subject: [PATCH] mac80211

---
 Kconfig.sources                               |   2 -
 Makefile                                      | 115 +--
 Makefile.kernel                               |   2 -
 Makefile.real                                 |  29 +-
 backport-include/asm/unaligned.h              |   4 +
 backport-include/linux/compiler_attributes.h  |  15 -
 backport-include/linux/compiler_types.h       |  23 +
 backport-include/net/genetlink.h              |  11 +
 compat/Makefile                               |   3 +-
 compat/backport-genetlink.c                   |  61 ++
 compat/main.c                                 |  25 -
 compat_version                                |   1 +
 drivers/bus/mhi/host/trace.h                  |  24 +
 drivers/net/wireless/ath/Kconfig              |   5 +-
 drivers/net/wireless/ath/Makefile             |   2 +-
 drivers/net/wireless/ath/ath.h                |   9 +-
 drivers/net/wireless/ath/ath10k/Kconfig       |   6 +
 drivers/net/wireless/ath/ath10k/Makefile      |   2 +-
 drivers/net/wireless/ath/ath10k/core.c        |  13 +
 drivers/net/wireless/ath/ath10k/core.h        |   4 +
 drivers/net/wireless/ath/ath10k/htt.h         |   4 +
 drivers/net/wireless/ath/ath10k/leds.c        |   2 +-
 drivers/net/wireless/ath/ath10k/mac.c         |  83 +-
 drivers/net/wireless/ath/ath10k/pci.c         |  16 +
 drivers/net/wireless/ath/ath10k/snoc.c        |   6 +-
 drivers/net/wireless/ath/ath10k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath10k/trace.h       |  77 ++
 drivers/net/wireless/ath/ath11k/Kconfig       |  13 +-
 drivers/net/wireless/ath/ath11k/Makefile      |   2 +-
 drivers/net/wireless/ath/ath11k/ahb.c         |  91 +-
 drivers/net/wireless/ath/ath11k/core.c        | 101 ++-
 drivers/net/wireless/ath/ath11k/core.h        |   5 +
 drivers/net/wireless/ath/ath11k/dp.c          |  56 ++
 drivers/net/wireless/ath/ath11k/dp.h          |   7 +
 drivers/net/wireless/ath/ath11k/dp_tx.c       |   4 +
 drivers/net/wireless/ath/ath11k/hal.c         |  17 +-
 drivers/net/wireless/ath/ath11k/hif.h         |   9 +
 drivers/net/wireless/ath/ath11k/hw.c          | 128 ++-
 drivers/net/wireless/ath/ath11k/hw.h          |  10 +-
 drivers/net/wireless/ath/ath11k/mac.c         |  18 +
 drivers/net/wireless/ath/ath11k/mhi.c         |  49 +-
 drivers/net/wireless/ath/ath11k/mhi.h         |   3 +
 drivers/net/wireless/ath/ath11k/pci.c         |  11 +-
 drivers/net/wireless/ath/ath11k/pcic.c        |   9 +
 drivers/net/wireless/ath/ath11k/qmi.c         |  33 +-
 drivers/net/wireless/ath/ath11k/qmi.h         |   3 +-
 drivers/net/wireless/ath/ath11k/reg.c         | 201 +----
 drivers/net/wireless/ath/ath11k/reg.h         |   2 +-
 drivers/net/wireless/ath/ath11k/thermal.h     |   2 +-
 drivers/net/wireless/ath/ath11k/trace.h       |  55 +-
 drivers/net/wireless/ath/ath12k/ce.h          |   2 +-
 drivers/net/wireless/ath/ath12k/mac.c         |   4 +-
 drivers/net/wireless/ath/ath12k/pci.c         |  17 +-
 drivers/net/wireless/ath/ath12k/trace.h       |  20 +
 drivers/net/wireless/ath/ath12k/wmi.c         |   3 +
 drivers/net/wireless/ath/ath12k/wmi.h         |   2 +
 drivers/net/wireless/ath/ath5k/ath5k.h        |   1 +
 drivers/net/wireless/ath/ath5k/base.c         |   8 +-
 drivers/net/wireless/ath/ath5k/debug.c        |  93 ++
 drivers/net/wireless/ath/ath5k/dma.c          |   8 +
 drivers/net/wireless/ath/ath5k/initvals.c     |   6 +
 drivers/net/wireless/ath/ath5k/mac80211-ops.c |   9 +-
 drivers/net/wireless/ath/ath5k/pci.c          |  26 +-
 drivers/net/wireless/ath/ath5k/reset.c        |   2 +
 drivers/net/wireless/ath/ath6kl/trace.h       |   5 +
 drivers/net/wireless/ath/ath9k/Kconfig        |  13 +
 drivers/net/wireless/ath/ath9k/Makefile       |   1 +
 drivers/net/wireless/ath/ath9k/ani.h          |   2 +-
 drivers/net/wireless/ath/ath9k/ar5008_phy.c   |  72 +-
 drivers/net/wireless/ath/ath9k/ar9002_phy.h   |  11 +
 drivers/net/wireless/ath/ath9k/ar9003_phy.c   |  95 +-
 drivers/net/wireless/ath/ath9k/ath9k.h        |  23 +-
 drivers/net/wireless/ath/ath9k/channel.c      |   7 +
 drivers/net/wireless/ath/ath9k/common-debug.c | 107 +++
 drivers/net/wireless/ath/ath9k/common-debug.h |   4 +
 drivers/net/wireless/ath/ath9k/common.c       |  21 +-
 drivers/net/wireless/ath/ath9k/debug.c        | 107 +++
 drivers/net/wireless/ath/ath9k/gpio.c         | 247 +++++-
 drivers/net/wireless/ath/ath9k/hsr.c          | 248 ++++++
 drivers/net/wireless/ath/ath9k/hsr.h          |  50 ++
 .../net/wireless/ath/ath9k/htc_drv_debug.c    |   2 +
 drivers/net/wireless/ath/ath9k/htc_drv_init.c |   7 +-
 drivers/net/wireless/ath/ath9k/hw-ops.h       |   6 +
 drivers/net/wireless/ath/ath9k/hw.c           | 184 ++--
 drivers/net/wireless/ath/ath9k/hw.h           |  15 +-
 drivers/net/wireless/ath/ath9k/init.c         | 168 +++-
 drivers/net/wireless/ath/ath9k/mac.c          |   9 +-
 drivers/net/wireless/ath/ath9k/main.c         |  12 +
 drivers/net/wireless/ath/ath9k/pci.c          |   1 +
 drivers/net/wireless/ath/ath9k/phy.h          |   3 +
 drivers/net/wireless/ath/carl9170/debug.c     |  28 +-
 drivers/net/wireless/ath/regd.c               |  72 +-
 drivers/net/wireless/ath/regd_common.h        |   3 +
 drivers/net/wireless/ath/trace.h              |   5 +
 drivers/net/wireless/broadcom/b43/Kconfig     |   2 +-
 drivers/net/wireless/broadcom/b43/Makefile    |   2 +-
 drivers/net/wireless/broadcom/b43/b43.h       |   3 +
 drivers/net/wireless/broadcom/b43/debugfs.c   |  27 +-
 drivers/net/wireless/broadcom/b43/dma.h       |   2 +-
 drivers/net/wireless/broadcom/b43/main.c      |  84 +-
 drivers/net/wireless/broadcom/b43/pio.h       |  34 +-
 .../net/wireless/broadcom/b43legacy/debugfs.c |  26 +-
 .../net/wireless/broadcom/brcm80211/Kconfig   |   2 +-
 .../broadcom/brcm80211/brcmfmac/bus.h         |   2 +-
 .../broadcom/brcm80211/brcmfmac/cfg80211.c    | 139 ++-
 .../broadcom/brcm80211/brcmfmac/common.c      |  39 +
 .../broadcom/brcm80211/brcmfmac/core.c        |  13 +-
 .../broadcom/brcm80211/brcmfmac/debug.h       |   1 +
 .../broadcom/brcm80211/brcmfmac/firmware.c    |  21 +-
 .../broadcom/brcm80211/brcmfmac/fweh.h        |  31 +-
 .../broadcom/brcm80211/brcmfmac/p2p.c         |   5 +
 .../broadcom/brcm80211/brcmfmac/pcie.c        |   2 +-
 .../broadcom/brcm80211/brcmfmac/sdio.c        | 265 +++++-
 .../broadcom/brcm80211/brcmfmac/sdio.h        | 110 +++
 .../broadcom/brcm80211/brcmfmac/tracepoint.h  |   8 +
 .../broadcom/brcm80211/brcmfmac/usb.c         |   8 +-
 .../brcm80211/brcmsmac/brcms_trace_brcmsmac.h |   4 +
 .../brcmsmac/brcms_trace_brcmsmac_msg.h       |   4 +
 .../brcmsmac/brcms_trace_brcmsmac_tx.h        |  12 +
 .../broadcom/brcm80211/brcmsmac/channel.c     |  19 +-
 .../broadcom/brcm80211/include/chipcommon.h   |   2 +
 .../wireless/intel/iwlwifi/iwl-devtrace-msg.h |   4 +
 .../net/wireless/intel/iwlwifi/iwl-devtrace.h |   4 +
 .../net/wireless/intel/iwlwifi/mld/thermal.c  |  17 +
 drivers/net/wireless/intel/iwlwifi/mvm/tt.c   |  15 +
 drivers/net/wireless/marvell/libertas/cfg.c   |   4 +
 drivers/net/wireless/marvell/libertas/main.c  |   1 +
 drivers/net/wireless/marvell/mwifiex/cmdevt.c |  91 +-
 drivers/net/wireless/marvell/mwifiex/decl.h   |   4 +-
 drivers/net/wireless/marvell/mwifiex/main.h   |   2 +
 .../wireless/marvell/mwifiex/sta_cmdresp.c    |   5 +-
 .../net/wireless/marvell/mwifiex/uap_cmd.c    |   3 +-
 drivers/net/wireless/marvell/mwl8k.c          |   5 +-
 drivers/net/wireless/mediatek/mt7601u/usb.h   |   2 +-
 drivers/net/wireless/ralink/rt2x00/Kconfig    |  20 +-
 drivers/net/wireless/ralink/rt2x00/Makefile   |   1 +
 drivers/net/wireless/ralink/rt2x00/rt2800.h   |  29 +-
 .../net/wireless/ralink/rt2x00/rt2800lib.c    | 630 ++++++++------
 .../net/wireless/ralink/rt2x00/rt2800lib.h    |  24 +
 .../net/wireless/ralink/rt2x00/rt2800mmio.c   |  38 +-
 .../net/wireless/ralink/rt2x00/rt2800pci.c    |  10 +
 .../net/wireless/ralink/rt2x00/rt2800soc.c    |  61 +-
 .../net/wireless/ralink/rt2x00/rt2800usb.c    |   7 +
 drivers/net/wireless/ralink/rt2x00/rt2x00.h   |  16 +
 .../net/wireless/ralink/rt2x00/rt2x00dev.c    |  10 +-
 .../net/wireless/ralink/rt2x00/rt2x00eeprom.c | 221 +++++
 .../net/wireless/ralink/rt2x00/rt2x00leds.c   |   3 +
 .../net/wireless/ralink/rt2x00/rt2x00queue.h  |  20 +
 drivers/net/wireless/realtek/rtw88/usb.c      |   4 +
 drivers/net/wireless/virtual/mac80211_hwsim.c |  14 +
 include/linux/ath5k_platform.h                |  30 +
 include/linux/mhi.h                           | 812 ------------------
 include/net/cfg80211.h                        |   4 +
 include/net/mac80211.h                        |   2 +-
 include/trace/events/qrtr.h                   |   4 +
 kconf/Makefile                                |   6 +-
 kconf/conf.c                                  |  46 +-
 kconf/confdata.c                              |   4 +-
 local-symbols                                 |  13 +-
 net/mac80211/airtime.c                        |  87 +-
 net/mac80211/cfg.c                            |  58 +-
 net/mac80211/chan.c                           |  28 +-
 net/mac80211/debugfs.c                        |  40 +-
 net/mac80211/debugfs_key.c                    |   9 +-
 net/mac80211/debugfs_netdev.c                 |   3 +-
 net/mac80211/debugfs_sta.c                    |   9 +-
 net/mac80211/ieee80211_i.h                    |  21 +-
 net/mac80211/main.c                           |  19 +-
 net/mac80211/offchannel.c                     |  40 +-
 net/mac80211/rate.c                           |   3 +-
 net/mac80211/rate.h                           |   2 +-
 net/mac80211/rc80211_minstrel_ht.c            |  75 +-
 net/mac80211/rc80211_minstrel_ht.h            |   2 +-
 net/mac80211/scan.c                           |  90 +-
 net/mac80211/sta_info.c                       |  50 +-
 net/mac80211/sta_info.h                       |   3 +-
 net/mac80211/status.c                         |   5 +-
 net/mac80211/trace.h                          |   6 +
 net/mac80211/tx.c                             |  63 +-
 net/mac80211/util.c                           |  17 +
 net/wireless/ap.c                             |   6 +-
 net/wireless/chan.c                           |  49 ++
 net/wireless/core.c                           |  35 +-
 net/wireless/core.h                           |   2 +
 net/wireless/mlme.c                           |   7 +-
 net/wireless/reg.c                            |   3 +
 net/wireless/sysfs.c                          |  27 +-
 net/wireless/trace.h                          |   4 +
 net/wireless/util.c                           |   3 +
 189 files changed, 4725 insertions(+), 2198 deletions(-)
 create mode 100644 backport-include/linux/compiler_types.h
 create mode 100644 compat_version
 create mode 100644 drivers/net/wireless/ath/ath9k/hsr.c
 create mode 100644 drivers/net/wireless/ath/ath9k/hsr.h
 create mode 100644 drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
 create mode 100644 include/linux/ath5k_platform.h
 delete mode 100644 include/linux/mhi.h

diff --git a/Kconfig.sources b/Kconfig.sources
index 0aa62a3..d74affd 100644
--- a/Kconfig.sources
+++ b/Kconfig.sources
@@ -4,8 +4,6 @@ source "$BACKPORT_DIR/compat/Kconfig"
 # these are copied from the kernel
 source "$BACKPORT_DIR/net/wireless/Kconfig"
 source "$BACKPORT_DIR/net/mac80211/Kconfig"
-source "$BACKPORT_DIR/net/qrtr/Kconfig"
-source "$BACKPORT_DIR/drivers/bus/mhi/Kconfig"
 source "$BACKPORT_DIR/drivers/soc/qcom/Kconfig"
 source "$BACKPORT_DIR/drivers/net/wireless/Kconfig"
 source "$BACKPORT_DIR/drivers/net/usb/Kconfig"
diff --git a/Makefile b/Makefile
index 548d813..989faff 100644
--- a/Makefile
+++ b/Makefile
@@ -2,10 +2,10 @@
 # Makefile for the output source package
 #
 
-ifeq ($(KERNELRELEASE),)
+ifeq ($(KERNELVERSION),)
 
 MAKEFLAGS += --no-print-directory
-SHELL := /bin/bash
+SHELL := /usr/bin/env bash
 BACKPORT_DIR := $(shell pwd)
 
 KMODDIR ?= updates
@@ -19,6 +19,7 @@ KLIB_BUILD ?= $(KLIB)/build/
 KERNEL_CONFIG := $(KLIB_BUILD)/.config
 KERNEL_MAKEFILE := $(KLIB_BUILD)/Makefile
 CONFIG_MD5 := $(shell md5sum $(KERNEL_CONFIG) 2>/dev/null | sed 's/\s.*//')
+STAMP_KERNEL_CONFIG := .kernel_config_md5_$(CONFIG_MD5)
 
 export KLIB KLIB_BUILD BACKPORT_DIR KMODDIR KMODPATH_ARG
 
@@ -36,7 +37,8 @@ mrproper:
 	@rm -f .kernel_config_md5 Kconfig.versions Kconfig.kernel
 	@rm -f backport-include/backport/autoconf.h
 
-.DEFAULT:
+.SILENT: $(STAMP_KERNEL_CONFIG)
+$(STAMP_KERNEL_CONFIG):
 	@set -e ; test -f local-symbols || (						\
 	echo "/--------------"								;\
 	echo "| You shouldn't run make in the backports tree, but only in"		;\
@@ -60,57 +62,62 @@ mrproper:
 	echo "| (that isn't currently running.)"					;\
 	echo "\\--"									;\
 	false)
-	@set -e ; if [ "$$(cat .kernel_config_md5 2>/dev/null)" != "$(CONFIG_MD5)" ]	;\
-	then 										\
-		echo -n "Generating local configuration database from kernel ..."	;\
-		grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
-			while read l ; do						\
-				if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
-					continue					;\
-				fi							;\
-				l=$${l:7}						;\
-				n=$${l%%=*}						;\
-				v=$${l#*=}						;\
-				if [ "$$v" = "m" ] ; then				\
-					echo config $$n					;\
-					echo '    tristate' 				;\
-				elif [ "$$v" = "y" ] ; then				\
-					echo config $$n					;\
-					echo '    bool'					;\
-				else							\
-					continue					;\
-				fi							;\
-				echo "    default $$v"					;\
-				echo ""							;\
-			done								\
-		) > Kconfig.kernel							;\
-		kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
-			kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
-		test "$$kver" != "" || echo "Kernel version parse failed!"		;\
-		test "$$kver" != ""							;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
-		kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
-		kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
-		print=0									;\
-		for v in $$kvers ; do							\
-			if [ "$$print" = "1" ] ; then					\
-				echo config KERNEL_$$(echo $$v | tr . _)	;\
-				echo "    def_bool y"					;\
-			fi								;\
-			if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
-		done > Kconfig.versions							;\
-		# RHEL as well, sadly we need to grep for it				;\
-		RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
-					sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
-		for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
-			echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
-			echo "    def_bool y"						;\
-		done >> Kconfig.versions						;\
-		echo " done."								;\
-	fi										;\
-	echo "$(CONFIG_MD5)" > .kernel_config_md5
+	@rm -f .kernel_config_md5_*
+	@touch $@
+
+Kconfig.kernel: $(STAMP_KERNEL_CONFIG) local-symbols
+	@printf "Generating local configuration database from kernel ..."
+	@grep -v -f local-symbols $(KERNEL_CONFIG) | grep = | (			\
+		while read l ; do						\
+			if [ "$${l:0:7}" != "CONFIG_" ] ; then			\
+				continue					;\
+			fi							;\
+			l=$${l:7}						;\
+			n=$${l%%=*}						;\
+			v=$${l#*=}						;\
+			if [ "$$v" = "m" ] ; then				\
+				echo config $$n					;\
+				echo '    tristate' 				;\
+			elif [ "$$v" = "y" ] ; then				\
+				echo config $$n					;\
+				echo '    bool'					;\
+			else							\
+				continue					;\
+			fi							;\
+			echo "    default $$v"					;\
+			echo ""							;\
+		done								\
+	) > $@
+	@echo " done."
+
+Kconfig.versions: Kconfig.kernel
+	@kver=$$($(MAKE) --no-print-directory -C $(KLIB_BUILD) M=$(BACKPORT_DIR)	\
+		kernelversion |	sed 's/^\(\([3-6]\|2\.6\)\.[0-9]\+\).*/\1/;t;d');\
+	test "$$kver" != "" || echo "Kernel version parse failed!"		;\
+	test "$$kver" != ""							;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/4./')"				;\
+	kvers="$$kvers $$(seq 0 19 | sed 's/^/5./')"				;\
+	kvers="$$kvers $$(seq 0 20 | sed 's/^/6./')"				;\
+	print=0									;\
+	for v in $$kvers ; do							\
+		if [ "$$print" = "1" ] ; then					\
+			echo config KERNEL_$$(echo $$v | tr . _)	;\
+			echo "    def_bool y"					;\
+		fi								;\
+		if [ "$$v" = "$$kver" ] ; then print=1 ; fi			;\
+	done > Kconfig.versions							;\
+	# RHEL as well, sadly we need to grep for it				;\
+	RHEL_MAJOR=$$(grep '^RHEL_MAJOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	RHEL_MINOR=$$(grep '^RHEL_MINOR' $(KERNEL_MAKEFILE) | 			\
+				sed 's/.*=\s*\([0-9]*\)/\1/;t;d')		;\
+	for v in $$(seq 0 $$RHEL_MINOR) ; do 					\
+		echo config BACKPORT_RHEL_KERNEL_$${RHEL_MAJOR}_$$v		;\
+		echo "    def_bool y"						;\
+	done >> $@
+
+.DEFAULT:
+	@$(MAKE) Kconfig.versions
 	@$(MAKE) -f Makefile.real "$@"
 
 .PHONY: defconfig-help
diff --git a/Makefile.kernel b/Makefile.kernel
index 1437560..495c1c3 100644
--- a/Makefile.kernel
+++ b/Makefile.kernel
@@ -38,9 +38,7 @@ obj-y += compat/
 
 obj-$(CPTCFG_CFG80211) += net/wireless/
 obj-$(CPTCFG_MAC80211) += net/mac80211/
-obj-$(CPTCFG_QRTR) += net/qrtr/
 obj-$(CPTCFG_QCOM_QMI_HELPERS) += drivers/soc/qcom/
-obj-$(CPTCFG_MHI_BUS) += drivers/bus/mhi/
 obj-$(CPTCFG_WLAN) += drivers/net/wireless/
 obj-$(CPTCFG_USB_NET_RNDIS_WLAN) += drivers/net/usb/
 
diff --git a/Makefile.real b/Makefile.real
index 6550802..971a543 100644
--- a/Makefile.real
+++ b/Makefile.real
@@ -6,6 +6,18 @@ else
 export BACKPORTS_GIT_TRACKER_DEF=
 endif
 
+ifneq ($(LLVM),)
+ifneq ($(filter %/,$(LLVM)),)
+LLVM_PREFIX := $(LLVM)
+else ifneq ($(filter -%,$(LLVM)),)
+LLVM_SUFFIX := $(LLVM)
+endif
+
+HOSTCC	= $(LLVM_PREFIX)clang$(LLVM_SUFFIX)
+else
+HOSTCC	= gcc
+endif
+
 # disable built-in rules for this file
 .SUFFIXES:
 
@@ -24,21 +36,21 @@ listnewconfig oldaskconfig oldconfig \
 silentoldconfig olddefconfig oldnoconfig \
 allnoconfig allyesconfig allmodconfig \
 alldefconfig randconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --$@ Kconfig
 
 .PHONY: usedefconfig
 usedefconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --defconfig=defconfig Kconfig
 
 .PHONY: savedefconfig
 savedefconfig:
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --savedefconfig=defconfig Kconfig
 
 defconfig-%::
-	@$(MAKE) -C kconf conf
+	@$(MAKE) -C kconf CC=$(HOSTCC) conf
 	@./kconf/conf --defconfig=defconfigs/$(@:defconfig-%=%) Kconfig
 
 .config:
@@ -59,7 +71,7 @@ defconfig-%::
 
 backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 	@$(MAKE) oldconfig
-	@echo -n "Building backport-include/backport/autoconf.h ..."
+	@printf "Building backport-include/backport/autoconf.h ..."
 	@grep -f local-symbols .config | (				\
 		echo "#ifndef COMPAT_AUTOCONF_INCLUDED"			;\
 		echo "#define COMPAT_AUTOCONF_INCLUDED"			;\
@@ -80,7 +92,12 @@ backport-include/backport/autoconf.h: .config Kconfig.versions Kconfig.kernel
 			esac						;\
 		done							;\
 		echo "#endif /* COMPAT_AUTOCONF_INCLUDED */"		;\
-	) > backport-include/backport/autoconf.h
+	) > $@.new
+	@if cmp -s $@ $@.new; then \
+		rm -f $@.new; \
+	else \
+		mv $@.new $@; \
+	fi
 	@echo " done."
 
 .PHONY: modules
diff --git a/backport-include/asm/unaligned.h b/backport-include/asm/unaligned.h
index 4e2a6a4..8a7c8ef 100644
--- a/backport-include/asm/unaligned.h
+++ b/backport-include/asm/unaligned.h
@@ -1,6 +1,10 @@
 #ifndef __BACKPORT_ASM_GENERIC_UNALIGNED_H
 #define __BACKPORT_ASM_GENERIC_UNALIGNED_H
+#if LINUX_VERSION_IS_GEQ(6,12,0)
+#include_next <linux/unaligned.h>
+#else
 #include_next <asm/unaligned.h>
+#endif
 
 #if LINUX_VERSION_IS_LESS(5,7,0)
 static inline u32 __get_unaligned_be24(const u8 *p)
diff --git a/backport-include/linux/compiler_attributes.h b/backport-include/linux/compiler_attributes.h
index 22787b6..31ddc16 100644
--- a/backport-include/linux/compiler_attributes.h
+++ b/backport-include/linux/compiler_attributes.h
@@ -31,19 +31,4 @@
 #endif
 #endif /* fallthrough */
 
-#ifndef __counted_by
-/*
- * Optional: only supported since gcc >= 14
- * Optional: only supported since clang >= 17
- *
- *   gcc: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108896
- * clang: https://reviews.llvm.org/D148381
- */
-#if __has_attribute(__element_count__)
-# define __counted_by(member)		__attribute__((__element_count__(#member)))
-#else
-# define __counted_by(member)
-#endif
-#endif
-
 #endif /* _BACKPORTS_LINUX_COMPILER_ATTRIBUTES_H */
diff --git a/backport-include/linux/compiler_types.h b/backport-include/linux/compiler_types.h
new file mode 100644
index 0000000..c9bb6c6
--- /dev/null
+++ b/backport-include/linux/compiler_types.h
@@ -0,0 +1,23 @@
+#ifndef _BACKPORTS_LINUX_COMPILER_TYPES_H
+#define _BACKPORTS_LINUX_COMPILER_TYPES_H 1
+
+#if LINUX_VERSION_IS_GEQ(6,12,1)
+#include_next <linux/compiler_types.h>
+#endif
+
+#ifndef __counted_by
+/*
+ * Optional: only supported since gcc >= 14
+ * Optional: only supported since clang >= 17
+ *
+ *   gcc: https://gcc.gnu.org/bugzilla/show_bug.cgi?id=108896
+ * clang: https://reviews.llvm.org/D148381
+ */
+#if __has_attribute(__element_count__)
+# define __counted_by(member)		__attribute__((__element_count__(#member)))
+#else
+# define __counted_by(member)
+#endif
+#endif
+
+#endif /* _BACKPORTS_LINUX_COMPILER_TYPES_H */
diff --git a/backport-include/net/genetlink.h b/backport-include/net/genetlink.h
index c3f05fc..02f9dc0 100644
--- a/backport-include/net/genetlink.h
+++ b/backport-include/net/genetlink.h
@@ -192,4 +192,15 @@ int backport_genlmsg_multicast_allns(const struct genl_family *family,
 #define genlmsg_multicast_allns LINUX_BACKPORT(genlmsg_multicast_allns)
 #endif /* LINUX_VERSION_IS_LESS(5,2,0) */
 
+#if LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) || \
+    LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) || \
+    LINUX_VERSION_IN_RANGE(6,6,0,6,6,58)
+#define genlmsg_multicast_allns LINUX_BACKPORT(genlmsg_multicast_allns)
+int backport_genlmsg_multicast_allns(const struct genl_family *family,
+				     struct sk_buff *skb, u32 portid,
+				     unsigned int group);
+#endif /* LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) ||
+	  LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) ||
+	  LINUX_VERSION_IN_RANGE(6,6,0,6,6,58) */
+
 #endif /* __BACKPORT_NET_GENETLINK_H */
diff --git a/compat/Makefile b/compat/Makefile
index c705150..06fa855 100644
--- a/compat/Makefile
+++ b/compat/Makefile
@@ -16,7 +16,8 @@ compat-$(CPTCFG_KERNEL_5_9) += backport-5.9.o
 compat-$(CPTCFG_KERNEL_5_10) += backport-5.10.o
 compat-$(CPTCFG_KERNEL_5_11) += backport-5.11.o
 compat-$(CPTCFG_KERNEL_5_13) += backport-5.13.o
-compat-$(CPTCFG_KERNEL_5_15) += backport-5.15.o
+compat-$(CPTCFG_KERNEL_5_15) += backport-5.15.o backport-genetlink.o
+compat-$(CPTCFG_KERNEL_6_1) += backport-genetlink.o
 compat-$(CPTCFG_KERNEL_6_4) += backport-6.4.o
 compat-$(CPTCFG_KERNEL_6_11) += backport-6.11.o
 
diff --git a/compat/backport-genetlink.c b/compat/backport-genetlink.c
index a630e2a..57a5c36 100644
--- a/compat/backport-genetlink.c
+++ b/compat/backport-genetlink.c
@@ -17,6 +17,7 @@
 #include <net/netlink.h>
 #include <net/sock.h>
 
+#if LINUX_VERSION_IS_LESS(5,2,0)
 static const struct genl_family *find_family_real_ops(const struct genl_ops **ops)
 {
 	const struct genl_family *family;
@@ -249,3 +250,63 @@ int backport_genlmsg_multicast_allns(const struct genl_family *family,
 	return genlmsg_mcast(skb, portid, group);
 }
 EXPORT_SYMBOL_GPL(backport_genlmsg_multicast_allns);
+#endif /* LINUX_VERSION_IS_LESS(5,2,0) */
+
+#if LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) || \
+    LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) || \
+    LINUX_VERSION_IN_RANGE(6,6,0,6,6,58)
+static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group)
+{
+	struct sk_buff *tmp;
+	struct net *net, *prev = NULL;
+	bool delivered = false;
+	int err;
+
+	rcu_read_lock();
+	for_each_net_rcu(net) {
+		if (prev) {
+			tmp = skb_clone(skb, GFP_ATOMIC);
+			if (!tmp) {
+				err = -ENOMEM;
+				goto error;
+			}
+			err = nlmsg_multicast(prev->genl_sock, tmp,
+					      portid, group, GFP_ATOMIC);
+			if (!err)
+				delivered = true;
+			else if (err != -ESRCH)
+				goto error;
+		}
+
+		prev = net;
+	}
+	err = nlmsg_multicast(prev->genl_sock, skb, portid, group, GFP_ATOMIC);
+
+	rcu_read_unlock();
+
+	if (!err)
+		delivered = true;
+	else if (err != -ESRCH)
+		return err;
+	return delivered ? 0 : -ESRCH;
+ error:
+	rcu_read_unlock();
+
+	kfree_skb(skb);
+	return err;
+}
+
+int backport_genlmsg_multicast_allns(const struct genl_family *family,
+				     struct sk_buff *skb, u32 portid,
+				     unsigned int group)
+{
+	if (WARN_ON_ONCE(group >= family->n_mcgrps))
+		return -EINVAL;
+
+	group = family->mcgrp_offset + group;
+	return genlmsg_mcast(skb, portid, group);
+}
+EXPORT_SYMBOL_GPL(backport_genlmsg_multicast_allns);
+#endif /* LINUX_VERSION_IN_RANGE(5,15,0,5,15,169) ||
+	  LINUX_VERSION_IN_RANGE(6,1,0,6,1,115) ||
+	  LINUX_VERSION_IN_RANGE(6,6,0,6,6,58) */
diff --git a/compat/main.c b/compat/main.c
index d4f3340..651ab63 100644
--- a/compat/main.c
+++ b/compat/main.c
@@ -19,31 +19,6 @@ MODULE_LICENSE("GPL");
 #error "You need a CPTCFG_VERSION"
 #endif
 
-static char *backported_kernel_name = CPTCFG_KERNEL_NAME;
-
-module_param(backported_kernel_name, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_name,
-		 "The kernel tree name that was used for this backport (" CPTCFG_KERNEL_NAME ")");
-
-#ifdef BACKPORTS_GIT_TRACKED
-static char *backports_tracker_id = BACKPORTS_GIT_TRACKED;
-module_param(backports_tracker_id, charp, 0400);
-MODULE_PARM_DESC(backports_tracker_id,
-		 "The version of the tree containing this backport (" BACKPORTS_GIT_TRACKED ")");
-#else
-static char *backported_kernel_version = CPTCFG_KERNEL_VERSION;
-static char *backports_version = CPTCFG_VERSION;
-
-module_param(backported_kernel_version, charp, 0400);
-MODULE_PARM_DESC(backported_kernel_version,
-		 "The kernel version that was used for this backport (" CPTCFG_KERNEL_VERSION ")");
-
-module_param(backports_version, charp, 0400);
-MODULE_PARM_DESC(backports_version,
-		 "The git version of the backports tree used to generate this backport (" CPTCFG_VERSION ")");
-
-#endif
-
 void backport_dependency_symbol(void)
 {
 }
diff --git a/compat_version b/compat_version
new file mode 100644
index 0000000..a8f83ad
--- /dev/null
+++ b/compat_version
@@ -0,0 +1 @@
+compat-wireless-6.18-1-v25.12.0-rc1
diff --git a/drivers/bus/mhi/host/trace.h b/drivers/bus/mhi/host/trace.h
index 3e0c417..059ed3c 100644
--- a/drivers/bus/mhi/host/trace.h
+++ b/drivers/bus/mhi/host/trace.h
@@ -104,7 +104,11 @@ TRACE_EVENT(mhi_gen_tre,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(name);
+#else
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
+#endif
 		__entry->ch_num = mhi_chan->chan;
 		__entry->wp = mhi_tre;
 		__entry->tre_ptr = le64_to_cpu(mhi_tre->ptr);
@@ -132,7 +136,11 @@ TRACE_EVENT(mhi_intvec_states,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(name);
+#else
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
+#endif
 		__entry->local_ee = mhi_cntrl->ee;
 		__entry->state = mhi_cntrl->dev_state;
 		__entry->dev_ee = dev_ee;
@@ -159,7 +167,11 @@ TRACE_EVENT(mhi_tryset_pm_state,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(name);
+#else
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
+#endif
 		if (pm_state)
 			pm_state = __fls(pm_state);
 		__entry->pm_state = pm_state;
@@ -185,7 +197,11 @@ DECLARE_EVENT_CLASS(mhi_process_event_ring,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(name);
+#else
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
+#endif
 		__entry->rp = rp;
 		__entry->ptr = le64_to_cpu(rp->ptr);
 		__entry->dword0 = le32_to_cpu(rp->dword[0]);
@@ -227,7 +243,11 @@ DECLARE_EVENT_CLASS(mhi_update_channel_state,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(name);
+#else
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
+#endif
 		__entry->ch_num = mhi_chan->chan;
 		__entry->state = state;
 		__entry->reason = reason;
@@ -266,7 +286,11 @@ TRACE_EVENT(mhi_pm_st_transition,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(name);
+#else
+		__assign_str(name, mhi_cntrl->mhi_dev->name);
+#endif
 		__entry->state = state;
 	),
 
diff --git a/drivers/net/wireless/ath/Kconfig b/drivers/net/wireless/ath/Kconfig
index 9ef8d46..bd576b4 100644
--- a/drivers/net/wireless/ath/Kconfig
+++ b/drivers/net/wireless/ath/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: ISC
 config ATH_COMMON
-	tristate
+	tristate "ath.ko"
 	depends on m
 
 config WLAN_VENDOR_ATH
@@ -24,6 +24,9 @@ config WLAN_VENDOR_ATH
 
 if WLAN_VENDOR_ATH
 
+config ATH_USER_REGD
+	bool "Do not enforce EEPROM regulatory restrictions"
+
 config ATH_DEBUG
 	bool "Atheros wireless debugging"
 	help
diff --git a/drivers/net/wireless/ath/Makefile b/drivers/net/wireless/ath/Makefile
index 7432d87..adea25c 100644
--- a/drivers/net/wireless/ath/Makefile
+++ b/drivers/net/wireless/ath/Makefile
@@ -16,10 +16,10 @@ ath-objs :=	main.o \
 		regd.o \
 		hw.o \
 		key.o \
+		debug.o \
 		dfs_pattern_detector.o \
 		dfs_pri_detector.o
 
-ath-$(CPTCFG_ATH_DEBUG) += debug.o
 ath-$(CPTCFG_ATH_TRACEPOINTS) += trace.o
 
 CFLAGS_trace.o := -I$(src)
diff --git a/drivers/net/wireless/ath/ath.h b/drivers/net/wireless/ath/ath.h
index 1bfd992..5377a35 100644
--- a/drivers/net/wireless/ath/ath.h
+++ b/drivers/net/wireless/ath/ath.h
@@ -151,6 +151,7 @@ struct ath_common {
 	int debug_mask;
 	enum ath_device_state state;
 	unsigned long op_flags;
+	u32 chan_bw;
 
 	struct ath_ani ani;
 
@@ -181,6 +182,7 @@ struct ath_common {
 	const struct ath_ops *ops;
 	const struct ath_bus_ops *bus_ops;
 	const struct ath_ps_ops *ps_ops;
+	const struct ieee80211_ops *ieee_ops;
 
 	bool btcoex_enabled;
 	bool disable_ani;
@@ -321,14 +323,7 @@ void _ath_dbg(struct ath_common *common, enum ATH_DEBUG dbg_mask,
 #endif /* CPTCFG_ATH_DEBUG */
 
 /** Returns string describing opmode, or NULL if unknown mode. */
-#ifdef CPTCFG_ATH_DEBUG
 const char *ath_opmode_to_string(enum nl80211_iftype opmode);
-#else
-static inline const char *ath_opmode_to_string(enum nl80211_iftype opmode)
-{
-	return "UNKNOWN";
-}
-#endif
 
 extern const char *ath_bus_type_strings[];
 static inline const char *ath_bus_type_to_string(enum ath_bus_type bustype)
diff --git a/drivers/net/wireless/ath/ath10k/Kconfig b/drivers/net/wireless/ath/ath10k/Kconfig
index 57c3be9..d8f919c 100644
--- a/drivers/net/wireless/ath/ath10k/Kconfig
+++ b/drivers/net/wireless/ath/ath10k/Kconfig
@@ -94,6 +94,12 @@ config ATH10K_TRACING
 	help
 	  Select this to ath10k use tracing infrastructure.
 
+config ATH10K_THERMAL
+	bool "Atheros ath10k thermal monitoring support"
+	depends on THERMAL
+	---help---
+	  Select this to ath10k use hwmon for thermal measurement.
+
 config ATH10K_DFS_CERTIFIED
 	bool "Atheros DFS support for certified platforms"
 	depends on ATH10K && CFG80211_CERTIFICATION_ONUS
diff --git a/drivers/net/wireless/ath/ath10k/Makefile b/drivers/net/wireless/ath/ath10k/Makefile
index 6bc1261..e040d84 100644
--- a/drivers/net/wireless/ath/ath10k/Makefile
+++ b/drivers/net/wireless/ath/ath10k/Makefile
@@ -18,7 +18,7 @@ ath10k_core-y += mac.o \
 ath10k_core-$(CPTCFG_ATH10K_SPECTRAL) += spectral.o
 ath10k_core-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath10k_core-$(CPTCFG_ATH10K_TRACING) += trace.o
-ath10k_core-$(CONFIG_THERMAL) += thermal.o
+ath10k_core-$(CPTCFG_ATH10K_THERMAL) += thermal.o
 ath10k_core-$(CPTCFG_ATH10K_LEDS) += leds.o
 ath10k_core-$(CPTCFG_MAC80211_DEBUGFS) += debugfs_sta.o
 ath10k_core-$(CONFIG_PM) += wow.o
diff --git a/drivers/net/wireless/ath/ath10k/core.c b/drivers/net/wireless/ath/ath10k/core.c
index 6f78f17..ec31787 100644
--- a/drivers/net/wireless/ath/ath10k/core.c
+++ b/drivers/net/wireless/ath/ath10k/core.c
@@ -11,6 +11,7 @@
 #include <linux/module.h>
 #include <linux/firmware.h>
 #include <linux/of.h>
+#include <linux/of_net.h>
 #include <linux/property.h>
 #include <linux/dmi.h>
 #include <linux/ctype.h>
@@ -3458,6 +3459,8 @@ static int ath10k_core_probe_fw(struct ath10k *ar)
 
 	device_get_mac_address(ar->dev, ar->mac_addr);
 
+	of_get_mac_address(ar->dev->of_node, ar->mac_addr);
+
 	ret = ath10k_core_init_firmware_features(ar);
 	if (ret) {
 		ath10k_err(ar, "fatal problem with firmware features: %d\n",
@@ -3586,6 +3589,16 @@ int ath10k_core_register(struct ath10k *ar,
 
 	queue_work(ar->workqueue, &ar->register_work);
 
+	/* OpenWrt requires all PHYs to be initialized to create the
+	 * configuration files during bootup. ath10k violates this
+	 * because it delays the creation of the PHY to a not well defined
+	 * point in the future.
+	 *
+	 * Forcing the work to be done immediately works around this problem
+	 * but may also delay the boot when firmware images cannot be found.
+	 */
+	flush_workqueue(ar->workqueue);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath10k_core_register);
diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h
index 0d33cde..4e6c0b8 100644
--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -1320,6 +1320,10 @@ struct ath10k {
 	s32 tx_power_2g_limit;
 	s32 tx_power_5g_limit;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	const char *led_default_trigger;
+#endif
+
 	/* must be last */
 	u8 drv_priv[] __aligned(sizeof(void *));
 };
diff --git a/drivers/net/wireless/ath/ath10k/htt.h b/drivers/net/wireless/ath/ath10k/htt.h
index 603f6de..bea1d16 100644
--- a/drivers/net/wireless/ath/ath10k/htt.h
+++ b/drivers/net/wireless/ath/ath10k/htt.h
@@ -236,7 +236,11 @@ enum htt_rx_ring_flags {
 };
 
 #define HTT_RX_RING_SIZE_MIN 128
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 #define HTT_RX_RING_SIZE_MAX 2048
+#else
+#define HTT_RX_RING_SIZE_MAX 512
+#endif
 #define HTT_RX_RING_SIZE HTT_RX_RING_SIZE_MAX
 #define HTT_RX_RING_FILL_LEVEL (((HTT_RX_RING_SIZE) / 2) - 1)
 #define HTT_RX_RING_FILL_LEVEL_DUAL_MAC (HTT_RX_RING_SIZE - 1)
diff --git a/drivers/net/wireless/ath/ath10k/leds.c b/drivers/net/wireless/ath/ath10k/leds.c
index 3a6c811..98a403a 100644
--- a/drivers/net/wireless/ath/ath10k/leds.c
+++ b/drivers/net/wireless/ath/ath10k/leds.c
@@ -69,7 +69,7 @@ int ath10k_leds_register(struct ath10k *ar)
 
 	ar->leds.cdev.name = ar->leds.label;
 	ar->leds.cdev.brightness_set_blocking = ath10k_leds_set_brightness_blocking;
-	ar->leds.cdev.default_trigger = ar->leds.wifi_led.default_trigger;
+	ar->leds.cdev.default_trigger = ar->led_default_trigger;
 
 	ret = led_classdev_register(wiphy_dev(ar->hw->wiphy), &ar->leds.cdev);
 	if (ret)
diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c
index 5aea16c..4bf149d 100644
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -1052,6 +1052,40 @@ static inline int ath10k_vdev_delete_sync(struct ath10k *ar)
 	return 0;
 }
 
+static u32 ath10k_get_max_antenna_gain(struct ath10k *ar,
+				       u32 ch_max_antenna_gain)
+{
+	u32 max_antenna_gain;
+
+	if (ar->dfs_detector && ar->dfs_detector->region == NL80211_DFS_FCC) {
+		/* FCC allows maximum antenna gain of 6 dBi. 15.247(b)(4):
+		 *
+		 * > (4) The conducted output power limit
+		 * > specified in paragraph (b) of this section
+		 * > is based on the use of antennas
+		 * > with directional gains that do not exceed
+		 * > 6 dBi. Except as shown in paragraph
+		 * > (c) of this section, if transmitting
+		 * > antennas of directional gain greater
+		 * > than 6 dBi are used, the conducted
+		 * > output power from the intentional radiator
+		 * > shall be reduced below the stated
+		 * > values in paragraphs (b)(1), (b)(2),
+		 * > and (b)(3) of this section, as appropriate,
+		 * > by the amount in dB that the
+		 * > directional gain of the antenna exceeds
+		 * > 6 dBi.
+		 *
+		 * https://www.gpo.gov/fdsys/pkg/CFR-2013-title47-vol1/pdf/CFR-2013-title47-vol1-sec15-247.pdf
+		 */
+		max_antenna_gain = 6;
+	} else {
+		max_antenna_gain = 0;
+	}
+
+	return max(ch_max_antenna_gain, max_antenna_gain);
+}
+
 static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 {
 	struct cfg80211_chan_def *chandef = NULL;
@@ -1084,7 +1118,8 @@ static int ath10k_monitor_vdev_start(struct ath10k *ar, int vdev_id)
 	arg.channel.min_power = 0;
 	arg.channel.max_power = channel->max_power * 2;
 	arg.channel.max_reg_power = channel->max_reg_power * 2;
-	arg.channel.max_antenna_gain = channel->max_antenna_gain;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 
 	reinit_completion(&ar->vdev_setup_done);
 	reinit_completion(&ar->vdev_delete_done);
@@ -1530,7 +1565,8 @@ static int ath10k_vdev_start_restart(struct ath10k_vif *arvif,
 	arg.channel.min_power = 0;
 	arg.channel.max_power = chandef->chan->max_power * 2;
 	arg.channel.max_reg_power = chandef->chan->max_reg_power * 2;
-	arg.channel.max_antenna_gain = chandef->chan->max_antenna_gain;
+	arg.channel.max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+					chandef->chan->max_antenna_gain);
 
 	if (arvif->vdev_type == WMI_VDEV_TYPE_AP) {
 		arg.ssid = arvif->u.ap.ssid;
@@ -3461,7 +3497,8 @@ static int ath10k_update_channel_list(struct ath10k *ar)
 			ch->min_power = 0;
 			ch->max_power = channel->max_power * 2;
 			ch->max_reg_power = channel->max_reg_power * 2;
-			ch->max_antenna_gain = channel->max_antenna_gain;
+			ch->max_antenna_gain = ath10k_get_max_antenna_gain(ar,
+						channel->max_antenna_gain);
 			ch->reg_class_id = 0; /* FIXME */
 
 			/* FIXME: why use only legacy modes, why not any
@@ -8143,6 +8180,20 @@ static void ath10k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 	mutex_unlock(&ar->conf_mutex);
 }
 
+static void ath10k_mac_op_flush_sta(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+			     struct ieee80211_sta *sta)
+{
+	struct ath10k_vif *arvif = (void *)vif->drv_priv;
+	struct ath10k *ar = hw->priv;
+	u32 bitmap = 0xFFFFFFFF;
+	int ret = 0;
+
+	ret = ath10k_wmi_peer_flush(ar, arvif->vdev_id, sta->addr, bitmap);
+	if (ret)
+		ath10k_warn(ar, "failed to flush sta (sta %pM)\n",
+			    sta->addr);
+}
+
 /* TODO: Implement this function properly
  * For now it is needed to reply to Probe Requests in IBSS mode.
  * Probably we need this information from FW.
@@ -9495,6 +9546,7 @@ static const struct ieee80211_ops ath10k_ops = {
 	.set_rts_threshold		= ath10k_set_rts_threshold,
 	.set_frag_threshold		= ath10k_mac_op_set_frag_threshold,
 	.flush				= ath10k_flush,
+	.flush_sta			= ath10k_mac_op_flush_sta,
 	.tx_last_beacon			= ath10k_tx_last_beacon,
 	.set_antenna			= ath10k_set_antenna,
 	.get_antenna			= ath10k_get_antenna,
@@ -9970,6 +10022,21 @@ static int ath10k_mac_init_rd(struct ath10k *ar)
 	return 0;
 }
 
+#ifdef CPTCFG_MAC80211_LEDS
+static const struct ieee80211_tpt_blink ath10k_tpt_blink[] = {
+	{ .throughput = 0 * 1024, .blink_time = 334 },
+	{ .throughput = 1 * 1024, .blink_time = 260 },
+	{ .throughput = 2 * 1024, .blink_time = 220 },
+	{ .throughput = 5 * 1024, .blink_time = 190 },
+	{ .throughput = 10 * 1024, .blink_time = 170 },
+	{ .throughput = 25 * 1024, .blink_time = 150 },
+	{ .throughput = 54 * 1024, .blink_time = 130 },
+	{ .throughput = 120 * 1024, .blink_time = 110 },
+	{ .throughput = 265 * 1024, .blink_time = 80 },
+	{ .throughput = 586 * 1024, .blink_time = 50 },
+};
+#endif
+
 int ath10k_mac_register(struct ath10k *ar)
 {
 	static const u32 cipher_suites[] = {
@@ -10088,7 +10155,6 @@ int ath10k_mac_register(struct ath10k *ar)
 	ieee80211_hw_set(ar->hw, CHANCTX_STA_CSA);
 	ieee80211_hw_set(ar->hw, QUEUE_CONTROL);
 	ieee80211_hw_set(ar->hw, SUPPORTS_TX_FRAG);
-	ieee80211_hw_set(ar->hw, REPORTS_LOW_ACK);
 
 	if (!test_bit(ATH10K_FLAG_RAW_MODE, &ar->dev_flags))
 		ieee80211_hw_set(ar->hw, SW_CRYPTO_CONTROL);
@@ -10302,6 +10368,9 @@ int ath10k_mac_register(struct ath10k *ar)
 	if (!ar->hw_params.hw_ops->set_coverage_class)
 		ar->ops->set_coverage_class = NULL;
 
+	if (ar->htt.disable_tx_comp)
+		ar->ops->flush_sta = NULL;
+
 	ret = ath_regd_init(&ar->ath_common.regulatory, ar->hw->wiphy,
 			    ath10k_reg_notifier);
 	if (ret) {
@@ -10332,6 +10401,12 @@ int ath10k_mac_register(struct ath10k *ar)
 
 	ar->hw->weight_multiplier = ATH10K_AIRTIME_WEIGHT_MULTIPLIER;
 
+#ifdef CPTCFG_MAC80211_LEDS
+	ar->led_default_trigger = ieee80211_create_tpt_led_trigger(ar->hw,
+		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath10k_tpt_blink,
+		ARRAY_SIZE(ath10k_tpt_blink));
+#endif
+
 	ret = ieee80211_register_hw(ar->hw);
 	if (ret) {
 		ath10k_err(ar, "failed to register ieee80211: %d\n", ret);
diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c
index 220fc68..f0b6f7d 100644
--- a/drivers/net/wireless/ath/ath10k/pci.c
+++ b/drivers/net/wireless/ath/ath10k/pci.c
@@ -133,7 +133,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 512,
+#else
+		.dest_nentries = 128,
+#endif
 		.recv_cb = ath10k_pci_htt_htc_rx_cb,
 	},
 
@@ -142,7 +146,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 128,
+#else
+		.dest_nentries = 64,
+#endif
 		.recv_cb = ath10k_pci_htc_rx_cb,
 	},
 
@@ -169,7 +177,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 512,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 512,
+#else
+		.dest_nentries = 128,
+#endif
 		.recv_cb = ath10k_pci_htt_rx_cb,
 	},
 
@@ -194,7 +206,11 @@ static const struct ce_attr pci_host_ce_config_wlan[] = {
 		.flags = CE_ATTR_FLAGS,
 		.src_nentries = 0,
 		.src_sz_max = 2048,
+#ifndef CONFIG_ATH10K_SMALLBUFFERS
 		.dest_nentries = 128,
+#else
+		.dest_nentries = 96,
+#endif
 		.recv_cb = ath10k_pci_pktlog_rx_cb,
 	},
 
diff --git a/drivers/net/wireless/ath/ath10k/snoc.c b/drivers/net/wireless/ath/ath10k/snoc.c
index 3b276eb..f595b9a 100644
--- a/drivers/net/wireless/ath/ath10k/snoc.c
+++ b/drivers/net/wireless/ath/ath10k/snoc.c
@@ -1630,10 +1630,10 @@ static int ath10k_fw_init(struct ath10k *ar)
 
 	ar_snoc->fw.dev = &pdev->dev;
 
-	iommu_dom = iommu_paging_domain_alloc(ar_snoc->fw.dev);
-	if (IS_ERR(iommu_dom)) {
+	iommu_dom = iommu_domain_alloc(&platform_bus_type);
+	if (!iommu_dom) {
 		ath10k_err(ar, "failed to allocate iommu domain\n");
-		ret = PTR_ERR(iommu_dom);
+		ret = -ENOMEM;
 		goto err_unregister;
 	}
 
diff --git a/drivers/net/wireless/ath/ath10k/thermal.h b/drivers/net/wireless/ath/ath10k/thermal.h
index 1f4de9f..fcfa3c2 100644
--- a/drivers/net/wireless/ath/ath10k/thermal.h
+++ b/drivers/net/wireless/ath/ath10k/thermal.h
@@ -25,7 +25,7 @@ struct ath10k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH10K_THERMAL)
 int ath10k_thermal_register(struct ath10k *ar);
 void ath10k_thermal_unregister(struct ath10k *ar);
 void ath10k_thermal_event_temperature(struct ath10k *ar, int temperature);
diff --git a/drivers/net/wireless/ath/ath10k/trace.h b/drivers/net/wireless/ath/ath10k/trace.h
index db8fcbe..7b3f488 100644
--- a/drivers/net/wireless/ath/ath10k/trace.h
+++ b/drivers/net/wireless/ath/ath10k/trace.h
@@ -55,8 +55,13 @@ DECLARE_EVENT_CLASS(ath10k_log_event,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk(
@@ -92,8 +97,13 @@ TRACE_EVENT(ath10k_log_dbg,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->level = level;
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
@@ -121,10 +131,17 @@ TRACE_EVENT(ath10k_log_dbg_dump,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
 		__assign_str(msg);
 		__assign_str(prefix);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+		__assign_str(msg, msg);
+		__assign_str(prefix, prefix);
+#endif
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
@@ -152,8 +169,13 @@ TRACE_EVENT(ath10k_wmi_cmd,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -182,8 +204,13 @@ TRACE_EVENT(ath10k_wmi_event,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -211,8 +238,13 @@ TRACE_EVENT(ath10k_htt_stats,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
@@ -239,8 +271,13 @@ TRACE_EVENT(ath10k_wmi_dbglog,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->hw_type = ar->hw_rev;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -269,8 +306,13 @@ TRACE_EVENT(ath10k_htt_pktlog,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->hw_type = ar->hw_rev;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
@@ -301,8 +343,13 @@ TRACE_EVENT(ath10k_htt_tx,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->msdu_id = msdu_id;
 		__entry->msdu_len = msdu_len;
 		__entry->vdev_id = vdev_id;
@@ -332,8 +379,13 @@ TRACE_EVENT(ath10k_txrx_tx_unref,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->msdu_id = msdu_id;
 	),
 
@@ -358,8 +410,13 @@ DECLARE_EVENT_CLASS(ath10k_hdr_event,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->len = ath10k_frm_hdr_len(data, len);
 		memcpy(__get_dynamic_array(data), data, __entry->len);
 	),
@@ -386,8 +443,13 @@ DECLARE_EVENT_CLASS(ath10k_payload_event,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->len = len - ath10k_frm_hdr_len(data, len);
 		memcpy(__get_dynamic_array(payload),
 		       data + ath10k_frm_hdr_len(data, len), __entry->len);
@@ -435,8 +497,13 @@ TRACE_EVENT(ath10k_htt_rx_desc,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->hw_type = ar->hw_rev;
 		__entry->len = len;
 		memcpy(__get_dynamic_array(rxdesc), data, len);
@@ -472,8 +539,13 @@ TRACE_EVENT(ath10k_wmi_diag_container,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->type = type;
 		__entry->timestamp = timestamp;
 		__entry->code = code;
@@ -505,8 +577,13 @@ TRACE_EVENT(ath10k_wmi_diag,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->dev));
+		__assign_str(driver, dev_driver_string(ar->dev));
+#endif
 		__entry->len = len;
 		memcpy(__get_dynamic_array(data), data, len);
 	),
diff --git a/drivers/net/wireless/ath/ath11k/Kconfig b/drivers/net/wireless/ath/ath11k/Kconfig
index f8e2af0..f50a905 100644
--- a/drivers/net/wireless/ath/ath11k/Kconfig
+++ b/drivers/net/wireless/ath/ath11k/Kconfig
@@ -25,9 +25,9 @@ config ATH11K_PCI
 	tristate "Atheros ath11k PCI support"
 	depends on m
 	depends on ATH11K && PCI
-	select MHI_BUS
-	select QRTR
-	select QRTR_MHI
+	depends on MHI_BUS
+	depends on QRTR
+	depends on QRTR_MHI
 	select PCI_PWRCTRL_PWRSEQ if HAVE_PWRCTRL
 	help
 	  This module adds support for PCIE bus
@@ -62,3 +62,10 @@ config ATH11K_SPECTRAL
 	  Enable ath11k spectral scan support
 
 	  Say Y to enable access to the FFT/spectral data via debugfs.
+
+config ATH11K_THERMAL
+	bool "ath11k thermal sensors and throttling support"
+	depends on ATH11K
+	depends on THERMAL
+	help
+	  Enable ath11k thermal sensors and throttling support.
diff --git a/drivers/net/wireless/ath/ath11k/Makefile b/drivers/net/wireless/ath/ath11k/Makefile
index 8f288ec..78d9822 100644
--- a/drivers/net/wireless/ath/ath11k/Makefile
+++ b/drivers/net/wireless/ath/ath11k/Makefile
@@ -24,7 +24,7 @@ ath11k-y += core.o \
 ath11k-$(CPTCFG_ATH11K_DEBUGFS) += debugfs.o debugfs_htt_stats.o debugfs_sta.o
 ath11k-$(CPTCFG_NL80211_TESTMODE) += testmode.o
 ath11k-$(CPTCFG_ATH11K_TRACING) += trace.o
-ath11k-$(CONFIG_THERMAL) += thermal.o
+ath11k-$(CPTCFG_ATH11K_THERMAL) += thermal.o
 ath11k-$(CPTCFG_ATH11K_SPECTRAL) += spectral.o
 ath11k-$(CONFIG_PM) += wow.o
 ath11k-$(CONFIG_DEV_COREDUMP) += coredump.o
diff --git a/drivers/net/wireless/ath/ath11k/ahb.c b/drivers/net/wireless/ath/ath11k/ahb.c
index 0fd6950..a97d8b8 100644
--- a/drivers/net/wireless/ath/ath11k/ahb.c
+++ b/drivers/net/wireless/ath/ath11k/ahb.c
@@ -37,6 +37,9 @@ static const struct of_device_id ath11k_ahb_of_match[] = {
 	{ .compatible = "qcom,ipq5018-wifi",
 	  .data = (void *)ATH11K_HW_IPQ5018_HW10,
 	},
+	{ .compatible = "qcom,qcn6122-wifi",
+	  .data = (void *)ATH11K_HW_QCN6122_HW10,
+	},
 	{ }
 };
 
@@ -198,12 +201,18 @@ static const struct ath11k_pci_ops ath11k_ahb_pci_ops_wcn6750 = {
 
 static inline u32 ath11k_ahb_read32(struct ath11k_base *ab, u32 offset)
 {
-	return ioread32(ab->mem + offset);
+	if ((offset & ATH11K_REG_TYPE_MASK) == ATH11K_REG_TYPE_CE)
+		return ioread32(ab->mem_ce + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
+	else
+		return ioread32(ab->mem + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
 }
 
 static inline void ath11k_ahb_write32(struct ath11k_base *ab, u32 offset, u32 value)
 {
-	iowrite32(value, ab->mem + offset);
+	if ((offset & ATH11K_REG_TYPE_MASK) == ATH11K_REG_TYPE_CE)
+		iowrite32(value, ab->mem_ce + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
+	else
+		iowrite32(value, ab->mem + FIELD_GET(ATH11K_REG_OFFSET_MASK, offset));
 }
 
 static void ath11k_ahb_kill_tasklets(struct ath11k_base *ab)
@@ -275,9 +284,9 @@ static void ath11k_ahb_ce_irq_enable(struct ath11k_base *ab, u16 ce_id)
 	const struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;
 	u32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;
 
-	ie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);
-	ie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);
-	ie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);
+	ie1_reg_addr = ce_ie_addr->ie1_reg_addr;
+	ie2_reg_addr = ce_ie_addr->ie2_reg_addr;
+	ie3_reg_addr = ce_ie_addr->ie3_reg_addr;
 
 	ce_attr = &ab->hw_params.host_ce_config[ce_id];
 	if (ce_attr->src_nentries)
@@ -296,9 +305,9 @@ static void ath11k_ahb_ce_irq_disable(struct ath11k_base *ab, u16 ce_id)
 	const struct ce_ie_addr *ce_ie_addr = ab->hw_params.ce_ie_addr;
 	u32 ie1_reg_addr, ie2_reg_addr, ie3_reg_addr;
 
-	ie1_reg_addr = ce_ie_addr->ie1_reg_addr + ATH11K_CE_OFFSET(ab);
-	ie2_reg_addr = ce_ie_addr->ie2_reg_addr + ATH11K_CE_OFFSET(ab);
-	ie3_reg_addr = ce_ie_addr->ie3_reg_addr + ATH11K_CE_OFFSET(ab);
+	ie1_reg_addr = ce_ie_addr->ie1_reg_addr;
+	ie2_reg_addr = ce_ie_addr->ie2_reg_addr;
+	ie3_reg_addr = ce_ie_addr->ie3_reg_addr;
 
 	ce_attr = &ab->hw_params.host_ce_config[ce_id];
 	if (ce_attr->src_nentries)
@@ -429,6 +438,7 @@ static void ath11k_ahb_init_qmi_ce_config(struct ath11k_base *ab)
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+	ab->qmi.service_ins_id += ab->userpd_id;
 }
 
 static void ath11k_ahb_free_ext_irq(struct ath11k_base *ab)
@@ -762,6 +772,18 @@ static int ath11k_ahb_hif_resume(struct ath11k_base *ab)
 	return 0;
 }
 
+static void ath11k_ahb_config_static_window_qcn6122(struct ath11k_base *ab)
+{
+	u32 umac_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_SEQ_WCSS_UMAC_OFFSET);
+	u32 ce_window = FIELD_GET(ATH11K_PCI_WINDOW_VALUE_MASK, HAL_CE_WFSS_CE_REG_BASE);
+	u32 window;
+
+	window = (umac_window) | (ce_window << 6);
+
+	iowrite32(ATH11K_PCI_WINDOW_ENABLE_BIT | window,
+		  ab->mem + ATH11K_PCI_WINDOW_REG_ADDRESS);
+}
+
 static const struct ath11k_hif_ops ath11k_ahb_hif_ops_ipq8074 = {
 	.start = ath11k_ahb_start,
 	.stop = ath11k_ahb_stop,
@@ -794,6 +816,24 @@ static const struct ath11k_hif_ops ath11k_ahb_hif_ops_wcn6750 = {
 	.ce_irq_disable = ath11k_pci_disable_ce_irqs_except_wake_irq,
 };
 
+static const struct ath11k_hif_ops ath11k_ahb_hif_ops_qcn6122 = {
+	.start = ath11k_pcic_start,
+	.stop = ath11k_pcic_stop,
+	.read32 = ath11k_pcic_read32,
+	.write32 = ath11k_pcic_write32,
+	.read = NULL,
+	.irq_enable = ath11k_pcic_ext_irq_enable,
+	.irq_disable = ath11k_pcic_ext_irq_disable,
+	.get_msi_address =  ath11k_pcic_get_msi_address,
+	.get_user_msi_vector = ath11k_pcic_get_user_msi_assignment,
+	.map_service_to_pipe = ath11k_pcic_map_service_to_pipe,
+	.power_down = ath11k_ahb_power_down,
+	.power_up = ath11k_ahb_power_up,
+	.ce_irq_enable = ath11k_pci_enable_ce_irqs_except_wake_irq,
+	.ce_irq_disable = ath11k_pci_disable_ce_irqs_except_wake_irq,
+	.config_static_window = ath11k_ahb_config_static_window_qcn6122,
+};
+
 static int ath11k_core_get_rproc(struct ath11k_base *ab)
 {
 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
@@ -1020,10 +1060,10 @@ static int ath11k_ahb_fw_resources_init(struct ath11k_base *ab)
 
 	ab_ahb->fw.dev = &pdev->dev;
 
-	iommu_dom = iommu_paging_domain_alloc(ab_ahb->fw.dev);
-	if (IS_ERR(iommu_dom)) {
+	iommu_dom = iommu_domain_alloc(&platform_bus_type);
+	if (!iommu_dom) {
 		ath11k_err(ab, "failed to allocate iommu domain\n");
-		ret = PTR_ERR(iommu_dom);
+		ret = -ENOMEM;
 		goto err_unregister;
 	}
 
@@ -1071,6 +1111,27 @@ err_unregister:
 	return ret;
 }
 
+static int ath11k_get_userpd_id(struct device *dev)
+{
+	int ret;
+	int userpd_id = 0;
+	const char *subsys_name;
+
+	ret = of_property_read_string(dev->of_node,
+				      "qcom,userpd-subsys-name",
+				      &subsys_name);
+	if (ret) 
+		return 0;
+
+	if (strcmp(subsys_name, "q6v5_wcss_userpd2") == 0)
+		userpd_id = ATH11K_QCN6122_USERPD_2;
+	else if (strcmp(subsys_name, "q6v5_wcss_userpd3") == 0)
+		userpd_id = ATH11K_QCN6122_USERPD_3;
+	dev_info(dev, "Multipd architecture - userpd: %d\n", userpd_id + 1);
+
+	return userpd_id;
+}
+
 static int ath11k_ahb_fw_resource_deinit(struct ath11k_base *ab)
 {
 	struct ath11k_ahb *ab_ahb = ath11k_ahb_priv(ab);
@@ -1112,7 +1173,7 @@ static int ath11k_ahb_probe(struct platform_device *pdev)
 	const struct ath11k_hif_ops *hif_ops;
 	const struct ath11k_pci_ops *pci_ops;
 	enum ath11k_hw_rev hw_rev;
-	int ret;
+	int ret, userpd_id;
 
 	hw_rev = (uintptr_t)device_get_match_data(&pdev->dev);
 
@@ -1127,11 +1188,16 @@ static int ath11k_ahb_probe(struct platform_device *pdev)
 		hif_ops = &ath11k_ahb_hif_ops_wcn6750;
 		pci_ops = &ath11k_ahb_pci_ops_wcn6750;
 		break;
+	case ATH11K_HW_QCN6122_HW10:
+		hif_ops = &ath11k_ahb_hif_ops_qcn6122;
+		pci_ops = &ath11k_ahb_pci_ops_wcn6750;
+		break;
 	default:
 		dev_err(&pdev->dev, "unsupported device type %d\n", hw_rev);
 		return -EOPNOTSUPP;
 	}
 
+	userpd_id = ath11k_get_userpd_id(&pdev->dev);
 	ret = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(32));
 	if (ret) {
 		dev_err(&pdev->dev, "failed to set 32-bit consistent dma\n");
@@ -1148,6 +1214,7 @@ static int ath11k_ahb_probe(struct platform_device *pdev)
 	ab->hif.ops = hif_ops;
 	ab->pdev = pdev;
 	ab->hw_rev = hw_rev;
+	ab->userpd_id = userpd_id;
 	ab->fw_mode = ATH11K_FIRMWARE_MODE_NORMAL;
 	platform_set_drvdata(pdev, ab);
 
diff --git a/drivers/net/wireless/ath/ath11k/core.c b/drivers/net/wireless/ath/ath11k/core.c
index 8126861..82bf7ae 100644
--- a/drivers/net/wireless/ath/ath11k/core.c
+++ b/drivers/net/wireless/ath/ath11k/core.c
@@ -39,7 +39,7 @@ bool ath11k_ftm_mode;
 module_param_named(ftm_mode, ath11k_ftm_mode, bool, 0444);
 MODULE_PARM_DESC(ftm_mode, "Boots up in factory test mode");
 
-static const struct ath11k_hw_params ath11k_hw_params[] = {
+static struct ath11k_hw_params ath11k_hw_params[] = {
 	{
 		.hw_rev = ATH11K_HW_IPQ8074,
 		.name = "ipq8074 hw2.0",
@@ -173,8 +173,8 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.supports_shadow_regs = false,
 		.idle_ps = false,
 		.supports_sta_ps = false,
-		.coldboot_cal_mm = true,
-		.coldboot_cal_ftm = true,
+		.coldboot_cal_mm = false,
+		.coldboot_cal_ftm = false,
 		.cbcal_restart_fw = true,
 		.fw_mem_mode = 0,
 		.num_vdevs = 16 + 1,
@@ -700,8 +700,8 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.supports_suspend = false,
 		.hal_params = &ath11k_hw_hal_params_ipq8074,
 		.single_pdev_only = false,
-		.coldboot_cal_mm = true,
-		.coldboot_cal_ftm = true,
+		.coldboot_cal_mm = false,
+		.coldboot_cal_ftm = false,
 		.cbcal_restart_fw = true,
 		.fix_l1ss = true,
 		.supports_dynamic_smps_6ghz = false,
@@ -729,6 +729,7 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.support_fw_mac_sequence = false,
 		.support_dual_stations = false,
 		.pdev_suspend = false,
+		.reo_status_poll = true,
 	},
 	{
 		.name = "qca2066 hw2.1",
@@ -907,6 +908,69 @@ static const struct ath11k_hw_params ath11k_hw_params[] = {
 		.support_dual_stations = true,
 		.pdev_suspend = false,
 	},
+	{
+		.hw_rev = ATH11K_HW_QCN6122_HW10,
+		.name = "qcn6122 hw1.0",
+		.fw = {
+			.dir = "QCN6122/hw1.0",
+			.board_size = 256 * 1024,
+			.cal_offset = 128 * 1024,
+		},
+		.hal_params = &ath11k_hw_hal_params_ipq8074,
+		.max_radios = MAX_RADIOS_5018,
+		.bdf_addr = 0x4D200000,
+		.hw_ops = &ipq5018_ops,
+		.ring_mask = &ath11k_hw_ring_mask_qcn6122,
+		.hal_desc_sz = sizeof(struct hal_rx_desc_qcn9074),
+		.regs = &qcn6122_regs,
+		.qmi_service_ins_id = ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122,
+		.interface_modes = BIT(NL80211_IFTYPE_STATION) |
+					BIT(NL80211_IFTYPE_AP) |
+					BIT(NL80211_IFTYPE_MESH_POINT),
+		.spectral = {
+			.fft_sz = 2,
+			.fft_pad_sz = 0,
+			.summary_pad_sz = 16,
+			.fft_hdr_len = 24,
+			.max_fft_bins = 1024,
+		},
+		.credit_flow = false,
+		.max_tx_ring = 1,
+		.supports_monitor = true,
+		.supports_shadow_regs = false,
+		.idle_ps = false,
+		.supports_suspend = false,
+		.host_ce_config = ath11k_host_ce_config_qcn9074,
+		.ce_count = CE_CNT_5018,
+		.target_ce_config = ath11k_target_ce_config_wlan_ipq5018,
+		.target_ce_count = TARGET_CE_CNT_5018,
+		.svc_to_ce_map = ath11k_target_service_to_ce_map_wlan_ipq5018,
+		.svc_to_ce_map_len = SVC_CE_MAP_LEN_5018,
+		.single_pdev_only = false,
+		.rxdma1_enable = true,
+		.num_rxdma_per_pdev = RXDMA_PER_PDEV_5018,
+		.rx_mac_buf_ring = false,
+		.vdev_start_delay = false,
+		.htt_peer_map_v2 = true,
+		.coldboot_cal_mm = false,
+		.coldboot_cal_ftm = false,
+		.cbcal_restart_fw = true,
+		.fix_l1ss = true,
+		.alloc_cacheable_memory = true,
+		.m3_fw_support = false,
+		.fixed_bdf_addr = true,
+		.fixed_mem_region = true,
+		.static_window_map = true,
+		.hybrid_bus_type = true,
+		.fw_mem_mode = 1,
+		.supports_sta_ps = false,
+		.dbr_debug_support = true,
+		.bios_sar_capa = NULL,
+		.fixed_fw_mem = false,
+		.support_off_channel_tx = false,
+		.tcl_ring_retry = true,
+		.tx_ring_size = DP_TCL_DATA_RING_SIZE,
+	},
 };
 
 static const struct dmi_system_id ath11k_pm_quirk_table[] = {
@@ -2521,7 +2585,8 @@ static void ath11k_core_reset(struct work_struct *work)
 static int ath11k_init_hw_params(struct ath11k_base *ab)
 {
 	const struct ath11k_hw_params *hw_params = NULL;
-	int i;
+	u32 fw_mem_mode;
+	int i, ret;
 
 	for (i = 0; i < ARRAY_SIZE(ath11k_hw_params); i++) {
 		hw_params = &ath11k_hw_params[i];
@@ -2537,7 +2602,31 @@ static int ath11k_init_hw_params(struct ath11k_base *ab)
 
 	ab->hw_params = *hw_params;
 
+	ret = of_property_read_u32(ab->dev->of_node,
+				   "qcom,ath11k-fw-memory-mode",
+				   &fw_mem_mode);
+	if (!ret) {
+		if (fw_mem_mode == 0) {
+			ab->hw_params.fw_mem_mode = 0;
+			ab->hw_params.num_vdevs = 16 + 1;
+			ab->hw_params.num_peers = 512;
+		}
+		else if (fw_mem_mode == 1) {
+			ab->hw_params.fw_mem_mode = 1;
+			ab->hw_params.num_vdevs = 8;
+			ab->hw_params.num_peers = 128;
+		} else if (fw_mem_mode == 2) {
+			ab->hw_params.fw_mem_mode = 2;
+			ab->hw_params.num_vdevs = 8;
+			ab->hw_params.num_peers = 128;
+			ab->hw_params.coldboot_cal_mm = false;
+			ab->hw_params.coldboot_cal_ftm = false;
+		} else
+			ath11k_info(ab, "Unsupported FW memory mode: %u\n", fw_mem_mode);
+	}
+
 	ath11k_info(ab, "%s\n", ab->hw_params.name);
+	ath11k_info(ab, "FW memory mode: %d\n", ab->hw_params.fw_mem_mode);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath11k/core.h b/drivers/net/wireless/ath/ath11k/core.h
index f1af99a..9de4b49 100644
--- a/drivers/net/wireless/ath/ath11k/core.h
+++ b/drivers/net/wireless/ath/ath11k/core.h
@@ -48,6 +48,9 @@
 #define ATH11K_INVALID_HW_MAC_ID	0xFF
 #define ATH11K_CONNECTION_LOSS_HZ	(3 * HZ)
 
+#define	ATH11K_QCN6122_USERPD_2		1
+#define	ATH11K_QCN6122_USERPD_3		2
+
 /* SMBIOS type containing Board Data File Name Extension */
 #define ATH11K_SMBIOS_BDF_EXT_TYPE 0xF8
 
@@ -152,6 +155,7 @@ enum ath11k_hw_rev {
 	ATH11K_HW_IPQ5018_HW10,
 	ATH11K_HW_QCA2066_HW21,
 	ATH11K_HW_QCA6698AQ_HW21,
+	ATH11K_HW_QCN6122_HW10,
 };
 
 enum ath11k_firmware_mode {
@@ -968,6 +972,7 @@ struct ath11k_base {
 	struct list_head peers;
 	wait_queue_head_t peer_mapping_wq;
 	u8 mac_addr[ETH_ALEN];
+	int userpd_id;
 	int irq_num[ATH11K_IRQ_NUM_MAX];
 	struct ath11k_ext_irq_grp ext_irq_grp[ATH11K_EXT_IRQ_GRP_NUM_MAX];
 	struct ath11k_targ_cap target_caps;
diff --git a/drivers/net/wireless/ath/ath11k/dp.c b/drivers/net/wireless/ath/ath11k/dp.c
index 56b1a65..745c93a 100644
--- a/drivers/net/wireless/ath/ath11k/dp.c
+++ b/drivers/net/wireless/ath/ath11k/dp.c
@@ -350,12 +350,66 @@ void ath11k_dp_stop_shadow_timers(struct ath11k_base *ab)
 	ath11k_dp_shadow_stop_timer(ab, &ab->dp.reo_cmd_timer);
 }
 
+static void ath11k_dp_handle_reo_status_timer(struct timer_list *timer)
+{
+	struct ath11k_dp *dp = from_timer(dp, timer, reo_status_timer);
+	struct ath11k_base *ab = dp->ab;
+
+	spin_lock_bh(&dp->reo_cmd_lock);
+	dp->reo_status_timer_running = false;
+	spin_unlock_bh(&dp->reo_cmd_lock);
+
+	ath11k_dp_process_reo_status(ab);
+}
+
+void ath11k_dp_start_reo_status_timer(struct ath11k_base *ab)
+{
+	struct ath11k_dp *dp = &ab->dp;
+
+	if (!ab->hw_params.reo_status_poll)
+		return;
+
+	spin_lock_bh(&dp->reo_cmd_lock);
+	if (dp->reo_status_timer_running) {
+		spin_unlock_bh(&dp->reo_cmd_lock);
+		return;
+	}
+	dp->reo_status_timer_running = true;
+	spin_unlock_bh(&dp->reo_cmd_lock);
+
+	mod_timer(&dp->reo_status_timer, jiffies +
+		  msecs_to_jiffies(ATH11K_REO_STATUS_POLL_TIMEOUT_MS));
+}
+
+static void ath11k_dp_stop_reo_status_timer(struct ath11k_base *ab)
+{
+	struct ath11k_dp *dp = &ab->dp;
+
+	if (!ab->hw_params.reo_status_poll)
+		return;
+
+	del_timer_sync(&dp->reo_status_timer);
+	dp->reo_status_timer_running = false;
+}
+
+static void ath11k_dp_init_reo_status_timer(struct ath11k_base *ab)
+{
+	struct ath11k_dp *dp = &ab->dp;
+
+	if (!ab->hw_params.reo_status_poll)
+		return;
+
+	timer_setup(&dp->reo_status_timer,
+		    ath11k_dp_handle_reo_status_timer, 0);
+}
+
 static void ath11k_dp_srng_common_cleanup(struct ath11k_base *ab)
 {
 	struct ath11k_dp *dp = &ab->dp;
 	int i;
 
 	ath11k_dp_stop_shadow_timers(ab);
+	ath11k_dp_stop_reo_status_timer(ab);
 	ath11k_dp_srng_cleanup(ab, &dp->wbm_desc_rel_ring);
 	ath11k_dp_srng_cleanup(ab, &dp->tcl_cmd_ring);
 	ath11k_dp_srng_cleanup(ab, &dp->tcl_status_ring);
@@ -377,6 +431,8 @@ static int ath11k_dp_srng_common_setup(struct ath11k_base *ab)
 	int i, ret;
 	u8 tcl_num, wbm_num;
 
+	ath11k_dp_init_reo_status_timer(ab);
+
 	ret = ath11k_dp_srng_setup(ab, &dp->wbm_desc_rel_ring,
 				   HAL_SW2WBM_RELEASE, 0, 0,
 				   DP_WBM_RELEASE_RING_SIZE);
diff --git a/drivers/net/wireless/ath/ath11k/dp.h b/drivers/net/wireless/ath/ath11k/dp.h
index 7a55afd..0743d5b 100644
--- a/drivers/net/wireless/ath/ath11k/dp.h
+++ b/drivers/net/wireless/ath/ath11k/dp.h
@@ -46,6 +46,8 @@ struct dp_rx_tid {
 #define DP_MON_PURGE_TIMEOUT_MS     100
 #define DP_MON_SERVICE_BUDGET       128
 
+#define ATH11K_REO_STATUS_POLL_TIMEOUT_MS 10
+
 struct dp_reo_cache_flush_elem {
 	struct list_head list;
 	struct dp_rx_tid data;
@@ -287,6 +289,10 @@ struct ath11k_dp {
 	spinlock_t reo_cmd_lock;
 	struct ath11k_hp_update_timer reo_cmd_timer;
 	struct ath11k_hp_update_timer tx_ring_timer[DP_TCL_NUM_RING_MAX];
+
+	/* reo status timer and flags */
+	struct timer_list reo_status_timer;
+	bool reo_status_timer_running;
 };
 
 /* HTT definitions */
@@ -1690,5 +1696,6 @@ void ath11k_dp_shadow_init_timer(struct ath11k_base *ab,
 				 struct ath11k_hp_update_timer *update_timer,
 				 u32 interval, u32 ring_id);
 void ath11k_dp_stop_shadow_timers(struct ath11k_base *ab);
+void ath11k_dp_start_reo_status_timer(struct ath11k_base *ab);
 
 #endif
diff --git a/drivers/net/wireless/ath/ath11k/dp_tx.c b/drivers/net/wireless/ath/ath11k/dp_tx.c
index 562aba6..31e9024 100644
--- a/drivers/net/wireless/ath/ath11k/dp_tx.c
+++ b/drivers/net/wireless/ath/ath11k/dp_tx.c
@@ -788,6 +788,10 @@ int ath11k_dp_tx_send_reo_cmd(struct ath11k_base *ab, struct dp_rx_tid *rx_tid,
 	if (cmd_num == 0)
 		return -EINVAL;
 
+	/* Trigger reo status polling if required */
+	if (cmd->flag & HAL_REO_CMD_FLG_NEED_STATUS)
+		ath11k_dp_start_reo_status_timer(ab);
+
 	if (!cb)
 		return 0;
 
diff --git a/drivers/net/wireless/ath/ath11k/hal.c b/drivers/net/wireless/ath/ath11k/hal.c
index 0c797b8..09bc387 100644
--- a/drivers/net/wireless/ath/ath11k/hal.c
+++ b/drivers/net/wireless/ath/ath11k/hal.c
@@ -1274,20 +1274,16 @@ static int ath11k_hal_srng_create_config(struct ath11k_base *ab)
 	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_TCL_REG + HAL_TCL_STATUS_RING_HP;
 
 	s = &hal->srng_config[HAL_CE_SRC];
-	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_BASE_LSB +
-		ATH11K_CE_OFFSET(ab);
-	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_HP +
-		ATH11K_CE_OFFSET(ab);
+	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_BASE_LSB;
+	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab) + HAL_CE_DST_RING_HP;
 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_SRC_REG(ab) -
 		HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab);
 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_SRC_REG(ab) -
 		HAL_SEQ_WCSS_UMAC_CE0_SRC_REG(ab);
 
 	s = &hal->srng_config[HAL_CE_DST];
-	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_BASE_LSB +
-		ATH11K_CE_OFFSET(ab);
-	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_HP +
-		ATH11K_CE_OFFSET(ab);
+	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_BASE_LSB;
+	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_RING_HP;
 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
 		HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab);
 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
@@ -1295,9 +1291,8 @@ static int ath11k_hal_srng_create_config(struct ath11k_base *ab)
 
 	s = &hal->srng_config[HAL_CE_DST_STATUS];
 	s->reg_start[0] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) +
-		HAL_CE_DST_STATUS_RING_BASE_LSB + ATH11K_CE_OFFSET(ab);
-	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_STATUS_RING_HP +
-		ATH11K_CE_OFFSET(ab);
+		HAL_CE_DST_STATUS_RING_BASE_LSB;
+	s->reg_start[1] = HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab) + HAL_CE_DST_STATUS_RING_HP;
 	s->reg_size[0] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
 		HAL_SEQ_WCSS_UMAC_CE0_DST_REG(ab);
 	s->reg_size[1] = HAL_SEQ_WCSS_UMAC_CE1_DST_REG(ab) -
diff --git a/drivers/net/wireless/ath/ath11k/hif.h b/drivers/net/wireless/ath/ath11k/hif.h
index cd9c4b8..e4c1ad4 100644
--- a/drivers/net/wireless/ath/ath11k/hif.h
+++ b/drivers/net/wireless/ath/ath11k/hif.h
@@ -32,6 +32,7 @@ struct ath11k_hif_ops {
 	void (*ce_irq_disable)(struct ath11k_base *ab);
 	void (*get_ce_msi_idx)(struct ath11k_base *ab, u32 ce_id, u32 *msi_idx);
 	void (*coredump_download)(struct ath11k_base *ab);
+	void (*config_static_window)(struct ath11k_base *ab);
 };
 
 static inline void ath11k_hif_ce_irq_enable(struct ath11k_base *ab)
@@ -159,4 +160,12 @@ static inline void ath11k_hif_coredump_download(struct ath11k_base *ab)
 		ab->hif.ops->coredump_download(ab);
 }
 
+static inline void ath11k_hif_config_static_window(struct ath11k_base *ab)
+{
+	if (!ab->hw_params.static_window_map || !ab->hif.ops->config_static_window)
+		return;
+
+	ab->hif.ops->config_static_window(ab);
+}
+
 #endif /* _HIF_H_ */
diff --git a/drivers/net/wireless/ath/ath11k/hw.c b/drivers/net/wireless/ath/ath11k/hw.c
index caa6dc1..6119c86 100644
--- a/drivers/net/wireless/ath/ath11k/hw.c
+++ b/drivers/net/wireless/ath/ath11k/hw.c
@@ -1175,7 +1175,7 @@ const struct ath11k_hw_ops ipq5018_ops = {
 	.rx_desc_get_attention = ath11k_hw_qcn9074_rx_desc_get_attention,
 	.reo_setup = ath11k_hw_ipq5018_reo_setup,
 	.rx_desc_get_msdu_payload = ath11k_hw_qcn9074_rx_desc_get_msdu_payload,
-	.mpdu_info_get_peerid = ath11k_hw_ipq8074_mpdu_info_get_peerid,
+	.mpdu_info_get_peerid = ath11k_hw_qcn9074_mpdu_info_get_peerid,
 	.rx_desc_mac_addr2_valid = ath11k_hw_ipq9074_rx_desc_mac_addr2_valid,
 	.rx_desc_mpdu_start_addr2 = ath11k_hw_ipq9074_rx_desc_mpdu_start_addr2,
 	.get_ring_selector = ath11k_hw_ipq8074_get_tcl_ring_selector,
@@ -2070,6 +2070,43 @@ const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_wcn6750 = {
 	},
 };
 
+const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn6122 = {
+	.tx  = {
+		ATH11K_TX_RING_MASK_0,
+		ATH11K_TX_RING_MASK_1,
+		ATH11K_TX_RING_MASK_2,
+	},
+	.rx_mon_status = {
+		0, 0, 0,
+		ATH11K_RX_MON_STATUS_RING_MASK_0,
+	},
+	.rx = {
+		0, 0, 0, 0,
+		ATH11K_RX_RING_MASK_0,
+		ATH11K_RX_RING_MASK_1,
+		ATH11K_RX_RING_MASK_2,
+		ATH11K_RX_RING_MASK_3,
+	},
+	.rx_err = {
+		0, 0, 0, 0, 0, 0, 0, 0,
+		ATH11K_RX_ERR_RING_MASK_0,
+	},
+	.rx_wbm_rel = {
+		0, 0, 0, 0, 0, 0, 0, 0, 0,
+		ATH11K_RX_WBM_REL_RING_MASK_0,
+	},
+       .reo_status = {
+		0, 0, 0,
+		ATH11K_REO_STATUS_RING_MASK_0,
+	},
+	.rxdma2host = {
+		ATH11K_RXDMA2HOST_RING_MASK_0,
+	},
+	.host2rxdma = {
+		ATH11K_HOST2RXDMA_RING_MASK_0,
+	},
+};
+
 /* Target firmware's Copy Engine configuration for IPQ5018 */
 const struct ce_pipe_config ath11k_target_ce_config_wlan_ipq5018[] = {
 	/* CE0: host->target HTC control and raw streams */
@@ -2268,9 +2305,9 @@ const struct ce_ie_addr ath11k_ce_ie_addr_ipq8074 = {
 };
 
 const struct ce_ie_addr ath11k_ce_ie_addr_ipq5018 = {
-	.ie1_reg_addr = CE_HOST_IPQ5018_IE_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
-	.ie2_reg_addr = CE_HOST_IPQ5018_IE_2_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
-	.ie3_reg_addr = CE_HOST_IPQ5018_IE_3_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
+	.ie1_reg_addr = ATH11K_REG_TYPE_CE + CE_HOST_IPQ5018_IE_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
+	.ie2_reg_addr = ATH11K_REG_TYPE_CE + CE_HOST_IPQ5018_IE_2_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
+	.ie3_reg_addr = ATH11K_REG_TYPE_CE + CE_HOST_IPQ5018_IE_3_ADDRESS - HAL_IPQ5018_CE_WFSS_REG_BASE,
 };
 
 const struct ce_remap ath11k_ce_remap_ipq5018 = {
@@ -2801,13 +2838,13 @@ const struct ath11k_hw_regs ipq5018_regs = {
 	.hal_reo_status_hp = 0x00003070,
 
 	/* WCSS relative address */
-	.hal_seq_wcss_umac_ce0_src_reg = 0x08400000
+	.hal_seq_wcss_umac_ce0_src_reg = ATH11K_REG_TYPE_CE + 0x08400000
 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-	.hal_seq_wcss_umac_ce0_dst_reg = 0x08401000
+	.hal_seq_wcss_umac_ce0_dst_reg = ATH11K_REG_TYPE_CE + 0x08401000
 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-	.hal_seq_wcss_umac_ce1_src_reg = 0x08402000
+	.hal_seq_wcss_umac_ce1_src_reg = ATH11K_REG_TYPE_CE + 0x08402000
 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
-	.hal_seq_wcss_umac_ce1_dst_reg = 0x08403000
+	.hal_seq_wcss_umac_ce1_dst_reg = ATH11K_REG_TYPE_CE + 0x08403000
 		- HAL_IPQ5018_CE_WFSS_REG_BASE,
 
 	/* WBM Idle address */
@@ -2822,6 +2859,81 @@ const struct ath11k_hw_regs ipq5018_regs = {
 	.hal_wbm1_release_ring_base_lsb = 0x0000097c,
 };
 
+const struct ath11k_hw_regs qcn6122_regs = {
+	/* SW2TCL(x) R0 ring configuration address */
+	.hal_tcl1_ring_base_lsb = 0x00000694,
+	.hal_tcl1_ring_base_msb = 0x00000698,
+	.hal_tcl1_ring_id = 0x0000069c,
+	.hal_tcl1_ring_misc = 0x000006a4,
+	.hal_tcl1_ring_tp_addr_lsb = 0x000006b0,
+	.hal_tcl1_ring_tp_addr_msb = 0x000006b4,
+	.hal_tcl1_ring_consumer_int_setup_ix0 = 0x000006c4,
+	.hal_tcl1_ring_consumer_int_setup_ix1 = 0x000006c8,
+	.hal_tcl1_ring_msi1_base_lsb = 0x000006dc,
+	.hal_tcl1_ring_msi1_base_msb = 0x000006e0,
+	.hal_tcl1_ring_msi1_data = 0x000006e4,
+	.hal_tcl2_ring_base_lsb = 0x000006ec,
+	.hal_tcl_ring_base_lsb = 0x0000079c,
+
+	/* TCL STATUS ring address */
+	.hal_tcl_status_ring_base_lsb = 0x000008a4,
+
+	/* REO2SW(x) R0 ring configuration address */
+	.hal_reo1_ring_base_lsb = 0x000001ec,
+	.hal_reo1_ring_base_msb = 0x000001f0,
+	.hal_reo1_ring_id = 0x000001f4,
+	.hal_reo1_ring_misc = 0x000001fc,
+	.hal_reo1_ring_hp_addr_lsb = 0x00000200,
+	.hal_reo1_ring_hp_addr_msb = 0x00000204,
+	.hal_reo1_ring_producer_int_setup = 0x00000210,
+	.hal_reo1_ring_msi1_base_lsb = 0x00000234,
+	.hal_reo1_ring_msi1_base_msb = 0x00000238,
+	.hal_reo1_ring_msi1_data = 0x0000023c,
+	.hal_reo2_ring_base_lsb = 0x00000244,
+	.hal_reo1_aging_thresh_ix_0 = 0x00000564,
+	.hal_reo1_aging_thresh_ix_1 = 0x00000568,
+	.hal_reo1_aging_thresh_ix_2 = 0x0000056c,
+	.hal_reo1_aging_thresh_ix_3 = 0x00000570,
+
+	/* REO2SW(x) R2 ring pointers (head/tail) address */
+	.hal_reo1_ring_hp = 0x00003028,
+	.hal_reo1_ring_tp = 0x0000302c,
+	.hal_reo2_ring_hp = 0x00003030,
+
+	/* REO2TCL R0 ring configuration address */
+	.hal_reo_tcl_ring_base_lsb = 0x000003fc,
+	.hal_reo_tcl_ring_hp = 0x00003058,
+
+	/* SW2REO ring address */
+	.hal_sw2reo_ring_base_lsb = 0x0000013c,
+	.hal_sw2reo_ring_hp = 0x00003018,
+
+	/* REO CMD ring address */
+	.hal_reo_cmd_ring_base_lsb = 0x000000e4,
+	.hal_reo_cmd_ring_hp = 0x00003010,
+
+	/* REO status address */
+	.hal_reo_status_ring_base_lsb = 0x00000504,
+	.hal_reo_status_hp = 0x00003070,
+
+	/* WCSS relative address */
+	.hal_seq_wcss_umac_ce0_src_reg = 0x01b80000,
+	.hal_seq_wcss_umac_ce0_dst_reg = 0x01b81000,
+	.hal_seq_wcss_umac_ce1_src_reg = 0x01b82000,
+	.hal_seq_wcss_umac_ce1_dst_reg = 0x01b83000,
+
+	/* WBM Idle address */
+	.hal_wbm_idle_link_ring_base_lsb = 0x00000874,
+	.hal_wbm_idle_link_ring_misc = 0x00000884,
+
+	/* SW2WBM release address */
+	.hal_wbm_release_ring_base_lsb = 0x000001ec,
+
+	/* WBM2SW release address */
+	.hal_wbm0_release_ring_base_lsb = 0x00000924,
+	.hal_wbm1_release_ring_base_lsb = 0x0000097c,
+};
+
 const struct ath11k_hw_hal_params ath11k_hw_hal_params_ipq8074 = {
 	.rx_buf_rbm = HAL_RX_BUF_RBM_SW3_BM,
 	.tcl2wbm_rbm_map = ath11k_hw_tcl2wbm_rbm_map_ipq8074,
diff --git a/drivers/net/wireless/ath/ath11k/hw.h b/drivers/net/wireless/ath/ath11k/hw.h
index 52d9f4c..5ee5e46 100644
--- a/drivers/net/wireless/ath/ath11k/hw.h
+++ b/drivers/net/wireless/ath/ath11k/hw.h
@@ -81,7 +81,12 @@
 #define ATH11K_M3_FILE			"m3.bin"
 #define ATH11K_REGDB_FILE_NAME		"regdb.bin"
 
-#define ATH11K_CE_OFFSET(ab)	(ab->mem_ce - ab->mem)
+#define ATH11K_REG_TYPE_MASK		GENMASK(31, 28)
+#define  ATH11K_REG_TYPE(x)		FIELD_PREP_CONST(ATH11K_REG_TYPE_MASK, x)
+#define  ATH11K_REG_TYPE_NORMAL		ATH11K_REG_TYPE(0)
+#define  ATH11K_REG_TYPE_DP		ATH11K_REG_TYPE(1)
+#define  ATH11K_REG_TYPE_CE		ATH11K_REG_TYPE(2)
+#define ATH11K_REG_OFFSET_MASK		GENMASK(27, 0)
 
 enum ath11k_hw_rate_cck {
 	ATH11K_HW_RATE_CCK_LP_11M = 0,
@@ -228,6 +233,7 @@ struct ath11k_hw_params {
 	bool support_fw_mac_sequence;
 	bool support_dual_stations;
 	bool pdev_suspend;
+	bool reo_status_poll;
 };
 
 struct ath11k_hw_ops {
@@ -285,6 +291,7 @@ extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_ipq8074;
 extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qca6390;
 extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn9074;
 extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_wcn6750;
+extern const struct ath11k_hw_ring_mask ath11k_hw_ring_mask_qcn6122;
 
 extern const struct ce_ie_addr ath11k_ce_ie_addr_ipq8074;
 extern const struct ce_ie_addr ath11k_ce_ie_addr_ipq5018;
@@ -421,6 +428,7 @@ extern const struct ath11k_hw_regs qcn9074_regs;
 extern const struct ath11k_hw_regs wcn6855_regs;
 extern const struct ath11k_hw_regs wcn6750_regs;
 extern const struct ath11k_hw_regs ipq5018_regs;
+extern const struct ath11k_hw_regs qcn6122_regs;
 
 static inline const char *ath11k_bd_ie_type_str(enum ath11k_bd_ie_type type)
 {
diff --git a/drivers/net/wireless/ath/ath11k/mac.c b/drivers/net/wireless/ath/ath11k/mac.c
index 52656a3..a2d1230 100644
--- a/drivers/net/wireless/ath/ath11k/mac.c
+++ b/drivers/net/wireless/ath/ath11k/mac.c
@@ -8330,6 +8330,23 @@ static void ath11k_mac_op_flush(struct ieee80211_hw *hw, struct ieee80211_vif *v
 	ath11k_mac_flush_tx_complete(ar);
 }
 
+static void ath11k_mac_op_flush_sta(struct ieee80211_hw *hw,
+				    struct ieee80211_vif *vif,
+				    struct ieee80211_sta *sta)
+{
+	struct ath11k_vif *arvif = (void *)vif->drv_priv;
+	struct ath11k *ar = hw->priv;
+	struct peer_flush_params params = {
+		.peer_tid_bitmap = 0xFF,
+		.vdev_id = arvif->vdev_id,
+	};
+	int ret;
+
+	ret = ath11k_wmi_send_peer_flush_tids_cmd(ar, sta->addr, &params);
+	if (ret)
+		ath11k_warn(ar->ab, "failed to flush sta %pM: %d\n", sta->addr, ret);
+}
+
 static bool
 ath11k_mac_has_single_legacy_rate(struct ath11k *ar,
 				  enum nl80211_band band,
@@ -9920,6 +9937,7 @@ static const struct ieee80211_ops ath11k_ops = {
 	.set_bitrate_mask		= ath11k_mac_op_set_bitrate_mask,
 	.get_survey			= ath11k_mac_op_get_survey,
 	.flush				= ath11k_mac_op_flush,
+	.flush_sta			= ath11k_mac_op_flush_sta,
 	.sta_statistics			= ath11k_mac_op_sta_statistics,
 	CFG80211_TESTMODE_CMD(ath11k_tm_cmd)
 
diff --git a/drivers/net/wireless/ath/ath11k/mhi.c b/drivers/net/wireless/ath/ath11k/mhi.c
index acd76e9..0c851bf 100644
--- a/drivers/net/wireless/ath/ath11k/mhi.c
+++ b/drivers/net/wireless/ath/ath11k/mhi.c
@@ -239,6 +239,34 @@ static void ath11k_mhi_op_runtime_put(struct mhi_controller *mhi_cntrl)
 {
 }
 
+static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
+				  void __iomem *addr,
+				  u32 *out)
+{
+	*out = readl(addr);
+
+	return 0;
+}
+
+static void ath11k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,
+				    void __iomem *addr,
+				    u32 val)
+{
+	writel(val, addr);
+}
+
+static void ath11k_mhi_qrtr_instance_set(struct mhi_controller *mhi_cntrl)
+{
+	struct ath11k_base *ab = dev_get_drvdata(mhi_cntrl->cntrl_dev);
+
+	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
+		ath11k_mhi_op_write_reg(mhi_cntrl,
+					mhi_cntrl->bhi + BHI_ERRDBG2,
+					FIELD_PREP(QRTR_INSTANCE_MASK,
+					ab->qmi.service_ins_id - ab->hw_params.qmi_service_ins_id));
+	}
+}
+
 static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
 {
 	switch (reason) {
@@ -260,6 +288,8 @@ static char *ath11k_mhi_op_callback_to_str(enum mhi_callback reason)
 		return "MHI_CB_FATAL_ERROR";
 	case MHI_CB_BW_REQ:
 		return "MHI_CB_BW_REQ";
+	case MHI_CB_EE_SBL_MODE:
+		return "MHI_CB_EE_SBL_MODE";
 	default:
 		return "UNKNOWN";
 	}
@@ -289,6 +319,9 @@ static void ath11k_mhi_op_status_cb(struct mhi_controller *mhi_cntrl,
 		if (!(test_bit(ATH11K_FLAG_UNREGISTERING, &ab->dev_flags)))
 			queue_work(ab->workqueue_aux, &ab->reset_work);
 
+		break;
+	case MHI_CB_EE_SBL_MODE:
+		ath11k_mhi_qrtr_instance_set(mhi_cntrl);
 		break;
 	default:
 		break;
@@ -297,22 +330,6 @@ static void ath11k_mhi_op_status_cb(struct mhi_controller *mhi_cntrl,
 	ab_pci->mhi_pre_cb = cb;
 }
 
-static int ath11k_mhi_op_read_reg(struct mhi_controller *mhi_cntrl,
-				  void __iomem *addr,
-				  u32 *out)
-{
-	*out = readl(addr);
-
-	return 0;
-}
-
-static void ath11k_mhi_op_write_reg(struct mhi_controller *mhi_cntrl,
-				    void __iomem *addr,
-				    u32 val)
-{
-	writel(val, addr);
-}
-
 static int ath11k_mhi_read_addr_from_dt(struct mhi_controller *mhi_ctrl)
 {
 	struct device_node *np;
diff --git a/drivers/net/wireless/ath/ath11k/mhi.h b/drivers/net/wireless/ath/ath11k/mhi.h
index 5c5c2b0..2aaf280 100644
--- a/drivers/net/wireless/ath/ath11k/mhi.h
+++ b/drivers/net/wireless/ath/ath11k/mhi.h
@@ -17,6 +17,9 @@
 #define MHICTRL					0x38
 #define MHICTRL_RESET_MASK			0x2
 
+#define BHI_ERRDBG2				0x38
+#define QRTR_INSTANCE_MASK			GENMASK(7, 0)
+
 int ath11k_mhi_start(struct ath11k_pci *ar_pci);
 void ath11k_mhi_stop(struct ath11k_pci *ar_pci, bool is_suspend);
 int ath11k_mhi_register(struct ath11k_pci *ar_pci);
diff --git a/drivers/net/wireless/ath/ath11k/pci.c b/drivers/net/wireless/ath/ath11k/pci.c
index d8655ba..f3ea661 100644
--- a/drivers/net/wireless/ath/ath11k/pci.c
+++ b/drivers/net/wireless/ath/ath11k/pci.c
@@ -376,13 +376,22 @@ static void ath11k_pci_sw_reset(struct ath11k_base *ab, bool power_on)
 static void ath11k_pci_init_qmi_ce_config(struct ath11k_base *ab)
 {
 	struct ath11k_qmi_ce_cfg *cfg = &ab->qmi.ce_cfg;
+	struct ath11k_pci *ab_pci = ath11k_pci_priv(ab);
+	struct pci_bus *bus = ab_pci->pdev->bus;
 
 	cfg->tgt_ce = ab->hw_params.target_ce_config;
 	cfg->tgt_ce_len = ab->hw_params.target_ce_count;
 
 	cfg->svc_to_ce_map = ab->hw_params.svc_to_ce_map;
 	cfg->svc_to_ce_map_len = ab->hw_params.svc_to_ce_map_len;
-	ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+
+	if (ab->hw_rev == ATH11K_HW_QCN9074_HW10) {
+		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id +
+		(((pci_domain_nr(bus) & 0xF) << 4) | (bus->number & 0xF));
+	} else
+		ab->qmi.service_ins_id = ab->hw_params.qmi_service_ins_id;
+
+	ab->qmi.service_ins_id += ab->userpd_id;
 
 	ath11k_ce_get_shadow_config(ab, &cfg->shadow_reg_v2,
 				    &cfg->shadow_reg_v2_len);
diff --git a/drivers/net/wireless/ath/ath11k/pcic.c b/drivers/net/wireless/ath/ath11k/pcic.c
index fc6e7da..ac1e156 100644
--- a/drivers/net/wireless/ath/ath11k/pcic.c
+++ b/drivers/net/wireless/ath/ath11k/pcic.c
@@ -139,6 +139,15 @@ static const struct ath11k_msi_config ath11k_msi_config[] = {
 		},
 		.hw_rev = ATH11K_HW_QCA6698AQ_HW21,
 	},
+	{
+		.total_vectors = 13,
+		.total_users = 2,
+		.users = (struct ath11k_msi_user[]) {
+			{ .name = "CE", .num_vectors = 5, .base_vector = 0 },
+			{ .name = "DP", .num_vectors = 8, .base_vector = 5 },
+		},
+		.hw_rev = ATH11K_HW_QCN6122_HW10,
+	},
 };
 
 int ath11k_pcic_init_msi_config(struct ath11k_base *ab)
diff --git a/drivers/net/wireless/ath/ath11k/qmi.c b/drivers/net/wireless/ath/ath11k/qmi.c
index aea56c3..f2aa36d 100644
--- a/drivers/net/wireless/ath/ath11k/qmi.c
+++ b/drivers/net/wireless/ath/ath11k/qmi.c
@@ -2039,9 +2039,10 @@ static int ath11k_qmi_alloc_target_mem_chunk(struct ath11k_base *ab)
 
 static int ath11k_qmi_assign_target_mem_chunk(struct ath11k_base *ab)
 {
+	struct resource res = DEFINE_RES_NAMED(0, 0, NULL, IORESOURCE_UNSET);
 	struct device *dev = ab->dev;
-	struct resource res = {};
 	u32 host_ddr_sz;
+	u32 addr;
 	int i, idx, ret;
 
 	for (i = 0, idx = 0; i < ab->qmi.mem_seg_count; i++) {
@@ -2073,7 +2074,9 @@ static int ath11k_qmi_assign_target_mem_chunk(struct ath11k_base *ab)
 			idx++;
 			break;
 		case BDF_MEM_REGION_TYPE:
-			ab->qmi.target_mem[idx].paddr = ab->hw_params.bdf_addr;
+			if (of_property_read_u32(dev->of_node, "qcom,bdf-addr", &addr))
+				addr = ab->hw_params.bdf_addr;
+			ab->qmi.target_mem[idx].paddr = addr;
 			ab->qmi.target_mem[idx].iaddr = NULL;
 			ab->qmi.target_mem[idx].size = ab->qmi.target_mem[i].size;
 			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
@@ -2086,7 +2089,7 @@ static int ath11k_qmi_assign_target_mem_chunk(struct ath11k_base *ab)
 			}
 
 			if (ath11k_core_coldboot_cal_support(ab)) {
-				if (resource_size(&res)) {
+				if (res.flags != IORESOURCE_UNSET) {
 					ab->qmi.target_mem[idx].paddr =
 							res.start + host_ddr_sz;
 					ab->qmi.target_mem[idx].iaddr =
@@ -2095,8 +2098,9 @@ static int ath11k_qmi_assign_target_mem_chunk(struct ath11k_base *ab)
 					if (!ab->qmi.target_mem[idx].iaddr)
 						return -EIO;
 				} else {
-					ab->qmi.target_mem[idx].paddr =
-						ATH11K_QMI_CALDB_ADDRESS;
+					if (of_property_read_u32(dev->of_node, "qcom,caldb-addr", &addr))
+						addr = ATH11K_QMI_CALDB_ADDRESS;
+					ab->qmi.target_mem[idx].paddr = addr;
 					ab->qmi.target_mem[idx].iaddr = NULL;
 				}
 			} else {
@@ -2107,6 +2111,18 @@ static int ath11k_qmi_assign_target_mem_chunk(struct ath11k_base *ab)
 			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
 			idx++;
 			break;
+		case M3_DUMP_REGION_TYPE:
+			if (of_property_read_u32(dev->of_node, "qcom,m3-dump-addr", &addr)) {
+				ath11k_warn(ab, "qmi fail to get qcom,m3-dump-addr, ignore m3 dump mem req\n");
+				break;
+			}
+
+			ab->qmi.target_mem[idx].paddr = (phys_addr_t) addr;
+			ab->qmi.target_mem[idx].vaddr = NULL;
+			ab->qmi.target_mem[idx].size = ab->qmi.target_mem[i].size;
+			ab->qmi.target_mem[idx].type = ab->qmi.target_mem[i].type;
+			idx++;
+			break;
 		default:
 			ath11k_warn(ab, "qmi ignore invalid mem req type %d\n",
 				    ab->qmi.target_mem[i].type);
@@ -2190,6 +2206,8 @@ static int ath11k_qmi_request_device_info(struct ath11k_base *ab)
 	if (!ab->hw_params.ce_remap)
 		ab->mem_ce = ab->mem;
 
+	ath11k_hif_config_static_window(ab);
+
 	return 0;
 out:
 	return ret;
@@ -2302,6 +2320,7 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 	struct qmi_wlanfw_bdf_download_resp_msg_v01 resp;
 	struct qmi_txn txn;
 	const u8 *temp = data;
+	u32 addr;
 	void __iomem *bdf_addr = NULL;
 	int ret = 0;
 	u32 remaining = len;
@@ -2313,7 +2332,9 @@ static int ath11k_qmi_load_file_target_mem(struct ath11k_base *ab,
 	memset(&resp, 0, sizeof(resp));
 
 	if (ab->hw_params.fixed_bdf_addr) {
-		bdf_addr = ioremap(ab->hw_params.bdf_addr, ab->hw_params.fw.board_size);
+		if(of_property_read_u32(ab->dev->of_node, "qcom,bdf-addr", &addr))
+			addr = ab->hw_params.bdf_addr;
+		bdf_addr = ioremap(addr, ab->hw_params.fw.board_size);
 		if (!bdf_addr) {
 			ath11k_warn(ab, "qmi ioremap error for bdf_addr\n");
 			ret = -EIO;
diff --git a/drivers/net/wireless/ath/ath11k/qmi.h b/drivers/net/wireless/ath/ath11k/qmi.h
index 7968ab1..f6014b9 100644
--- a/drivers/net/wireless/ath/ath11k/qmi.h
+++ b/drivers/net/wireless/ath/ath11k/qmi.h
@@ -22,10 +22,11 @@
 #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_IPQ8074	0x02
 #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN9074	0x07
 #define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_WCN6750	0x03
+#define ATH11K_QMI_WLFW_SERVICE_INS_ID_V01_QCN6122	0x40
 #define ATH11K_QMI_WLANFW_MAX_TIMESTAMP_LEN_V01	32
 #define ATH11K_QMI_RESP_LEN_MAX			8192
 #define ATH11K_QMI_WLANFW_MAX_NUM_MEM_SEG_V01	52
-#define ATH11K_QMI_CALDB_SIZE			0x480000
+#define ATH11K_QMI_CALDB_SIZE			0x500000
 #define ATH11K_QMI_BDF_EXT_STR_LENGTH		0x20
 #define ATH11K_QMI_FW_MEM_REQ_SEGMENT_CNT	5
 
diff --git a/drivers/net/wireless/ath/ath11k/reg.c b/drivers/net/wireless/ath/ath11k/reg.c
index 6eff826..cdbfe6d 100644
--- a/drivers/net/wireless/ath/ath11k/reg.c
+++ b/drivers/net/wireless/ath/ath11k/reg.c
@@ -353,134 +353,6 @@ static u32 ath11k_map_fw_phy_flags(u32 phy_flags)
 	return flags;
 }
 
-static bool
-ath11k_reg_can_intersect(struct ieee80211_reg_rule *rule1,
-			 struct ieee80211_reg_rule *rule2)
-{
-	u32 start_freq1, end_freq1;
-	u32 start_freq2, end_freq2;
-
-	start_freq1 = rule1->freq_range.start_freq_khz;
-	start_freq2 = rule2->freq_range.start_freq_khz;
-
-	end_freq1 = rule1->freq_range.end_freq_khz;
-	end_freq2 = rule2->freq_range.end_freq_khz;
-
-	if ((start_freq1 >= start_freq2 &&
-	     start_freq1 < end_freq2) ||
-	    (start_freq2 > start_freq1 &&
-	     start_freq2 < end_freq1))
-		return true;
-
-	/* TODO: Should we restrict intersection feasibility
-	 *  based on min bandwidth of the intersected region also,
-	 *  say the intersected rule should have a  min bandwidth
-	 * of 20MHz?
-	 */
-
-	return false;
-}
-
-static void ath11k_reg_intersect_rules(struct ieee80211_reg_rule *rule1,
-				       struct ieee80211_reg_rule *rule2,
-				       struct ieee80211_reg_rule *new_rule)
-{
-	u32 start_freq1, end_freq1;
-	u32 start_freq2, end_freq2;
-	u32 freq_diff, max_bw;
-
-	start_freq1 = rule1->freq_range.start_freq_khz;
-	start_freq2 = rule2->freq_range.start_freq_khz;
-
-	end_freq1 = rule1->freq_range.end_freq_khz;
-	end_freq2 = rule2->freq_range.end_freq_khz;
-
-	new_rule->freq_range.start_freq_khz = max_t(u32, start_freq1,
-						    start_freq2);
-	new_rule->freq_range.end_freq_khz = min_t(u32, end_freq1, end_freq2);
-
-	freq_diff = new_rule->freq_range.end_freq_khz -
-			new_rule->freq_range.start_freq_khz;
-	max_bw = min_t(u32, rule1->freq_range.max_bandwidth_khz,
-		       rule2->freq_range.max_bandwidth_khz);
-	new_rule->freq_range.max_bandwidth_khz = min_t(u32, max_bw, freq_diff);
-
-	new_rule->power_rule.max_antenna_gain =
-		min_t(u32, rule1->power_rule.max_antenna_gain,
-		      rule2->power_rule.max_antenna_gain);
-
-	new_rule->power_rule.max_eirp = min_t(u32, rule1->power_rule.max_eirp,
-					      rule2->power_rule.max_eirp);
-
-	/* Use the flags of both the rules */
-	new_rule->flags = rule1->flags | rule2->flags;
-
-	if ((rule1->flags & NL80211_RRF_PSD) && (rule2->flags & NL80211_RRF_PSD))
-		new_rule->psd = min_t(s8, rule1->psd, rule2->psd);
-	else
-		new_rule->flags &= ~NL80211_RRF_PSD;
-
-	/* To be safe, lts use the max cac timeout of both rules */
-	new_rule->dfs_cac_ms = max_t(u32, rule1->dfs_cac_ms,
-				     rule2->dfs_cac_ms);
-}
-
-static struct ieee80211_regdomain *
-ath11k_regd_intersect(struct ieee80211_regdomain *default_regd,
-		      struct ieee80211_regdomain *curr_regd)
-{
-	u8 num_old_regd_rules, num_curr_regd_rules, num_new_regd_rules;
-	struct ieee80211_reg_rule *old_rule, *curr_rule, *new_rule;
-	struct ieee80211_regdomain *new_regd = NULL;
-	u8 i, j, k;
-
-	num_old_regd_rules = default_regd->n_reg_rules;
-	num_curr_regd_rules = curr_regd->n_reg_rules;
-	num_new_regd_rules = 0;
-
-	/* Find the number of intersecting rules to allocate new regd memory */
-	for (i = 0; i < num_old_regd_rules; i++) {
-		old_rule = default_regd->reg_rules + i;
-		for (j = 0; j < num_curr_regd_rules; j++) {
-			curr_rule = curr_regd->reg_rules + j;
-
-			if (ath11k_reg_can_intersect(old_rule, curr_rule))
-				num_new_regd_rules++;
-		}
-	}
-
-	if (!num_new_regd_rules)
-		return NULL;
-
-	new_regd = kzalloc(sizeof(*new_regd) + (num_new_regd_rules *
-			sizeof(struct ieee80211_reg_rule)),
-			GFP_ATOMIC);
-
-	if (!new_regd)
-		return NULL;
-
-	/* We set the new country and dfs region directly and only trim
-	 * the freq, power, antenna gain by intersecting with the
-	 * default regdomain. Also MAX of the dfs cac timeout is selected.
-	 */
-	new_regd->n_reg_rules = num_new_regd_rules;
-	memcpy(new_regd->alpha2, curr_regd->alpha2, sizeof(new_regd->alpha2));
-	new_regd->dfs_region = curr_regd->dfs_region;
-	new_rule = new_regd->reg_rules;
-
-	for (i = 0, k = 0; i < num_old_regd_rules; i++) {
-		old_rule = default_regd->reg_rules + i;
-		for (j = 0; j < num_curr_regd_rules; j++) {
-			curr_rule = curr_regd->reg_rules + j;
-
-			if (ath11k_reg_can_intersect(old_rule, curr_rule))
-				ath11k_reg_intersect_rules(old_rule, curr_rule,
-							   (new_rule + k++));
-		}
-	}
-	return new_regd;
-}
-
 static const char *
 ath11k_reg_get_regdom_str(enum nl80211_dfs_regions dfs_region)
 {
@@ -631,11 +503,11 @@ ath11k_reg_ap_pwr_convert(enum ieee80211_ap_reg_power power_type)
 
 struct ieee80211_regdomain *
 ath11k_reg_build_regd(struct ath11k_base *ab,
-		      struct cur_regulatory_info *reg_info, bool intersect,
+		      struct cur_regulatory_info *reg_info,
 		      enum wmi_vdev_type vdev_type,
 		      enum ieee80211_ap_reg_power power_type)
 {
-	struct ieee80211_regdomain *tmp_regd, *default_regd, *new_regd = NULL;
+	struct ieee80211_regdomain *new_regd = NULL;
 	struct cur_reg_rule *reg_rule, *reg_rule_6ghz;
 	u8 i = 0, j = 0, k = 0;
 	u8 num_rules;
@@ -678,26 +550,26 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 	}
 
 	if (!num_rules)
-		goto ret;
+		return new_regd;
 
 	/* Add max additional rules to accommodate weather radar band */
 	if (reg_info->dfs_region == ATH11K_DFS_REG_ETSI)
 		num_rules += 2;
 
-	tmp_regd =  kzalloc(sizeof(*tmp_regd) +
+	new_regd =  kzalloc(sizeof(*new_regd) +
 			(num_rules * sizeof(struct ieee80211_reg_rule)),
 			GFP_ATOMIC);
-	if (!tmp_regd)
-		goto ret;
+	if (!new_regd)
+		return new_regd;
 
-	memcpy(tmp_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
+	memcpy(new_regd->alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
 	memcpy(alpha2, reg_info->alpha2, REG_ALPHA2_LEN + 1);
 	alpha2[2] = '\0';
-	tmp_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
+	new_regd->dfs_region = ath11k_map_fw_dfs_region(reg_info->dfs_region);
 
 	ath11k_dbg(ab, ATH11K_DBG_REG,
 		   "Country %s, CFG Regdomain %s FW Regdomain %d, num_reg_rules %d\n",
-		   alpha2, ath11k_reg_get_regdom_str(tmp_regd->dfs_region),
+		   alpha2, ath11k_reg_get_regdom_str(new_regd->dfs_region),
 		   reg_info->dfs_region, num_rules);
 	/* Update reg_rules[] below. Firmware is expected to
 	 * send these rules in order(2 GHz rules first and then 5 GHz)
@@ -736,7 +608,7 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 		flags |= ath11k_map_fw_reg_flags(reg_rule->flags);
 		flags |= ath11k_map_fw_phy_flags(reg_info->phybitmap);
 
-		ath11k_reg_update_rule(tmp_regd->reg_rules + i,
+		ath11k_reg_update_rule(new_regd->reg_rules + i,
 				       reg_rule->start_freq,
 				       reg_rule->end_freq, max_bw,
 				       reg_rule->ant_gain, reg_rule->reg_power,
@@ -751,7 +623,7 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 		    reg_info->dfs_region == ATH11K_DFS_REG_ETSI &&
 		    (reg_rule->end_freq > ETSI_WEATHER_RADAR_BAND_LOW &&
 		    reg_rule->start_freq < ETSI_WEATHER_RADAR_BAND_HIGH)){
-			ath11k_reg_update_weather_radar_band(ab, tmp_regd,
+			ath11k_reg_update_weather_radar_band(ab, new_regd,
 							     reg_rule, &i,
 							     flags, max_bw);
 			continue;
@@ -762,37 +634,20 @@ ath11k_reg_build_regd(struct ath11k_base *ab,
 				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d) (%d, %d)\n",
 				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
 				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-				   tmp_regd->reg_rules[i].dfs_cac_ms, flags,
+				   new_regd->reg_rules[i].dfs_cac_ms, flags,
 				   reg_rule->psd_flag, reg_rule->psd_eirp);
 		} else {
 			ath11k_dbg(ab, ATH11K_DBG_REG,
 				   "\t%d. (%d - %d @ %d) (%d, %d) (%d ms) (FLAGS %d)\n",
 				   i + 1, reg_rule->start_freq, reg_rule->end_freq,
 				   max_bw, reg_rule->ant_gain, reg_rule->reg_power,
-				   tmp_regd->reg_rules[i].dfs_cac_ms,
+				   new_regd->reg_rules[i].dfs_cac_ms,
 				   flags);
 		}
 	}
 
-	tmp_regd->n_reg_rules = i;
-
-	if (intersect) {
-		default_regd = ab->default_regd[reg_info->phy_id];
+	new_regd->n_reg_rules = i;
 
-		/* Get a new regd by intersecting the received regd with
-		 * our default regd.
-		 */
-		new_regd = ath11k_regd_intersect(default_regd, tmp_regd);
-		kfree(tmp_regd);
-		if (!new_regd) {
-			ath11k_warn(ab, "Unable to create intersected regdomain\n");
-			goto ret;
-		}
-	} else {
-		new_regd = tmp_regd;
-	}
-
-ret:
 	return new_regd;
 }
 
@@ -844,17 +699,6 @@ void ath11k_regd_update_chan_list_work(struct work_struct *work)
 	}
 }
 
-static bool ath11k_reg_is_world_alpha(char *alpha)
-{
-	if (alpha[0] == '0' && alpha[1] == '0')
-		return true;
-
-	if (alpha[0] == 'n' && alpha[1] == 'a')
-		return true;
-
-	return false;
-}
-
 static enum wmi_vdev_type ath11k_reg_get_ar_vdev_type(struct ath11k *ar)
 {
 	struct ath11k_vif *arvif;
@@ -877,7 +721,6 @@ int ath11k_reg_handle_chan_list(struct ath11k_base *ab,
 				enum ieee80211_ap_reg_power power_type)
 {
 	struct ieee80211_regdomain *regd;
-	bool intersect = false;
 	int pdev_idx;
 	struct ath11k *ar;
 	enum wmi_vdev_type vdev_type;
@@ -929,24 +772,14 @@ int ath11k_reg_handle_chan_list(struct ath11k_base *ab,
 		    (char *)reg_info->alpha2, 2))
 		goto retfail;
 
-	/* Intersect new rules with default regd if a new country setting was
-	 * requested, i.e a default regd was already set during initialization
-	 * and the regd coming from this event has a valid country info.
-	 */
-	if (ab->default_regd[pdev_idx] &&
-	    !ath11k_reg_is_world_alpha((char *)
-		ab->default_regd[pdev_idx]->alpha2) &&
-	    !ath11k_reg_is_world_alpha((char *)reg_info->alpha2))
-		intersect = true;
-
 	ar = ab->pdevs[pdev_idx].ar;
 	vdev_type = ath11k_reg_get_ar_vdev_type(ar);
 
 	ath11k_dbg(ab, ATH11K_DBG_WMI,
-		   "wmi handle chan list power type %d vdev type %d intersect %d\n",
-		   power_type, vdev_type, intersect);
+		   "wmi handle chan list power type %d vdev type %d\n",
+		   power_type, vdev_type);
 
-	regd = ath11k_reg_build_regd(ab, reg_info, intersect, vdev_type, power_type);
+	regd = ath11k_reg_build_regd(ab, reg_info, vdev_type, power_type);
 	if (!regd) {
 		ath11k_warn(ab, "failed to build regd from reg_info\n");
 		goto fallback;
diff --git a/drivers/net/wireless/ath/ath11k/reg.h b/drivers/net/wireless/ath/ath11k/reg.h
index 72b4835..3ed95f8 100644
--- a/drivers/net/wireless/ath/ath11k/reg.h
+++ b/drivers/net/wireless/ath/ath11k/reg.h
@@ -36,7 +36,7 @@ void ath11k_regd_update_work(struct work_struct *work);
 void ath11k_regd_update_chan_list_work(struct work_struct *work);
 struct ieee80211_regdomain *
 ath11k_reg_build_regd(struct ath11k_base *ab,
-		      struct cur_regulatory_info *reg_info, bool intersect,
+		      struct cur_regulatory_info *reg_info,
 		      enum wmi_vdev_type vdev_type,
 		      enum ieee80211_ap_reg_power power_type);
 int ath11k_regd_update(struct ath11k *ar);
diff --git a/drivers/net/wireless/ath/ath11k/thermal.h b/drivers/net/wireless/ath/ath11k/thermal.h
index cdaf4e0..be102bc 100644
--- a/drivers/net/wireless/ath/ath11k/thermal.h
+++ b/drivers/net/wireless/ath/ath11k/thermal.h
@@ -26,7 +26,7 @@ struct ath11k_thermal {
 	int temperature;
 };
 
-#if IS_REACHABLE(CONFIG_THERMAL)
+#if IS_REACHABLE(CPTCFG_ATH11K_THERMAL)
 int ath11k_thermal_register(struct ath11k_base *ab);
 void ath11k_thermal_unregister(struct ath11k_base *ab);
 int ath11k_thermal_set_throttling(struct ath11k *ar, u32 throttle_state);
diff --git a/drivers/net/wireless/ath/ath11k/trace.h b/drivers/net/wireless/ath/ath11k/trace.h
index 7e7b25d..ae4860d 100644
--- a/drivers/net/wireless/ath/ath11k/trace.h
+++ b/drivers/net/wireless/ath/ath11k/trace.h
@@ -48,8 +48,13 @@ TRACE_EVENT(ath11k_htt_pktlog,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		__entry->buf_len = buf_len;
 		__entry->pktlog_checksum = pktlog_checksum;
 		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
@@ -77,8 +82,13 @@ TRACE_EVENT(ath11k_htt_ppdu_stats,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		__entry->len = len;
 		memcpy(__get_dynamic_array(ppdu), data, len);
 	),
@@ -105,8 +115,13 @@ TRACE_EVENT(ath11k_htt_rxdesc,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		__entry->len = len;
 		__entry->log_type = log_type;
 		memcpy(__get_dynamic_array(rxdesc), data, len);
@@ -130,8 +145,13 @@ DECLARE_EVENT_CLASS(ath11k_log_event,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+#endif
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk(
@@ -171,8 +191,13 @@ TRACE_EVENT(ath11k_wmi_cmd,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+#endif
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -201,8 +226,13 @@ TRACE_EVENT(ath11k_wmi_event,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+#endif
 		__entry->id = id;
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
@@ -230,8 +260,13 @@ TRACE_EVENT(ath11k_log_dbg,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+#endif
 		__entry->level = level;
 		WARN_ON_ONCE(vsnprintf(__get_dynamic_array(msg),
 				       ATH11K_MSG_MAX, vaf->fmt,
@@ -262,10 +297,17 @@ TRACE_EVENT(ath11k_log_dbg_dump,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
 		__assign_str(msg);
 		__assign_str(prefix);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+		__assign_str(msg, msg);
+		__assign_str(prefix, prefix);
+#endif
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
@@ -292,8 +334,13 @@ TRACE_EVENT(ath11k_wmi_diag,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+#endif
 		__entry->len = len;
 		memcpy(__get_dynamic_array(data), data, len);
 	),
@@ -318,8 +365,14 @@ TRACE_EVENT(ath11k_ps_timekeeper,
 			 __field(u32, peer_ps_timestamp)
 	),
 
-	TP_fast_assign(__assign_str(device);
+	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
+		       __assign_str(device);
 		       __assign_str(driver);
+#else
+		       __assign_str(device, dev_name(ar->ab->dev));
+		       __assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		       memcpy(__get_dynamic_array(peer_addr), peer_addr,
 			      ETH_ALEN);
 		       __entry->peer_ps_state = peer_ps_state;
diff --git a/drivers/net/wireless/ath/ath12k/ce.h b/drivers/net/wireless/ath/ath12k/ce.h
index 57f7589..1d13fb8 100644
--- a/drivers/net/wireless/ath/ath12k/ce.h
+++ b/drivers/net/wireless/ath/ath12k/ce.h
@@ -159,7 +159,7 @@ struct ath12k_ce_pipe {
 	void (*send_cb)(struct ath12k_ce_pipe *pipe);
 	void (*recv_cb)(struct ath12k_base *ab, struct sk_buff *skb);
 
-	struct work_struct intr_wq;
+	struct tasklet_struct intr_tq;
 	struct ath12k_ce_ring *src_ring;
 	struct ath12k_ce_ring *dest_ring;
 	struct ath12k_ce_ring *status_ring;
diff --git a/drivers/net/wireless/ath/ath12k/mac.c b/drivers/net/wireless/ath/ath12k/mac.c
index a979e14..2f6ef0f 100644
--- a/drivers/net/wireless/ath/ath12k/mac.c
+++ b/drivers/net/wireless/ath/ath12k/mac.c
@@ -7723,9 +7723,7 @@ static void ath12k_mac_setup_ht_vht_cap(struct ath12k *ar,
 						    rate_cap_rx_chainmask);
 	}
 
-	if (cap->supported_bands & WMI_HOST_WLAN_5GHZ_CAP &&
-	    (ar->ab->hw_params->single_pdev_only ||
-	     !ar->supports_6ghz)) {
+	if (cap->supported_bands & WMI_HOST_WLAN_5GHZ_CAP) {
 		band = &ar->mac.sbands[NL80211_BAND_5GHZ];
 		ht_cap = cap->band[NL80211_BAND_5GHZ].ht_cap_info;
 		if (ht_cap_info)
diff --git a/drivers/net/wireless/ath/ath12k/pci.c b/drivers/net/wireless/ath/ath12k/pci.c
index ece51b0..0453d26 100644
--- a/drivers/net/wireless/ath/ath12k/pci.c
+++ b/drivers/net/wireless/ath/ath12k/pci.c
@@ -279,6 +279,9 @@ static void ath12k_pci_enable_ltssm(struct ath12k_base *ab)
 	u32 val;
 	int i;
 
+	/* Prevent startup crash on BPI-Rx */
+	return;
+
 	val = ath12k_pci_read32(ab, PCIE_PCIE_PARF_LTSSM);
 
 	/* PCIE link seems very unstable after the Hot Reset*/
@@ -427,9 +430,9 @@ static void ath12k_pci_sync_ce_irqs(struct ath12k_base *ab)
 	}
 }
 
-static void ath12k_pci_ce_workqueue(struct work_struct *work)
+static void ath12k_pci_ce_tasklet(struct tasklet_struct *t)
 {
-	struct ath12k_ce_pipe *ce_pipe = from_work(ce_pipe, work, intr_wq);
+	struct ath12k_ce_pipe *ce_pipe = from_tasklet(ce_pipe, t, intr_tq);
 	int irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + ce_pipe->pipe_num;
 
 	ath12k_ce_per_engine_service(ce_pipe->ab, ce_pipe->pipe_num);
@@ -451,7 +454,7 @@ static irqreturn_t ath12k_pci_ce_interrupt_handler(int irq, void *arg)
 
 	disable_irq_nosync(ab->irq_num[irq_idx]);
 
-	queue_work(system_bh_wq, &ce_pipe->intr_wq);
+	tasklet_schedule(&ce_pipe->intr_tq);
 
 	return IRQ_HANDLED;
 }
@@ -681,7 +684,7 @@ static int ath12k_pci_config_irq(struct ath12k_base *ab)
 
 		irq_idx = ATH12K_PCI_IRQ_CE0_OFFSET + i;
 
-		INIT_WORK(&ce_pipe->intr_wq, ath12k_pci_ce_workqueue);
+		tasklet_setup(&ce_pipe->intr_tq, ath12k_pci_ce_tasklet);
 
 		ret = request_irq(irq, ath12k_pci_ce_interrupt_handler,
 				  ab_pci->irq_flags, irq_name[irq_idx],
@@ -964,7 +967,7 @@ static void ath12k_pci_aspm_restore(struct ath12k_pci *ab_pci)
 						   PCI_EXP_LNKCTL_ASPMC);
 }
 
-static void ath12k_pci_cancel_workqueue(struct ath12k_base *ab)
+static void ath12k_pci_kill_tasklets(struct ath12k_base *ab)
 {
 	int i;
 
@@ -974,7 +977,7 @@ static void ath12k_pci_cancel_workqueue(struct ath12k_base *ab)
 		if (ath12k_ce_get_attr_flags(ab, i) & CE_ATTR_DIS_INTR)
 			continue;
 
-		cancel_work_sync(&ce_pipe->intr_wq);
+		tasklet_kill(&ce_pipe->intr_tq);
 	}
 }
 
@@ -982,7 +985,7 @@ static void ath12k_pci_ce_irq_disable_sync(struct ath12k_base *ab)
 {
 	ath12k_pci_ce_irqs_disable(ab);
 	ath12k_pci_sync_ce_irqs(ab);
-	ath12k_pci_cancel_workqueue(ab);
+	ath12k_pci_kill_tasklets(ab);
 }
 
 int ath12k_pci_map_service_to_pipe(struct ath12k_base *ab, u16 service_id,
diff --git a/drivers/net/wireless/ath/ath12k/trace.h b/drivers/net/wireless/ath/ath12k/trace.h
index 8f3aef2..4b9e79c 100644
--- a/drivers/net/wireless/ath/ath12k/trace.h
+++ b/drivers/net/wireless/ath/ath12k/trace.h
@@ -36,8 +36,13 @@ TRACE_EVENT(ath12k_htt_pktlog,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		__entry->buf_len = buf_len;
 		__entry->pktlog_checksum = pktlog_checksum;
 		memcpy(__get_dynamic_array(pktlog), buf, buf_len);
@@ -73,8 +78,13 @@ TRACE_EVENT(ath12k_htt_ppdu_stats,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		__entry->len = len;
 		__entry->info = ar->pdev->timestamp.info;
 		__entry->sync_tstmp_lo_us = ar->pdev->timestamp.sync_timestamp_hi_us;
@@ -117,8 +127,13 @@ TRACE_EVENT(ath12k_htt_rxdesc,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ar->ab->dev));
+		__assign_str(driver, dev_driver_string(ar->ab->dev));
+#endif
 		__entry->len = len;
 		__entry->type = type;
 		__entry->info = ar->pdev->timestamp.info;
@@ -153,8 +168,13 @@ TRACE_EVENT(ath12k_wmi_diag,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(device);
 		__assign_str(driver);
+#else
+		__assign_str(device, dev_name(ab->dev));
+		__assign_str(driver, dev_driver_string(ab->dev));
+#endif
 		__entry->len = len;
 		memcpy(__get_dynamic_array(data), data, len);
 	),
diff --git a/drivers/net/wireless/ath/ath12k/wmi.c b/drivers/net/wireless/ath/ath12k/wmi.c
index 36df9d7..3112ccf 100644
--- a/drivers/net/wireless/ath/ath12k/wmi.c
+++ b/drivers/net/wireless/ath/ath12k/wmi.c
@@ -2891,6 +2891,9 @@ int ath12k_wmi_send_scan_chan_list_cmd(struct ath12k *ar,
 		max_chan_limit = (wmi->wmi_ab->max_msg_len[ar->pdev_idx] - len) /
 			sizeof(*chan_info);
 
+		if (max_chan_limit > WMI_MAX_NUM_CHAN_PER_WMI_CMD)
+			max_chan_limit = WMI_MAX_NUM_CHAN_PER_WMI_CMD;
+
 		num_send_chans = min(arg->nallchans, max_chan_limit);
 
 		arg->nallchans -= num_send_chans;
diff --git a/drivers/net/wireless/ath/ath12k/wmi.h b/drivers/net/wireless/ath/ath12k/wmi.h
index a8c3190..78669ea 100644
--- a/drivers/net/wireless/ath/ath12k/wmi.h
+++ b/drivers/net/wireless/ath/ath12k/wmi.h
@@ -4004,6 +4004,8 @@ struct wmi_stop_scan_cmd {
 	__le32 pdev_id;
 } __packed;
 
+#define WMI_MAX_NUM_CHAN_PER_WMI_CMD	58
+
 struct ath12k_wmi_scan_chan_list_arg {
 	struct list_head list;
 	u32 pdev_id;
diff --git a/drivers/net/wireless/ath/ath5k/ath5k.h b/drivers/net/wireless/ath/ath5k/ath5k.h
index 308a429..0e6d184 100644
--- a/drivers/net/wireless/ath/ath5k/ath5k.h
+++ b/drivers/net/wireless/ath/ath5k/ath5k.h
@@ -1372,6 +1372,7 @@ struct ath5k_hw {
 	u8			ah_coverage_class;
 	bool			ah_ack_bitrate_high;
 	u8			ah_bwmode;
+	u8			ah_bwmode_debug;
 	bool			ah_short_slot;
 
 	/* Antenna Control */
diff --git a/drivers/net/wireless/ath/ath5k/base.c b/drivers/net/wireless/ath/ath5k/base.c
index a9cb132..1e76790 100644
--- a/drivers/net/wireless/ath/ath5k/base.c
+++ b/drivers/net/wireless/ath/ath5k/base.c
@@ -465,6 +465,9 @@ ath5k_chan_set(struct ath5k_hw *ah, struct cfg80211_chan_def *chandef)
 		return -EINVAL;
 	}
 
+	if (ah->ah_bwmode_debug != AR5K_BWMODE_DEFAULT)
+		ah->ah_bwmode = ah->ah_bwmode_debug;
+
 	/*
 	 * To switch channels clear any pending DMA operations;
 	 * wait long enough for the RX fifo to drain, reset the
@@ -2009,7 +2012,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
 	}
 
 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
-			ah->num_mesh_vifs > 1) ||
+			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
 			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
 		u64 tsf = ath5k_hw_get_tsf64(ah);
 		u32 tsftu = TSF_TO_TU(tsf);
@@ -2095,7 +2098,7 @@ ath5k_beacon_update_timers(struct ath5k_hw *ah, u64 bc_tsf)
 
 	intval = ah->bintval & AR5K_BEACON_PERIOD;
 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
-		+ ah->num_mesh_vifs > 1) {
+		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
 		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
 		if (intval < 15)
 			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
@@ -2561,6 +2564,7 @@ static const struct ieee80211_iface_limit if_limits[] = {
 				 BIT(NL80211_IFTYPE_MESH_POINT) |
 #endif
 				 BIT(NL80211_IFTYPE_AP) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 static const struct ieee80211_iface_combination if_comb = {
diff --git a/drivers/net/wireless/ath/ath5k/debug.c b/drivers/net/wireless/ath/ath5k/debug.c
index ec13051..239d789 100644
--- a/drivers/net/wireless/ath/ath5k/debug.c
+++ b/drivers/net/wireless/ath/ath5k/debug.c
@@ -803,6 +803,97 @@ static const struct file_operations fops_ani = {
 	.llseek = default_llseek,
 };
 
+/* debugfs: bwmode */
+
+static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[15];
+	unsigned int len = 0;
+
+	int cur_ah_bwmode = ah->ah_bwmode_debug;
+
+#define print_selected(MODE, LABEL) \
+	if (cur_ah_bwmode == MODE) \
+		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
+	else \
+		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
+	len += snprintf(buf+len, sizeof(buf)-len, " ");
+
+	print_selected(AR5K_BWMODE_5MHZ, "5");
+	print_selected(AR5K_BWMODE_10MHZ, "10");
+	print_selected(AR5K_BWMODE_DEFAULT, "20");
+	print_selected(AR5K_BWMODE_40MHZ, "40");
+#undef print_selected
+
+	len += snprintf(buf+len, sizeof(buf)-len, "\n");
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_bwmode(struct file *file,
+				 const char __user *userbuf,
+				 size_t count, loff_t *ppos)
+{
+	struct ath5k_hw *ah = file->private_data;
+	char buf[3];
+	int bw = 20;
+	int tobwmode = AR5K_BWMODE_DEFAULT;
+
+	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
+		return -EFAULT;
+
+	/* TODO: Add check for active interface */
+
+	if(strncmp(buf, "5", 1) == 0 ) {
+		tobwmode = AR5K_BWMODE_5MHZ;
+		bw = 5;
+	} else if ( strncmp(buf, "10", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_10MHZ;
+		bw = 10;
+	} else if ( strncmp(buf, "20", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_DEFAULT;
+		bw = 20;
+	} else if ( strncmp(buf, "40", 2) == 0 ) {
+		tobwmode = AR5K_BWMODE_40MHZ;
+		bw = 40;
+	} else
+		return -EINVAL;
+
+	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
+		bw, tobwmode);
+
+	switch (ah->ah_radio) {
+	/* TODO: only define radios that actually support 5/10mhz channels */
+	case AR5K_RF5413:
+	case AR5K_RF5110:
+	case AR5K_RF5111:
+	case AR5K_RF5112:
+	case AR5K_RF2413:
+	case AR5K_RF2316:
+	case AR5K_RF2317:
+	case AR5K_RF2425:
+		if(ah->ah_bwmode_debug != tobwmode) {
+			mutex_lock(&ah->lock);
+			ah->ah_bwmode = tobwmode;
+			ah->ah_bwmode_debug = tobwmode;
+			mutex_unlock(&ah->lock);
+		}
+		break;
+	default:
+		return -EOPNOTSUPP;
+	}
+	return count;
+}
+
+static const struct file_operations fops_bwmode = {
+	.read = read_file_bwmode,
+	.write = write_file_bwmode,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
 
 /* debugfs: queues etc */
 
@@ -995,6 +1086,8 @@ ath5k_debug_init_device(struct ath5k_hw *ah)
 	debugfs_create_file("queue", 0600, phydir, ah, &fops_queue);
 	debugfs_create_bool("32khz_clock", 0600, phydir,
 			    &ah->ah_use_32khz_clock);
+	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
+			    &fops_bwmode);
 }
 
 /* functions used in other places */
diff --git a/drivers/net/wireless/ath/ath5k/dma.c b/drivers/net/wireless/ath/ath5k/dma.c
index d9e376e..db06ff8 100644
--- a/drivers/net/wireless/ath/ath5k/dma.c
+++ b/drivers/net/wireless/ath/ath5k/dma.c
@@ -854,10 +854,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
 	 * guess we can tweak it and see how it goes ;-)
 	 */
 	if (ah->ah_version != AR5K_AR5210) {
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
 			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
 		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
 			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_128B);
+#else
+		/* WAR for AR71xx PCI bug */
+		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
+			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
+		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
+			AR5K_RXCFG_SDMAMW, AR5K_DMASIZE_4B);
+#endif
 	}
 
 	/* Pre-enable interrupts on 5211/5212*/
diff --git a/drivers/net/wireless/ath/ath5k/initvals.c b/drivers/net/wireless/ath/ath5k/initvals.c
index ee1c2fa..122fe1c 100644
--- a/drivers/net/wireless/ath/ath5k/initvals.c
+++ b/drivers/net/wireless/ath/ath5k/initvals.c
@@ -62,8 +62,14 @@ static const struct ath5k_ini ar5210_ini[] = {
 	{ AR5K_IMR,		0 },
 	{ AR5K_IER,		AR5K_IER_DISABLE },
 	{ AR5K_BSR,		0, AR5K_INI_READ },
+#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
 	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
 	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
+#else
+	/* WAR for AR71xx PCI bug */
+	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
+	{ AR5K_RXCFG,		AR5K_DMASIZE_4B },
+#endif
 	{ AR5K_CFG,		AR5K_INIT_CFG },
 	{ AR5K_TOPS,		8 },
 	{ AR5K_RXNOFRM,		8 },
diff --git a/drivers/net/wireless/ath/ath5k/mac80211-ops.c b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
index eca8145..e405a6f 100644
--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
@@ -86,13 +86,8 @@ ath5k_add_interface(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
 		goto end;
 	}
 
-	/* Don't allow other interfaces if one ad-hoc is configured.
-	 * TODO: Fix the problems with ad-hoc and multiple other interfaces.
-	 * We would need to operate the HW in ad-hoc mode to allow TSF updates
-	 * for the IBSS, but this breaks with additional AP or STA interfaces
-	 * at the moment. */
-	if (ah->num_adhoc_vifs ||
-	    (ah->nvifs && vif->type == NL80211_IFTYPE_ADHOC)) {
+	/* Don't allow more than one ad-hoc interface */
+	if (ah->num_adhoc_vifs && vif->type == NL80211_IFTYPE_ADHOC) {
 		ATH5K_ERR(ah, "Only one single ad-hoc interface is allowed.\n");
 		ret = -ELNRNG;
 		goto end;
diff --git a/drivers/net/wireless/ath/ath5k/pci.c b/drivers/net/wireless/ath/ath5k/pci.c
index f5ca2fe..111d2d4 100644
--- a/drivers/net/wireless/ath/ath5k/pci.c
+++ b/drivers/net/wireless/ath/ath5k/pci.c
@@ -20,6 +20,7 @@
 #include <linux/pci.h>
 #include <linux/etherdevice.h>
 #include <linux/module.h>
+#include <linux/ath5k_platform.h>
 #include "../ath.h"
 #include "ath5k.h"
 #include "debug.h"
@@ -73,7 +74,7 @@ static void ath5k_pci_read_cachesize(struct ath_common *common, int *csz)
 }
 
 /*
- * Read from eeprom
+ * Read from eeprom or platform_data
  */
 static bool
 ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
@@ -81,6 +82,19 @@ ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
 	struct ath5k_hw *ah = common->ah;
 	u32 status, timeout;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
+		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS)
+			return false;
+
+		*data = pdata->eeprom_data[offset];
+		return true;
+	}
+
 	/*
 	 * Initialize EEPROM access
 	 */
@@ -124,6 +138,16 @@ static int ath5k_pci_eeprom_read_mac(struct ath5k_hw *ah, u8 *mac)
 	u16 data;
 	int octet;
 
+	struct ath5k_platform_data *pdata = NULL;
+
+	if (ah->pdev)
+		pdata = ah->pdev->dev.platform_data;
+
+	if (pdata && pdata->macaddr) {
+		memcpy(mac, pdata->macaddr, ETH_ALEN);
+		return 0;
+	}
+
 	AR5K_EEPROM_READ(0x20, data);
 
 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff --git a/drivers/net/wireless/ath/ath5k/reset.c b/drivers/net/wireless/ath/ath5k/reset.c
index c67f163..9e1aeee 100644
--- a/drivers/net/wireless/ath/ath5k/reset.c
+++ b/drivers/net/wireless/ath/ath5k/reset.c
@@ -1154,6 +1154,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	tsf_lo = 0;
 	mode = 0;
 
+#if 0
 	/*
 	 * Sanity check for fast flag
 	 * Fast channel change only available
@@ -1161,6 +1162,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum nl80211_iftype op_mode,
 	 */
 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
 	(ah->ah_radio != AR5K_RF5413))
+#endif
 		fast = false;
 
 	/* Disable sleep clock operation
diff --git a/drivers/net/wireless/ath/ath6kl/trace.h b/drivers/net/wireless/ath/ath6kl/trace.h
index def9c1d..5da454f 100644
--- a/drivers/net/wireless/ath/ath6kl/trace.h
+++ b/drivers/net/wireless/ath/ath6kl/trace.h
@@ -304,8 +304,13 @@ TRACE_EVENT(ath6kl_log_dbg_dump,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(msg);
 		__assign_str(prefix);
+#else
+		__assign_str(msg, msg);
+		__assign_str(prefix, prefix);
+#endif
 		__entry->buf_len = buf_len;
 		memcpy(__get_dynamic_array(buf), buf, buf_len);
 	),
diff --git a/drivers/net/wireless/ath/ath9k/Kconfig b/drivers/net/wireless/ath/ath9k/Kconfig
index b97598f..d3e72a8 100644
--- a/drivers/net/wireless/ath/ath9k/Kconfig
+++ b/drivers/net/wireless/ath/ath9k/Kconfig
@@ -58,6 +58,19 @@ config ATH9K_AHB
 	  Say Y, if you have a SoC with a compatible built-in
 	  wireless MAC. Say N if unsure.
 
+config ATH9K_UBNTHSR
+	bool "Ubiquiti UniFi Outdoor Plus HSR support"
+	depends on ATH9K
+	---help---
+	  This options enables code to control the HSR RF
+	  filter in the receive path of the Ubiquiti UniFi
+	  Outdoor Plus access point.
+
+	  Say Y if you want to use the access point. The
+	  code will only be used if the device is detected,
+	  so it does not harm other setup other than occupying
+	  a bit of memory.
+
 config ATH9K_DEBUGFS
 	bool "Atheros ath9k debugging"
 	depends on ATH9K && DEBUG_FS && MAC80211_DEBUGFS
diff --git a/drivers/net/wireless/ath/ath9k/Makefile b/drivers/net/wireless/ath/ath9k/Makefile
index 847c8a8..6427bc6 100644
--- a/drivers/net/wireless/ath/ath9k/Makefile
+++ b/drivers/net/wireless/ath/ath9k/Makefile
@@ -17,6 +17,7 @@ ath9k-$(CPTCFG_ATH9K_DFS_CERTIFIED) += dfs.o
 ath9k-$(CPTCFG_ATH9K_TX99) += tx99.o
 ath9k-$(CPTCFG_ATH9K_WOW) += wow.o
 ath9k-$(CPTCFG_ATH9K_HWRNG) += rng.o
+ath9k-$(CPTCFG_ATH9K_UBNTHSR) += hsr.o
 
 ath9k-$(CPTCFG_ATH9K_DEBUGFS) += debug.o
 
diff --git a/drivers/net/wireless/ath/ath9k/ani.h b/drivers/net/wireless/ath/ath9k/ani.h
index c40965b..f66f7ed 100644
--- a/drivers/net/wireless/ath/ath9k/ani.h
+++ b/drivers/net/wireless/ath/ath9k/ani.h
@@ -42,7 +42,7 @@
 #define ATH9K_ANI_PERIOD                  300
 
 /* in ms */
-#define ATH9K_ANI_POLLINTERVAL            1000
+#define ATH9K_ANI_POLLINTERVAL            300
 
 #define ATH9K_SIG_FIRSTEP_SETTING_MIN     0
 #define ATH9K_SIG_FIRSTEP_SETTING_MAX     20
diff --git a/drivers/net/wireless/ath/ath9k/ar5008_phy.c b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
index 7a45f5f..3f0ca1d 100644
--- a/drivers/net/wireless/ath/ath9k/ar5008_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar5008_phy.c
@@ -969,55 +969,6 @@ static bool ar5008_hw_ani_control_new(struct ath_hw *ah,
 		 * on == 0 means more noise imm
 		 */
 		u32 on = param ? 1 : 0;
-		/*
-		 * make register setting for default
-		 * (weak sig detect ON) come from INI file
-		 */
-		int m1ThreshLow = on ?
-			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
-		int m2ThreshLow = on ?
-			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
-		int m1Thresh = on ?
-			aniState->iniDef.m1Thresh : m1Thresh_off;
-		int m2Thresh = on ?
-			aniState->iniDef.m2Thresh : m2Thresh_off;
-		int m2CountThr = on ?
-			aniState->iniDef.m2CountThr : m2CountThr_off;
-		int m2CountThrLow = on ?
-			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
-		int m1ThreshLowExt = on ?
-			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
-		int m2ThreshLowExt = on ?
-			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
-		int m1ThreshExt = on ?
-			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
-		int m2ThreshExt = on ?
-			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
-			      m1ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
-			      m2ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M1_THRESH, m1Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2_THRESH, m2Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2COUNT_THR, m2CountThr);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
-			      m2CountThrLow);
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW, m1ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW, m2ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH, m1ThreshExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH, m2ThreshExt);
 
 		if (on)
 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
@@ -1340,9 +1291,30 @@ void ar5008_hw_init_rate_txpower(struct ath_hw *ah, int16_t *rate_array,
 	}
 }
 
+static void ar5008_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
+{
+	int i, j;
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST, AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST, AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST2, AR_PHY_TEST2_RX_OBS_SEL, 0);
+
+	memset(buf, 0, len);
+	for (i = 0; i < len; i++) {
+		for (j = 0; j < 4; j++) {
+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
+
+			buf[i] <<= 2;
+			buf[i] |= (regval & 1) | ((regval & BIT(9)) >> 8);
+			udelay(1);
+		}
+	}
+}
+
 int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
 {
 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
+	struct ath_hw_ops *ops = ath9k_hw_ops(ah);
 	static const u32 ar5416_cca_regs[6] = {
 		AR_PHY_CCA,
 		AR_PHY_CH1_CCA,
@@ -1357,6 +1329,8 @@ int ar5008_hw_attach_phy_ops(struct ath_hw *ah)
 	if (ret)
 	    return ret;
 
+	ops->get_adc_entropy = ar5008_hw_get_adc_entropy;
+
 	priv_ops->rf_set_freq = ar5008_hw_set_channel;
 	priv_ops->spur_mitigate_freq = ar5008_hw_spur_mitigate;
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9002_phy.h b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
index 2b58245..d20a936 100644
--- a/drivers/net/wireless/ath/ath9k/ar9002_phy.h
+++ b/drivers/net/wireless/ath/ath9k/ar9002_phy.h
@@ -20,6 +20,12 @@
 #define PHY_AGC_CLR             0x10000000
 #define RFSILENT_BB             0x00002000
 
+#define AR_PHY_TEST_BBB_OBS_SEL       0x780000
+#define AR_PHY_TEST_BBB_OBS_SEL_S     19
+
+#define AR_PHY_TEST_RX_OBS_SEL_BIT5_S 23
+#define AR_PHY_TEST_RX_OBS_SEL_BIT5   (1 << AR_PHY_TEST_RX_OBS_SEL_BIT5_S)
+
 #define AR_PHY_TURBO                0x9804
 #define AR_PHY_FC_TURBO_MODE        0x00000001
 #define AR_PHY_FC_TURBO_SHORT       0x00000002
@@ -36,6 +42,9 @@
 
 #define AR_PHY_TEST2			0x9808
 
+#define AR_PHY_TEST2_RX_OBS_SEL        0x3C00
+#define AR_PHY_TEST2_RX_OBS_SEL_S      10
+
 #define AR_PHY_TIMING2           0x9810
 #define AR_PHY_TIMING3           0x9814
 #define AR_PHY_TIMING3_DSC_MAN   0xFFFE0000
@@ -393,6 +402,8 @@
 #define AR_PHY_RFBUS_GRANT       0x9C20
 #define AR_PHY_RFBUS_GRANT_EN    0x00000001
 
+#define AR_PHY_TST_ADC      0x9C24
+
 #define AR_PHY_CHAN_INFO_GAIN_DIFF             0x9CF4
 #define AR_PHY_CHAN_INFO_GAIN_DIFF_UPPER_LIMIT 320
 
diff --git a/drivers/net/wireless/ath/ath9k/ar9003_phy.c b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
index f715149..0246ad0 100644
--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
@@ -42,20 +42,6 @@ static const int cycpwrThr1_table[] =
 /* level:  0   1   2   3   4   5   6   7   8  */
 	{ -6, -4, -2,  0,  2,  4,  6,  8 };     /* lvl 0-7, default 3 */
 
-/*
- * register values to turn OFDM weak signal detection OFF
- */
-static const int m1ThreshLow_off = 127;
-static const int m2ThreshLow_off = 127;
-static const int m1Thresh_off = 127;
-static const int m2Thresh_off = 127;
-static const int m2CountThr_off =  31;
-static const int m2CountThrLow_off =  63;
-static const int m1ThreshLowExt_off = 127;
-static const int m2ThreshLowExt_off = 127;
-static const int m1ThreshExt_off = 127;
-static const int m2ThreshExt_off = 127;
-
 static const u8 ofdm2pwr[] = {
 	ALL_TARGET_LEGACY_6_24,
 	ALL_TARGET_LEGACY_6_24,
@@ -1065,11 +1051,6 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_channel *chan = ah->curchan;
 	struct ar5416AniState *aniState = &ah->ani;
-	int m1ThreshLow, m2ThreshLow;
-	int m1Thresh, m2Thresh;
-	int m2CountThr, m2CountThrLow;
-	int m1ThreshLowExt, m2ThreshLowExt;
-	int m1ThreshExt, m2ThreshExt;
 	s32 value, value2;
 
 	switch (cmd & ah->ani_function) {
@@ -1083,61 +1064,6 @@ static bool ar9003_hw_ani_control(struct ath_hw *ah,
 		 */
 		u32 on = param ? 1 : 0;
 
-		if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
-			goto skip_ws_det;
-
-		m1ThreshLow = on ?
-			aniState->iniDef.m1ThreshLow : m1ThreshLow_off;
-		m2ThreshLow = on ?
-			aniState->iniDef.m2ThreshLow : m2ThreshLow_off;
-		m1Thresh = on ?
-			aniState->iniDef.m1Thresh : m1Thresh_off;
-		m2Thresh = on ?
-			aniState->iniDef.m2Thresh : m2Thresh_off;
-		m2CountThr = on ?
-			aniState->iniDef.m2CountThr : m2CountThr_off;
-		m2CountThrLow = on ?
-			aniState->iniDef.m2CountThrLow : m2CountThrLow_off;
-		m1ThreshLowExt = on ?
-			aniState->iniDef.m1ThreshLowExt : m1ThreshLowExt_off;
-		m2ThreshLowExt = on ?
-			aniState->iniDef.m2ThreshLowExt : m2ThreshLowExt_off;
-		m1ThreshExt = on ?
-			aniState->iniDef.m1ThreshExt : m1ThreshExt_off;
-		m2ThreshExt = on ?
-			aniState->iniDef.m2ThreshExt : m2ThreshExt_off;
-
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M1_THRESH_LOW,
-			      m1ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2_THRESH_LOW,
-			      m2ThreshLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M1_THRESH,
-			      m1Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2_THRESH,
-			      m2Thresh);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR,
-			      AR_PHY_SFCORR_M2COUNT_THR,
-			      m2CountThr);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_LOW,
-			      AR_PHY_SFCORR_LOW_M2COUNT_THR_LOW,
-			      m2CountThrLow);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH_LOW,
-			      m1ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH_LOW,
-			      m2ThreshLowExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M1_THRESH,
-			      m1ThreshExt);
-		REG_RMW_FIELD(ah, AR_PHY_SFCORR_EXT,
-			      AR_PHY_SFCORR_EXT_M2_THRESH,
-			      m2ThreshExt);
-skip_ws_det:
 		if (on)
 			REG_SET_BIT(ah, AR_PHY_SFCORR_LOW,
 				    AR_PHY_SFCORR_LOW_USE_SELF_CORR_LOW);
@@ -1915,6 +1841,26 @@ void ar9003_hw_init_rate_txpower(struct ath_hw *ah, u8 *rate_array,
 	}
 }
 
+static void ar9003_hw_get_adc_entropy(struct ath_hw *ah, u8 *buf, size_t len)
+{
+	int i, j;
+
+	REG_RMW_FIELD(ah, AR_PHY_TEST(ah), AR_PHY_TEST_BBB_OBS_SEL, 1);
+	REG_CLR_BIT(ah, AR_PHY_TEST(ah), AR_PHY_TEST_RX_OBS_SEL_BIT5);
+	REG_RMW_FIELD(ah, AR_PHY_TEST_CTL_STATUS(ah), AR_PHY_TEST_CTL_RX_OBS_SEL, 0);
+
+	memset(buf, 0, len);
+	for (i = 0; i < len; i++) {
+		for (j = 0; j < 4; j++) {
+			u32 regval = REG_READ(ah, AR_PHY_TST_ADC);
+
+			buf[i] <<= 2;
+			buf[i] |= (regval & 1) | ((regval & BIT(10)) >> 9);
+			udelay(1);
+		}
+	}
+}
+
 void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 {
 	struct ath_hw_private_ops *priv_ops = ath9k_hw_private_ops(ah);
@@ -1951,6 +1897,7 @@ void ar9003_hw_attach_phy_ops(struct ath_hw *ah)
 	priv_ops->set_radar_params = ar9003_hw_set_radar_params;
 	priv_ops->fast_chan_change = ar9003_hw_fast_chan_change;
 
+	ops->get_adc_entropy = ar9003_hw_get_adc_entropy;
 	ops->antdiv_comb_conf_get = ar9003_hw_antdiv_comb_conf_get;
 	ops->antdiv_comb_conf_set = ar9003_hw_antdiv_comb_conf_set;
 	ops->spectral_scan_config = ar9003_hw_spectral_scan_config;
diff --git a/drivers/net/wireless/ath/ath9k/ath9k.h b/drivers/net/wireless/ath/ath9k/ath9k.h
index bf8a1db..5dbe680 100644
--- a/drivers/net/wireless/ath/ath9k/ath9k.h
+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
@@ -25,6 +25,8 @@
 #include <linux/completion.h>
 #include <linux/time.h>
 #include <linux/hw_random.h>
+#include <linux/gpio/driver.h>
+#include <linux/gpio/consumer.h>
 
 #include "common.h"
 #include "debug.h"
@@ -90,7 +92,7 @@ int ath_descdma_setup(struct ath_softc *sc, struct ath_descdma *dd,
 		(_l) &= ((_sz) - 1);		\
 	} while (0)
 
-#define ATH_RXBUF               512
+#define ATH_RXBUF               256
 #define ATH_TXBUF               512
 #define ATH_TXBUF_RESERVE       5
 #define ATH_TXMAXTRY            13
@@ -844,6 +846,9 @@ static inline int ath9k_dump_btcoex(struct ath_softc *sc, u8 *buf, u32 size)
 #ifdef CPTCFG_MAC80211_LEDS
 void ath_init_leds(struct ath_softc *sc);
 void ath_deinit_leds(struct ath_softc *sc);
+int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
+			const char *trigger, bool active_low);
+
 #else
 static inline void ath_init_leds(struct ath_softc *sc)
 {
@@ -980,6 +985,13 @@ void ath_ant_comb_scan(struct ath_softc *sc, struct ath_rx_status *rs);
 
 #define ATH9K_NUM_CHANCTX  2 /* supports 2 operating channels */
 
+struct ath_led {
+	struct list_head list;
+	struct ath_softc *sc;
+	const struct gpio_led *gpio;
+	struct led_classdev cdev;
+};
+
 struct ath_softc {
 	struct ieee80211_hw *hw;
 	struct device *dev;
@@ -1035,9 +1047,12 @@ struct ath_softc {
 	spinlock_t chan_lock;
 
 #ifdef CPTCFG_MAC80211_LEDS
-	bool led_registered;
-	char led_name[32];
-	struct led_classdev led_cdev;
+	const char *led_default_trigger;
+	struct list_head leds;
+#ifdef CONFIG_GPIOLIB
+	struct gpio_chip *gpiochip;
+	struct gpio_desc *gpiodesc;
+#endif
 #endif
 
 #ifdef CPTCFG_ATH9K_DEBUGFS
diff --git a/drivers/net/wireless/ath/ath9k/channel.c b/drivers/net/wireless/ath/ath9k/channel.c
index 11cad30..c352625 100644
--- a/drivers/net/wireless/ath/ath9k/channel.c
+++ b/drivers/net/wireless/ath/ath9k/channel.c
@@ -15,6 +15,7 @@
  */
 
 #include "ath9k.h"
+#include "hsr.h"
 
 /* Set/change channels.  If the channel is really being changed, it's done
  * by resetting the chip.  To accomplish this we must first cleanup any pending
@@ -22,6 +23,7 @@
  */
 static int ath_set_channel(struct ath_softc *sc)
 {
+	struct device_node *np = sc->dev->of_node;
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ieee80211_hw *hw = sc->hw;
@@ -42,6 +44,11 @@ static int ath_set_channel(struct ath_softc *sc)
 	ath_dbg(common, CONFIG, "Set channel: %d MHz width: %d\n",
 		chan->center_freq, chandef->width);
 
+	if (of_property_read_bool(np, "ubnt,hsr")) {
+		ath9k_hsr_enable(ah, chandef->width, chan->center_freq);
+		ath9k_hsr_status(ah);
+	}
+
 	/* update survey stats for the old channel before switching */
 	spin_lock_irqsave(&common->cc_lock, flags);
 	ath_update_survey_stats(sc);
diff --git a/drivers/net/wireless/ath/ath9k/common-debug.c b/drivers/net/wireless/ath/ath9k/common-debug.c
index 1ea0702..0207d89 100644
--- a/drivers/net/wireless/ath/ath9k/common-debug.c
+++ b/drivers/net/wireless/ath/ath9k/common-debug.c
@@ -261,3 +261,110 @@ void ath9k_cmn_debug_phy_err(struct dentry *debugfs_phy,
 			    &fops_phy_err);
 }
 EXPORT_SYMBOL(ath9k_cmn_debug_phy_err);
+
+static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_hw *ah = file->private_data;
+	struct ath_common *common = ath9k_hw_common(ah);
+	int bytes = 0;
+	int pos = *ppos;
+	int size = 4096;
+	u16 val;
+	int i;
+
+	if (AR_SREV_9300_20_OR_LATER(ah))
+		size = 16384;
+
+	if (*ppos < 0)
+		return -EINVAL;
+
+	if (count > size - *ppos)
+		count = size - *ppos;
+
+	for (i = *ppos / 2; count > 0; count -= bytes, *ppos += bytes, i++) {
+		void *from = &val;
+
+		if (!common->bus_ops->eeprom_read(common, i, &val))
+			val = 0xffff;
+
+		if (*ppos % 2) {
+			from++;
+			bytes = 1;
+		} else if (count == 1) {
+			bytes = 1;
+		} else {
+			bytes = 2;
+		}
+		if (copy_to_user(user_buf, from, bytes))
+			return -EFAULT;
+		user_buf += bytes;
+	}
+	return *ppos - pos;
+}
+
+static const struct file_operations fops_eeprom = {
+	.read = read_file_eeprom,
+	.open = simple_open,
+	.owner = THIS_MODULE
+};
+
+void ath9k_cmn_debug_eeprom(struct dentry *debugfs_phy,
+			    struct ath_hw *ah)
+{
+	debugfs_create_file("eeprom", S_IRUSR, debugfs_phy, ah,
+			    &fops_eeprom);
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_eeprom);
+
+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_hw *ah = file->private_data;
+	struct ath_common *common = ath9k_hw_common(ah);
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08x\n", common->chan_bw);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_hw *ah = file->private_data;
+	struct ath_common *common = ath9k_hw_common(ah);
+	unsigned long chan_bw;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &chan_bw))
+		return -EINVAL;
+
+	common->chan_bw = chan_bw;
+	if (!test_bit(ATH_OP_INVALID, &common->op_flags))
+		common->ieee_ops->config(ah->hw, -1, IEEE80211_CONF_CHANGE_CHANNEL);
+
+	return count;
+}
+
+static const struct file_operations fops_chanbw = {
+	.read = read_file_chan_bw,
+	.write = write_file_chan_bw,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+void ath9k_cmn_debug_chanbw(struct dentry *debugfs_phy,
+			    struct ath_hw *ah)
+{
+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, debugfs_phy, ah,
+			    &fops_chanbw);
+}
+EXPORT_SYMBOL(ath9k_cmn_debug_chanbw);
diff --git a/drivers/net/wireless/ath/ath9k/common-debug.h b/drivers/net/wireless/ath/ath9k/common-debug.h
index 54f4c42..7a8b7ed 100644
--- a/drivers/net/wireless/ath/ath9k/common-debug.h
+++ b/drivers/net/wireless/ath/ath9k/common-debug.h
@@ -69,6 +69,10 @@ void ath9k_cmn_debug_modal_eeprom(struct dentry *debugfs_phy,
 				  struct ath_hw *ah);
 void ath9k_cmn_debug_base_eeprom(struct dentry *debugfs_phy,
 				 struct ath_hw *ah);
+void ath9k_cmn_debug_eeprom(struct dentry *debugfs_phy,
+			    struct ath_hw *ah);
+void ath9k_cmn_debug_chanbw(struct dentry *debugfs_phy,
+			    struct ath_hw *ah);
 void ath9k_cmn_debug_stat_rx(struct ath_rx_stats *rxstats,
 			     struct ath_rx_status *rs);
 void ath9k_cmn_debug_recv(struct dentry *debugfs_phy,
diff --git a/drivers/net/wireless/ath/ath9k/common.c b/drivers/net/wireless/ath/ath9k/common.c
index ffcf227..1be435c 100644
--- a/drivers/net/wireless/ath/ath9k/common.c
+++ b/drivers/net/wireless/ath/ath9k/common.c
@@ -298,11 +298,13 @@ EXPORT_SYMBOL(ath9k_cmn_get_hw_crypto_keytype);
 /*
  * Update internal channel flags.
  */
-static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
+static void ath9k_cmn_update_ichannel(struct ath_common *common,
+				      struct ath9k_channel *ichan,
 				      struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_channel *chan = chandef->chan;
 	u16 flags = 0;
+	int width;
 
 	ichan->channel = chan->center_freq;
 	ichan->chan = chan;
@@ -310,7 +312,19 @@ static void ath9k_cmn_update_ichannel(struct ath9k_channel *ichan,
 	if (chan->band == NL80211_BAND_5GHZ)
 		flags |= CHANNEL_5GHZ;
 
-	switch (chandef->width) {
+	switch (common->chan_bw) {
+	case 5:
+		width = NL80211_CHAN_WIDTH_5;
+		break;
+	case 10:
+		width = NL80211_CHAN_WIDTH_10;
+		break;
+	default:
+		width = chandef->width;
+		break;
+	}
+
+	switch (width) {
 	case NL80211_CHAN_WIDTH_5:
 		flags |= CHANNEL_QUARTER;
 		break;
@@ -343,10 +357,11 @@ struct ath9k_channel *ath9k_cmn_get_channel(struct ieee80211_hw *hw,
 					    struct cfg80211_chan_def *chandef)
 {
 	struct ieee80211_channel *curchan = chandef->chan;
+	struct ath_common *common = ath9k_hw_common(ah);
 	struct ath9k_channel *channel;
 
 	channel = &ah->channels[curchan->hw_value];
-	ath9k_cmn_update_ichannel(channel, chandef);
+	ath9k_cmn_update_ichannel(common, channel, chandef);
 
 	return channel;
 }
diff --git a/drivers/net/wireless/ath/ath9k/debug.c b/drivers/net/wireless/ath/ath9k/debug.c
index 4e65562..5d50e4d 100644
--- a/drivers/net/wireless/ath/ath9k/debug.c
+++ b/drivers/net/wireless/ath/ath9k/debug.c
@@ -123,6 +123,61 @@ static const struct file_operations fops_debug = {
 
 #define DMA_BUF_LEN 1024
 
+#ifdef CONFIG_MAC80211_LEDS
+
+static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
+				   size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	char buf[32], *str, *name, *c;
+	ssize_t len;
+	unsigned int gpio;
+	bool active_low = false;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, ubuf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	name = strchr(buf, ',');
+	if (!name)
+		return -EINVAL;
+
+	*(name++) = 0;
+	if (!*name)
+		return -EINVAL;
+
+	c = strchr(name, '\n');
+	if (c)
+		*c = 0;
+
+	str = buf;
+	if (*str == '!') {
+		str++;
+		active_low = true;
+	}
+
+	if (kstrtouint(str, 0, &gpio) < 0)
+		return -EINVAL;
+
+	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
+		return -EINVAL;
+
+	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static const struct file_operations fops_gpio_led = {
+	.write = write_file_gpio_led,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+#endif
+
 
 static ssize_t read_file_ani(struct file *file, char __user *user_buf,
 			     size_t count, loff_t *ppos)
@@ -1374,6 +1429,50 @@ void ath9k_deinit_debug(struct ath_softc *sc)
 	ath9k_cmn_spectral_deinit_debug(&sc->spec_priv);
 }
 
+static ssize_t read_file_diag(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	char buf[32];
+	unsigned int len;
+
+	len = sprintf(buf, "0x%08lx\n", ah->diag);
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t write_file_diag(struct file *file, const char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	unsigned long diag;
+	char buf[32];
+	ssize_t len;
+
+	len = min(count, sizeof(buf) - 1);
+	if (copy_from_user(buf, user_buf, len))
+		return -EFAULT;
+
+	buf[len] = '\0';
+	if (kstrtoul(buf, 0, &diag))
+		return -EINVAL;
+
+	ah->diag = diag;
+	ath9k_hw_update_diag(ah);
+
+	return count;
+}
+
+static const struct file_operations fops_diag = {
+	.read = read_file_diag,
+	.write = write_file_diag,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};
+
+
 int ath9k_init_debug(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -1391,6 +1490,12 @@ int ath9k_init_debug(struct ath_hw *ah)
 	ath9k_tx99_init_debug(sc);
 	ath9k_cmn_spectral_init_debug(&sc->spec_priv, sc->debug.debugfs_phy);
 
+#ifdef CONFIG_MAC80211_LEDS
+	debugfs_create_file("gpio_led", S_IWUSR,
+			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
+#endif
+	debugfs_create_file("diag", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
+			    sc, &fops_diag);
 	debugfs_create_devm_seqfile(sc->dev, "dma", sc->debug.debugfs_phy,
 				    read_file_dma);
 	debugfs_create_devm_seqfile(sc->dev, "interrupt", sc->debug.debugfs_phy,
@@ -1430,6 +1535,8 @@ int ath9k_init_debug(struct ath_hw *ah)
 
 	ath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
 	ath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+	ath9k_cmn_debug_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
+	ath9k_cmn_debug_chanbw(sc->debug.debugfs_phy, sc->sc_ah);
 
 	debugfs_create_u32("gpio_mask", 0600,
 			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
diff --git a/drivers/net/wireless/ath/ath9k/gpio.c b/drivers/net/wireless/ath/ath9k/gpio.c
index 55e91c8..55ac6a9 100644
--- a/drivers/net/wireless/ath/ath9k/gpio.c
+++ b/drivers/net/wireless/ath/ath9k/gpio.c
@@ -16,12 +16,120 @@
 
 #include "ath9k.h"
 
+#ifdef CPTCFG_MAC80211_LEDS
+
+#ifdef CONFIG_GPIOLIB
+
+/***************/
+/*  GPIO Chip  */
+/***************/
+
+/* gpio_chip handler : set GPIO to input */
+static int ath9k_gpio_pin_cfg_input(struct gpio_chip *chip, unsigned offset)
+{
+	struct ath_softc *sc = gpiochip_get_data(chip);
+
+	ath9k_hw_gpio_request_in(sc->sc_ah, offset, "ath9k-gpio");
+
+	return 0;
+}
+
+/* gpio_chip handler : set GPIO to output */
+static int ath9k_gpio_pin_cfg_output(struct gpio_chip *chip, unsigned offset,
+				     int value)
+{
+	struct ath_softc *sc = gpiochip_get_data(chip);
+
+	ath9k_hw_gpio_request_out(sc->sc_ah, offset, "ath9k-gpio",
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_set_gpio(sc->sc_ah, offset, value);
+
+	return 0;
+}
+
+/* gpio_chip handler : query GPIO direction (0=out, 1=in) */
+static int ath9k_gpio_pin_get_dir(struct gpio_chip *chip, unsigned offset)
+{
+	struct ath_softc *sc = gpiochip_get_data(chip);
+	struct ath_hw *ah = sc->sc_ah;
+
+	return !((REG_READ(ah, AR_GPIO_OE_OUT(ah)) >> (offset * 2)) & 3);
+}
+
+/* gpio_chip handler : get GPIO pin value */
+static int ath9k_gpio_pin_get(struct gpio_chip *chip, unsigned offset)
+{
+	struct ath_softc *sc = gpiochip_get_data(chip);
+
+	return ath9k_hw_gpio_get(sc->sc_ah, offset);
+}
+
+/* gpio_chip handler : set GPIO pin to value */
+static void ath9k_gpio_pin_set(struct gpio_chip *chip, unsigned offset,
+			       int value)
+{
+	struct ath_softc *sc = gpiochip_get_data(chip);
+
+	ath9k_hw_set_gpio(sc->sc_ah, offset, value);
+}
+
+/* register GPIO chip */
+static void ath9k_register_gpio_chip(struct ath_softc *sc)
+{
+	struct gpio_chip *gc = sc->gpiochip;
+	struct ath_hw *ah = sc->sc_ah;
+
+	gc = kzalloc(sizeof(struct gpio_chip), GFP_KERNEL);
+	if (!gc)
+		return;
+
+	gc->label = kasprintf(GFP_KERNEL, "ath9k-%s",
+			wiphy_name(sc->hw->wiphy));
+	gc->parent = sc->dev;
+	gc->base = -1;	/* determine base automatically */
+	gc->ngpio = ah->caps.num_gpio_pins;
+	gc->direction_input = ath9k_gpio_pin_cfg_input;
+	gc->direction_output = ath9k_gpio_pin_cfg_output;
+	gc->get_direction = ath9k_gpio_pin_get_dir;
+	gc->get = ath9k_gpio_pin_get;
+	gc->set = ath9k_gpio_pin_set;
+
+	if (gpiochip_add_data(gc, sc)) {
+		kfree(gc->label);
+		kfree(gc);
+		return;
+	}
+}
+
+/* remove GPIO chip */
+static void ath9k_unregister_gpio_chip(struct ath_softc *sc)
+{
+	struct gpio_chip *gc = sc->gpiochip;
+
+	if (!gc)
+		return;
+
+	gpiochip_remove(gc);
+	kfree(gc->label);
+	kfree(gc);
+}
+
+#else /* CONFIG_GPIOLIB */
+
+static inline void ath9k_register_gpio_chip(struct ath_softc *sc)
+{
+}
+
+static inline void ath9k_unregister_gpio_chip(struct ath_softc *sc)
+{
+}
+
+#endif /* CONFIG_GPIOLIB */
+
 /********************************/
 /*	 LED functions		*/
 /********************************/
 
-#ifdef CPTCFG_MAC80211_LEDS
-
 static void ath_fill_led_pin(struct ath_softc *sc)
 {
 	struct ath_hw *ah = sc->sc_ah;
@@ -39,61 +147,136 @@ static void ath_fill_led_pin(struct ath_softc *sc)
 		else
 			ah->led_pin = ATH_LED_PIN_DEF;
 	}
+}
+
+static void ath_led_brightness(struct led_classdev *led_cdev,
+			       enum led_brightness brightness)
+{
+	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
+	struct ath_softc *sc = led->sc;
+
+	ath9k_ps_wakeup(sc);
+	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
+			  (brightness != LED_OFF) ^ led->gpio->active_low);
+	ath9k_ps_restore(sc);
+}
+
+static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
+{
+	const struct gpio_led *gpio = led->gpio;
+	int ret;
+
+	led->cdev.name = gpio->name;
+	led->cdev.default_trigger = gpio->default_trigger;
+	led->cdev.brightness_set = ath_led_brightness;
+
+	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
+	if (ret < 0)
+		return ret;
+
+	led->sc = sc;
+	list_add(&led->list, &sc->leds);
 
 	/* Configure gpio for output */
-	ath9k_hw_gpio_request_out(ah, ah->led_pin, "ath9k-led",
+	ath9k_hw_gpio_request_out(sc->sc_ah, gpio->gpio, gpio->name,
 				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 
-	/* LED off, active low */
-	ath9k_hw_set_gpio(ah, ah->led_pin, ah->config.led_active_high ? 0 : 1);
+	/* Set default LED state */
+	if (gpio->default_state == LEDS_GPIO_DEFSTATE_ON)
+		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, !gpio->active_low);
+	else
+		ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
+
+#ifdef CONFIG_GPIOLIB
+	/* If there is GPIO chip configured, reserve LED pin */
+	if (sc->gpiochip)
+		sc->gpiodesc = gpiod_get(sc->dev, gpio->name, GPIOD_ASIS);
+#endif
+
+	return 0;
 }
 
-static void ath_led_brightness(struct led_classdev *led_cdev,
-			       enum led_brightness brightness)
+int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
+			const char *trigger, bool active_low)
 {
-	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
-	u32 val = (brightness == LED_OFF);
+	struct ath_led *led;
+	struct gpio_led *gpio;
+	char *_name;
+	int ret;
 
-	if (sc->sc_ah->config.led_active_high)
-		val = !val;
+	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
+		      GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
 
-	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, val);
+	led->gpio = gpio = (struct gpio_led *) (led + 1);
+	_name = (char *) (led->gpio + 1);
+
+	strcpy(_name, name);
+	gpio->name = _name;
+	gpio->gpio = gpio_num;
+	gpio->active_low = active_low;
+	gpio->default_trigger = trigger;
+
+	ret = ath_add_led(sc, led);
+	if (unlikely(ret < 0))
+		kfree(led);
+
+	return ret;
 }
 
 void ath_deinit_leds(struct ath_softc *sc)
 {
-	if (!sc->led_registered)
-		return;
-
-	ath_led_brightness(&sc->led_cdev, LED_OFF);
-	led_classdev_unregister(&sc->led_cdev);
-
-	ath9k_hw_gpio_free(sc->sc_ah, sc->sc_ah->led_pin);
+	struct ath_led *led;
+
+	while (!list_empty(&sc->leds)) {
+		led = list_first_entry(&sc->leds, struct ath_led, list);
+#ifdef CONFIG_GPIOLIB
+		/* If there is GPIO chip configured, free LED pin */
+		if (sc->gpiochip)
+			gpiod_put(sc->gpiodesc);
+#endif
+		list_del(&led->list);
+		ath_led_brightness(&led->cdev, LED_OFF);
+		led_classdev_unregister(&led->cdev);
+		ath9k_hw_gpio_free(sc->sc_ah, led->gpio->gpio);
+		kfree(led);
+	}
+	ath9k_unregister_gpio_chip(sc);
 }
 
 void ath_init_leds(struct ath_softc *sc)
 {
-	int ret;
+	struct device_node *np = sc->dev->of_node;
+	char led_name[32];
+	const char *trigger;
+
+	INIT_LIST_HEAD(&sc->leds);
 
 	if (AR_SREV_9100(sc->sc_ah))
 		return;
 
-	ath_fill_led_pin(sc);
+	if (!np)
+		ath9k_register_gpio_chip(sc);
+
+	/* setup gpio controller only if requested and skip the led_pin setup */
+	if (of_property_read_bool(np, "gpio-controller")) {
+		ath9k_register_gpio_chip(sc);
+		return;
+	}
 
-	if (!ath9k_led_blink)
-		sc->led_cdev.default_trigger =
-			ieee80211_get_radio_led_name(sc->hw);
+	ath_fill_led_pin(sc);
 
-	snprintf(sc->led_name, sizeof(sc->led_name),
-		"ath9k-%s", wiphy_name(sc->hw->wiphy));
-	sc->led_cdev.name = sc->led_name;
-	sc->led_cdev.brightness_set = ath_led_brightness;
+	snprintf(led_name, sizeof(led_name), "ath9k-%s",
+		 wiphy_name(sc->hw->wiphy));
 
-	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
-	if (ret < 0)
-		return;
+	if (ath9k_led_blink)
+		trigger = sc->led_default_trigger;
+	else
+		trigger = ieee80211_get_radio_led_name(sc->hw);
 
-	sc->led_registered = true;
+	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger,
+			   !sc->sc_ah->config.led_active_high);
 }
 #endif
 
diff --git a/drivers/net/wireless/ath/ath9k/hsr.c b/drivers/net/wireless/ath/ath9k/hsr.c
new file mode 100644
index 0000000..79eec5c
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/hsr.c
@@ -0,0 +1,248 @@
+/*
+ *
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2015 Kirill Berezin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ *
+ */
+
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/time.h>
+#include <linux/bitops.h>
+#include <linux/etherdevice.h>
+#include <linux/rtnetlink.h>
+#include <asm/unaligned.h>
+
+#include "hw.h"
+#include "ath9k.h"
+#include "hsr.h"
+
+#define HSR_GPIO_CSN 8
+#define HSR_GPIO_CLK 6
+#define HSR_GPIO_DOUT 7
+#define HSR_GPIO_DIN 5
+
+/* delays are in useconds */
+#define HSR_DELAY_HALF_TICK 100
+#define HSR_DELAY_PRE_WRITE 75
+#define HSR_DELAY_FINAL 20000
+#define HSR_DELAY_TRAILING 200
+
+void ath9k_hsr_init(struct ath_hw *ah)
+{
+	ath9k_hw_gpio_request_in(ah, HSR_GPIO_DIN, NULL);
+	ath9k_hw_gpio_request_out(ah, HSR_GPIO_CSN, NULL,
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_gpio_request_out(ah, HSR_GPIO_CLK, NULL,
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+	ath9k_hw_gpio_request_out(ah, HSR_GPIO_DOUT, NULL,
+				  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CSN, 1);
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 0);
+	ath9k_hw_set_gpio(ah, HSR_GPIO_DOUT, 0);
+
+	udelay(HSR_DELAY_TRAILING);
+}
+
+static u32 ath9k_hsr_write_byte(struct ath_hw *ah, int delay, u32 value)
+{
+	struct ath_common *common = ath9k_hw_common(ah);
+	int i;
+	u32 rval = 0;
+
+	udelay(delay);
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 0);
+	udelay(HSR_DELAY_HALF_TICK);
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CSN, 0);
+	udelay(HSR_DELAY_HALF_TICK);
+
+	for (i = 0; i < 8; ++i) {
+		rval = rval << 1;
+
+		/* pattern is left to right, that is 7-th bit runs first */
+		ath9k_hw_set_gpio(ah, HSR_GPIO_DOUT, (value >> (7 - i)) & 0x1);
+		udelay(HSR_DELAY_HALF_TICK);
+
+		ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 1);
+		udelay(HSR_DELAY_HALF_TICK);
+
+		rval |= ath9k_hw_gpio_get(ah, HSR_GPIO_DIN);
+
+		ath9k_hw_set_gpio(ah, HSR_GPIO_CLK, 0);
+		udelay(HSR_DELAY_HALF_TICK);
+	}
+
+	ath9k_hw_set_gpio(ah, HSR_GPIO_CSN, 1);
+	udelay(HSR_DELAY_HALF_TICK);
+
+	ath_dbg(common, CONFIG, "ath9k_hsr_write_byte: write byte %d return value is %d %c\n",
+		value, rval, rval > 32 ? rval : '-');
+
+	return rval & 0xff;
+}
+
+static int ath9k_hsr_write_a_chain(struct ath_hw *ah, char *chain, int items)
+{
+	int status = 0;
+	int i = 0;
+	int err;
+
+	/* a preamble */
+	ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+	status = ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+
+	/* clear HSR's reply buffer */
+	if (status) {
+		int loop = 0;
+
+		for (loop = 0; (loop < 42) && status; ++loop)
+			status = ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE,
+						      0);
+
+		if (loop >= 42) {
+			ATH_DBG_WARN(1,
+				     "ath9k_hsr_write_a_chain: can't clear an output buffer after a 42 cycles.\n");
+			return -1;
+		}
+	}
+
+	for (i = 0; (i < items) && (chain[i] != 0); ++i)
+		ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, (u32)chain[i]);
+
+	ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+	mdelay(HSR_DELAY_FINAL / 1000);
+
+	/* reply */
+	memset(chain, 0, items);
+
+	ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+	udelay(HSR_DELAY_TRAILING);
+
+	for (i = 0; i < (items - 1); ++i) {
+		u32 ret;
+
+		ret = ath9k_hsr_write_byte(ah, HSR_DELAY_PRE_WRITE, 0);
+		if (ret != 0)
+			chain[i] = (char)ret;
+		else
+			break;
+
+		udelay(HSR_DELAY_TRAILING);
+	}
+
+	if (i <= 1)
+		return 0;
+
+	err = kstrtoint(chain + 1, 10, &i);
+	if (err)
+		return err;
+
+	return i;
+}
+
+int ath9k_hsr_disable(struct ath_hw *ah)
+{
+	char cmd[10] = {'b', '4', '0', 0, 0, 0, 0, 0, 0, 0};
+	int ret;
+
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if ((ret > 0) && (*cmd == 'B'))
+		return 0;
+
+	return -1;
+}
+
+int ath9k_hsr_enable(struct ath_hw *ah, int bw, int fq)
+{
+	char cmd[10];
+	int ret;
+
+	/* Bandwidth argument is 0 sometimes. Assume default 802.11bgn
+	 * 20MHz on invalid values
+	 */
+	if ((bw != 5) && (bw != 10) && (bw != 20) && (bw != 40))
+		bw = 20;
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'b';
+	snprintf(cmd + 1, 3, "%02d", bw);
+
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if ((*cmd != 'B') || (ret != bw)) {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed changing bandwidth -> set (%d,%d) reply (%d, %d)\n",
+			     'b', bw, *cmd, ret);
+		return -1;
+	}
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'x';
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if (*cmd != 'X') {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed 'x' command -> reply (%d, %d)\n",
+			     *cmd, ret);
+		return -1;
+	}
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'm';
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if (*cmd != 'M') {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed 'm' command -> reply (%d, %d)\n",
+			     *cmd, ret);
+		return  -1;
+	}
+
+	memset(cmd, 0, sizeof(cmd));
+	*cmd = 'f';
+	snprintf(cmd + 1, 6, "%05d", fq);
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if ((*cmd != 'F') && (ret != fq)) {
+		ATH_DBG_WARN(1,
+			     "ath9k_hsr_enable: failed set frequency -> reply (%d, %d)\n",
+			     *cmd, ret);
+		return -1;
+	}
+
+	return 0;
+}
+
+int ath9k_hsr_status(struct ath_hw *ah)
+{
+	char cmd[10] = {'s', 0, 0, 0, 0, 0, 0, 0, 0, 0};
+	int ret;
+
+	ret = ath9k_hsr_write_a_chain(ah, cmd, sizeof(cmd));
+	if (*cmd != 'S') {
+		ATH_DBG_WARN(1, "ath9k_hsr_status: returned %d,%d\n", *cmd,
+			     ret);
+		return -1;
+	}
+
+	return 0;
+}
diff --git a/drivers/net/wireless/ath/ath9k/hsr.h b/drivers/net/wireless/ath/ath9k/hsr.h
new file mode 100644
index 0000000..d45fc52
--- /dev/null
+++ b/drivers/net/wireless/ath/ath9k/hsr.h
@@ -0,0 +1,50 @@
+/*
+ * The MIT License (MIT)
+ *
+ * Copyright (c) 2015 Kirill Berezin
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a copy
+ * of this software and associated documentation files (the "Software"), to deal
+ * in the Software without restriction, including without limitation the rights
+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+ * copies of the Software, and to permit persons to whom the Software is
+ * furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+
+#ifndef HSR_H
+#define HSR_H
+
+ struct ath_hw;
+
+#ifdef CPTCFG_ATH9K_UBNTHSR
+
+void ath9k_hsr_init(struct ath_hw *ah);
+int ath9k_hsr_disable(struct ath_hw *ah);
+int ath9k_hsr_enable(struct ath_hw *ah, int bw, int fq);
+int ath9k_hsr_status(struct ath_hw *ah);
+
+#else
+static inline void ath9k_hsr_init(struct ath_hw *ah) {}
+
+static inline int ath9k_hsr_enable(struct ath_hw *ah, int bw, int fq)
+{
+	return 0;
+}
+
+static inline int ath9k_hsr_disable(struct ath_hw *ah) { return 0; }
+static inline int ath9k_hsr_status(struct ath_hw *ah) { return 0; }
+
+#endif
+
+#endif /* HSR_H */
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
index 9437d69..7f761f4 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_debug.c
@@ -512,6 +512,8 @@ int ath9k_htc_init_debug(struct ath_hw *ah)
 
 	ath9k_cmn_debug_base_eeprom(priv->debug.debugfs_phy, priv->ah);
 	ath9k_cmn_debug_modal_eeprom(priv->debug.debugfs_phy, priv->ah);
+	ath9k_cmn_debug_eeprom(priv->debug.debugfs_phy, priv->ah);
+	ath9k_cmn_debug_chanbw(priv->debug.debugfs_phy, priv->ah);
 
 	return 0;
 }
diff --git a/drivers/net/wireless/ath/ath9k/htc_drv_init.c b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
index fa02d9a..53e49b6 100644
--- a/drivers/net/wireless/ath/ath9k/htc_drv_init.c
+++ b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
@@ -631,6 +631,7 @@ static int ath9k_init_priv(struct ath9k_htc_priv *priv,
 	priv->ah = ah;
 
 	common = ath9k_hw_common(ah);
+	common->ieee_ops = &ath9k_htc_ops;
 	common->ops = &ah->reg_ops;
 	common->ps_ops = &ath9k_htc_ps_ops;
 	common->bus_ops = &ath9k_usb_bus_ops;
@@ -746,9 +747,9 @@ static void ath9k_set_hw_capab(struct ath9k_htc_priv *priv,
 
 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN |
 			    WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL |
-			    WIPHY_FLAG_HAS_CHANNEL_SWITCH;
-
-	hw->wiphy->flags |= WIPHY_FLAG_SUPPORTS_TDLS;
+			    WIPHY_FLAG_HAS_CHANNEL_SWITCH |
+			    WIPHY_FLAG_SUPPORTS_5_10_MHZ |
+			    WIPHY_FLAG_SUPPORTS_TDLS;
 
 	hw->queues = 4;
 	hw->max_listen_interval = 1;
diff --git a/drivers/net/wireless/ath/ath9k/hw-ops.h b/drivers/net/wireless/ath/ath9k/hw-ops.h
index 174d716..605abe1 100644
--- a/drivers/net/wireless/ath/ath9k/hw-ops.h
+++ b/drivers/net/wireless/ath/ath9k/hw-ops.h
@@ -100,6 +100,12 @@ static inline void ath9k_hw_tx99_set_txpower(struct ath_hw *ah, u8 power)
 		ath9k_hw_ops(ah)->tx99_set_txpower(ah, power);
 }
 
+static inline void ath9k_hw_get_adc_entropy(struct ath_hw *ah,
+		u8 *buf, size_t len)
+{
+	ath9k_hw_ops(ah)->get_adc_entropy(ah, buf, len);
+}
+
 #ifdef CPTCFG_ATH9K_BTCOEX_SUPPORT
 
 static inline void ath9k_hw_set_bt_ant_diversity(struct ath_hw *ah, bool enable)
diff --git a/drivers/net/wireless/ath/ath9k/hw.c b/drivers/net/wireless/ath/ath9k/hw.c
index 8e439f2..27d411b 100644
--- a/drivers/net/wireless/ath/ath9k/hw.c
+++ b/drivers/net/wireless/ath/ath9k/hw.c
@@ -21,7 +21,7 @@
 #include <linux/time.h>
 #include <linux/bitops.h>
 #include <linux/etherdevice.h>
-#include <linux/gpio.h>
+#include <linux/gpio/consumer.h>
 #include <linux/unaligned.h>
 
 #include "hw.h"
@@ -248,6 +248,19 @@ void ath9k_hw_get_channel_centers(struct ath_hw *ah,
 		centers->synth_center + (extoff * HT40_CHANNEL_CENTER_SHIFT);
 }
 
+static inline void ath9k_hw_disable_pll_lock_detect(struct ath_hw *ah)
+{
+	/* On AR9330 and AR9340 devices, some PHY registers must be
+	 * tuned to gain better stability/performance. These registers
+	 * might be changed while doing wlan reset so the registers must
+	 * be reprogrammed after each reset.
+	 */
+	REG_CLR_BIT(ah, AR_PHY_USB_CTRL1, BIT(20));
+	REG_RMW(ah, AR_PHY_USB_CTRL2,
+		(1 << 21) | (0xf << 22),
+		(1 << 21) | (0x3 << 22));
+}
+
 /******************/
 /* Chip Revisions */
 /******************/
@@ -403,13 +416,8 @@ static void ath9k_hw_init_config(struct ath_hw *ah)
 
 	ah->config.rx_intr_mitigation = true;
 
-	if (AR_SREV_9300_20_OR_LATER(ah)) {
-		ah->config.rimt_last = 500;
-		ah->config.rimt_first = 2000;
-	} else {
-		ah->config.rimt_last = 250;
-		ah->config.rimt_first = 700;
-	}
+	ah->config.rimt_last = 250;
+	ah->config.rimt_first = 500;
 
 	if (AR_SREV_9462(ah) || AR_SREV_9565(ah))
 		ah->config.pll_pwrsave = 7;
@@ -668,6 +676,7 @@ int ath9k_hw_init(struct ath_hw *ah)
 
 	/* These are all the AR5008/AR9001/AR9002/AR9003 hardware family of chipsets */
 	switch (ah->hw_version.devid) {
+	case AR9300_DEVID_INVALID:
 	case AR5416_DEVID_PCI:
 	case AR5416_DEVID_PCIE:
 	case AR5416_AR9100_DEVID:
@@ -1312,39 +1321,56 @@ void ath9k_hw_get_delta_slope_vals(struct ath_hw *ah, u32 coef_scaled,
 	*coef_exponent = coef_exp - 16;
 }
 
-/* AR9330 WAR:
- * call external reset function to reset WMAC if:
- * - doing a cold reset
- * - we have pending frames in the TX queues.
- */
-static bool ath9k_hw_ar9330_reset_war(struct ath_hw *ah, int type)
+static bool ath9k_hw_need_external_reset(struct ath_hw *ah, int type)
 {
-	int i, npend = 0;
+	int i;
 
-	for (i = 0; i < AR_NUM_QCU; i++) {
-		npend = ath9k_hw_numtxpending(ah, i);
-		if (npend)
-			break;
+	if (type == ATH9K_RESET_COLD)
+		return true;
+
+	if (AR_SREV_9550(ah))
+		return true;
+
+	/* AR9330 WAR:
+	 * call external reset function to reset WMAC if:
+	 * - doing a cold reset
+	 * - we have pending frames in the TX queues.
+	 */
+	if (AR_SREV_9330(ah)) {
+		for (i = 0; i < AR_NUM_QCU; i++) {
+			if (ath9k_hw_numtxpending(ah, i))
+				return true;
+		}
 	}
 
-	if (ah->external_reset &&
-	    (npend || type == ATH9K_RESET_COLD)) {
-		int reset_err = 0;
+	return false;
+}
 
-		ath_dbg(ath9k_hw_common(ah), RESET,
-			"reset MAC via external reset\n");
+static bool ath9k_hw_external_reset(struct ath_hw *ah, int type)
+{
+	int err;
 
-		reset_err = ah->external_reset();
-		if (reset_err) {
-			ath_err(ath9k_hw_common(ah),
-				"External reset failed, err=%d\n",
-				reset_err);
-			return false;
-		}
+	if (!ah->external_reset || !ath9k_hw_need_external_reset(ah, type))
+		return true;
+
+	ath_dbg(ath9k_hw_common(ah), RESET,
+		"reset MAC via external reset\n");
+
+	err = ah->external_reset();
+	if (err) {
+		ath_err(ath9k_hw_common(ah),
+			"External reset failed, err=%d\n", err);
+		return false;
+	}
 
-		REG_WRITE(ah, AR_RTC_RESET(ah), 1);
+	if (AR_SREV_9550(ah)) {
+		REG_WRITE(ah, AR_RTC_RESET(ah), 0);
+		udelay(10);
 	}
 
+	REG_WRITE(ah, AR_RTC_RESET(ah), 1);
+	udelay(10);
+
 	return true;
 }
 
@@ -1397,24 +1423,24 @@ static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
 			rst_flags |= AR_RTC_RC_MAC_COLD;
 	}
 
-	if (AR_SREV_9330(ah)) {
-		if (!ath9k_hw_ar9330_reset_war(ah, type))
-			return false;
-	}
-
 	if (ath9k_hw_mci_is_enabled(ah))
 		ar9003_mci_check_gpm_offset(ah);
 
 	/* DMA HALT added to resolve ar9300 and ar9580 bus error during
-	 * RTC_RC reg read
+	 * RTC_RC reg read. Also needed for AR9550 external reset
 	 */
-	if (AR_SREV_9300(ah) || AR_SREV_9580(ah)) {
+	if (AR_SREV_9300(ah) || AR_SREV_9580(ah) || AR_SREV_9550(ah)) {
 		REG_SET_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 		ath9k_hw_wait(ah, AR_CFG, AR_CFG_HALT_ACK, AR_CFG_HALT_ACK,
 			      20 * AH_WAIT_TIMEOUT);
-		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
 	}
 
+	if (!AR_SREV_9100(ah))
+		ath9k_hw_external_reset(ah, type);
+
+	if (AR_SREV_9300(ah) || AR_SREV_9580(ah))
+		REG_CLR_BIT(ah, AR_CFG, AR_CFG_HALT_REQ);
+
 	REG_WRITE(ah, AR_RTC_RC(ah), rst_flags);
 
 	REGWRITE_BUFFER_FLUSH(ah);
@@ -1435,8 +1461,15 @@ static bool ath9k_hw_set_reset(struct ath_hw *ah, int type)
 	if (!AR_SREV_9100(ah))
 		REG_WRITE(ah, AR_RC, 0);
 
-	if (AR_SREV_9100(ah))
+	if (AR_SREV_9100(ah)) {
+		/* Reset the AHB-WMAC interface */
+		if (ah->external_reset)
+			ah->external_reset();
 		udelay(50);
+	}
+
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
 
 	return true;
 }
@@ -1537,6 +1570,9 @@ static bool ath9k_hw_chip_reset(struct ath_hw *ah,
 		ar9003_hw_internal_regulator_apply(ah);
 	ath9k_hw_init_pll(ah, chan);
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return true;
 }
 
@@ -1843,8 +1879,14 @@ static int ath9k_hw_do_fastcc(struct ath_hw *ah, struct ath9k_channel *chan)
 	if (AR_SREV_9271(ah))
 		ar9002_hw_load_ani_reg(ah, chan);
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return 0;
 fail:
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return -EINVAL;
 }
 
@@ -1856,6 +1898,20 @@ u32 ath9k_hw_get_tsf_offset(ktime_t last, ktime_t cur)
 }
 EXPORT_SYMBOL(ath9k_hw_get_tsf_offset);
 
+void ath9k_hw_update_diag(struct ath_hw *ah)
+{
+	if (test_bit(ATH_DIAG_DISABLE_RX, &ah->diag))
+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+	else
+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_DIS);
+
+	if (test_bit(ATH_DIAG_DISABLE_TX, &ah->diag))
+		REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
+	else
+		REG_CLR_BIT(ah, AR_DIAG_SW, AR_DIAG_LOOP_BACK);
+}
+EXPORT_SYMBOL(ath9k_hw_update_diag);
+
 int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 		   struct ath9k_hw_cal_data *caldata, bool fastcc)
 {
@@ -2064,6 +2120,7 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 		ar9003_hw_disable_phy_restart(ah);
 
 	ath9k_hw_apply_gpio_override(ah);
+	ath9k_hw_update_diag(ah);
 
 	if (AR_SREV_9565(ah) && common->bt_ant_diversity)
 		REG_SET_BIT(ah, AR_BTCOEX_WL_LNADIV, AR_BTCOEX_WL_LNADIV_FORCE_ON);
@@ -2074,6 +2131,9 @@ int ath9k_hw_reset(struct ath_hw *ah, struct ath9k_channel *chan,
 		ath9k_hw_set_radar_params(ah);
 	}
 
+	if (AR_SREV_9330(ah) || AR_SREV_9340(ah))
+		ath9k_hw_disable_pll_lock_detect(ah);
+
 	return 0;
 }
 EXPORT_SYMBOL(ath9k_hw_reset);
@@ -2719,19 +2779,25 @@ static void ath9k_hw_gpio_cfg_output_mux(struct ath_hw *ah, u32 gpio, u32 type)
 static void ath9k_hw_gpio_cfg_soc(struct ath_hw *ah, u32 gpio, bool out,
 				  const char *label)
 {
+	enum gpiod_flags flags = out ? GPIOD_OUT_LOW : GPIOD_IN;
+	struct gpio_desc *gpiod;
 	int err;
 
-	if (ah->caps.gpio_requested & BIT(gpio))
+	if (ah->gpiods[gpio])
 		return;
 
-	err = devm_gpio_request_one(ah->dev, gpio, out ? GPIOF_OUT_INIT_LOW : GPIOF_IN, label);
-	if (err) {
+	/* Obtains a system specific GPIO descriptor from another GPIO controller */
+	gpiod = gpiod_get_index(NULL, "ath9k", gpio, flags);
+
+	if (IS_ERR(gpiod)) {
+		err = PTR_ERR(gpiod);
 		ath_err(ath9k_hw_common(ah), "request GPIO%d failed:%d\n",
 			gpio, err);
 		return;
 	}
 
-	ah->caps.gpio_requested |= BIT(gpio);
+	gpiod_set_consumer_name(gpiod, label);
+	ah->gpiods[gpio] = gpiod;
 }
 
 static void ath9k_hw_gpio_cfg_wmac(struct ath_hw *ah, u32 gpio, bool out,
@@ -2793,8 +2859,10 @@ void ath9k_hw_gpio_free(struct ath_hw *ah, u32 gpio)
 
 	WARN_ON(gpio >= ah->caps.num_gpio_pins);
 
-	if (ah->caps.gpio_requested & BIT(gpio))
-		ah->caps.gpio_requested &= ~BIT(gpio);
+	if (ah->gpiods[gpio]) {
+		gpiod_put(ah->gpiods[gpio]);
+		ah->gpiods[gpio] = NULL;
+	}
 }
 EXPORT_SYMBOL(ath9k_hw_gpio_free);
 
@@ -2822,8 +2890,8 @@ u32 ath9k_hw_gpio_get(struct ath_hw *ah, u32 gpio)
 			val = REG_READ(ah, AR_GPIO_IN(ah)) & BIT(gpio);
 		else
 			val = MS_REG_READ(AR, gpio);
-	} else if (BIT(gpio) & ah->caps.gpio_requested) {
-		val = gpio_get_value(gpio) & BIT(gpio);
+	} else if (ah->gpiods[gpio]) {
+		val = gpiod_get_value(ah->gpiods[gpio]);
 	} else {
 		WARN_ON(1);
 	}
@@ -2846,8 +2914,8 @@ void ath9k_hw_set_gpio(struct ath_hw *ah, u32 gpio, u32 val)
 			AR7010_GPIO_OUT : AR_GPIO_IN_OUT(ah);
 
 		REG_RMW(ah, out_addr, val << gpio, BIT(gpio));
-	} else if (BIT(gpio) & ah->caps.gpio_requested) {
-		gpio_set_value(gpio, val);
+	} else if (ah->gpiods[gpio]) {
+		gpiod_set_value(ah->gpiods[gpio], val);
 	} else {
 		WARN_ON(1);
 	}
@@ -2946,7 +3014,8 @@ void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,
 {
 	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
 	struct ieee80211_channel *channel;
-	int chan_pwr, new_pwr;
+	int chan_pwr, new_pwr, max_gain;
+	int ant_gain, ant_reduction = 0;
 	u16 ctl = NO_CTL;
 
 	if (!chan)
@@ -2958,9 +3027,18 @@ void ath9k_hw_apply_txpower(struct ath_hw *ah, struct ath9k_channel *chan,
 	channel = chan->chan;
 	chan_pwr = min_t(int, channel->max_power * 2, MAX_COMBINED_POWER);
 	new_pwr = min_t(int, chan_pwr, reg->power_limit);
+	max_gain = chan_pwr - new_pwr + channel->max_antenna_gain * 2;
+
+	ant_gain = get_antenna_gain(ah, chan);
+	if (ant_gain > max_gain)
+		ant_reduction = ant_gain - max_gain;
+
+	/* FCC allows maximum antenna gain of 6 dBi */
+	if (reg->region == NL80211_DFS_FCC)
+		ant_reduction = max_t(int, ant_reduction - 12, 0);
 
 	ah->eep_ops->set_txpower(ah, chan, ctl,
-				 get_antenna_gain(ah, chan), new_pwr, test);
+				 ant_reduction, new_pwr, test);
 }
 
 void ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)
diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h
index 9287bf6..4ad3bb7 100644
--- a/drivers/net/wireless/ath/ath9k/hw.h
+++ b/drivers/net/wireless/ath/ath9k/hw.h
@@ -19,6 +19,7 @@
 
 #include <linux/if_ether.h>
 #include <linux/delay.h>
+#include <linux/gpio/consumer.h>
 #include <linux/io.h>
 #include <linux/firmware.h>
 
@@ -36,6 +37,7 @@
 
 #define ATHEROS_VENDOR_ID	0x168c
 
+#define AR9300_DEVID_INVALID	0xabcd
 #define AR5416_DEVID_PCI	0x0023
 #define AR5416_DEVID_PCIE	0x0024
 #define AR9160_DEVID_PCI	0x0027
@@ -302,7 +304,6 @@ struct ath9k_hw_capabilities {
 	u8 max_rxchains;
 	u8 num_gpio_pins;
 	u32 gpio_mask;
-	u32 gpio_requested;
 	u8 rx_hp_qdepth;
 	u8 rx_lp_qdepth;
 	u8 rx_status_len;
@@ -521,6 +522,12 @@ enum {
 	ATH9K_RESET_COLD,
 };
 
+enum {
+	ATH_DIAG_DISABLE_RX,
+	ATH_DIAG_DISABLE_TX,
+	ATH_DIAG_TRIGGER_ERROR,
+};
+
 struct ath9k_hw_version {
 	u32 magic;
 	u16 devid;
@@ -716,6 +723,7 @@ struct ath_spec_scan {
  * @config_pci_powersave:
  * @calibrate: periodic calibration for NF, ANI, IQ, ADC gain, ADC-DC
  *
+ * @get_adc_entropy: get entropy from the raw ADC I/Q output
  * @spectral_scan_config: set parameters for spectral scan and enable/disable it
  * @spectral_scan_trigger: trigger a spectral scan run
  * @spectral_scan_wait: wait for a spectral scan run to finish
@@ -738,6 +746,7 @@ struct ath_hw_ops {
 			struct ath_hw_antcomb_conf *antconf);
 	void (*antdiv_comb_conf_set)(struct ath_hw *ah,
 			struct ath_hw_antcomb_conf *antconf);
+	void (*get_adc_entropy)(struct ath_hw *ah, u8 *buf, size_t len);
 	void (*spectral_scan_config)(struct ath_hw *ah,
 				     struct ath_spec_scan *param);
 	void (*spectral_scan_trigger)(struct ath_hw *ah);
@@ -783,6 +792,7 @@ struct ath_hw {
 	struct ath9k_hw_capabilities caps;
 	struct ath9k_channel channels[ATH9K_NUM_CHANNELS];
 	struct ath9k_channel *curchan;
+	struct gpio_desc *gpiods[32];
 
 	union {
 		struct ar5416_eeprom_def def;
@@ -809,6 +819,8 @@ struct ath_hw {
 	u32 ah_flags;
 	s16 nf_override;
 
+	unsigned long diag;
+
 	bool reset_power_on;
 	bool htc_reset_init;
 
@@ -1078,6 +1090,7 @@ void ath9k_hw_check_nav(struct ath_hw *ah);
 bool ath9k_hw_check_alive(struct ath_hw *ah);
 
 bool ath9k_hw_setpower(struct ath_hw *ah, enum ath9k_power_mode mode);
+void ath9k_hw_update_diag(struct ath_hw *ah);
 
 /* Generic hw timer primitives */
 struct ath_gen_timer *ath_gen_timer_alloc(struct ath_hw *ah,
diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c
index a172284..cd0d1bf 100644
--- a/drivers/net/wireless/ath/ath9k/init.c
+++ b/drivers/net/wireless/ath/ath9k/init.c
@@ -28,6 +28,11 @@
 
 #include "ath9k.h"
 
+#ifdef CONFIG_ATH79
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
+#endif
+ 
 struct ath9k_eeprom_ctx {
 	struct completion complete;
 	struct ath_hw *ah;
@@ -47,7 +52,7 @@ int ath9k_modparam_nohwcrypt;
 module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
 MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
 
-int ath9k_led_blink;
+int ath9k_led_blink = 1;
 module_param_named(blink, ath9k_led_blink, int, 0444);
 MODULE_PARM_DESC(blink, "Enable LED blink on activity");
 
@@ -242,6 +247,81 @@ static unsigned int ath9k_reg_rmw(void *hw_priv, u32 reg_offset, u32 set, u32 cl
 	return val;
 }
 
+#ifdef CONFIG_ATH79
+#define QCA955X_DDR_CTL_CONFIG          0x108
+#define QCA955X_DDR_CTL_CONFIG_ACT_WMAC BIT(23)
+
+static int ar913x_wmac_reset(void)
+{
+	ath79_device_reset_set(AR913X_RESET_AMBA2WMAC);
+	mdelay(10);
+
+	ath79_device_reset_clear(AR913X_RESET_AMBA2WMAC);
+	mdelay(10);
+
+	return 0;
+}
+
+static int ar933x_wmac_reset(void)
+{
+	int retries = 20;
+
+	ath79_device_reset_set(AR933X_RESET_WMAC);
+	ath79_device_reset_clear(AR933X_RESET_WMAC);
+
+	while (1) {
+		u32 bootstrap;
+
+		bootstrap = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+		if ((bootstrap & AR933X_BOOTSTRAP_EEPBUSY) == 0)
+			return 0;
+
+		if (retries-- == 0)
+			break;
+
+		udelay(10000);
+	}
+
+	pr_err("ar933x: WMAC reset timed out");
+	return -ETIMEDOUT;
+}
+
+static int qca955x_wmac_reset(void)
+{
+	int i;
+
+	/* Try to wait for WMAC DDR activity to stop */
+	for (i = 0; i < 10; i++) {
+		if (!(__raw_readl(ath79_ddr_base + QCA955X_DDR_CTL_CONFIG) &
+		    QCA955X_DDR_CTL_CONFIG_ACT_WMAC))
+			break;
+
+		udelay(10);
+	}
+
+	ath79_device_reset_set(QCA955X_RESET_RTC);
+	udelay(10);
+	ath79_device_reset_clear(QCA955X_RESET_RTC);
+	udelay(10);
+
+	return 0;
+}
+
+
+static int ar9330_get_soc_revision(void)
+{
+	if (ath79_soc_rev == 1)
+		return ath79_soc_rev;
+
+	return 0;
+}
+
+static int ath79_get_soc_revision(void)
+{
+	return ath79_soc_rev;
+}
+#endif
+
 /**************************/
 /*     Initialization     */
 /**************************/
@@ -626,6 +706,7 @@ static int ath9k_of_init(struct ath_softc *sc)
 	struct ath_common *common = ath9k_hw_common(ah);
 	enum ath_bus_type bus_type = common->bus_ops->ath_bus_type;
 	char eeprom_name[100];
+	u32 mask;
 	int ret;
 
 	if (!of_device_is_available(np))
@@ -633,6 +714,43 @@ static int ath9k_of_init(struct ath_softc *sc)
 
 	ath_dbg(common, CONFIG, "parsing configuration from OF node\n");
 
+	if (!of_property_read_u32(np, "qca,gpio-mask", &mask))
+		ah->caps.gpio_mask = mask;
+
+	if (of_property_read_bool(np, "qca,tx-gain-buffalo"))
+		ah->config.tx_gain_buffalo = true;
+
+#ifdef CONFIG_ATH79
+	if (ah->hw_version.devid == AR5416_AR9100_DEVID) {
+		ah->external_reset = ar913x_wmac_reset;
+	} else if (ah->hw_version.devid == AR9300_DEVID_AR9330) {
+		ah->get_mac_revision = ar9330_get_soc_revision;
+		u32 t = ath79_reset_rr(AR933X_RESET_REG_BOOTSTRAP);
+		ah->is_clk_25mhz = !(t & AR933X_BOOTSTRAP_REF_CLK_40);
+		ah->external_reset = ar933x_wmac_reset;
+	} else if (ah->hw_version.devid == AR9300_DEVID_AR9340) {
+		ah->get_mac_revision = ath79_get_soc_revision;
+		u32 t = ath79_reset_rr(AR934X_RESET_REG_BOOTSTRAP);
+		ah->is_clk_25mhz = !(t & AR934X_BOOTSTRAP_REF_CLK_40);
+	} else if (ah->hw_version.devid == AR9300_DEVID_AR953X) {
+		ah->get_mac_revision = ath79_get_soc_revision;
+		/*
+		 * QCA953x only supports 25MHz refclk.
+		 * Some vendors have an invalid bootstrap option
+		 * set, which would break the WMAC here.
+		 */
+		ah->is_clk_25mhz = true;
+	} else if (ah->hw_version.devid == AR9300_DEVID_QCA955X) {
+		u32 t = ath79_reset_rr(QCA955X_RESET_REG_BOOTSTRAP);
+		ah->is_clk_25mhz = !(t & QCA955X_BOOTSTRAP_REF_CLK_40);
+		ah->external_reset = qca955x_wmac_reset;
+	} else if (ah->hw_version.devid == AR9300_DEVID_QCA956X) {
+		ah->get_mac_revision = ath79_get_soc_revision;
+		u32 t = ath79_reset_rr(QCA956X_RESET_REG_BOOTSTRAP);
+		ah->is_clk_25mhz = !(t & QCA956X_BOOTSTRAP_REF_CLK_40);
+	}
+#endif
+
 	if (of_property_read_bool(np, "qca,no-eeprom")) {
 		/* ath9k-eeprom-<bus>-<id>.bin */
 		scnprintf(eeprom_name, sizeof(eeprom_name),
@@ -651,6 +769,17 @@ static int ath9k_of_init(struct ath_softc *sc)
 	if (ret == -EPROBE_DEFER)
 		return ret;
 
+	np = of_get_child_by_name(np, "led");
+	if (np && of_device_is_available(np)) {
+		u32 led_pin;
+
+		if (!of_property_read_u32(np, "led-sources", &led_pin))
+			ah->led_pin = led_pin;
+
+		ah->config.led_active_high = !of_property_read_bool(np, "led-active-low");
+		of_node_put(np);
+	}
+
 	return 0;
 }
 
@@ -691,6 +820,7 @@ static int ath9k_init_softc(u16 devid, struct ath_softc *sc,
 	if (!ath9k_is_chanctx_enabled())
 		sc->cur_chan->hw_queue_base = 0;
 
+	common->ieee_ops = &ath9k_ops;
 	common->ops = &ah->reg_ops;
 	common->bus_ops = bus_ops;
 	common->ps_ops = &ath9k_ps_ops;
@@ -824,7 +954,8 @@ static void ath9k_init_txpower_limits(struct ath_softc *sc)
 	if (ah->caps.hw_caps & ATH9K_HW_CAP_5GHZ)
 		ath9k_init_band_txpower(sc, NL80211_BAND_5GHZ);
 
-	ah->curchan = curchan;
+	if (curchan)
+		ah->curchan = curchan;
 }
 
 static const struct ieee80211_iface_limit if_limits[] = {
@@ -836,6 +967,7 @@ static const struct ieee80211_iface_limit if_limits[] = {
 				 BIT(NL80211_IFTYPE_AP) },
 	{ .max = 1,	.types = BIT(NL80211_IFTYPE_P2P_CLIENT) |
 				 BIT(NL80211_IFTYPE_P2P_GO) },
+	{ .max = 1,	.types = BIT(NL80211_IFTYPE_ADHOC) },
 };
 
 #ifdef CPTCFG_ATH9K_CHANNEL_CONTEXT
@@ -916,6 +1048,7 @@ static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 	ieee80211_hw_set(hw, HOST_BROADCAST_PS_BUFFERING);
 	ieee80211_hw_set(hw, SUPPORT_FAST_XMIT);
 	ieee80211_hw_set(hw, SUPPORTS_CLONED_SKBS);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
 
 	if (ath9k_ps_enable)
 		ieee80211_hw_set(hw, SUPPORTS_PS);
@@ -928,9 +1061,6 @@ static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 				IEEE80211_RADIOTAP_MCS_HAVE_STBC;
 	}
 
-	if (AR_SREV_9160_10_OR_LATER(sc->sc_ah) || ath9k_modparam_nohwcrypt)
-		ieee80211_hw_set(hw, MFP_CAPABLE);
-
 	hw->wiphy->features |= NL80211_FEATURE_ACTIVE_MONITOR |
 			       NL80211_FEATURE_AP_MODE_CHAN_WIDTH_CHANGE |
 			       NL80211_FEATURE_P2P_GO_CTWIN;
@@ -1003,6 +1133,18 @@ static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)
 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CAN_REPLACE_PTK0);
 }
 
+static void ath_get_initial_entropy(struct ath_softc *sc)
+{
+	struct ath_hw *ah = sc->sc_ah;
+	char buf[256];
+
+	/* reuse last channel initialized by the tx power test */
+	ath9k_hw_reset(ah, ah->curchan, NULL, false);
+
+	ath9k_hw_get_adc_entropy(ah, buf, sizeof(buf));
+	add_device_randomness(buf, sizeof(buf));
+}
+
 int ath9k_init_device(u16 devid, struct ath_softc *sc,
 		    const struct ath_bus_ops *bus_ops)
 {
@@ -1043,13 +1185,15 @@ int ath9k_init_device(u16 devid, struct ath_softc *sc,
 
 #ifdef CPTCFG_MAC80211_LEDS
 	/* must be initialized before ieee80211_register_hw */
-	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
+	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
 		ARRAY_SIZE(ath9k_tpt_blink));
 #endif
 
 	wiphy_read_of_freq_limits(hw->wiphy);
 
+	ath_get_initial_entropy(sc);
+
 	/* Register with mac80211 */
 	error = ieee80211_register_hw(hw);
 	if (error)
@@ -1133,25 +1277,25 @@ static int __init ath9k_init(void)
 {
 	int error;
 
-	error = ath_pci_init();
+	error = ath_ahb_init();
 	if (error < 0) {
-		pr_err("No PCI devices found, driver not installed\n");
 		error = -ENODEV;
 		goto err_out;
 	}
 
-	error = ath_ahb_init();
+	error = ath_pci_init();
 	if (error < 0) {
+		pr_err("No PCI devices found, driver not installed\n");
 		error = -ENODEV;
-		goto err_pci_exit;
+		goto err_ahb_exit;
 	}
 
 	dmi_check_system(ath9k_quirks);
 
 	return 0;
 
- err_pci_exit:
-	ath_pci_exit();
+ err_ahb_exit:
+	ath_ahb_exit();
  err_out:
 	return error;
 }
diff --git a/drivers/net/wireless/ath/ath9k/mac.c b/drivers/net/wireless/ath/ath9k/mac.c
index b070403..d8d14a5 100644
--- a/drivers/net/wireless/ath/ath9k/mac.c
+++ b/drivers/net/wireless/ath/ath9k/mac.c
@@ -678,13 +678,18 @@ void ath9k_hw_startpcureceive(struct ath_hw *ah, bool is_scanning)
 
 	ath9k_ani_reset(ah, is_scanning);
 
-	REG_CLR_BIT(ah, AR_DIAG_SW, (AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT));
+	REG_CLR_BIT(ah, AR_DIAG_SW,
+		    AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT | AR_DIAG_FORCE_RX_CLEAR);
 }
 EXPORT_SYMBOL(ath9k_hw_startpcureceive);
 
 void ath9k_hw_abortpcurecv(struct ath_hw *ah)
 {
-	REG_SET_BIT(ah, AR_DIAG_SW, AR_DIAG_RX_ABORT | AR_DIAG_RX_DIS);
+	u32 reg = AR_DIAG_RX_DIS | AR_DIAG_RX_ABORT;
+
+	if (!IS_ENABLED(CPTCFG_ATH9K_TX99))
+		reg |= AR_DIAG_FORCE_RX_CLEAR;
+	REG_SET_BIT(ah, AR_DIAG_SW, reg);
 
 	ath9k_hw_disable_mib_counters(ah);
 }
diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c
index 5b9fa4f..e87d1b4 100644
--- a/drivers/net/wireless/ath/ath9k/main.c
+++ b/drivers/net/wireless/ath/ath9k/main.c
@@ -18,6 +18,7 @@
 #include <linux/delay.h>
 #include "ath9k.h"
 #include "btcoex.h"
+#include "hsr.h"
 
 static void ath9k_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
 			u32 queues, bool drop);
@@ -537,6 +538,11 @@ irqreturn_t ath_isr(int irq, void *dev)
 		return IRQ_HANDLED;
 	}
 
+	if (test_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag)) {
+		status |= ATH9K_INT_FATAL;
+		clear_bit(ATH_DIAG_TRIGGER_ERROR, &ah->diag);
+	}
+
 	/*
 	 * If there are no status bits set, then this interrupt was not
 	 * for me (should have been caught above).
@@ -653,6 +659,7 @@ void ath_reset_work(struct work_struct *work)
 static int ath9k_start(struct ieee80211_hw *hw)
 {
 	struct ath_softc *sc = hw->priv;
+	struct device_node *np = sc->dev->of_node;
 	struct ath_hw *ah = sc->sc_ah;
 	struct ath_common *common = ath9k_hw_common(ah);
 	struct ieee80211_channel *curchan = sc->cur_chan->chandef.chan;
@@ -731,6 +738,11 @@ static int ath9k_start(struct ieee80211_hw *hw)
 					  AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
 	}
 
+	if (of_property_read_bool(np, "ubnt,hsr")) {
+		ath9k_hsr_init(ah);
+		ath9k_hsr_disable(ah);
+	}
+
 	/*
 	 * Reset key cache to sane defaults (all entries cleared) instead of
 	 * semi-random values after suspend/resume.
diff --git a/drivers/net/wireless/ath/ath9k/pci.c b/drivers/net/wireless/ath/ath9k/pci.c
index c3f41cf..dd21d74 100644
--- a/drivers/net/wireless/ath/ath9k/pci.c
+++ b/drivers/net/wireless/ath/ath9k/pci.c
@@ -772,6 +772,7 @@ static const struct pci_device_id ath_pci_id_table[] = {
 	  .driver_data = ATH9K_PCI_BT_ANT_DIV },
 #endif
 
+	{ PCI_VDEVICE(ATHEROS, 0xabcd) }, /* PCI-E  internal chip default ID */
 	{ 0 }
 };
 
diff --git a/drivers/net/wireless/ath/ath9k/phy.h b/drivers/net/wireless/ath/ath9k/phy.h
index 4a1b992..af667a3 100644
--- a/drivers/net/wireless/ath/ath9k/phy.h
+++ b/drivers/net/wireless/ath/ath9k/phy.h
@@ -48,6 +48,9 @@
 #define AR_PHY_PLL_CONTROL 0x16180
 #define AR_PHY_PLL_MODE 0x16184
 
+#define AR_PHY_USB_CTRL1	0x16c84
+#define AR_PHY_USB_CTRL2	0x16c88
+
 enum ath9k_ant_div_comb_lna_conf {
 	ATH_ANT_DIV_COMB_LNA1_MINUS_LNA2,
 	ATH_ANT_DIV_COMB_LNA2,
diff --git a/drivers/net/wireless/ath/carl9170/debug.c b/drivers/net/wireless/ath/carl9170/debug.c
index 2d73456..bb40889 100644
--- a/drivers/net/wireless/ath/carl9170/debug.c
+++ b/drivers/net/wireless/ath/carl9170/debug.c
@@ -54,6 +54,7 @@ struct carl9170_debugfs_fops {
 	char *(*read)(struct ar9170 *ar, char *buf, size_t bufsize,
 		      ssize_t *len);
 	ssize_t (*write)(struct ar9170 *aru, const char *buf, size_t size);
+	const struct file_operations fops;
 
 	enum carl9170_device_state req_dev_state;
 };
@@ -61,7 +62,7 @@ struct carl9170_debugfs_fops {
 static ssize_t carl9170_debugfs_read(struct file *file, char __user *userbuf,
 				     size_t count, loff_t *ppos)
 {
-	const struct carl9170_debugfs_fops *dfops;
+	struct carl9170_debugfs_fops *dfops;
 	struct ar9170 *ar;
 	char *buf = NULL, *res_buf = NULL;
 	ssize_t ret = 0;
@@ -74,7 +75,8 @@ static ssize_t carl9170_debugfs_read(struct file *file, char __user *userbuf,
 
 	if (!ar)
 		return -ENODEV;
-	dfops = debugfs_get_aux(file);
+	dfops = container_of(debugfs_real_fops(file),
+			     struct carl9170_debugfs_fops, fops);
 
 	if (!dfops->read)
 		return -ENOSYS;
@@ -111,7 +113,7 @@ out_free:
 static ssize_t carl9170_debugfs_write(struct file *file,
 	const char __user *userbuf, size_t count, loff_t *ppos)
 {
-	const struct carl9170_debugfs_fops *dfops;
+	struct carl9170_debugfs_fops *dfops;
 	struct ar9170 *ar;
 	char *buf = NULL;
 	int err = 0;
@@ -126,7 +128,8 @@ static ssize_t carl9170_debugfs_write(struct file *file,
 
 	if (!ar)
 		return -ENODEV;
-	dfops = debugfs_get_aux(file);
+	dfops = container_of(debugfs_real_fops(file),
+			     struct carl9170_debugfs_fops, fops);
 
 	if (!dfops->write)
 		return -ENOSYS;
@@ -162,11 +165,6 @@ out_free:
 	return err;
 }
 
-static struct debugfs_short_fops debugfs_fops = {
-	.read	= carl9170_debugfs_read,
-	.write	= carl9170_debugfs_write,
-};
-
 #define __DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize,	\
 			       _attr, _dstate)				\
 static const struct carl9170_debugfs_fops carl_debugfs_##name ##_ops = {\
@@ -175,6 +173,12 @@ static const struct carl9170_debugfs_fops carl_debugfs_##name ##_ops = {\
 	.write = _write,						\
 	.attr = _attr,							\
 	.req_dev_state = _dstate,					\
+	.fops = {							\
+		.open	= simple_open,					\
+		.read	= carl9170_debugfs_read,			\
+		.write	= carl9170_debugfs_write,			\
+		.owner	= THIS_MODULE					\
+	},								\
 }
 
 #define DEBUGFS_DECLARE_FILE(name, _read, _write, _read_bufsize, _attr)	\
@@ -812,9 +816,9 @@ void carl9170_debugfs_register(struct ar9170 *ar)
 		ar->hw->wiphy->debugfsdir);
 
 #define DEBUGFS_ADD(name)						\
-	debugfs_create_file_aux(#name, carl_debugfs_##name ##_ops.attr,	\
-			    ar->debug_dir, ar, &carl_debugfs_##name ## _ops, \
-			    &debugfs_fops)
+	debugfs_create_file(#name, carl_debugfs_##name ##_ops.attr,	\
+			    ar->debug_dir, ar,				\
+			    &carl_debugfs_##name ## _ops.fops)
 
 	DEBUGFS_ADD(usb_tx_anch_urbs);
 	DEBUGFS_ADD(usb_rx_pool_urbs);
diff --git a/drivers/net/wireless/ath/regd.c b/drivers/net/wireless/ath/regd.c
index 2afdebf..3ba9fc3 100644
--- a/drivers/net/wireless/ath/regd.c
+++ b/drivers/net/wireless/ath/regd.c
@@ -24,6 +24,7 @@
 #include "regd_common.h"
 
 static int __ath_regd_init(struct ath_regulatory *reg);
+static struct reg_dmn_pair_mapping *ath_get_regpair(int regdmn);
 
 /*
  * This is a set of common rules used by our world regulatory domains.
@@ -43,7 +44,8 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 					 NL80211_RRF_NO_OFDM)
 
 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
+#define ATH_5GHZ_5150_5350	REG_RULE(5150-10, 5240+10, 80, 0, 30, 0),\
+				REG_RULE(5260-10, 5350+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
 #define ATH_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
 					 NL80211_RRF_NO_IR)
@@ -61,64 +63,79 @@ static int __ath_regd_init(struct ath_regulatory *reg);
 #define ATH_5GHZ_NO_MIDBAND	ATH_5GHZ_5150_5350, \
 				ATH_5GHZ_5725_5850
 
+#define REGD_RULES(...) \
+	.reg_rules = { __VA_ARGS__ }, \
+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
+
 /* Can be used for:
  * 0x60, 0x61, 0x62 */
 static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
-	.n_reg_rules = 5,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_ALL,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x63 and 0x65 */
 static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x64 only */
 static const struct ieee80211_regdomain ath_world_regdom_64 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_NO_MIDBAND,
-	}
+	)
 };
 
 /* Can be used by 0x66 and 0x69 */
 static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
-	.n_reg_rules = 3,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
 /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
 static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
-	.n_reg_rules = 4,
 	.alpha2 =  "99",
-	.reg_rules = {
+	REGD_RULES(
 		ATH_2GHZ_CH01_11,
 		ATH_2GHZ_CH12_13,
 		ATH_5GHZ_ALL,
-	}
+	)
 };
 
+static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
+{
+	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
+}
+
+static bool is_default_regd(struct ath_regulatory *reg)
+{
+	return ath_regd_get_eepromRD(reg) == CTRY_DEFAULT;
+}
+
 static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
+
 	if (IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;
 
+	if (is_default_regd(reg))
+		return true;
+
 	switch (reg->country_code) {
 	case CTRY_UNITED_STATES:
 	case CTRY_JAPAN1:
@@ -188,6 +205,8 @@ static bool dynamic_country_user_possible(struct ath_regulatory *reg)
 
 static bool ath_reg_dyn_country_user_allow(struct ath_regulatory *reg)
 {
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return true;
 	if (!IS_ENABLED(CPTCFG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
 	if (!dynamic_country_user_possible(reg))
@@ -202,11 +221,6 @@ static inline bool is_wwr_sku(u16 regd)
 		(regd == WORLD));
 }
 
-static u16 ath_regd_get_eepromRD(struct ath_regulatory *reg)
-{
-	return reg->current_rd & ~WORLDWIDE_ROAMING_FLAG;
-}
-
 bool ath_is_world_regd(struct ath_regulatory *reg)
 {
 	return is_wwr_sku(ath_regd_get_eepromRD(reg));
@@ -345,6 +359,9 @@ ath_reg_apply_beaconing_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
@@ -379,6 +396,9 @@ ath_reg_apply_ir_flags(struct wiphy *wiphy,
 {
 	struct ieee80211_supported_band *sband;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
@@ -408,6 +428,9 @@ static void ath_reg_apply_radar_flags(struct wiphy *wiphy,
 	struct ieee80211_channel *ch;
 	unsigned int i;
 
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return;
+
 	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;
 
@@ -640,6 +663,13 @@ ath_regd_init_wiphy(struct ath_regulatory *reg,
 	const struct ieee80211_regdomain *regd;
 
 	wiphy->reg_notifier = reg_notifier;
+
+	if (IS_ENABLED(CPTCFG_ATH_USER_REGD))
+		return 0;
+
+	if (is_default_regd(reg))
+		return 0;
+
 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
 				   REGULATORY_CUSTOM_REG;
 
diff --git a/drivers/net/wireless/ath/regd_common.h b/drivers/net/wireless/ath/regd_common.h
index cdb1e9a..2574f80 100644
--- a/drivers/net/wireless/ath/regd_common.h
+++ b/drivers/net/wireless/ath/regd_common.h
@@ -32,6 +32,7 @@ enum EnumRd {
 	FCC2_WORLD = 0x21,
 	FCC2_ETSIC = 0x22,
 	FCC6_WORLD = 0x23,
+	FCC3_FCCA_2 = 0x2A,
 	FRANCE_RES = 0x31,
 	FCC3_FCCA = 0x3A,
 	FCC3_WORLD = 0x3B,
@@ -173,6 +174,7 @@ static struct reg_dmn_pair_mapping regDomainPairs[] = {
 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
 	{FCC3_ETSIC, CTL_FCC, CTL_ETSI},
 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
@@ -486,6 +488,7 @@ static struct country_code_to_enum_rd allCountries[] = {
 	{CTRY_UAE, NULL1_WORLD, "AE"},
 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
 	{CTRY_UNITED_STATES2, FCC3_FCCA, "US"},
 	{CTRY_UNITED_STATES3, FCC3_FCCA, "US"},
 	/* This "PS" is for US public safety actually... to support this we
diff --git a/drivers/net/wireless/ath/trace.h b/drivers/net/wireless/ath/trace.h
index 070e61d..c3bd41d 100644
--- a/drivers/net/wireless/ath/trace.h
+++ b/drivers/net/wireless/ath/trace.h
@@ -44,8 +44,13 @@ TRACE_EVENT(ath_log,
 	    ),
 
 	    TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		    __assign_str(device);
 		    __assign_str(driver);
+#else
+		    __assign_str(device, wiphy_name(wiphy));
+		    __assign_str(driver, KBUILD_MODNAME);
+#endif
 		    __assign_vstr(msg, vaf->fmt, vaf->va);
 	    ),
 
diff --git a/drivers/net/wireless/broadcom/b43/Kconfig b/drivers/net/wireless/broadcom/b43/Kconfig
index 84cbe38..5f008b4 100644
--- a/drivers/net/wireless/broadcom/b43/Kconfig
+++ b/drivers/net/wireless/broadcom/b43/Kconfig
@@ -100,7 +100,7 @@ config B43_BCMA_PIO
 	default y
 
 config B43_PIO
-	bool
+	bool "Broadcom 43xx PIO support"
 	depends on B43 && B43_SSB
 	depends on SSB_BLOCKIO
 	default y
diff --git a/drivers/net/wireless/broadcom/b43/Makefile b/drivers/net/wireless/broadcom/b43/Makefile
index f20b692..48589b5 100644
--- a/drivers/net/wireless/broadcom/b43/Makefile
+++ b/drivers/net/wireless/broadcom/b43/Makefile
@@ -18,7 +18,7 @@ b43-$(CPTCFG_B43_PHY_AC)	+= phy_ac.o
 b43-y				+= sysfs.o
 b43-y				+= xmit.o
 b43-y				+= dma.o
-b43-y				+= pio.o
+b43-$(CPTCFG_B43_PIO)		+= pio.o
 b43-y				+= rfkill.o
 b43-y				+= ppr.o
 b43-$(CPTCFG_B43_LEDS)		+= leds.o
diff --git a/drivers/net/wireless/broadcom/b43/b43.h b/drivers/net/wireless/broadcom/b43/b43.h
index 0e4ea13..946cfe5 100644
--- a/drivers/net/wireless/broadcom/b43/b43.h
+++ b/drivers/net/wireless/broadcom/b43/b43.h
@@ -840,6 +840,9 @@ struct b43_wldev {
 	bool qos_enabled;		/* TRUE, if QoS is used. */
 	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
 	bool use_pio;			/* TRUE if next init should use PIO */
+	int gpiomask;			/* GPIO LED mask as a module parameter */
+	int rx_antenna;			/* Used RX antenna (B43_ANTENNAxxx) */
+	int tx_antenna;			/* Used TX antenna (B43_ANTENNAxxx) */
 
 	/* PHY/Radio device. */
 	struct b43_phy phy;
diff --git a/drivers/net/wireless/broadcom/b43/debugfs.c b/drivers/net/wireless/broadcom/b43/debugfs.c
index 5a49970..efa9844 100644
--- a/drivers/net/wireless/broadcom/b43/debugfs.c
+++ b/drivers/net/wireless/broadcom/b43/debugfs.c
@@ -30,6 +30,7 @@ static struct dentry *rootdir;
 struct b43_debugfs_fops {
 	ssize_t (*read)(struct b43_wldev *dev, char *buf, size_t bufsize);
 	int (*write)(struct b43_wldev *dev, const char *buf, size_t count);
+	struct file_operations fops;
 	/* Offset of struct b43_dfs_file in struct b43_dfsentry */
 	size_t file_struct_offset;
 };
@@ -490,7 +491,7 @@ static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,
 				size_t count, loff_t *ppos)
 {
 	struct b43_wldev *dev;
-	const struct b43_debugfs_fops *dfops;
+	struct b43_debugfs_fops *dfops;
 	struct b43_dfs_file *dfile;
 	ssize_t ret;
 	char *buf;
@@ -510,7 +511,8 @@ static ssize_t b43_debugfs_read(struct file *file, char __user *userbuf,
 		goto out_unlock;
 	}
 
-	dfops = debugfs_get_aux(file);
+	dfops = container_of(debugfs_real_fops(file),
+			     struct b43_debugfs_fops, fops);
 	if (!dfops->read) {
 		err = -ENOSYS;
 		goto out_unlock;
@@ -553,7 +555,7 @@ static ssize_t b43_debugfs_write(struct file *file,
 				 size_t count, loff_t *ppos)
 {
 	struct b43_wldev *dev;
-	const struct b43_debugfs_fops *dfops;
+	struct b43_debugfs_fops *dfops;
 	char *buf;
 	int err = 0;
 
@@ -571,7 +573,8 @@ static ssize_t b43_debugfs_write(struct file *file,
 		goto out_unlock;
 	}
 
-	dfops = debugfs_get_aux(file);
+	dfops = container_of(debugfs_real_fops(file),
+			     struct b43_debugfs_fops, fops);
 	if (!dfops->write) {
 		err = -ENOSYS;
 		goto out_unlock;
@@ -599,16 +602,16 @@ out_unlock:
 }
 
 
-static struct debugfs_short_fops debugfs_ops = {
-	.read	= b43_debugfs_read,
-	.write	= b43_debugfs_write,
-	.llseek = generic_file_llseek,
-};
-
 #define B43_DEBUGFS_FOPS(name, _read, _write)			\
 	static struct b43_debugfs_fops fops_##name = {		\
 		.read	= _read,				\
 		.write	= _write,				\
+		.fops	= {					\
+			.open	= simple_open,			\
+			.read	= b43_debugfs_read,		\
+			.write	= b43_debugfs_write,		\
+			.llseek = generic_file_llseek,		\
+		},						\
 		.file_struct_offset = offsetof(struct b43_dfsentry, \
 					       file_##name),	\
 	}
@@ -700,9 +703,9 @@ void b43_debugfs_add_device(struct b43_wldev *dev)
 
 #define ADD_FILE(name, mode)	\
 	do {							\
-		debugfs_create_file_aux(__stringify(name),	\
+		debugfs_create_file(__stringify(name),		\
 				mode, e->subdir, dev,		\
-				&fops_##name, &debugfs_ops);	\
+				&fops_##name.fops);		\
 	} while (0)
 
 
diff --git a/drivers/net/wireless/broadcom/b43/dma.h b/drivers/net/wireless/broadcom/b43/dma.h
index dfebc64..ec72414 100644
--- a/drivers/net/wireless/broadcom/b43/dma.h
+++ b/drivers/net/wireless/broadcom/b43/dma.h
@@ -170,7 +170,7 @@ struct b43_dmadesc_generic {
 
 /* DMA engine tuning knobs */
 #define B43_TXRING_SLOTS		256
-#define B43_RXRING_SLOTS		256
+#define B43_RXRING_SLOTS		32
 #define B43_DMA0_RX_FW598_BUFSIZE	(B43_DMA0_RX_FW598_FO + IEEE80211_MAX_FRAME_LEN)
 #define B43_DMA0_RX_FW351_BUFSIZE	(B43_DMA0_RX_FW351_FO + IEEE80211_MAX_FRAME_LEN)
 
diff --git a/drivers/net/wireless/broadcom/b43/main.c b/drivers/net/wireless/broadcom/b43/main.c
index ecbdcaa..7bcc3d2 100644
--- a/drivers/net/wireless/broadcom/b43/main.c
+++ b/drivers/net/wireless/broadcom/b43/main.c
@@ -72,6 +72,11 @@ MODULE_FIRMWARE("b43/ucode40.fw");
 MODULE_FIRMWARE("b43/ucode42.fw");
 MODULE_FIRMWARE("b43/ucode9.fw");
 
+static int modparam_gpiomask = 0x000F;
+module_param_named(gpiomask, modparam_gpiomask, int, 0444);
+MODULE_PARM_DESC(gpiomask,
+         "GPIO mask for LED control (default 0x000F)");
+
 static int modparam_bad_frames_preempt;
 module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
 MODULE_PARM_DESC(bad_frames_preempt,
@@ -109,7 +114,7 @@ static int b43_modparam_pio;
 module_param_named(pio, b43_modparam_pio, int, 0644);
 MODULE_PARM_DESC(pio, "Use PIO accesses by default: 0=DMA, 1=PIO");
 
-static int modparam_allhwsupport = !IS_ENABLED(CPTCFG_BRCMSMAC);
+static int modparam_allhwsupport = 1;
 module_param_named(allhwsupport, modparam_allhwsupport, int, 0444);
 MODULE_PARM_DESC(allhwsupport, "Enable support for all hardware (even it if overlaps with the brcmsmac driver)");
 
@@ -1638,7 +1643,7 @@ static void b43_write_beacon_template(struct b43_wldev *dev,
 				  len, ram_offset, shm_size_offset, rate);
 
 	/* Write the PHY TX control parameters. */
-	antenna = B43_ANTENNA_DEFAULT;
+	antenna = dev->tx_antenna;
 	antenna = b43_antenna_to_phyctl(antenna);
 	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
 	/* We can't send beacons with short preamble. Would get PHY errors. */
@@ -1996,10 +2001,12 @@ static void b43_do_interrupt_thread(struct b43_wldev *dev)
 			dma_reason[0], dma_reason[1],
 			dma_reason[2], dma_reason[3],
 			dma_reason[4], dma_reason[5]);
+#ifdef CPTCFG_B43_PIO
 		b43err(dev->wl, "This device does not support DMA "
 			       "on your system. It will now be switched to PIO.\n");
 		/* Fall back to PIO transfers if we get fatal DMA errors! */
 		dev->use_pio = true;
+#endif
 		b43_controller_restart(dev, "DMA error");
 		return;
 	}
@@ -2870,16 +2877,24 @@ static int b43_gpio_init(struct b43_wldev *dev)
 	u32 mask, set;
 
 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
-	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
+	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
 
 	mask = 0x0000001F;
-	set = 0x0000000F;
+	set = modparam_gpiomask;
 	if (dev->dev->chip_id == 0x4301) {
 		mask |= 0x0060;
 		set |= 0x0060;
 	} else if (dev->dev->chip_id == 0x5354) {
 		/* Don't allow overtaking buttons GPIOs */
 		set &= 0x2; /* 0x2 is LED GPIO on BCM5354 */
+	} else if (dev->dev->chip_id == BCMA_CHIP_ID_BCM4716 || 
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM47162 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5356 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM5357 ||
+		   dev->dev->chip_id == BCMA_CHIP_ID_BCM53572) {
+		/* just use gpio 0 and 1 for 2.4 GHz wifi led */
+		set &= 0x3;
+		mask &= 0x3;
 	}
 
 	if (0 /* FIXME: conditional unknown */ ) {
@@ -3278,8 +3293,8 @@ static int b43_chip_init(struct b43_wldev *dev)
 
 	/* Select the antennae */
 	if (phy->ops->set_rx_antenna)
-		phy->ops->set_rx_antenna(dev, B43_ANTENNA_DEFAULT);
-	b43_mgmtframe_txantenna(dev, B43_ANTENNA_DEFAULT);
+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
 
 	if (phy->type == B43_PHYTYPE_B) {
 		value16 = b43_read16(dev, 0x005E);
@@ -3981,7 +3996,6 @@ static int b43_op_config(struct ieee80211_hw *hw, int radio_idx, u32 changed)
 	struct b43_wldev *dev = wl->current_dev;
 	struct b43_phy *phy = &dev->phy;
 	struct ieee80211_conf *conf = &hw->conf;
-	int antenna;
 	int err = 0;
 
 	mutex_lock(&wl->mutex);
@@ -4024,11 +4038,9 @@ static int b43_op_config(struct ieee80211_hw *hw, int radio_idx, u32 changed)
 	}
 
 	/* Antennas for RX and management frame TX. */
-	antenna = B43_ANTENNA_DEFAULT;
-	b43_mgmtframe_txantenna(dev, antenna);
-	antenna = B43_ANTENNA_DEFAULT;
+	b43_mgmtframe_txantenna(dev, dev->tx_antenna);
 	if (phy->ops->set_rx_antenna)
-		phy->ops->set_rx_antenna(dev, antenna);
+		phy->ops->set_rx_antenna(dev, dev->rx_antenna);
 
 	if (wl->radio_enabled != phy->radio_on) {
 		if (wl->radio_enabled) {
@@ -5171,6 +5183,49 @@ static int b43_op_get_survey(struct ieee80211_hw *hw, int idx,
 	return 0;
 }
 
+static int b43_op_set_antenna(struct ieee80211_hw *hw, int radio_idx,
+			      u32 tx_ant, u32 rx_ant)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev = wl->current_dev;
+
+	if (tx_ant == 1 && rx_ant == 1) {
+		dev->tx_antenna = B43_ANTENNA0;
+		dev->rx_antenna = B43_ANTENNA0;
+	}
+	else if (tx_ant == 2 && rx_ant == 2) {
+		dev->tx_antenna = B43_ANTENNA1;
+		dev->rx_antenna = B43_ANTENNA1;
+	}
+	else if ((tx_ant & 3) == 3 && (rx_ant & 3) == 3) {
+		dev->tx_antenna = B43_ANTENNA_DEFAULT;
+		dev->rx_antenna = B43_ANTENNA_DEFAULT;
+	}
+	else {
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static int b43_op_get_antenna(struct ieee80211_hw *hw, int radio_idx,
+			      u32 *tx_ant, u32 *rx_ant)
+{
+	struct b43_wl *wl = hw_to_b43_wl(hw);
+	struct b43_wldev *dev = wl->current_dev;
+
+	switch (dev->tx_antenna) {
+	case B43_ANTENNA0:
+		*tx_ant = 1; *rx_ant = 1; break;
+	case B43_ANTENNA1:
+		*tx_ant = 2; *rx_ant = 2; break;
+	case B43_ANTENNA_DEFAULT:
+		*tx_ant = 3; *rx_ant = 3; break;
+	}
+	return 0;
+}
+
 static const struct ieee80211_ops b43_hw_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -5197,6 +5252,8 @@ static const struct ieee80211_ops b43_hw_ops = {
 	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
 	.get_survey		= b43_op_get_survey,
 	.rfkill_poll		= b43_rfkill_poll,
+	.set_antenna		= b43_op_set_antenna,
+	.get_antenna		= b43_op_get_antenna,
 };
 
 /* Hard-reset the chip. Do not call this directly.
@@ -5498,6 +5555,8 @@ static int b43_one_core_attach(struct b43_bus_dev *dev, struct b43_wl *wl)
 	if (!wldev)
 		goto out;
 
+	wldev->rx_antenna = B43_ANTENNA_DEFAULT;
+	wldev->tx_antenna = B43_ANTENNA_DEFAULT;
 	wldev->use_pio = b43_modparam_pio;
 	wldev->dev = dev;
 	wldev->wl = wl;
@@ -5589,6 +5648,9 @@ static struct b43_wl *b43_wireless_init(struct b43_bus_dev *dev)
 
 	wiphy_ext_feature_set(hw->wiphy, NL80211_EXT_FEATURE_CQM_RSSI_LIST);
 
+	hw->wiphy->available_antennas_rx = 0x3;
+	hw->wiphy->available_antennas_tx = 0x3;
+
 	wl->hw_registered = false;
 	hw->max_rates = 2;
 	SET_IEEE80211_DEV(hw, dev->dev);
diff --git a/drivers/net/wireless/broadcom/b43/pio.h b/drivers/net/wireless/broadcom/b43/pio.h
index ffbfec6..a3742b7 100644
--- a/drivers/net/wireless/broadcom/b43/pio.h
+++ b/drivers/net/wireless/broadcom/b43/pio.h
@@ -151,7 +151,7 @@ static inline void b43_piorx_write32(struct b43_pio_rxqueue *q,
 	b43_write32(q->dev, q->mmio_base + offset, value);
 }
 
-
+#ifdef CPTCFG_B43_PIO
 int b43_pio_init(struct b43_wldev *dev);
 void b43_pio_free(struct b43_wldev *dev);
 
@@ -162,5 +162,37 @@ void b43_pio_rx(struct b43_pio_rxqueue *q);
 
 void b43_pio_tx_suspend(struct b43_wldev *dev);
 void b43_pio_tx_resume(struct b43_wldev *dev);
+#else
+static inline int b43_pio_init(struct b43_wldev *dev)
+{
+	return 0;
+}
+
+static inline void b43_pio_free(struct b43_wldev *dev)
+{
+}
+
+static inline int b43_pio_tx(struct b43_wldev *dev, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static inline void b43_pio_handle_txstatus(struct b43_wldev *dev,
+					   const struct b43_txstatus *status)
+{
+}
+
+static inline void b43_pio_rx(struct b43_pio_rxqueue *q)
+{
+}
+
+static inline void b43_pio_tx_suspend(struct b43_wldev *dev)
+{
+}
+
+static inline void b43_pio_tx_resume(struct b43_wldev *dev)
+{
+}
+#endif /* CPTCFG_B43_PIO */
 
 #endif /* B43_PIO_H_ */
diff --git a/drivers/net/wireless/broadcom/b43legacy/debugfs.c b/drivers/net/wireless/broadcom/b43legacy/debugfs.c
index 5d04bcc..6b0e8d1 100644
--- a/drivers/net/wireless/broadcom/b43legacy/debugfs.c
+++ b/drivers/net/wireless/broadcom/b43legacy/debugfs.c
@@ -31,6 +31,7 @@ static struct dentry *rootdir;
 struct b43legacy_debugfs_fops {
 	ssize_t (*read)(struct b43legacy_wldev *dev, char *buf, size_t bufsize);
 	int (*write)(struct b43legacy_wldev *dev, const char *buf, size_t count);
+	struct file_operations fops;
 	/* Offset of struct b43legacy_dfs_file in struct b43legacy_dfsentry */
 	size_t file_struct_offset;
 	/* Take wl->irq_lock before calling read/write? */
@@ -187,7 +188,7 @@ static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,
 				size_t count, loff_t *ppos)
 {
 	struct b43legacy_wldev *dev;
-	const struct b43legacy_debugfs_fops *dfops;
+	struct b43legacy_debugfs_fops *dfops;
 	struct b43legacy_dfs_file *dfile;
 	ssize_t ret;
 	char *buf;
@@ -207,7 +208,8 @@ static ssize_t b43legacy_debugfs_read(struct file *file, char __user *userbuf,
 		goto out_unlock;
 	}
 
-	dfops = debugfs_get_aux(file);
+	dfops = container_of(debugfs_real_fops(file),
+			     struct b43legacy_debugfs_fops, fops);
 	if (!dfops->read) {
 		err = -ENOSYS;
 		goto out_unlock;
@@ -255,7 +257,7 @@ static ssize_t b43legacy_debugfs_write(struct file *file,
 				 size_t count, loff_t *ppos)
 {
 	struct b43legacy_wldev *dev;
-	const struct b43legacy_debugfs_fops *dfops;
+	struct b43legacy_debugfs_fops *dfops;
 	char *buf;
 	int err = 0;
 
@@ -273,7 +275,8 @@ static ssize_t b43legacy_debugfs_write(struct file *file,
 		goto out_unlock;
 	}
 
-	dfops = debugfs_get_aux(file);
+	dfops = container_of(debugfs_real_fops(file),
+			     struct b43legacy_debugfs_fops, fops);
 	if (!dfops->write) {
 		err = -ENOSYS;
 		goto out_unlock;
@@ -305,16 +308,17 @@ out_unlock:
 	return err ? err : count;
 }
 
-static struct debugfs_short_fops debugfs_ops = {
-	.read	= b43legacy_debugfs_read,
-	.write	= b43legacy_debugfs_write,
-	.llseek = generic_file_llseek
-};
 
 #define B43legacy_DEBUGFS_FOPS(name, _read, _write, _take_irqlock)	\
 	static struct b43legacy_debugfs_fops fops_##name = {		\
 		.read	= _read,				\
 		.write	= _write,				\
+		.fops	= {					\
+			.open	= simple_open,				\
+			.read	= b43legacy_debugfs_read,		\
+			.write	= b43legacy_debugfs_write,		\
+			.llseek = generic_file_llseek,			\
+		},						\
 		.file_struct_offset = offsetof(struct b43legacy_dfsentry, \
 					       file_##name),	\
 		.take_irqlock	= _take_irqlock,		\
@@ -382,9 +386,9 @@ void b43legacy_debugfs_add_device(struct b43legacy_wldev *dev)
 
 #define ADD_FILE(name, mode)	\
 	do {							\
-		debugfs_create_file_aux(__stringify(name), mode,	\
+		debugfs_create_file(__stringify(name), mode,	\
 				    e->subdir, dev,		\
-				    &fops_##name, &debugfs_ops);	\
+				    &fops_##name.fops);		\
 	} while (0)
 
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/Kconfig b/drivers/net/wireless/broadcom/brcm80211/Kconfig
index a86ad74..195ceee 100644
--- a/drivers/net/wireless/broadcom/brcm80211/Kconfig
+++ b/drivers/net/wireless/broadcom/brcm80211/Kconfig
@@ -1,6 +1,6 @@
 # SPDX-License-Identifier: GPL-2.0-only
 config BRCMUTIL
-	tristate
+	tristate "Broadcom 802.11 driver utility functions"
 	depends on m
 
 config BRCMSMAC
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
index 09689dd..f23927e 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/bus.h
@@ -298,7 +298,7 @@ void brcmf_rx_event(struct device *dev, struct sk_buff *rxp);
 
 int brcmf_alloc(struct device *dev, struct brcmf_mp_device *settings);
 /* Indication from bus module regarding presence/insertion of dongle. */
-int brcmf_attach(struct device *dev);
+int brcmf_attach(struct device *dev, bool start_bus);
 /* Indication from bus module regarding removal/absence of dongle */
 void brcmf_detach(struct device *dev);
 void brcmf_free(struct device *dev);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
index bb96b87..6112650 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
@@ -9,6 +9,7 @@
 #include <linux/etherdevice.h>
 #include <linux/module.h>
 #include <linux/vmalloc.h>
+#include <linux/ctype.h>
 #include <net/cfg80211.h>
 #include <net/netlink.h>
 #include <uapi/linux/if_arp.h>
@@ -983,8 +984,36 @@ static struct wireless_dev *brcmf_cfg80211_add_iface(struct wiphy *wiphy,
 	struct brcmf_cfg80211_info *cfg = wiphy_to_cfg(wiphy);
 	struct brcmf_pub *drvr = cfg->pub;
 	struct wireless_dev *wdev;
+	struct net_device *dev;
 	int err;
 
+	/*
+	 * There is a bug with in-firmware BSS management. When adding virtual
+	 * interface brcmfmac first tells firmware to create new BSS and then
+	 * it creates new struct net_device.
+	 *
+	 * If creating/registering netdev(ice) fails, BSS remains in some bugged
+	 * state. It conflicts with existing BSSes by overtaking their auth
+	 * requests.
+	 *
+	 * It results in one BSS (addresss X) sending beacons and another BSS
+	 * (address Y) replying to authentication requests. This makes interface
+	 * unusable as AP.
+	 *
+	 * To workaround this bug we may try to guess if register_netdev(ice)
+	 * will fail. The most obvious case is using interface name that already
+	 * exists. This is actually quite likely with brcmfmac & some user space
+	 * scripts as brcmfmac doesn't allow deleting virtual interfaces.
+	 * So this bug can be triggered even by something trivial like:
+	 * iw dev wlan0 delete
+	 * iw phy phy0 interface add wlan0 type __ap
+	 */
+	dev = dev_get_by_name(&init_net, name);
+	if (dev) {
+		dev_put(dev);
+		return ERR_PTR(-ENFILE);
+	}
+
 	brcmf_dbg(TRACE, "enter: %s type %d\n", name, type);
 	err = brcmf_vif_add_validate(wiphy_to_cfg(wiphy), type);
 	if (err) {
@@ -2483,43 +2512,50 @@ brcmf_cfg80211_connect(struct wiphy *wiphy, struct net_device *ndev,
 		goto done;
 	}
 
-	if (sme->crypto.psk &&
-	    profile->use_fwsup != BRCMF_PROFILE_FWSUP_SAE) {
-		if (WARN_ON(profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE)) {
-			err = -EINVAL;
-			goto done;
+	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_FWSUP)) {
+		if (sme->crypto.psk) {
+			if (profile->use_fwsup != BRCMF_PROFILE_FWSUP_SAE) {
+				if (WARN_ON(profile->use_fwsup !=
+					BRCMF_PROFILE_FWSUP_NONE)) {
+					err = -EINVAL;
+					goto done;
+				}
+				brcmf_dbg(INFO, "using PSK offload\n");
+				profile->use_fwsup = BRCMF_PROFILE_FWSUP_PSK;
+			}
+		} else {
+			profile->use_fwsup = BRCMF_PROFILE_FWSUP_NONE;
 		}
-		brcmf_dbg(INFO, "using PSK offload\n");
-		profile->use_fwsup = BRCMF_PROFILE_FWSUP_PSK;
-	}
 
-	if (profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {
-		/* enable firmware supplicant for this interface */
-		err = brcmf_fil_iovar_int_set(ifp, "sup_wpa", 1);
-		if (err < 0) {
-			bphy_err(drvr, "failed to enable fw supplicant\n");
-			goto done;
+		if (profile->use_fwsup != BRCMF_PROFILE_FWSUP_NONE) {
+			/* enable firmware supplicant for this interface */
+			err = brcmf_fil_iovar_int_set(ifp, "sup_wpa", 1);
+			if (err < 0) {
+				bphy_err(drvr, "failed to enable fw supplicant\n");
+				goto done;
+			}
+		} else {
+			err = brcmf_fil_iovar_int_set(ifp, "sup_wpa", 0);
 		}
-	}
 
-	if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_PSK)
-		err = brcmf_set_pmk(ifp, sme->crypto.psk,
-				    BRCMF_WSEC_MAX_PSK_LEN);
-	else if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_SAE) {
-		/* clean up user-space RSNE */
-		err = brcmf_fil_iovar_data_set(ifp, "wpaie", NULL, 0);
-		if (err) {
-			bphy_err(drvr, "failed to clean up user-space RSNE\n");
-			goto done;
-		}
-		err = brcmf_fwvid_set_sae_password(ifp, &sme->crypto);
-		if (!err && sme->crypto.psk)
+		if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_PSK) {
 			err = brcmf_set_pmk(ifp, sme->crypto.psk,
 					    BRCMF_WSEC_MAX_PSK_LEN);
+		} else if (profile->use_fwsup == BRCMF_PROFILE_FWSUP_SAE) {
+			/* clean up user-space RSNE */
+			err = brcmf_fil_iovar_data_set(ifp, "wpaie", NULL, 0);
+			if (err) {
+				bphy_err(drvr, "failed to clean up user-space RSNE\n");
+				goto done;
+			}
+			err = brcmf_fwvid_set_sae_password(ifp, &sme->crypto);
+			if (!err && sme->crypto.psk)
+				err = brcmf_set_pmk(ifp, sme->crypto.psk,
+						    BRCMF_WSEC_MAX_PSK_LEN);
+		}
+		if (err)
+			goto done;
 	}
-	if (err)
-		goto done;
-
 	/* Join with specific BSSID and cached SSID
 	 * If SSID is zero join based on BSSID only
 	 */
@@ -3331,6 +3367,7 @@ brcmf_cfg80211_set_power_mgmt(struct wiphy *wiphy, struct net_device *ndev,
 			bphy_err(drvr, "error (%d)\n", err);
 	}
 
+	timeout = 2000; /* 2000ms - the maximum */
 	err = brcmf_fil_iovar_int_set(ifp, "pm2_sleep_ret",
 				min_t(u32, timeout, BRCMF_PS_MAX_TIMEOUT_MS));
 	if (err)
@@ -8012,6 +8049,7 @@ static s32 brcmf_translate_country_code(struct brcmf_pub *drvr, char alpha2[2],
 	return 0;
 }
 
+#if !defined(CONFIG_ARCH_BCM2835)
 static int
 brcmf_parse_dump_obss(char *buf, struct brcmf_dump_survey *survey)
 {
@@ -8234,6 +8272,7 @@ exit:
 		brcmf_set_mpc(ifp, 1);
 	return err;
 }
+#endif /* CONFIG_ARCH_BCM2835 */
 
 static void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,
 					struct regulatory_request *req)
@@ -8242,31 +8281,45 @@ static void brcmf_cfg80211_reg_notifier(struct wiphy *wiphy,
 	struct brcmf_if *ifp = brcmf_get_ifp(cfg->pub, 0);
 	struct brcmf_pub *drvr = cfg->pub;
 	struct brcmf_fil_country_le ccreq;
+	char *alpha2;
 	s32 err;
 	int i;
 
-	/* The country code gets set to "00" by default at boot, ignore */
-	if (req->alpha2[0] == '0' && req->alpha2[1] == '0')
+	err = brcmf_fil_iovar_data_get(ifp, "country", &ccreq, sizeof(ccreq));
+	if (err) {
+		bphy_err(drvr, "Country code iovar returned err = %d\n", err);
 		return;
+	}
+
+	/* The country code gets set to "00" by default at boot - substitute
+	 * any saved ccode from the nvram file unless there is a valid code
+	 * already set.
+	 */
+	alpha2 = req->alpha2;
+	if (alpha2[0] == '0' && alpha2[1] == '0') {
+		extern char saved_ccode[2];
+
+		if ((isupper(ccreq.country_abbrev[0]) &&
+		     isupper(ccreq.country_abbrev[1])) ||
+		    !saved_ccode[0])
+			return;
+		alpha2 = saved_ccode;
+		pr_debug("brcmfmac: substituting saved ccode %c%c\n",
+			 alpha2[0], alpha2[1]);
+	}
 
 	/* ignore non-ISO3166 country codes */
 	for (i = 0; i < 2; i++)
-		if (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {
+		if (alpha2[i] < 'A' || alpha2[i] > 'Z') {
 			bphy_err(drvr, "not an ISO3166 code (0x%02x 0x%02x)\n",
-				 req->alpha2[0], req->alpha2[1]);
+				 alpha2[0], alpha2[1]);
 			return;
 		}
 
 	brcmf_dbg(TRACE, "Enter: initiator=%d, alpha=%c%c\n", req->initiator,
-		  req->alpha2[0], req->alpha2[1]);
-
-	err = brcmf_fil_iovar_data_get(ifp, "country", &ccreq, sizeof(ccreq));
-	if (err) {
-		bphy_err(drvr, "Country code iovar returned err = %d\n", err);
-		return;
-	}
+		  alpha2[0], alpha2[1]);
 
-	err = brcmf_translate_country_code(ifp->drvr, req->alpha2, &ccreq);
+	err = brcmf_translate_country_code(ifp->drvr, alpha2, &ccreq);
 	if (err)
 		return;
 
@@ -8386,8 +8439,10 @@ struct brcmf_cfg80211_info *brcmf_cfg80211_attach(struct brcmf_pub *drvr,
 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_WOWL_GTK))
 		ops->set_rekey_data = brcmf_cfg80211_set_rekey_data;
 #endif
+#if !defined(CONFIG_ARCH_BCM2835)
 	if (brcmf_feat_is_enabled(ifp, BRCMF_FEAT_DUMP_OBSS))
 		ops->dump_survey = brcmf_cfg80211_dump_survey;
+#endif /* CONFIG_ARCH_BCM2835 */
 
 	err = wiphy_register(wiphy);
 	if (err < 0) {
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
index 1b7c001..207af43 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/common.c
@@ -20,6 +20,8 @@
 #include "of.h"
 #include "firmware.h"
 #include "chip.h"
+#include "fweh.h"
+#include <brcm_hw_ids.h>
 
 MODULE_AUTHOR("Broadcom Corporation");
 MODULE_DESCRIPTION("Broadcom 802.11 wireless LAN fullmac driver.");
@@ -274,6 +276,8 @@ int brcmf_c_preinit_dcmds(struct brcmf_if *ifp)
 	char *clmver;
 	char *ptr;
 	s32 err;
+	struct eventmsgs_ext *eventmask_msg = NULL;
+	u8 msglen;
 
 	if (is_valid_ether_addr(ifp->mac_addr)) {
 		/* set mac address */
@@ -433,6 +437,41 @@ int brcmf_c_preinit_dcmds(struct brcmf_if *ifp)
 		goto done;
 	}
 
+	/* Enable event_msg_ext specific to 43012 chip */
+	if (bus->chip == CY_CC_43012_CHIP_ID) {
+		/* Program event_msg_ext to support event larger than 128 */
+		msglen = (roundup(BRCMF_E_LAST, NBBY) / NBBY) +
+				  EVENTMSGS_EXT_STRUCT_SIZE;
+		/* Allocate buffer for eventmask_msg */
+		eventmask_msg = kzalloc(msglen, GFP_KERNEL);
+		if (!eventmask_msg) {
+			err = -ENOMEM;
+			goto done;
+		}
+
+		/* Read the current programmed event_msgs_ext */
+		eventmask_msg->ver = EVENTMSGS_VER;
+		eventmask_msg->len = roundup(BRCMF_E_LAST, NBBY) / NBBY;
+		err = brcmf_fil_iovar_data_get(ifp, "event_msgs_ext",
+					       eventmask_msg,
+					       msglen);
+
+		/* Enable ULP event */
+		brcmf_dbg(EVENT, "enable event ULP\n");
+		setbit(eventmask_msg->mask, BRCMF_E_ULP);
+
+		/* Write updated Event mask */
+		eventmask_msg->ver = EVENTMSGS_VER;
+		eventmask_msg->command = EVENTMSGS_SET_MASK;
+		eventmask_msg->len = (roundup(BRCMF_E_LAST, NBBY) / NBBY);
+
+		err = brcmf_fil_iovar_data_set(ifp, "event_msgs_ext",
+					       eventmask_msg, msglen);
+		if (err) {
+			brcmf_err("Set event_msgs_ext error (%d)\n", err);
+			goto done;
+		}
+	}
 	/* Setup default scan channel time */
 	err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,
 				    BRCMF_DEFAULT_SCAN_CHANNEL_TIME);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
index 862a033..3a5a4de 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/core.c
@@ -1327,7 +1327,7 @@ int brcmf_alloc(struct device *dev, struct brcmf_mp_device *settings)
 	return 0;
 }
 
-int brcmf_attach(struct device *dev)
+int brcmf_attach(struct device *dev, bool start_bus)
 {
 	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
 	struct brcmf_pub *drvr = bus_if->drvr;
@@ -1370,10 +1370,13 @@ int brcmf_attach(struct device *dev)
 
 	brcmf_fwvid_get_cfg80211_ops(drvr);
 
-	ret = brcmf_bus_started(drvr, drvr->ops);
-	if (ret != 0) {
-		bphy_err(drvr, "dongle is not responding: err=%d\n", ret);
-		goto fail;
+	if (start_bus) {
+		ret = brcmf_bus_started(drvr, drvr->ops);
+		if (ret != 0) {
+			bphy_err(drvr, "dongle is not responding: err=%d\n",
+				 ret);
+			goto fail;
+		}
 	}
 
 	return 0;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
index acc9c2b..c5c56c7 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/debug.h
@@ -29,6 +29,7 @@
 #define BRCMF_MSGBUF_VAL	0x00040000
 #define BRCMF_PCIE_VAL		0x00080000
 #define BRCMF_FWCON_VAL		0x00100000
+#define BRCMF_ULP_VAL		0x00200000
 
 /* set default print format */
 #undef pr_fmt
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
index ef79924..0ef3d8d 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c
@@ -10,6 +10,7 @@
 #include <linux/firmware.h>
 #include <linux/module.h>
 #include <linux/bcm47xx_nvram.h>
+#include <linux/ctype.h>
 
 #include "debug.h"
 #include "firmware.h"
@@ -32,6 +33,8 @@ enum nvram_parser_state {
 	END
 };
 
+char saved_ccode[2] = {};
+
 /**
  * struct nvram_parser - internal info for parser.
  *
@@ -566,11 +569,27 @@ static int brcmf_fw_request_nvram_done(const struct firmware *fw, void *ctx)
 		}
 	}
 
-	if (data)
+	if (data) {
+		char *ccode = strnstr((char *)data, "ccode=", data_len);
+		/* Ensure this is a whole token */
+		if (ccode && ((void *)ccode == (void *)data || isspace(ccode[-1]))) {
+			/* Comment out the line */
+			ccode[0] = '#';
+			ccode += 6;
+			if (isupper(ccode[0]) && isupper(ccode[1]) &&
+			    isspace(ccode[2])) {
+				pr_debug("brcmfmac: intercepting ccode=%c%c\n",
+					 ccode[0], ccode[1]);
+				saved_ccode[0] = ccode[0];
+				saved_ccode[1] = ccode[1];
+			}
+		};
+
 		nvram = brcmf_fw_nvram_strip(data, data_len, &nvram_length,
 					     fwctx->req->domain_nr,
 					     fwctx->req->bus_nr,
 					     fwctx->dev);
+	}
 
 	if (free_bcm47xx_nvram)
 		bcm47xx_nvram_release_contents(data);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
index e327dd5..b2be07d 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/fweh.h
@@ -98,7 +98,8 @@ struct brcmf_cfg80211_info;
 	BRCMF_ABSTRACT_ENUM_DEF(EXT_AUTH_REQ, 0) \
 	BRCMF_ABSTRACT_ENUM_DEF(EXT_AUTH_FRAME_RX, 1) \
 	BRCMF_ABSTRACT_ENUM_DEF(MGMT_FRAME_TXSTATUS, 2) \
-	BRCMF_ABSTRACT_ENUM_DEF(MGMT_FRAME_OFFCHAN_DONE, 3)
+	BRCMF_ABSTRACT_ENUM_DEF(MGMT_FRAME_OFFCHAN_DONE, 3) \
+	BRCMF_ENUM_DEF(ULP, 146)
 
 #define BRCMF_ENUM_DEF(id, val) \
 	BRCMF_E_##id = (val),
@@ -106,6 +107,12 @@ struct brcmf_cfg80211_info;
 /* firmware event codes sent by the dongle */
 enum brcmf_fweh_event_code {
 	BRCMF_FWEH_EVENT_ENUM_DEFLIST
+
+	/* this determines event mask length which must match
+	 * minimum length check in device firmware so it is
+	 * hard-coded here.
+	 */
+	BRCMF_E_LAST
 };
 #undef BRCMF_ENUM_DEF
 
@@ -284,6 +291,28 @@ struct brcmf_if_event {
 	u8 role;
 };
 
+enum event_msgs_ext_command {
+	EVENTMSGS_NONE		=	0,
+	EVENTMSGS_SET_BIT	=	1,
+	EVENTMSGS_RESET_BIT	=	2,
+	EVENTMSGS_SET_MASK	=	3
+};
+
+#define EVENTMSGS_VER 1
+#define EVENTMSGS_EXT_STRUCT_SIZE	offsetof(struct eventmsgs_ext, mask[0])
+
+/* len-	for SET it would be mask size from the application to the firmware */
+/*		for GET it would be actual firmware mask size */
+/* maxgetsize -	is only used for GET. indicate max mask size that the */
+/*				application can read from the firmware */
+struct eventmsgs_ext {
+	u8	ver;
+	u8	command;
+	u8	len;
+	u8	maxgetsize;
+	u8	mask[1];
+};
+
 typedef int (*brcmf_fweh_handler_t)(struct brcmf_if *ifp,
 				    const struct brcmf_event_msg *evtmsg,
 				    void *data);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
index e1752a5..20e5bde 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/p2p.c
@@ -1281,6 +1281,10 @@ static s32 brcmf_p2p_abort_action_frame(struct brcmf_cfg80211_info *cfg)
 	brcmf_dbg(TRACE, "Enter\n");
 
 	vif = p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif;
+
+	if (!vif)
+		vif = p2p->bss_idx[P2PAPI_BSSCFG_PRIMARY].vif;
+
 	err = brcmf_fil_bsscfg_data_set(vif->ifp, "actframe_abort", &int_val,
 					sizeof(s32));
 	if (err)
@@ -1817,6 +1821,7 @@ bool brcmf_p2p_send_action_frame(struct brcmf_if *ifp,
 	/* validate channel and p2p ies */
 	if (config_af_params.search_channel &&
 	    IS_P2P_SOCIAL_CHANNEL(le32_to_cpu(af_params->channel)) &&
+	    p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif &&
 	    p2p->bss_idx[P2PAPI_BSSCFG_DEVICE].vif->saved_ie.probe_req_ie_len) {
 		afx_hdl = &p2p->afx_hdl;
 		afx_hdl->peer_listen_chan = le32_to_cpu(af_params->channel);
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
index 84e4a1a..aefd54d 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c
@@ -2214,7 +2214,7 @@ static void brcmf_pcie_setup(struct device *dev, int ret,
 
 	init_waitqueue_head(&devinfo->mbdata_resp_wait);
 
-	ret = brcmf_attach(&devinfo->pdev->dev);
+	ret = brcmf_attach(&devinfo->pdev->dev, true);
 	if (ret)
 		goto fail;
 
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
index 8cf9d7e..bc828f8 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c
@@ -35,9 +35,12 @@
 #include "core.h"
 #include "common.h"
 #include "bcdc.h"
+#include "debug.h"
+#include "fwil.h"
 
 #define DCMD_RESP_TIMEOUT	msecs_to_jiffies(2500)
 #define CTL_DONE_TIMEOUT	msecs_to_jiffies(2500)
+#define ULP_HUDI_PROC_DONE_TIME	msecs_to_jiffies(2500)
 
 /* watermark expressed in number of words */
 #define DEFAULT_F2_WATERMARK    0x8
@@ -325,7 +328,16 @@ struct rte_console {
 
 #define KSO_WAIT_US 50
 #define MAX_KSO_ATTEMPTS (PMU_MAX_TRANSITION_DLY/KSO_WAIT_US)
-#define BRCMF_SDIO_MAX_ACCESS_ERRORS	5
+#define BRCMF_SDIO_MAX_ACCESS_ERRORS	20
+
+static void brcmf_sdio_firmware_callback(struct device *dev, int err,
+					 struct brcmf_fw_request *fwreq);
+static struct brcmf_fw_request *
+	brcmf_sdio_prepare_fw_request(struct brcmf_sdio *bus);
+static int brcmf_sdio_f2_ready(struct brcmf_sdio *bus);
+static int brcmf_ulp_event_notify(struct brcmf_if *ifp,
+				  const struct brcmf_event_msg *evtmsg,
+				  void *data);
 
 #ifdef DEBUG
 /* Device console log buffer state */
@@ -609,6 +621,7 @@ BRCMF_FW_DEF(4329, "brcmfmac4329-sdio");
 BRCMF_FW_DEF(4330, "brcmfmac4330-sdio");
 BRCMF_FW_DEF(4334, "brcmfmac4334-sdio");
 BRCMF_FW_DEF(43340, "brcmfmac43340-sdio");
+BRCMF_FW_DEF(43341, "brcmfmac43341-sdio");
 BRCMF_FW_DEF(4335, "brcmfmac4335-sdio");
 BRCMF_FW_DEF(43362, "brcmfmac43362-sdio");
 BRCMF_FW_DEF(4339, "brcmfmac4339-sdio");
@@ -618,7 +631,7 @@ BRCMF_FW_CLM_DEF(43430A1, "brcmfmac43430-sdio");
 BRCMF_FW_DEF(43430B0, "brcmfmac43430b0-sdio");
 BRCMF_FW_CLM_DEF(43439, "brcmfmac43439-sdio");
 BRCMF_FW_CLM_DEF(43455, "brcmfmac43455-sdio");
-BRCMF_FW_DEF(43456, "brcmfmac43456-sdio");
+BRCMF_FW_CLM_DEF(43456, "brcmfmac43456-sdio");
 BRCMF_FW_CLM_DEF(4354, "brcmfmac4354-sdio");
 BRCMF_FW_CLM_DEF(4356, "brcmfmac4356-sdio");
 BRCMF_FW_DEF(4359, "brcmfmac4359-sdio");
@@ -641,7 +654,7 @@ static const struct brcmf_firmware_mapping brcmf_sdio_fwnames[] = {
 	BRCMF_FW_ENTRY(BRCM_CC_4330_CHIP_ID, 0xFFFFFFFF, 4330),
 	BRCMF_FW_ENTRY(BRCM_CC_4334_CHIP_ID, 0xFFFFFFFF, 4334),
 	BRCMF_FW_ENTRY(BRCM_CC_43340_CHIP_ID, 0xFFFFFFFF, 43340),
-	BRCMF_FW_ENTRY(BRCM_CC_43341_CHIP_ID, 0xFFFFFFFF, 43340),
+	BRCMF_FW_ENTRY(BRCM_CC_43341_CHIP_ID, 0xFFFFFFFF, 43341),
 	BRCMF_FW_ENTRY(BRCM_CC_4335_CHIP_ID, 0xFFFFFFFF, 4335),
 	BRCMF_FW_ENTRY(BRCM_CC_43362_CHIP_ID, 0xFFFFFFFE, 43362),
 	BRCMF_FW_ENTRY(BRCM_CC_4339_CHIP_ID, 0xFFFFFFFF, 4339),
@@ -1105,7 +1118,7 @@ static void brcmf_sdio_get_console_addr(struct brcmf_sdio *bus)
 }
 #endif /* DEBUG */
 
-static u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus)
+static u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus, u32 *hmbd)
 {
 	struct brcmf_sdio_dev *sdiod = bus->sdiodev;
 	struct brcmf_core *core = bus->sdio_core;
@@ -1194,6 +1207,9 @@ static u32 brcmf_sdio_hostmail(struct brcmf_sdio *bus)
 			 HMB_DATA_FCDATA_MASK | HMB_DATA_VERSION_MASK))
 		brcmf_err("Unknown mailbox data content: 0x%02x\n",
 			  hmb_data);
+	/* Populate hmb_data if argument is passed for DS1 check later */
+	if (hmbd)
+		*hmbd = hmb_data;
 
 	return intstatus;
 }
@@ -2580,6 +2596,182 @@ static int brcmf_sdio_intr_rstatus(struct brcmf_sdio *bus)
 	return ret;
 }
 
+/* This Function is used to retrieve important
+ * details from dongle related to ULP mode Mostly
+ * values/SHM details that will be vary depending
+ * on the firmware branches
+ */
+static void
+brcmf_sdio_ulp_preinit(struct device *dev)
+{
+	struct brcmf_bus *bus_if = dev_get_drvdata(dev);
+	struct brcmf_sdio_dev *sdiodev = bus_if->bus_priv.sdio;
+	struct brcmf_if *ifp = bus_if->drvr->iflist[0];
+
+	brcmf_dbg(ULP, "Enter\n");
+
+	/* Query ulp_sdioctrl iovar to get the ULP related SHM offsets */
+	brcmf_fil_iovar_data_get(ifp, "ulp_sdioctrl",
+				 &sdiodev->fmac_ulp.ulp_shm_offset,
+				 sizeof(sdiodev->fmac_ulp.ulp_shm_offset));
+
+	sdiodev->ulp = false;
+
+	brcmf_dbg(ULP, "m_ulp_ctrl_sdio[%x] m_ulp_wakeevt_ind [%x]\n",
+		  M_DS1_CTRL_SDIO(sdiodev->fmac_ulp),
+		  M_WAKEEVENT_IND(sdiodev->fmac_ulp));
+	brcmf_dbg(ULP, "m_ulp_wakeind [%x]\n",
+		  M_ULP_WAKE_IND(sdiodev->fmac_ulp));
+}
+
+/* Reinitialize ARM because In DS1 mode ARM got off */
+static int
+brcmf_sdio_ulp_reinit_fw(struct brcmf_sdio *bus)
+{
+	struct brcmf_sdio_dev *sdiodev = bus->sdiodev;
+	struct brcmf_fw_request *fwreq;
+	int err = 0;
+
+	/* After firmware redownload tx/rx seq are reset accordingly
+	 * these values are reset on FMAC side tx_max is initially set to 4,
+	 * which later is updated by FW.
+	 */
+	bus->tx_seq = 0;
+	bus->rx_seq = 0;
+	bus->tx_max = 4;
+
+	fwreq = brcmf_sdio_prepare_fw_request(bus);
+	if (!fwreq)
+		return -ENOMEM;
+
+	err = brcmf_fw_get_firmwares(sdiodev->dev, fwreq,
+				     brcmf_sdio_firmware_callback);
+	if (err != 0) {
+		brcmf_err("async firmware request failed: %d\n", err);
+		kfree(fwreq);
+	}
+
+	return err;
+}
+
+/* Check if device is in DS1 mode and handshake with ULP UCODE */
+static bool
+brcmf_sdio_ulp_pre_redownload_check(struct brcmf_sdio *bus, u32 hmb_data)
+{
+	struct brcmf_sdio_dev *sdiod = bus->sdiodev;
+	int err = 0;
+	u32 value = 0;
+	u32 val32, ulp_wake_ind, wowl_wake_ind;
+	int reg_addr;
+	unsigned long timeout;
+	struct brcmf_ulp *fmac_ulp = &bus->sdiodev->fmac_ulp;
+	int i = 0;
+
+	/* If any host mail box data is present, ignore DS1 exit sequence */
+	if (hmb_data)
+		return false;
+	/* Skip if DS1 Exit is already in progress
+	 * This can happen if firmware download is taking more time
+	 */
+	if (fmac_ulp->ulp_state == FMAC_ULP_TRIGGERED)
+		return false;
+
+	value = brcmf_sdiod_func0_rb(sdiod, SDIO_CCCR_IOEx, &err);
+
+	if (value == SDIO_FUNC_ENABLE_1) {
+		brcmf_dbg(ULP, "GOT THE INTERRUPT FROM UCODE\n");
+		sdiod->ulp = true;
+		fmac_ulp->ulp_state = FMAC_ULP_TRIGGERED;
+		ulp_wake_ind = D11SHM_RDW(sdiod,
+					  M_ULP_WAKE_IND(sdiod->fmac_ulp),
+					  &err);
+		wowl_wake_ind = D11SHM_RDW(sdiod,
+					   M_WAKEEVENT_IND(sdiod->fmac_ulp),
+					   &err);
+
+		brcmf_dbg(ULP, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x state %s\n",
+			  wowl_wake_ind, ulp_wake_ind, (fmac_ulp->ulp_state) ?
+			  "DS1 Exit Triggered" : "IDLE State");
+
+		if (wowl_wake_ind || ulp_wake_ind) {
+			/* RX wake Don't do anything.
+			 * Just bail out and re-download firmware.
+			 */
+			 /* Print out PHY TX error block when bit 9 set */
+			if ((ulp_wake_ind & C_DS1_PHY_TXERR) &&
+			    M_DS1_PHYTX_ERR_BLK(sdiod->fmac_ulp)) {
+				brcmf_err("Dump PHY TX Error SHM Locations\n");
+				for (i = 0; i < PHYTX_ERR_BLK_SIZE; i++) {
+					pr_err("0x%x",
+					       D11SHM_RDW(sdiod,
+					       (M_DS1_PHYTX_ERR_BLK(sdiod->fmac_ulp) +
+						(i * 2)), &err));
+				}
+				brcmf_err("\n");
+			}
+		} else {
+			/* TX wake negotiate with MAC */
+			brcmf_dbg(ULP, "M_DS1_CTRL_SDIO: 0x%08x\n",
+				  (u32)D11SHM_RDW(sdiod,
+				  M_DS1_CTRL_SDIO(sdiod->fmac_ulp),
+				  &err));
+			val32 = D11SHM_RD(sdiod,
+					  M_DS1_CTRL_SDIO(sdiod->fmac_ulp),
+					  &err);
+			D11SHM_WR(sdiod, M_DS1_CTRL_SDIO(sdiod->fmac_ulp),
+				  val32, (C_DS1_CTRL_SDIO_DS1_EXIT |
+				  C_DS1_CTRL_REQ_VALID), &err);
+			val32 = D11REG_RD(sdiod, D11_MACCONTROL_REG, &err);
+			val32 = val32 | D11_MACCONTROL_REG_WAKE;
+			D11REG_WR(sdiod, D11_MACCONTROL_REG, val32, &err);
+
+			/* Poll for PROC_DONE to be set by ucode */
+			value = D11SHM_RDW(sdiod,
+					   M_DS1_CTRL_SDIO(sdiod->fmac_ulp),
+					   &err);
+			/* Wait here (polling) for C_DS1_CTRL_PROC_DONE */
+			timeout = jiffies + ULP_HUDI_PROC_DONE_TIME;
+			while (!(value & C_DS1_CTRL_PROC_DONE)) {
+				value = D11SHM_RDW(sdiod,
+						   M_DS1_CTRL_SDIO(sdiod->fmac_ulp),
+						   &err);
+				if (time_after(jiffies, timeout))
+					break;
+				usleep_range(1000, 2000);
+			}
+			brcmf_dbg(ULP, "M_DS1_CTRL_SDIO: 0x%08x\n",
+				  (u32)D11SHM_RDW(sdiod,
+				  M_DS1_CTRL_SDIO(sdiod->fmac_ulp), &err));
+			value = D11SHM_RDW(sdiod,
+					   M_DS1_CTRL_SDIO(sdiod->fmac_ulp),
+					   &err);
+			if (!(value & C_DS1_CTRL_PROC_DONE)) {
+				brcmf_err("Timeout Failed to enter DS1 Exit state!\n");
+				return false;
+			}
+		}
+
+		ulp_wake_ind = D11SHM_RDW(sdiod,
+					  M_ULP_WAKE_IND(sdiod->fmac_ulp),
+					  &err);
+		wowl_wake_ind = D11SHM_RDW(sdiod,
+					   M_WAKEEVENT_IND(sdiod->fmac_ulp),
+					   &err);
+		brcmf_dbg(ULP, "wowl_wake_ind: 0x%08x, ulp_wake_ind: 0x%08x\n",
+			  wowl_wake_ind, ulp_wake_ind);
+		reg_addr = CORE_CC_REG(
+			  brcmf_chip_get_pmu(bus->ci)->base, min_res_mask);
+		brcmf_sdiod_writel(sdiod, reg_addr,
+				   DEFAULT_43012_MIN_RES_MASK, &err);
+		if (err)
+			brcmf_err("min_res_mask failed\n");
+
+		return true;
+	}
+
+	return false;
+}
+
 static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 {
 	struct brcmf_sdio_dev *sdiod = bus->sdiodev;
@@ -2651,8 +2843,11 @@ static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 
 	/* Handle host mailbox indication */
 	if (intstatus & I_HMB_HOST_INT) {
+		u32 hmb_data = 0;
 		intstatus &= ~I_HMB_HOST_INT;
-		intstatus |= brcmf_sdio_hostmail(bus);
+		intstatus |= brcmf_sdio_hostmail(bus, &hmb_data);
+		if (brcmf_sdio_ulp_pre_redownload_check(bus, hmb_data))
+			brcmf_sdio_ulp_reinit_fw(bus);
 	}
 
 	sdio_release_host(bus->sdiodev->func1);
@@ -2697,7 +2892,7 @@ static void brcmf_sdio_dpc(struct brcmf_sdio *bus)
 	brcmf_sdio_clrintr(bus);
 
 	if (bus->ctrl_frame_stat && (bus->clkstate == CLK_AVAIL) &&
-	    txctl_ok(bus)) {
+	    txctl_ok(bus) && brcmf_sdio_f2_ready(bus)) {
 		sdio_claim_host(bus->sdiodev->func1);
 		if (bus->ctrl_frame_stat) {
 			err = brcmf_sdio_tx_ctrlframe(bus,  bus->ctrl_frame_buf,
@@ -3568,6 +3763,10 @@ static int brcmf_sdio_bus_preinit(struct device *dev)
 	if (err < 0)
 		goto done;
 
+	/* initialize SHM address from firmware for DS1 */
+	if (!bus->sdiodev->ulp)
+		brcmf_sdio_ulp_preinit(dev);
+
 	bus->tx_hdrlen = SDPCM_HWHDR_LEN + SDPCM_SWHDR_LEN;
 	if (sdiodev->sg_support) {
 		bus->txglom = false;
@@ -4218,7 +4417,7 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 	u8 saveclk, bpreq;
 	u8 devctl;
 
-	brcmf_dbg(TRACE, "Enter: dev=%s, err=%d\n", dev_name(dev), err);
+	brcmf_dbg(ULP, "Enter: dev=%s, err=%d\n", dev_name(dev), err);
 
 	if (err)
 		goto fail;
@@ -4396,12 +4595,25 @@ static void brcmf_sdio_firmware_callback(struct device *dev, int err,
 	}
 
 	/* Attach to the common layer, reserve hdr space */
-	err = brcmf_attach(sdiod->dev);
+	err = brcmf_attach(sdiod->dev, !bus->sdiodev->ulp);
 	if (err != 0) {
 		brcmf_err("brcmf_attach failed\n");
 		goto free;
 	}
 
+	/* Register for ULP events */
+	if (sdiod->func1->device == SDIO_DEVICE_ID_BROADCOM_CYPRESS_43012)
+		brcmf_fweh_register(bus_if->drvr, BRCMF_E_ULP,
+				    brcmf_ulp_event_notify);
+
+	if (bus->sdiodev->ulp) {
+		/* For ULP, after firmware redownload complete
+		 * set ULP state to IDLE
+		 */
+		if (bus->sdiodev->fmac_ulp.ulp_state == FMAC_ULP_TRIGGERED)
+			bus->sdiodev->fmac_ulp.ulp_state = FMAC_ULP_IDLE;
+	}
+
 	/* ready */
 	return;
 
@@ -4648,3 +4860,40 @@ int brcmf_sdio_sleep(struct brcmf_sdio *bus, bool sleep)
 
 	return ret;
 }
+
+/* Check F2 Ready bit before sending data to Firmware */
+static int
+brcmf_sdio_f2_ready(struct brcmf_sdio *bus)
+{
+	int ret = -1;
+	int iordy_status = 0;
+
+	sdio_claim_host(bus->sdiodev->func1);
+	/* Read the status of IOR2 */
+	iordy_status = brcmf_sdiod_func0_rb(bus->sdiodev, SDIO_CCCR_IORx, NULL);
+
+	sdio_release_host(bus->sdiodev->func1);
+	ret = iordy_status & SDIO_FUNC_ENABLE_2;
+	return ret;
+}
+
+static int brcmf_ulp_event_notify(struct brcmf_if *ifp,
+				  const struct brcmf_event_msg *evtmsg,
+				  void *data)
+{
+	int err = 0;
+	struct brcmf_bus *bus_if = ifp->drvr->bus_if;
+	struct brcmf_sdio_dev *sdiodev;
+	struct brcmf_sdio *bus;
+	struct brcmf_ulp_event *ulp_event = (struct brcmf_ulp_event *)data;
+
+	sdiodev = bus_if->bus_priv.sdio;
+	bus = sdiodev->bus;
+
+	brcmf_dbg(ULP, "Chip went to DS1 state : action %d\n",
+		  ulp_event->ulp_dongle_action);
+	if (ulp_event->ulp_dongle_action == FMAC_ULP_ENTRY)
+		bus->sdiodev->fmac_ulp.ulp_state = FMAC_ULP_ENTRY_RECV;
+
+	return err;
+}
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
index 0d18ed1..aadf251 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.h
@@ -165,6 +165,35 @@ struct brcmf_sdreg {
 struct brcmf_sdio;
 struct brcmf_sdiod_freezer;
 
+/* ULP SHM Offsets info */
+struct ulp_shm_info {
+	u32 m_ulp_ctrl_sdio;
+	u32 m_ulp_wakeevt_ind;
+	u32 m_ulp_wakeind;
+	u32 m_ulp_phytxblk;
+};
+
+/* FMAC ULP state machine */
+#define FMAC_ULP_IDLE		(0)
+#define FMAC_ULP_ENTRY_RECV		(1)
+#define FMAC_ULP_TRIGGERED		(2)
+
+/* BRCMF_E_ULP event data */
+#define FMAC_ULP_EVENT_VERSION		1
+#define FMAC_ULP_DISABLE_CONSOLE		1 /* Disable console */
+#define FMAC_ULP_UCODE_DOWNLOAD		2 /* Download ULP ucode file */
+#define FMAC_ULP_ENTRY		3 /* Inform ulp entry to Host */
+
+struct brcmf_ulp {
+	uint ulp_state;
+	struct ulp_shm_info ulp_shm_offset;
+};
+
+struct brcmf_ulp_event {
+	u16 version;
+	u16 ulp_dongle_action;
+};
+
 struct brcmf_sdio_dev {
 	struct sdio_func *func1;
 	struct sdio_func *func2;
@@ -193,6 +222,8 @@ struct brcmf_sdio_dev {
 	enum brcmf_sdiod_state state;
 	struct brcmf_sdiod_freezer *freezer;
 	const struct firmware *clm_fw;
+	struct brcmf_ulp fmac_ulp;
+	bool ulp;
 };
 
 /* sdio core registers */
@@ -367,4 +398,83 @@ void brcmf_sdio_wowl_config(struct device *dev, bool enabled);
 int brcmf_sdio_sleep(struct brcmf_sdio *bus, bool sleep);
 void brcmf_sdio_trigger_dpc(struct brcmf_sdio *bus);
 
+/* SHM offsets */
+#define M_DS1_CTRL_SDIO(ptr)	((ptr).ulp_shm_offset.m_ulp_ctrl_sdio)
+#define M_WAKEEVENT_IND(ptr)	((ptr).ulp_shm_offset.m_ulp_wakeevt_ind)
+#define M_ULP_WAKE_IND(ptr)		((ptr).ulp_shm_offset.m_ulp_wakeind)
+#define M_DS1_PHYTX_ERR_BLK(ptr)	((ptr).ulp_shm_offset.m_ulp_phytxblk)
+
+#define D11_BASE_ADDR			0x18001000
+#define D11_AXI_BASE_ADDR		0xE8000000
+#define D11_SHM_BASE_ADDR		(D11_AXI_BASE_ADDR + 0x4000)
+
+#define D11REG_ADDR(offset)	(D11_BASE_ADDR + (offset))
+#define D11IHR_ADDR(offset)	(D11_AXI_BASE_ADDR + 0x400 + (2 * (offset)))
+#define D11SHM_ADDR(offset)	(D11_SHM_BASE_ADDR + (offset))
+
+/* MacControl register */
+#define D11_MACCONTROL_REG			D11REG_ADDR(0x120)
+#define D11_MACCONTROL_REG_WAKE		0x4000000
+
+/* HUDI Sequence SHM bits */
+#define	C_DS1_CTRL_SDIO_DS1_SLEEP		0x1
+#define	C_DS1_CTRL_SDIO_MAC_ON			0x2
+#define	C_DS1_CTRL_SDIO_RADIO_PHY_ON	0x4
+#define	C_DS1_CTRL_SDIO_DS1_EXIT		0x8
+#define	C_DS1_CTRL_PROC_DONE			0x100
+#define	C_DS1_CTRL_REQ_VALID			0x200
+
+/* M_ULP_WAKEIND bits */
+#define	C_WATCHDOG_EXPIRY	BIT(0)
+#define	C_FCBS_ERROR		BIT(1)
+#define	C_RETX_FAILURE		BIT(2)
+#define	C_HOST_WAKEUP		BIT(3)
+#define	C_INVALID_FCBS_BLOCK	BIT(4)
+#define	C_HUDI_DS1_EXIT		BIT(5)
+#define	C_LOB_SLEEP		BIT(6)
+#define	C_DS1_PHY_TXERR		BIT(9)
+#define	C_DS1_WAKE_TIMER	BIT(10)
+
+#define PHYTX_ERR_BLK_SIZE		18
+#define D11SHM_FIRST2BYTE_MASK		0xFFFF0000
+#define D11SHM_SECOND2BYTE_MASK		0x0000FFFF
+#define D11SHM_2BYTE_SHIFT		16
+
+#define D11SHM_RD(sdh, offset, ret) \
+	brcmf_sdiod_readl(sdh, D11SHM_ADDR(offset), ret)
+
+/* SHM Read is motified based on SHM 4 byte alignment as SHM size is 2 bytes and
+ * 2 byte is currently not working on FMAC
+ * If SHM address is not 4 byte aligned, then right shift by 16
+ * otherwise, mask the first two MSB bytes
+ * Suppose data in address 7260 is 0x440002 and it is 4 byte aligned
+ * Correct SHM value is 0x2 for this SHM offset and next SHM value is 0x44
+ */
+#define D11SHM_RDW(sdh, offset, ret) \
+	((offset % 4) ? \
+		(brcmf_sdiod_readl(sdh, D11SHM_ADDR(offset), ret) \
+		>> D11SHM_2BYTE_SHIFT) : \
+		(brcmf_sdiod_readl(sdh, D11SHM_ADDR(offset), ret) \
+		& D11SHM_SECOND2BYTE_MASK))
+
+/* SHM is of size 2 bytes, 4 bytes write will overwrite other SHM's
+ * First read 4 bytes and then clear the required two bytes based on
+ * 4 byte alignment, then update the required value and write the
+ * 4 byte value now
+ */
+#define D11SHM_WR(sdh, offset, val, mask, ret) \
+	do { \
+		if ((offset) % 4) \
+			val = (val & D11SHM_SECOND2BYTE_MASK) | \
+				((mask) << D11SHM_2BYTE_SHIFT); \
+		else \
+			val = (mask) | (val & D11SHM_FIRST2BYTE_MASK); \
+		brcmf_sdiod_writel(sdh, D11SHM_ADDR(offset), val, ret); \
+	} while (0)
+#define D11REG_WR(sdh, addr, val, ret) \
+	brcmf_sdiod_writel(sdh, addr, val, ret)
+
+#define D11REG_RD(sdh, addr, ret) \
+	brcmf_sdiod_readl(sdh, addr, ret)
+
 #endif /* BRCMFMAC_SDIO_H */
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
index 23cd5e2..9965617 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/tracepoint.h
@@ -41,7 +41,11 @@ TRACE_EVENT(brcmf_err,
 		__vstring(msg, vaf->fmt, vaf->va)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(func);
+#else
+		__assign_str(func, func);
+#endif
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s: %s", __get_str(func), __get_str(msg))
@@ -57,7 +61,11 @@ TRACE_EVENT(brcmf_dbg,
 	),
 	TP_fast_assign(
 		__entry->level = level;
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(func);
+#else
+		__assign_str(func, func);
+#endif
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s: %s", __get_str(func), __get_str(msg))
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
index f0129d1..5bedc8f 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c
@@ -1208,7 +1208,7 @@ static void brcmf_usb_probe_phase2(struct device *dev, int ret,
 		goto error;
 
 	/* Attach to the common driver interface */
-	ret = brcmf_attach(devinfo->dev);
+	ret = brcmf_attach(devinfo->dev, true);
 	if (ret)
 		goto error;
 
@@ -1288,7 +1288,7 @@ static int brcmf_usb_probe_cb(struct brcmf_usbdev_info *devinfo,
 		ret = brcmf_alloc(devinfo->dev, devinfo->settings);
 		if (ret)
 			goto fail;
-		ret = brcmf_attach(devinfo->dev);
+		ret = brcmf_attach(devinfo->dev, true);
 		if (ret)
 			goto fail;
 		/* we are done */
@@ -1585,7 +1585,11 @@ static int brcmf_usb_reset_device(struct device *dev, void *notused)
 
 void brcmf_usb_exit(void)
 {
+#if LINUX_VERSION_IS_GEQ(6,8,0)
 	struct device_driver *drv = &brcmf_usbdrvr.driver;
+#else
+	struct device_driver *drv = &brcmf_usbdrvr.drvwrap.driver;
+#endif
 	int ret;
 
 	brcmf_dbg(USB, "Enter\n");
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
index bf8510b..224025c 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac.h
@@ -81,7 +81,11 @@ TRACE_EVENT(brcms_macintstatus,
 		__field(u32, mask)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(dev);
+#else
+		__assign_str(dev, dev_name(dev));
+#endif
 		__entry->in_isr = in_isr;
 		__entry->macintstatus = macintstatus;
 		__entry->mask = mask;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
index e31bd3c..394304d 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_msg.h
@@ -71,7 +71,11 @@ TRACE_EVENT(brcms_dbg,
 	),
 	TP_fast_assign(
 		__entry->level = level;
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(func);
+#else
+		__assign_str(func, func);
+#endif
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s: %s", __get_str(func), __get_str(msg))
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
index c1ea40e..48a50df 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/brcms_trace_brcmsmac_tx.h
@@ -31,7 +31,11 @@ TRACE_EVENT(brcms_txdesc,
 		__dynamic_array(u8, txh, txh_len)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(dev);
+#else
+		__assign_str(dev, dev_name(dev));
+#endif
 		memcpy(__get_dynamic_array(txh), txh, txh_len);
 	),
 	TP_printk("[%s] txdesc", __get_str(dev))
@@ -54,7 +58,11 @@ TRACE_EVENT(brcms_txstatus,
 		__field(u16, ackphyrxsh)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(dev);
+#else
+		__assign_str(dev, dev_name(dev));
+#endif
 		__entry->framelen = framelen;
 		__entry->frameid = frameid;
 		__entry->status = status;
@@ -85,7 +93,11 @@ TRACE_EVENT(brcms_ampdu_session,
 		__field(u16, dma_len)
 	),
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(dev);
+#else
+		__assign_str(dev, dev_name(dev));
+#endif
 		__entry->max_ampdu_len = max_ampdu_len;
 		__entry->max_ampdu_frames = max_ampdu_frames;
 		__entry->ampdu_len = ampdu_len;
diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
index 3878c41..deedbd6 100644
--- a/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
+++ b/drivers/net/wireless/broadcom/brcm80211/brcmsmac/channel.c
@@ -58,19 +58,12 @@
 				 (((c) < 149) ? 3 : 4))))
 
 #define BRCM_2GHZ_2412_2462	REG_RULE(2412-10, 2462+10, 40, 0, 19, 0)
-#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, \
-					 NL80211_RRF_NO_IR)
-
-#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, \
-					 NL80211_RRF_DFS | \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, \
-					 NL80211_RRF_DFS | \
-					 NL80211_RRF_NO_IR)
-#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, \
-					 NL80211_RRF_NO_IR)
+#define BRCM_2GHZ_2467_2472	REG_RULE(2467-10, 2472+10, 20, 0, 19, 0)
+
+#define BRCM_5GHZ_5180_5240	REG_RULE(5180-10, 5240+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5260_5320	REG_RULE(5260-10, 5320+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5500_5700	REG_RULE(5500-10, 5700+10, 40, 0, 21, 0)
+#define BRCM_5GHZ_5745_5825	REG_RULE(5745-10, 5825+10, 40, 0, 21, 0)
 
 static const struct ieee80211_regdomain brcms_regdom_x2 = {
 	.n_reg_rules = 6,
diff --git a/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h b/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
index 0340bba..090a75b 100644
--- a/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
+++ b/drivers/net/wireless/broadcom/brcm80211/include/chipcommon.h
@@ -308,4 +308,6 @@ struct chipcregs {
 */
 #define PMU_MAX_TRANSITION_DLY	15000
 
+#define DEFAULT_43012_MIN_RES_MASK 0x0f8bfe77
+
 #endif				/* _SBCHIPC_H */
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
index 0db1fa5..25cc7df 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace-msg.h
@@ -57,7 +57,11 @@ TRACE_EVENT(iwlwifi_dbg,
 	),
 	TP_fast_assign(
 		__entry->level = level;
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(function);
+#else
+		__assign_str(function, function);
+#endif
 		__assign_vstr(msg, vaf->fmt, vaf->va);
 	),
 	TP_printk("%s", __get_str(msg))
diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
index 1a06f9e..f1fbcac 100644
--- a/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
+++ b/drivers/net/wireless/intel/iwlwifi/iwl-devtrace.h
@@ -88,7 +88,11 @@ static inline void trace_ ## name(proto) {}
 #endif
 
 #define DEV_ENTRY	__string(dev, dev_name(dev))
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 #define DEV_ASSIGN	__assign_str(dev)
+#else
+#define DEV_ASSIGN	__assign_str(dev, dev_name(dev))
+#endif
 
 #include "iwl-devtrace-io.h"
 #include "iwl-devtrace-ucode.h"
diff --git a/drivers/net/wireless/intel/iwlwifi/mld/thermal.c b/drivers/net/wireless/intel/iwlwifi/mld/thermal.c
index f8a8c35..1d7e3f0 100644
--- a/drivers/net/wireless/intel/iwlwifi/mld/thermal.c
+++ b/drivers/net/wireless/intel/iwlwifi/mld/thermal.c
@@ -209,9 +209,15 @@ unlock:
 	return ret;
 }
 
+#if LINUX_VERSION_IS_GEQ(6,11,0)
 static int iwl_mld_tzone_set_trip_temp(struct thermal_zone_device *device,
 				       const struct thermal_trip *trip,
 				       int temp)
+#else
+static int iwl_mld_tzone_set_trip_temp(struct thermal_zone_device *device,
+				       int trip,
+				       int temp)
+#endif
 {
 	struct iwl_mld *mld = thermal_zone_device_priv(device);
 	int ret;
@@ -248,18 +254,29 @@ static void iwl_mld_thermal_zone_register(struct iwl_mld *mld)
 		[0 ... IWL_MAX_DTS_TRIPS - 1] = {
 			.temperature = THERMAL_TEMP_INVALID,
 			.type = THERMAL_TRIP_PASSIVE,
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 			.flags = THERMAL_TRIP_FLAG_RW_TEMP,
+#endif
 		},
 	};
 
 	BUILD_BUG_ON(ARRAY_SIZE(name) >= THERMAL_NAME_LENGTH);
 
 	sprintf(name, "iwlwifi_%u", atomic_inc_return(&counter) & 0xFF);
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 	mld->tzone =
 		thermal_zone_device_register_with_trips(name, trips,
 							IWL_MAX_DTS_TRIPS,
 							mld, &tzone_ops,
 							NULL, 0, 0);
+#else
+	mld->tzone =
+		thermal_zone_device_register_with_trips(name, trips,
+							IWL_MAX_DTS_TRIPS, 0,
+							mld, &tzone_ops,
+							NULL, 0, 0);
+#endif
+
 	if (IS_ERR(mld->tzone)) {
 		IWL_DEBUG_TEMP(mld,
 			       "Failed to register to thermal zone (err = %ld)\n",
diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
index 53bab21..4bbffae 100644
--- a/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tt.c
@@ -626,8 +626,13 @@ static int iwl_mvm_tzone_get_temp(struct thermal_zone_device *device,
 	return 0;
 }
 
+#if LINUX_VERSION_IS_GEQ(6,11,0)
 static int iwl_mvm_tzone_set_trip_temp(struct thermal_zone_device *device,
 				       const struct thermal_trip *trip, int temp)
+#else
+static int iwl_mvm_tzone_set_trip_temp(struct thermal_zone_device *device,
+				       int trip, int temp)
+#endif
 {
 	struct iwl_mvm *mvm = thermal_zone_device_priv(device);
 
@@ -670,13 +675,23 @@ static void iwl_mvm_thermal_zone_register(struct iwl_mvm *mvm)
 	for (i = 0 ; i < IWL_MAX_DTS_TRIPS; i++) {
 		mvm->tz_device.trips[i].temperature = THERMAL_TEMP_INVALID;
 		mvm->tz_device.trips[i].type = THERMAL_TRIP_PASSIVE;
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 		mvm->tz_device.trips[i].flags = THERMAL_TRIP_FLAG_RW_TEMP;
+#endif
 	}
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 	mvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,
 							mvm->tz_device.trips,
 							IWL_MAX_DTS_TRIPS,
 							mvm, &tzone_ops,
 							NULL, 0, 0);
+#else
+	mvm->tz_device.tzone = thermal_zone_device_register_with_trips(name,
+							mvm->tz_device.trips,
+							IWL_MAX_DTS_TRIPS, 0,
+							mvm, &tzone_ops,
+							NULL, 0, 0);
+#endif
 	if (IS_ERR(mvm->tz_device.tzone)) {
 		IWL_DEBUG_TEMP(mvm,
 			       "Failed to register to thermal zone (err = %ld)\n",
diff --git a/drivers/net/wireless/marvell/libertas/cfg.c b/drivers/net/wireless/marvell/libertas/cfg.c
index caba749..267c5de 100644
--- a/drivers/net/wireless/marvell/libertas/cfg.c
+++ b/drivers/net/wireless/marvell/libertas/cfg.c
@@ -2105,6 +2105,8 @@ struct wireless_dev *lbs_cfg_alloc(struct device *dev)
 		goto err_wiphy_new;
 	}
 
+	set_wiphy_dev(wdev->wiphy, dev);
+
 	return wdev;
 
  err_wiphy_new:
@@ -2180,6 +2182,8 @@ int lbs_cfg_register(struct lbs_private *priv)
 	wdev->wiphy->n_cipher_suites = ARRAY_SIZE(cipher_suites);
 	wdev->wiphy->reg_notifier = lbs_reg_notifier;
 
+	memcpy(wdev->wiphy->perm_addr, priv->current_addr, ETH_ALEN);
+
 	ret = wiphy_register(wdev->wiphy);
 	if (ret < 0)
 		pr_err("cannot register wiphy device\n");
diff --git a/drivers/net/wireless/marvell/libertas/main.c b/drivers/net/wireless/marvell/libertas/main.c
index d44e02c..ba143b2 100644
--- a/drivers/net/wireless/marvell/libertas/main.c
+++ b/drivers/net/wireless/marvell/libertas/main.c
@@ -852,6 +852,7 @@ struct lbs_private *lbs_add_card(void *card, struct device *dmdev)
 		goto err_adapter;
 	}
 
+	dev_net_set(dev, wiphy_net(wdev->wiphy));
 	dev->ieee80211_ptr = wdev;
 	dev->ml_priv = priv;
 	SET_NETDEV_DEV(dev, dmdev);
diff --git a/drivers/net/wireless/marvell/mwifiex/cmdevt.c b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
index 0f466c3..ad7f6d8 100644
--- a/drivers/net/wireless/marvell/mwifiex/cmdevt.c
+++ b/drivers/net/wireless/marvell/mwifiex/cmdevt.c
@@ -16,6 +16,85 @@
 
 static void mwifiex_cancel_pending_ioctl(struct mwifiex_adapter *adapter);
 
+const char *
+mwifiex_cmd_to_str(u16 command)
+{
+	switch (command) {
+	case HostCmd_CMD_GET_HW_SPEC:			return "GET_HW_SPEC";
+	case HostCmd_CMD_802_11_SCAN:			return "SCAN";
+	case HostCmd_CMD_802_11_GET_LOG:		return "GET_LOG";
+	case HostCmd_CMD_MAC_MULTICAST_ADR:		return "MAC_MULTICAST_ADR";
+	case HostCmd_CMD_802_11_EEPROM_ACCESS:		return "EEPROM_ACCESS";
+	case HostCmd_CMD_802_11_ASSOCIATE:		return "ASSOCIATE";
+	case HostCmd_CMD_802_11_SNMP_MIB:		return "SNMP_MIB";
+	case HostCmd_CMD_MAC_REG_ACCESS:		return "MAC_REG_ACCESS";
+	case HostCmd_CMD_BBP_REG_ACCESS:		return "BBP_REG_ACCESS";
+	case HostCmd_CMD_RF_REG_ACCESS:			return "RF_REG_ACCESS";
+	case HostCmd_CMD_PMIC_REG_ACCESS:		return "PMIC_REG_ACCESS";
+	case HostCmd_CMD_RF_TX_PWR:			return "RF_TX_PWR";
+	case HostCmd_CMD_RF_ANTENNA:			return "RF_ANTENNA";
+	case HostCmd_CMD_802_11_DEAUTHENTICATE:		return "DEAUTHENTICATE";
+	case HostCmd_CMD_MAC_CONTROL:			return "MAC_CONTROL";
+	case HostCmd_CMD_802_11_AD_HOC_START:		return "AD_HOC_START";
+	case HostCmd_CMD_802_11_AD_HOC_JOIN:		return "AD_HOC_JOIN";
+	case HostCmd_CMD_802_11_AD_HOC_STOP:		return "AD_HOC_STOP";
+	case HostCmd_CMD_802_11_MAC_ADDRESS:		return "MAC_ADDRESS";
+	case HostCmd_CMD_802_11D_DOMAIN_INFO:		return "DOMAIN_INFO";
+	case HostCmd_CMD_802_11_KEY_MATERIAL:		return "KEY_MATERIAL";
+	case HostCmd_CMD_802_11_BG_SCAN_CONFIG:		return "BG_SCAN_CONFIG";
+	case HostCmd_CMD_802_11_BG_SCAN_QUERY:		return "BG_SCAN_QUERY";
+	case HostCmd_CMD_WMM_GET_STATUS:		return "WMM_GET_STATUS";
+	case HostCmd_CMD_802_11_SUBSCRIBE_EVENT:	return "SUBSCRIBE_EVENT";
+	case HostCmd_CMD_802_11_TX_RATE_QUERY:		return "TX_RATE_QUERY";
+	case HostCmd_CMD_802_11_IBSS_COALESCING_STATUS:	return "IBSS_COALESCING_STATUS";
+	case HostCmd_CMD_MEM_ACCESS:			return "MEM_ACCESS";
+	case HostCmd_CMD_CFG_DATA:			return "CFG_DATA";
+	case HostCmd_CMD_VERSION_EXT:			return "VERSION_EXT";
+	case HostCmd_CMD_MEF_CFG:			return "MEF_CFG";
+	case HostCmd_CMD_RSSI_INFO:			return "RSSI_INFO";
+	case HostCmd_CMD_FUNC_INIT:			return "FUNC_INIT";
+	case HostCmd_CMD_FUNC_SHUTDOWN:			return "FUNC_SHUTDOWN";
+	case HOST_CMD_APCMD_SYS_RESET:			return "SYS_RESET";
+	case HostCmd_CMD_UAP_SYS_CONFIG:		return "UAP_SYS_CONFIG";
+	case HostCmd_CMD_UAP_BSS_START:			return "UAP_BSS_START";
+	case HostCmd_CMD_UAP_BSS_STOP:			return "UAP_BSS_STOP";
+	case HOST_CMD_APCMD_STA_LIST:			return "STA_LIST";
+	case HostCmd_CMD_UAP_STA_DEAUTH:		return "UAP_STA_DEAUTH";
+	case HostCmd_CMD_11N_CFG:			return "11N_CFG";
+	case HostCmd_CMD_11N_ADDBA_REQ:			return "ADDBA_REQ";
+	case HostCmd_CMD_11N_ADDBA_RSP:			return "ADDBA_RSP";
+	case HostCmd_CMD_11N_DELBA:			return "DELBA";
+	case HostCmd_CMD_RECONFIGURE_TX_BUFF:		return "RECONFIGURE_TX_BUFF";
+	case HostCmd_CMD_CHAN_REPORT_REQUEST:		return "CHAN_REPORT_REQUEST";
+	case HostCmd_CMD_AMSDU_AGGR_CTRL:		return "AMSDU_AGGR_CTRL";
+	case HostCmd_CMD_TXPWR_CFG:			return "TXPWR_CFG";
+	case HostCmd_CMD_TX_RATE_CFG:			return "TX_RATE_CFG";
+	case HostCmd_CMD_ROBUST_COEX:			return "ROBUST_COEX";
+	case HostCmd_CMD_802_11_PS_MODE_ENH:		return "PS_MODE_ENH";
+	case HostCmd_CMD_802_11_HS_CFG_ENH:		return "HS_CFG_ENH";
+	case HostCmd_CMD_P2P_MODE_CFG:			return "P2P_MODE_CFG";
+	case HostCmd_CMD_CAU_REG_ACCESS:		return "CAU_REG_ACCESS";
+	case HostCmd_CMD_SET_BSS_MODE:			return "SET_BSS_MODE";
+	case HostCmd_CMD_PCIE_DESC_DETAILS:		return "PCIE_DESC_DETAILS";
+	case HostCmd_CMD_802_11_SCAN_EXT:		return "SCAN_EXT";
+	case HostCmd_CMD_COALESCE_CFG:			return "COALESCE_CFG";
+	case HostCmd_CMD_MGMT_FRAME_REG:		return "MGMT_FRAME_REG";
+	case HostCmd_CMD_REMAIN_ON_CHAN:		return "REMAIN_ON_CHAN";
+	case HostCmd_CMD_GTK_REKEY_OFFLOAD_CFG:		return "GTK_REKEY_OFFLOAD_CFG";
+	case HostCmd_CMD_11AC_CFG:			return "11AC_CFG";
+	case HostCmd_CMD_HS_WAKEUP_REASON:		return "HS_WAKEUP_REASON";
+	case HostCmd_CMD_TDLS_CONFIG:			return "TDLS_CONFIG";
+	case HostCmd_CMD_MC_POLICY:			return "MC_POLICY";
+	case HostCmd_CMD_TDLS_OPER:			return "TDLS_OPER";
+	case HostCmd_CMD_FW_DUMP_EVENT:			return "FW_DUMP_EVENT";
+	case HostCmd_CMD_SDIO_SP_RX_AGGR_CFG:		return "SDIO_SP_RX_AGGR_CFG";
+	case HostCmd_CMD_STA_CONFIGURE:			return "STA_CONFIGURE";
+	case HostCmd_CMD_CHAN_REGION_CFG:		return "CHAN_REGION_CFG";
+	case HostCmd_CMD_PACKET_AGGR_CTRL:		return "PACKET_AGGR_CTRL";
+	default:					return "UNKNOWN";
+	}
+}
+
 /*
  * This function initializes a command node.
  *
@@ -191,8 +270,8 @@ static int mwifiex_dnld_cmd_to_fw(struct mwifiex_adapter *adapter,
 	    cmd_code != HostCmd_CMD_FUNC_SHUTDOWN &&
 	    cmd_code != HostCmd_CMD_FUNC_INIT) {
 		mwifiex_dbg(adapter, ERROR,
-			    "DNLD_CMD: FW in reset state, ignore cmd %#x\n",
-			cmd_code);
+			    "DNLD_CMD: FW in reset state, ignore cmd %s (%#x)\n",
+			    mwifiex_cmd_to_str(cmd_code), cmd_code);
 		mwifiex_recycle_cmd_node(adapter, cmd_node);
 		queue_work(adapter->workqueue, &adapter->main_work);
 		return -1;
@@ -651,8 +730,8 @@ int mwifiex_send_cmd(struct mwifiex_private *priv, u16 cmd_no,
 	/* Return error, since the command preparation failed */
 	if (ret) {
 		mwifiex_dbg(adapter, ERROR,
-			    "PREP_CMD: cmd %#x preparation failed\n",
-			cmd_no);
+			    "PREP_CMD: cmd %s (%#x) preparation failed\n",
+			    mwifiex_cmd_to_str(cmd_no), cmd_no);
 		mwifiex_insert_cmd_to_free_q(adapter, cmd_node);
 		return -1;
 	}
@@ -1262,8 +1341,8 @@ mwifiex_process_sleep_confirm_resp(struct mwifiex_adapter *adapter,
 
 	if (command != HostCmd_CMD_802_11_PS_MODE_ENH) {
 		mwifiex_dbg(adapter, ERROR,
-			    "%s: rcvd unexpected resp for cmd %#x, result = %x\n",
-			    __func__, command, result);
+			    "%s: rcvd unexpected resp for cmd %s (%#x), result = %x\n",
+			    __func__, mwifiex_cmd_to_str(command), command, result);
 		return;
 	}
 
diff --git a/drivers/net/wireless/marvell/mwifiex/decl.h b/drivers/net/wireless/marvell/mwifiex/decl.h
index 84603f1..80e4410 100644
--- a/drivers/net/wireless/marvell/mwifiex/decl.h
+++ b/drivers/net/wireless/marvell/mwifiex/decl.h
@@ -18,7 +18,7 @@
 #include <net/cfg80211.h>
 
 #define MWIFIEX_BSS_COEX_COUNT	     2
-#define MWIFIEX_MAX_BSS_NUM         (3)
+#define MWIFIEX_MAX_BSS_NUM         (4)
 
 #define MWIFIEX_DMA_ALIGN_SZ	    64
 #define MWIFIEX_RX_HEADROOM	    64
@@ -123,7 +123,7 @@
 #define MWIFIEX_RATE_INDEX_OFDM0   4
 
 #define MWIFIEX_MAX_STA_NUM		3
-#define MWIFIEX_MAX_UAP_NUM		3
+#define MWIFIEX_MAX_UAP_NUM		4
 #define MWIFIEX_MAX_P2P_NUM		3
 
 #define MWIFIEX_A_BAND_START_FREQ	5000
diff --git a/drivers/net/wireless/marvell/mwifiex/main.h b/drivers/net/wireless/marvell/mwifiex/main.h
index 27559e2..86559e4 100644
--- a/drivers/net/wireless/marvell/mwifiex/main.h
+++ b/drivers/net/wireless/marvell/mwifiex/main.h
@@ -1091,6 +1091,8 @@ void mwifiex_cancel_all_pending_cmd(struct mwifiex_adapter *adapter);
 void mwifiex_cancel_pending_scan_cmd(struct mwifiex_adapter *adapter);
 void mwifiex_cancel_scan(struct mwifiex_adapter *adapter);
 
+const char *mwifiex_cmd_to_str(u16 command);
+
 void mwifiex_recycle_cmd_node(struct mwifiex_adapter *adapter,
 			      struct cmd_ctrl_node *cmd_node);
 
diff --git a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
index 9c53825..5808060 100644
--- a/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
+++ b/drivers/net/wireless/marvell/mwifiex/sta_cmdresp.c
@@ -36,8 +36,9 @@ mwifiex_process_cmdresp_error(struct mwifiex_private *priv,
 	struct host_cmd_ds_802_11_ps_mode_enh *pm;
 
 	mwifiex_dbg(adapter, ERROR,
-		    "CMD_RESP: cmd %#x error, result=%#x\n",
-		    resp->command, resp->result);
+		    "CMD_RESP: cmd %s (%#x) error, result=%#x\n",
+		    mwifiex_cmd_to_str(le16_to_cpu(resp->command)),
+		    le16_to_cpu(resp->command), le16_to_cpu(resp->result));
 
 	if (adapter->curr_cmd->wait_q_enabled)
 		adapter->cmd_wait_q.status = -1;
diff --git a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
index 1c0ceac..4444d2c 100644
--- a/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
+++ b/drivers/net/wireless/marvell/mwifiex/uap_cmd.c
@@ -964,7 +964,8 @@ int mwifiex_uap_prepare_cmd(struct mwifiex_private *priv, u16 cmd_no,
 		break;
 	default:
 		mwifiex_dbg(priv->adapter, ERROR,
-			    "PREP_CMD: unknown cmd %#x\n", cmd_no);
+			    "PREP_CMD: unknown cmd (%s) %#x\n",
+			    mwifiex_cmd_to_str(cmd_no), cmd_no);
 		return -1;
 	}
 
diff --git a/drivers/net/wireless/marvell/mwl8k.c b/drivers/net/wireless/marvell/mwl8k.c
index 54d6d00..3a765ac 100644
--- a/drivers/net/wireless/marvell/mwl8k.c
+++ b/drivers/net/wireless/marvell/mwl8k.c
@@ -5779,6 +5779,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw");
 MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
 
 static const struct pci_device_id mwl8k_pci_id_table[] = {
+	{ PCI_VDEVICE(MARVELL, 0x2a02), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a0a), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a0c), .driver_data = MWL8363, },
 	{ PCI_VDEVICE(MARVELL, 0x2a24), .driver_data = MWL8363, },
@@ -6364,6 +6365,8 @@ static int mwl8k_probe(struct pci_dev *pdev,
 
 	priv->running_bsses = 0;
 
+	wait_for_completion(&priv->firmware_loading_complete);
+
 	return rc;
 
 err_stop_firmware:
@@ -6397,8 +6400,6 @@ static void mwl8k_remove(struct pci_dev *pdev)
 		return;
 	priv = hw->priv;
 
-	wait_for_completion(&priv->firmware_loading_complete);
-
 	if (priv->fw_state == FW_STATE_ERROR) {
 		mwl8k_hw_reset(priv);
 		goto unmap;
diff --git a/drivers/net/wireless/mediatek/mt7601u/usb.h b/drivers/net/wireless/mediatek/mt7601u/usb.h
index 9fdf359..66481b7 100644
--- a/drivers/net/wireless/mediatek/mt7601u/usb.h
+++ b/drivers/net/wireless/mediatek/mt7601u/usb.h
@@ -8,7 +8,7 @@
 
 #include "mt7601u.h"
 
-#define MT7601U_FIRMWARE	"mt7601u.bin"
+#define MT7601U_FIRMWARE	"mediatek/mt7601u.bin"
 
 #define MT_VEND_REQ_MAX_RETRY	10
 #define MT_VEND_REQ_TOUT_MS	300
diff --git a/drivers/net/wireless/ralink/rt2x00/Kconfig b/drivers/net/wireless/ralink/rt2x00/Kconfig
index 6462b1b..26175d2 100644
--- a/drivers/net/wireless/ralink/rt2x00/Kconfig
+++ b/drivers/net/wireless/ralink/rt2x00/Kconfig
@@ -70,6 +70,7 @@ config RT2800PCI
 	select RT2X00_LIB_MMIO
 	select RT2X00_LIB_PCI
 	select RT2X00_LIB_FIRMWARE
+	select RT2X00_LIB_EEPROM
 	select RT2X00_LIB_CRYPTO
 	depends on EEPROM_93CX6
 	help
@@ -209,12 +210,14 @@ endif
 config RT2800SOC
 	tristate "Ralink WiSoC support"
 	depends on m
-	depends on OF && (SOC_RT288X || SOC_RT305X || SOC_MT7620 || COMPILE_TEST)
+	depends on OF && (SOC_RT288X || SOC_RT305X || SOC_RT3883 || SOC_MT7620 || COMPILE_TEST)
 	select RT2X00_LIB_MMIO
 	select RT2X00_LIB_CRYPTO
 	select RT2X00_LIB_FIRMWARE
+	select RT2X00_LIB_EEPROM
 	select RT2800_LIB
 	select RT2800_LIB_MMIO
+	select MTD if SOC_RT288X || SOC_RT305X
 	help
 	  This adds support for Ralink WiSoC devices.
 	  Supported chips: RT2880, RT3050, RT3052, RT3350, RT3352.
@@ -223,33 +226,33 @@ config RT2800SOC
 
 
 config RT2800_LIB
-	tristate
+	tristate "RT2800 USB/PCI support"
 	depends on m
 	depends on CRC_CCITT
 
 config RT2800_LIB_MMIO
-	tristate
+	tristate "RT2800 MMIO support"
 	depends on m
 	select RT2X00_LIB_MMIO
 	select RT2800_LIB
 
 config RT2X00_LIB_MMIO
-	tristate
+	tristate "RT2x00 MMIO support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB_PCI
-	tristate
+	tristate "RT2x00 PCI support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB_USB
-	tristate
+	tristate "RT2x00 USB support"
 	depends on m
 	select RT2X00_LIB
 
 config RT2X00_LIB
-	tristate
+	tristate "RT2x00 support"
 	depends on m
 
 config RT2X00_LIB_FIRMWARE
@@ -259,6 +262,9 @@ config RT2X00_LIB_FIRMWARE
 config RT2X00_LIB_CRYPTO
 	bool
 
+config RT2X00_LIB_EEPROM
+	bool
+
 config RT2X00_LIB_LEDS
 	bool
 	default y if (RT2X00_LIB=y && LEDS_CLASS=y) || (RT2X00_LIB=m && LEDS_CLASS!=n)
diff --git a/drivers/net/wireless/ralink/rt2x00/Makefile b/drivers/net/wireless/ralink/rt2x00/Makefile
index f722da6..9c9ac48 100644
--- a/drivers/net/wireless/ralink/rt2x00/Makefile
+++ b/drivers/net/wireless/ralink/rt2x00/Makefile
@@ -8,6 +8,7 @@ rt2x00lib-$(CPTCFG_RT2X00_LIB_DEBUGFS)	+= rt2x00debug.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_CRYPTO)	+= rt2x00crypto.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_FIRMWARE)	+= rt2x00firmware.o
 rt2x00lib-$(CPTCFG_RT2X00_LIB_LEDS)	+= rt2x00leds.o
+rt2x00lib-$(CPTCFG_RT2X00_LIB_EEPROM)	+= rt2x00eeprom.o
 
 obj-$(CPTCFG_RT2X00_LIB)		+= rt2x00lib.o
 obj-$(CPTCFG_RT2X00_LIB_MMIO)		+= rt2x00mmio.o
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800.h b/drivers/net/wireless/ralink/rt2x00/rt2800.h
index 8930589..fbb791c 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800.h
@@ -379,10 +379,10 @@
 
 /*
  * WMM_AIFSN_CFG: Aifsn for each EDCA AC
- * AIFSN0: AC_VO
- * AIFSN1: AC_VI
- * AIFSN2: AC_BE
- * AIFSN3: AC_BK
+ * AIFSN0: AC_BE
+ * AIFSN1: AC_BK
+ * AIFSN2: AC_VI
+ * AIFSN3: AC_VO
  */
 #define WMM_AIFSN_CFG			0x0214
 #define WMM_AIFSN_CFG_AIFSN0		FIELD32(0x0000000f)
@@ -392,10 +392,10 @@
 
 /*
  * WMM_CWMIN_CSR: CWmin for each EDCA AC
- * CWMIN0: AC_VO
- * CWMIN1: AC_VI
- * CWMIN2: AC_BE
- * CWMIN3: AC_BK
+ * CWMIN0: AC_BE
+ * CWMIN1: AC_BK
+ * CWMIN2: AC_VI
+ * CWMIN3: AC_VO
  */
 #define WMM_CWMIN_CFG			0x0218
 #define WMM_CWMIN_CFG_CWMIN0		FIELD32(0x0000000f)
@@ -405,10 +405,10 @@
 
 /*
  * WMM_CWMAX_CSR: CWmax for each EDCA AC
- * CWMAX0: AC_VO
- * CWMAX1: AC_VI
- * CWMAX2: AC_BE
- * CWMAX3: AC_BK
+ * CWMAX0: AC_BE
+ * CWMAX1: AC_BK
+ * CWMAX2: AC_VI
+ * CWMAX3: AC_VO
  */
 #define WMM_CWMAX_CFG			0x021c
 #define WMM_CWMAX_CFG_CWMAX0		FIELD32(0x0000000f)
@@ -1056,6 +1056,11 @@
 #define MIMO_PS_CFG_RX_STBY_POL		FIELD32(0x00000010)
 #define MIMO_PS_CFG_RX_RX_STBY0		FIELD32(0x00000020)
 
+#define BB_PA_MODE_CFG0			0x1214
+#define BB_PA_MODE_CFG1			0x1218
+#define RF_PA_MODE_CFG0			0x121C
+#define RF_PA_MODE_CFG1			0x1220
+
 /*
  * EDCA_AC0_CFG:
  */
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
index 8245a15..311619b 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.c
@@ -25,6 +25,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/slab.h>
+#include <linux/of.h>
 
 #include "rt2x00.h"
 #include "rt2800lib.h"
@@ -304,6 +305,24 @@ static void rt2800_rf_write(struct rt2x00_dev *rt2x00dev,
 	mutex_unlock(&rt2x00dev->csr_mutex);
 }
 
+static void rt6352_enable_pa_pin(struct rt2x00_dev *rt2x00dev, int enable)
+{
+	if (!rt2x00dev->pinctrl)
+		return;
+
+	if (enable) {
+		if (!rt2x00dev->pins_default)
+			return;
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_default);
+	} else {
+		if (!rt2x00dev->pins_pa_gpio)
+			return;
+
+		pinctrl_select_state(rt2x00dev->pinctrl, rt2x00dev->pins_pa_gpio);
+	}
+}
+
 static const unsigned int rt2800_eeprom_map[EEPROM_WORD_COUNT] = {
 	[EEPROM_CHIP_ID]		= 0x0000,
 	[EEPROM_VERSION]		= 0x0001,
@@ -834,7 +853,8 @@ void rt2800_write_tx_data(struct queue_entry *entry,
 			   txdesc->key_idx : txdesc->u.ht.wcid);
 	rt2x00_set_field32(&word, TXWI_W1_MPDU_TOTAL_BYTE_COUNT,
 			   txdesc->length);
-	rt2x00_set_field32(&word, TXWI_W1_PACKETID_QUEUE, entry->queue->qid);
+	rt2x00_set_field32(&word, TXWI_W1_PACKETID_QUEUE,
+			   rt2x00_ac_to_hwq(entry->queue->qid));
 	rt2x00_set_field32(&word, TXWI_W1_PACKETID_ENTRY, (entry->entry_idx % 3) + 1);
 	rt2x00_desc_write(txwi, 1, word);
 
@@ -1124,6 +1144,12 @@ void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota)
 	u32 reg;
 	u8 qid;
 	bool match;
+	static const u8 rt2ac[] = {
+		IEEE80211_AC_BE,
+		IEEE80211_AC_BK,
+		IEEE80211_AC_VI,
+		IEEE80211_AC_VO,
+	};
 
 	while (quota-- > 0 && kfifo_get(&rt2x00dev->txstatus_fifo, &reg)) {
 		/*
@@ -1131,6 +1157,8 @@ void rt2800_txdone(struct rt2x00_dev *rt2x00dev, unsigned int quota)
 		 * guaranteed to be one of the TX QIDs .
 		 */
 		qid = rt2x00_get_field32(reg, TX_STA_FIFO_PID_QUEUE);
+		/* Convert Ralink hardware queue index to IEEE80211 queue id. */
+		qid = rt2ac[qid];
 		queue = rt2x00queue_get_tx_queue(rt2x00dev, qid);
 
 		if (unlikely(rt2x00queue_empty(queue))) {
@@ -1310,26 +1338,45 @@ static bool rt2800_watchdog_hung(struct rt2x00_dev *rt2x00dev)
 	return true;
 }
 
+static inline bool check_dma_busy_rx(u32 reg_cfg, u32 reg_int)
+{
+	return (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_RX_DMA_BUSY) &&
+		rt2x00_get_field32(reg_int, INT_SOURCE_CSR_RX_COHERENT));
+}
+
+static inline bool check_dma_busy_tx(u32 reg_cfg, u32 reg_int)
+{
+	return (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_TX_DMA_BUSY) &&
+		rt2x00_get_field32(reg_int, INT_SOURCE_CSR_TX_COHERENT));
+}
+
 static bool rt2800_watchdog_dma_busy(struct rt2x00_dev *rt2x00dev)
 {
 	bool busy_rx, busy_tx;
 	u32 reg_cfg = rt2800_register_read(rt2x00dev, WPDMA_GLO_CFG);
 	u32 reg_int = rt2800_register_read(rt2x00dev, INT_SOURCE_CSR);
 
-	if (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_RX_DMA_BUSY) &&
-	    rt2x00_get_field32(reg_int, INT_SOURCE_CSR_RX_COHERENT))
-		rt2x00dev->rxdma_busy++;
-	else
-		rt2x00dev->rxdma_busy = 0;
-
-	if (rt2x00_get_field32(reg_cfg, WPDMA_GLO_CFG_TX_DMA_BUSY) &&
-	    rt2x00_get_field32(reg_int, INT_SOURCE_CSR_TX_COHERENT))
-		rt2x00dev->txdma_busy++;
-	else
-		rt2x00dev->txdma_busy = 0;
+	rt2x00dev->rxdma_busy = check_dma_busy_rx(reg_cfg, reg_int) ?
+				rt2x00dev->rxdma_busy + 1 : 0;
+	rt2x00dev->txdma_busy = check_dma_busy_tx(reg_cfg, reg_int) ?
+				rt2x00dev->txdma_busy + 1 : 0;
+
+	if (rt2x00dev->rxdma_busy > 25 || rt2x00dev->txdma_busy > 25) {
+		int cnt;
+		for (cnt = 0; cnt < 10; cnt++) {
+			msleep(5);
+			reg_cfg = rt2800_register_read(rt2x00dev, WPDMA_GLO_CFG);
+			reg_int = rt2800_register_read(rt2x00dev, INT_SOURCE_CSR);
+
+			if (!check_dma_busy_rx(reg_cfg, reg_int))
+				rt2x00dev->rxdma_busy = 0;
+			if (!check_dma_busy_tx(reg_cfg, reg_int))
+				rt2x00dev->txdma_busy = 0;
+		}
+	}
 
-	busy_rx = rt2x00dev->rxdma_busy > 30;
-	busy_tx = rt2x00dev->txdma_busy > 30;
+	busy_rx = rt2x00dev->rxdma_busy > 40;
+	busy_tx = rt2x00dev->txdma_busy > 40;
 
 	if (!busy_rx && !busy_tx)
 		return false;
@@ -3547,9 +3594,8 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 
 		/* TODO RF27 <- tssi */
 
-		rfcsr = rf->channel <= 10 ? 0x07 : 0x06;
-		rt2800_rfcsr_write(rt2x00dev, 23, rfcsr);
-		rt2800_rfcsr_write(rt2x00dev, 59, rfcsr);
+		rt2800_rfcsr_write(rt2x00dev, 23, rf->channel <= 10 ? 0x08 : 0x07);
+		rt2800_rfcsr_write(rt2x00dev, 59, rf->channel <= 4 ? 0x06 : 0x04);
 
 		if (is_11b) {
 			/* CCK */
@@ -3570,7 +3616,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		power_bound = POWER_BOUND;
 		ep_reg = 0x2;
 	} else {
-		rt2800_rfcsr_write(rt2x00dev, 10, 0x97);
+		rt2800_rfcsr_write(rt2x00dev, 10, 0x95);
 		/* FIMXE: RF11 overwrite */
 		rt2800_rfcsr_write(rt2x00dev, 11, 0x40);
 		rt2800_rfcsr_write(rt2x00dev, 25, 0xBF);
@@ -3579,13 +3625,15 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		rt2800_rfcsr_write(rt2x00dev, 37, 0x04);
 		rt2800_rfcsr_write(rt2x00dev, 38, 0x85);
 		rt2800_rfcsr_write(rt2x00dev, 40, 0x42);
-		rt2800_rfcsr_write(rt2x00dev, 41, 0xBB);
+		rt2800_rfcsr_write(rt2x00dev, 41, 0xAB);
 		rt2800_rfcsr_write(rt2x00dev, 42, 0xD7);
-		rt2800_rfcsr_write(rt2x00dev, 45, 0x41);
+		rt2800_rfcsr_write(rt2x00dev, 45, 0x01);
 		rt2800_rfcsr_write(rt2x00dev, 48, 0x00);
 		rt2800_rfcsr_write(rt2x00dev, 57, 0x77);
+		rt2800_rfcsr_write(rt2x00dev, 58, 0x19);
 		rt2800_rfcsr_write(rt2x00dev, 60, 0x05);
 		rt2800_rfcsr_write(rt2x00dev, 61, 0x01);
+		rt2800_rfcsr_write(rt2x00dev, 62, 0x19);
 
 		/* TODO RF27 <- tssi */
 
@@ -3594,82 +3642,59 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 			rt2800_rfcsr_write(rt2x00dev, 12, 0x2E);
 			rt2800_rfcsr_write(rt2x00dev, 13, 0x22);
 			rt2800_rfcsr_write(rt2x00dev, 22, 0x60);
-			rt2800_rfcsr_write(rt2x00dev, 23, 0x7F);
-			if (rf->channel <= 50)
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x09);
-			else if (rf->channel >= 52)
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x07);
+			rt2800_rfcsr_write(rt2x00dev, 23, 0x7E);
+			rt2800_rfcsr_write(rt2x00dev, 24, 0x07);
 			rt2800_rfcsr_write(rt2x00dev, 39, 0x1C);
 			rt2800_rfcsr_write(rt2x00dev, 43, 0x5B);
-			rt2800_rfcsr_write(rt2x00dev, 44, 0X40);
 			rt2800_rfcsr_write(rt2x00dev, 46, 0X00);
-			rt2800_rfcsr_write(rt2x00dev, 51, 0xFE);
-			rt2800_rfcsr_write(rt2x00dev, 52, 0x0C);
-			rt2800_rfcsr_write(rt2x00dev, 54, 0xF8);
+			rt2800_rfcsr_write(rt2x00dev, 51, 0xFD);
+			rt2800_rfcsr_write(rt2x00dev, 52, 0x0E);
+			rt2800_rfcsr_write(rt2x00dev, 55, 0x04);
+			rt2800_rfcsr_write(rt2x00dev, 56, 0xBB);
+			rt2800_rfcsr_write(rt2x00dev, 59, 0x7C);
+
 			if (rf->channel <= 50) {
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x06);
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xD3);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0X32);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xF9);
 			} else if (rf->channel >= 52) {
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x04);
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xBB);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0X2A);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xF8);
 			}
-
-			rt2800_rfcsr_write(rt2x00dev, 58, 0x15);
-			rt2800_rfcsr_write(rt2x00dev, 59, 0x7F);
-			rt2800_rfcsr_write(rt2x00dev, 62, 0x15);
-
 		} else if (rf->channel >= 100 && rf->channel <= 165) {
-
 			rt2800_rfcsr_write(rt2x00dev, 12, 0x0E);
 			rt2800_rfcsr_write(rt2x00dev, 13, 0x42);
 			rt2800_rfcsr_write(rt2x00dev, 22, 0x40);
-			if (rf->channel <= 153) {
-				rt2800_rfcsr_write(rt2x00dev, 23, 0x3C);
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x06);
-			} else if (rf->channel >= 155) {
-				rt2800_rfcsr_write(rt2x00dev, 23, 0x38);
-				rt2800_rfcsr_write(rt2x00dev, 24, 0x05);
-			}
+			rt2800_rfcsr_write(rt2x00dev, 52, 0x06);
+			rt2800_rfcsr_write(rt2x00dev, 55, 0x01);
+
 			if (rf->channel <= 138) {
+				rt2800_rfcsr_write(rt2x00dev, 23, 0x7C);
 				rt2800_rfcsr_write(rt2x00dev, 39, 0x1A);
 				rt2800_rfcsr_write(rt2x00dev, 43, 0x3B);
-				rt2800_rfcsr_write(rt2x00dev, 44, 0x20);
 				rt2800_rfcsr_write(rt2x00dev, 46, 0x18);
-			} else if (rf->channel >= 140) {
+			} else {
+				rt2800_rfcsr_write(rt2x00dev, 23, 0x78);
 				rt2800_rfcsr_write(rt2x00dev, 39, 0x18);
 				rt2800_rfcsr_write(rt2x00dev, 43, 0x1B);
-				rt2800_rfcsr_write(rt2x00dev, 44, 0x10);
 				rt2800_rfcsr_write(rt2x00dev, 46, 0X08);
 			}
-			if (rf->channel <= 124)
-				rt2800_rfcsr_write(rt2x00dev, 51, 0xFC);
-			else if (rf->channel >= 126)
-				rt2800_rfcsr_write(rt2x00dev, 51, 0xEC);
-			if (rf->channel <= 138)
-				rt2800_rfcsr_write(rt2x00dev, 52, 0x06);
-			else if (rf->channel >= 140)
-				rt2800_rfcsr_write(rt2x00dev, 52, 0x06);
-			rt2800_rfcsr_write(rt2x00dev, 54, 0xEB);
-			if (rf->channel <= 138)
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x01);
-			else if (rf->channel >= 140)
-				rt2800_rfcsr_write(rt2x00dev, 55, 0x00);
-			if (rf->channel <= 128)
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xBB);
-			else if (rf->channel >= 130)
-				rt2800_rfcsr_write(rt2x00dev, 56, 0xAB);
-			if (rf->channel <= 116)
-				rt2800_rfcsr_write(rt2x00dev, 58, 0x1D);
-			else if (rf->channel >= 118)
-				rt2800_rfcsr_write(rt2x00dev, 58, 0x15);
-			if (rf->channel <= 138)
-				rt2800_rfcsr_write(rt2x00dev, 59, 0x3F);
-			else if (rf->channel >= 140)
-				rt2800_rfcsr_write(rt2x00dev, 59, 0x7C);
-			if (rf->channel <= 116)
-				rt2800_rfcsr_write(rt2x00dev, 62, 0x1D);
-			else if (rf->channel >= 118)
-				rt2800_rfcsr_write(rt2x00dev, 62, 0x15);
+
+			if (rf->channel <= 114) {
+				rt2800_rfcsr_write(rt2x00dev, 24, 0x02);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0x1A);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xEA);
+				rt2800_rfcsr_write(rt2x00dev, 56, 0xB3);
+			} else {
+				rt2800_rfcsr_write(rt2x00dev, 24, 0x03);
+				rt2800_rfcsr_write(rt2x00dev, 44, 0x0A);
+				rt2800_rfcsr_write(rt2x00dev, 54, 0xF9);
+				rt2800_rfcsr_write(rt2x00dev, 56, 0x9B);
+			}
+
+			rt2800_rfcsr_write(rt2x00dev, 51, rf->channel <= 124 ? 0xFC : 0xEC);
+			rt2800_rfcsr_write(rt2x00dev, 58, rf->channel <= 116 ? 0x1D : 0x15);
+			rfcsr = (rf->channel >= 116 && rf->channel <= 138) ? 0x7E : 0x7C;
+			rt2800_rfcsr_write(rt2x00dev, 59, rfcsr);
 		}
 
 		power_bound = POWER_BOUND_5G;
@@ -3681,7 +3706,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		rt2x00_set_field8(&rfcsr, RFCSR49_TX, power_bound);
 	else
 		rt2x00_set_field8(&rfcsr, RFCSR49_TX, info->default_power1);
-	if (is_type_ep)
+	if (!is_type_ep)
 		rt2x00_set_field8(&rfcsr, RFCSR49_EP, ep_reg);
 	rt2800_rfcsr_write(rt2x00dev, 49, rfcsr);
 
@@ -3690,7 +3715,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 		rt2x00_set_field8(&rfcsr, RFCSR50_TX, power_bound);
 	else
 		rt2x00_set_field8(&rfcsr, RFCSR50_TX, info->default_power2);
-	if (is_type_ep)
+	if (!is_type_ep)
 		rt2x00_set_field8(&rfcsr, RFCSR50_EP, ep_reg);
 	rt2800_rfcsr_write(rt2x00dev, 50, rfcsr);
 
@@ -3711,7 +3736,6 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 	rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
 
 	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
-	rt2800_rfcsr_write(rt2x00dev, 6, 0xe4);
 
 	if (conf_is_ht40(conf))
 		rt2800_rfcsr_write(rt2x00dev, 30, 0x16);
@@ -3740,6 +3764,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 	rt2800_bbp_write(rt2x00dev, 80, (rf->channel <= 14) ? 0x0E : 0x08);
 	rt2800_bbp_write(rt2x00dev, 81, (rf->channel <= 14) ? 0x3A : 0x38);
 	rt2800_bbp_write(rt2x00dev, 82, (rf->channel <= 14) ? 0x62 : 0x92);
+	rt2800_bbp_write(rt2x00dev, 95, (rf->channel <= 14) ? 0x9A : 0x1A);
 
 	/* GLRT band configuration */
 	rt2800_bbp_write(rt2x00dev, 195, 128);
@@ -3752,7 +3777,7 @@ static void rt2800_config_channel_rf55xx(struct rt2x00_dev *rt2x00dev,
 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x32 : 0x20);
 	rt2800_bbp_write(rt2x00dev, 195, 133);
 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x28 : 0x7F);
-	rt2800_bbp_write(rt2x00dev, 195, 124);
+	rt2800_bbp_write(rt2x00dev, 195, 134);
 	rt2800_bbp_write(rt2x00dev, 196, (rf->channel <= 14) ? 0x19 : 0x7F);
 }
 
@@ -3817,14 +3842,16 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 	rt2x00_set_field8(&rfcsr, RFCSR19_K, rf->rf4);
 	rt2800_rfcsr_write(rt2x00dev, 19, rfcsr);
 
-	/* Default: XO=20MHz , SDM mode */
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
-	rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 0x80);
-	rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		/* Default: XO=20MHz , SDM mode */
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 16);
+		rt2x00_set_field8(&rfcsr, RFCSR16_SDM_MODE_MT7620, 4);
+		rt2800_rfcsr_write(rt2x00dev, 16, rfcsr);
 
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
-	rt2x00_set_field8(&rfcsr, RFCSR21_BIT8, 1);
-	rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 21);
+		rt2x00_set_field8(&rfcsr, RFCSR21_BIT8, 1);
+		rt2800_rfcsr_write(rt2x00dev, 21, rfcsr);
+	}
 
 	rfcsr = rt2800_rfcsr_read(rt2x00dev, 1);
 	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_EN_MT7620,
@@ -3858,18 +3885,23 @@ static void rt2800_config_channel_rf7620(struct rt2x00_dev *rt2x00dev,
 		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x20);
 	}
 
-	if (conf_is_ht40(conf)) {
-		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
-		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
-	} else {
-		rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
-		rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		if (conf_is_ht40(conf)) {
+			rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x08);
+			rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x08);
+		} else {
+			rt2800_rfcsr_write_dccal(rt2x00dev, 58, 0x28);
+			rt2800_rfcsr_write_dccal(rt2x00dev, 59, 0x28);
+		}
 	}
 
-	rfcsr = rt2800_rfcsr_read(rt2x00dev, 28);
-	rt2x00_set_field8(&rfcsr, RFCSR28_CH11_HT40,
-			  conf_is_ht40(conf) && (rf->channel == 11));
-	rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) == 2) {
+		rfcsr = rt2800_rfcsr_read(rt2x00dev, 28);
+		rt2x00_set_field8(&rfcsr, RFCSR28_CH11_HT40,
+				  conf_is_ht40(conf) && (rf->channel == 11));
+		rt2800_rfcsr_write(rt2x00dev, 28, rfcsr);
+	}
 
 	if (!test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags)) {
 		if (conf_is_ht40(conf)) {
@@ -3983,25 +4015,29 @@ static void rt2800_config_alc_rt6352(struct rt2x00_dev *rt2x00dev,
 	if (unlikely(rt2800_wait_bbp_rf_ready(rt2x00dev, MAC_STATUS_CFG_BBP_RF_BUSY)))
 		rt2x00_warn(rt2x00dev, "RF busy while configuring ALC\n");
 
-	if (chan->center_freq > 2457) {
-		bbp = rt2800_bbp_read(rt2x00dev, 30);
-		bbp = 0x40;
-		rt2800_bbp_write(rt2x00dev, 30, bbp);
-		rt2800_rfcsr_write(rt2x00dev, 39, 0);
-		if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
-			rt2800_rfcsr_write(rt2x00dev, 42, 0xfb);
-		else
-			rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
-	} else {
-		bbp = rt2800_bbp_read(rt2x00dev, 30);
-		bbp = 0x1f;
-		rt2800_bbp_write(rt2x00dev, 30, bbp);
-		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
-		if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
-			rt2800_rfcsr_write(rt2x00dev, 42, 0xdb);
-		else
-			rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		if (chan->center_freq > 2457) {
+			bbp = rt2800_bbp_read(rt2x00dev, 30);
+			bbp = 0x40;
+			rt2800_bbp_write(rt2x00dev, 30, bbp);
+			rt2800_rfcsr_write(rt2x00dev, 39, 0);
+			if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
+				rt2800_rfcsr_write(rt2x00dev, 42, 0xfb);
+			else
+				rt2800_rfcsr_write(rt2x00dev, 42, 0x7b);
+		} else {
+			bbp = rt2800_bbp_read(rt2x00dev, 30);
+			bbp = 0x1f;
+			rt2800_bbp_write(rt2x00dev, 30, bbp);
+			rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+			if (rt2x00_has_cap_external_lna_bg(rt2x00dev))
+				rt2800_rfcsr_write(rt2x00dev, 42, 0xdb);
+			else
+				rt2800_rfcsr_write(rt2x00dev, 42, 0x5b);
+		}
 	}
+
 	rt2800_register_write(rt2x00dev, MAC_SYS_CTRL, mac_sys_ctrl);
 
 	rt2800_vco_calibration(rt2x00dev);
@@ -4298,7 +4334,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
 		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
 		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
-		if (rt2x00_rt(rt2x00dev, RT6352))
+		if (rt2x00_rt(rt2x00dev, RT5592) ||
+		    rt2x00_rt(rt2x00dev, RT6352))
 			rt2800_bbp_write(rt2x00dev, 86, 0x38);
 		else
 			rt2800_bbp_write(rt2x00dev, 86, 0);
@@ -4307,6 +4344,7 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 	if (rf->channel <= 14) {
 		if (!rt2x00_rt(rt2x00dev, RT5390) &&
 		    !rt2x00_rt(rt2x00dev, RT5392) &&
+		    !rt2x00_rt(rt2x00dev, RT5592) &&
 		    !rt2x00_rt(rt2x00dev, RT6352)) {
 			if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 				rt2800_bbp_write(rt2x00dev, 82, 0x62);
@@ -4330,17 +4368,20 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 		else if (rt2x00_rt(rt2x00dev, RT3593) ||
 			 rt2x00_rt(rt2x00dev, RT3883))
 			rt2800_bbp_write(rt2x00dev, 82, 0x82);
-		else if (!rt2x00_rt(rt2x00dev, RT6352))
+		else if (!rt2x00_rt(rt2x00dev, RT5592) &&
+			 !rt2x00_rt(rt2x00dev, RT6352))
 			rt2800_bbp_write(rt2x00dev, 82, 0xf2);
 
 		if (rt2x00_rt(rt2x00dev, RT3593) ||
 		    rt2x00_rt(rt2x00dev, RT3883))
 			rt2800_bbp_write(rt2x00dev, 83, 0x9a);
 
-		if (rt2x00_has_cap_external_lna_a(rt2x00dev))
-			rt2800_bbp_write(rt2x00dev, 75, 0x46);
-		else
-			rt2800_bbp_write(rt2x00dev, 75, 0x50);
+		if (!rt2x00_rt(rt2x00dev, RT5592)) {
+			if (rt2x00_has_cap_external_lna_a(rt2x00dev))
+				rt2800_bbp_write(rt2x00dev, 75, 0x46);
+			else
+				rt2800_bbp_write(rt2x00dev, 75, 0x50);
+		}
 	}
 
 	reg = rt2800_register_read(rt2x00dev, TX_BAND_CFG);
@@ -4494,7 +4535,8 @@ static void rt2800_config_channel(struct rt2x00_dev *rt2x00dev,
 	if (rt2x00_rt(rt2x00dev, RT6352)) {
 		/* BBP for GLRT BW */
 		bbp = conf_is_ht40(conf) ?
-		      0x10 : rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
+		      0x10 : !rt2x00_has_cap_external_lna_bg(rt2x00dev) ?
+		      0x1a : rt2800_hw_get_chippkg(rt2x00dev) == 1 ?
 		      0x15 : 0x1a;
 		rt2800_bbp_glrt_write(rt2x00dev, 141, bbp);
 
@@ -5532,6 +5574,9 @@ static void rt2800_config_txpower(struct rt2x00_dev *rt2x00dev,
 
 void rt2800_gain_calibration(struct rt2x00_dev *rt2x00dev)
 {
+	if (rt2x00_rt(rt2x00dev, RT6352))
+		return;
+
 	rt2800_config_txpower(rt2x00dev, rt2x00dev->hw->conf.chandef.chan,
 			      rt2x00dev->tx_power);
 }
@@ -5675,6 +5720,9 @@ static void rt2800_config_ps(struct rt2x00_dev *rt2x00dev,
 	}
 }
 
+static void rt2800_calibration_rt6352_stage1(struct rt2x00_dev *rt2x00dev);
+static void rt2800_calibration_rt6352_stage2(struct rt2x00_dev *rt2x00dev);
+
 void rt2800_config(struct rt2x00_dev *rt2x00dev,
 		   struct rt2x00lib_conf *libconf,
 		   const unsigned int flags)
@@ -5689,10 +5737,18 @@ void rt2800_config(struct rt2x00_dev *rt2x00dev,
 		 */
 		rt2800_update_survey(rt2x00dev);
 
+		if (rt2x00_rt(rt2x00dev, RT6352) &&
+		    !test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
+			rt2800_calibration_rt6352_stage1(rt2x00dev);
+
 		rt2800_config_channel(rt2x00dev, libconf->conf,
 				      &libconf->rf, &libconf->channel);
 		rt2800_config_txpower(rt2x00dev, libconf->conf->chandef.chan,
 				      libconf->conf->power_level);
+
+		if (rt2x00_rt(rt2x00dev, RT6352) &&
+		    !test_bit(DEVICE_STATE_SCANNING, &rt2x00dev->flags))
+			rt2800_calibration_rt6352_stage2(rt2x00dev);
 	}
 	if (flags & IEEE80211_CONF_CHANGE_POWER)
 		rt2800_config_txpower(rt2x00dev, libconf->conf->chandef.chan,
@@ -5733,9 +5789,10 @@ static u8 rt2800_get_default_vgc(struct rt2x00_dev *rt2x00dev)
 		    rt2x00_rt(rt2x00dev, RT3593) ||
 		    rt2x00_rt(rt2x00dev, RT5390) ||
 		    rt2x00_rt(rt2x00dev, RT5392) ||
-		    rt2x00_rt(rt2x00dev, RT5592) ||
-		    rt2x00_rt(rt2x00dev, RT6352))
+		    rt2x00_rt(rt2x00dev, RT5592))
 			vgc = 0x1c + (2 * rt2x00dev->lna_gain);
+		else if(rt2x00_rt(rt2x00dev, RT6352))
+			vgc = 0x04 + (2 * rt2x00dev->lna_gain);
 		else
 			vgc = 0x2e + rt2x00dev->lna_gain;
 	} else { /* 5GHZ band */
@@ -5762,12 +5819,10 @@ static inline void rt2800_set_vgc(struct rt2x00_dev *rt2x00dev,
 		if (rt2x00_rt(rt2x00dev, RT3572) ||
 		    rt2x00_rt(rt2x00dev, RT3593) ||
 		    rt2x00_rt(rt2x00dev, RT3883) ||
+		    rt2x00_rt(rt2x00dev, RT5592) ||
 		    rt2x00_rt(rt2x00dev, RT6352)) {
 			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66,
 						       vgc_level);
-		} else if (rt2x00_rt(rt2x00dev, RT5592)) {
-			rt2800_bbp_write(rt2x00dev, 83, qual->rssi > -65 ? 0x4a : 0x7a);
-			rt2800_bbp_write_with_rx_chain(rt2x00dev, 66, vgc_level);
 		} else {
 			rt2800_bbp_write(rt2x00dev, 66, vgc_level);
 		}
@@ -5788,7 +5843,8 @@ void rt2800_link_tuner(struct rt2x00_dev *rt2x00dev, struct link_qual *qual,
 {
 	u8 vgc;
 
-	if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C))
+	if (rt2x00_rt_rev(rt2x00dev, RT2860, REV_RT2860C) ||
+	    rt2x00_rt(rt2x00dev, RT6352))
 		return;
 
 	/* When RSSI is better than a certain threshold, increase VGC
@@ -5998,18 +6054,34 @@ static int rt2800_init_registers(struct rt2x00_dev *rt2x00dev)
 	} else if (rt2x00_rt(rt2x00dev, RT5350)) {
 		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000404);
 	} else if (rt2x00_rt(rt2x00dev, RT6352)) {
-		rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
-		rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
-		rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x00000000);
-		rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
-		rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
-		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN, 0x6C6C666C);
-		rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN, 0x6C6C666C);
-		rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
-				      0x3630363A);
-		rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
-				      0x3630363A);
+		if (rt2800_hw_get_chipver(rt2x00dev) <= 1) {
+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3,
+					      0x00000000);
+			rt2800_register_write(rt2x00dev, BB_PA_MODE_CFG0,
+					      0x000055FF);
+			rt2800_register_write(rt2x00dev, BB_PA_MODE_CFG1,
+					      0x00550055);
+			rt2800_register_write(rt2x00dev, RF_PA_MODE_CFG0,
+					      0x000055FF);
+			rt2800_register_write(rt2x00dev, RF_PA_MODE_CFG1,
+					      0x00550055);
+		} else {
+			rt2800_register_write(rt2x00dev, TX_SW_CFG0, 0x00000401);
+			rt2800_register_write(rt2x00dev, TX_SW_CFG1, 0x000C0001);
+			rt2800_register_write(rt2x00dev, TX_SW_CFG2, 0x00000000);
+			rt2800_register_write(rt2x00dev, TX_PIN_CFG, 0x00150f0f);
+			rt2800_register_write(rt2x00dev, TX_ALC_VGA3, 0x06060606);
+			rt2800_register_write(rt2x00dev, TX0_BB_GAIN_ATTEN, 0x0);
+			rt2800_register_write(rt2x00dev, TX1_BB_GAIN_ATTEN, 0x0);
+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_ATTEN,
+					      0x6C6C666C);
+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_ATTEN,
+					      0x6C6C666C);
+			rt2800_register_write(rt2x00dev, TX0_RF_GAIN_CORRECT,
+					      0x3630363A);
+			rt2800_register_write(rt2x00dev, TX1_RF_GAIN_CORRECT,
+					      0x3630363A);
+		}
 		reg = rt2800_register_read(rt2x00dev, TX_ALC_CFG_1);
 		rt2x00_set_field32(&reg, TX_ALC_CFG_1_ROS_BUSY_EN, 0);
 		rt2800_register_write(rt2x00dev, TX_ALC_CFG_1, reg);
@@ -6994,7 +7066,6 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 88, 0x90);
 	rt2800_bbp_write(rt2x00dev, 91, 0x04);
 	rt2800_bbp_write(rt2x00dev, 92, 0x02);
-	rt2800_bbp_write(rt2x00dev, 95, 0x9a);
 	rt2800_bbp_write(rt2x00dev, 98, 0x12);
 	rt2800_bbp_write(rt2x00dev, 103, 0xC0);
 	rt2800_bbp_write(rt2x00dev, 104, 0x92);
@@ -7005,6 +7076,7 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 134, 0xD0);
 	rt2800_bbp_write(rt2x00dev, 135, 0xF6);
 	rt2800_bbp_write(rt2x00dev, 137, 0x0F);
+	rt2800_bbp_write(rt2x00dev, 148, 0x84);
 
 	/* Initialize GLRT (Generalized Likehood Radio Test) */
 	rt2800_init_bbp_5592_glrt(rt2x00dev);
@@ -7029,12 +7101,6 @@ static void rt2800_init_bbp_5592(struct rt2x00_dev *rt2x00dev)
 		rt2x00_set_field8(&value, BBP254_BIT7, 1);
 		rt2800_bbp_write(rt2x00dev, 254, value);
 	}
-
-	rt2800_init_freq_calibration(rt2x00dev);
-
-	rt2800_bbp_write(rt2x00dev, 84, 0x19);
-	if (rt2x00_rt_rev_gte(rt2x00dev, RT5592, REV_RT5592C))
-		rt2800_bbp_write(rt2x00dev, 103, 0xc0);
 }
 
 static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
@@ -7122,14 +7188,16 @@ static void rt2800_init_bbp_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_bbp_write(rt2x00dev, 188, 0x00);
 	rt2800_bbp_write(rt2x00dev, 189, 0x00);
 
-	rt2800_bbp_write(rt2x00dev, 91, 0x06);
-	rt2800_bbp_write(rt2x00dev, 92, 0x04);
-	rt2800_bbp_write(rt2x00dev, 93, 0x54);
-	rt2800_bbp_write(rt2x00dev, 99, 0x50);
-	rt2800_bbp_write(rt2x00dev, 148, 0x84);
-	rt2800_bbp_write(rt2x00dev, 167, 0x80);
-	rt2800_bbp_write(rt2x00dev, 178, 0xFF);
-	rt2800_bbp_write(rt2x00dev, 106, 0x13);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_bbp_write(rt2x00dev, 91, 0x06);
+		rt2800_bbp_write(rt2x00dev, 92, 0x04);
+		rt2800_bbp_write(rt2x00dev, 93, 0x54);
+		rt2800_bbp_write(rt2x00dev, 99, 0x50);
+		rt2800_bbp_write(rt2x00dev, 148, 0x84);
+		rt2800_bbp_write(rt2x00dev, 167, 0x80);
+		rt2800_bbp_write(rt2x00dev, 178, 0xFF);
+		rt2800_bbp_write(rt2x00dev, 106, 0x13);
+	}
 
 	/* BBP for G band GLRT function (BBP_128 ~ BBP_221) */
 	rt2800_bbp_glrt_write(rt2x00dev, 0, 0x00);
@@ -8460,12 +8528,15 @@ static void rt2800_init_rfcsr_5392(struct rt2x00_dev *rt2x00dev)
 
 static void rt2800_init_rfcsr_5592(struct rt2x00_dev *rt2x00dev)
 {
+	u16 eeprom;
+
 	rt2800_rf_init_calibration(rt2x00dev, 30);
 
 	rt2800_rfcsr_write(rt2x00dev, 1, 0x3F);
+	rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
 	rt2800_rfcsr_write(rt2x00dev, 3, 0x08);
 	rt2800_rfcsr_write(rt2x00dev, 5, 0x10);
-	rt2800_rfcsr_write(rt2x00dev, 6, 0xE4);
+	rt2800_rfcsr_write(rt2x00dev, 6, 0xE0);
 	rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
 	rt2800_rfcsr_write(rt2x00dev, 14, 0x00);
 	rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
@@ -8481,9 +8552,13 @@ static void rt2800_init_rfcsr_5592(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write(rt2x00dev, 34, 0x07);
 	rt2800_rfcsr_write(rt2x00dev, 35, 0x12);
 	rt2800_rfcsr_write(rt2x00dev, 47, 0x0C);
-	rt2800_rfcsr_write(rt2x00dev, 53, 0x22);
+	rt2800_rfcsr_write(rt2x00dev, 53, 0x44);
 	rt2800_rfcsr_write(rt2x00dev, 63, 0x07);
 
+	eeprom = rt2800_eeprom_read(rt2x00dev, EEPROM_NIC_CONF2);
+	if (!rt2x00_get_field16(eeprom, EEPROM_NIC_CONF2_CRYSTAL))
+		rt2800_rfcsr_write(rt2x00dev, 6, 0xE4);
+
 	rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
 	msleep(1);
 
@@ -8801,7 +8876,7 @@ static void rt2800_rxiq_calibration(struct rt2x00_dev *rt2x00dev)
 		rt2x00_warn(rt2x00dev, "Timeout waiting for MAC status in RXIQ calibration\n");
 
 	bbpval = bbp4 & (~0x18);
-	bbpval = bbp4 | 0x00;
+	bbpval = bbpval | 0x00;
 	rt2800_bbp_write(rt2x00dev, 4, bbpval);
 
 	bbpval = rt2800_bbp_read(rt2x00dev, 21);
@@ -10353,6 +10428,9 @@ static void rt2800_restore_rf_bbp_rt6352(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, RF_BYPASS3, 0x0);
 	}
 
+	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
+		return;
+
 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
@@ -10392,15 +10470,21 @@ static void rt2800_restore_rf_bbp_rt6352(struct rt2x00_dev *rt2x00dev)
 	}
 }
 
-static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
+static void rt2800_calibration_rt6352_stage1(struct rt2x00_dev *rt2x00dev)
 {
-	u32 reg;
-
 	if (rt2x00_has_cap_external_pa(rt2x00dev) ||
-	    rt2x00_has_cap_external_lna_bg(rt2x00dev))
+	    rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
+		rt6352_enable_pa_pin(rt2x00dev, 0);
 		rt2800_restore_rf_bbp_rt6352(rt2x00dev);
+	}
 
 	rt2800_r_calibration(rt2x00dev);
+}
+
+static void rt2800_calibration_rt6352_stage2(struct rt2x00_dev *rt2x00dev)
+{
+	u32 reg;
+
 	rt2800_rf_self_txdc_cal(rt2x00dev);
 	rt2800_rxdcoc_calibration(rt2x00dev);
 	rt2800_bw_filter_calibration(rt2x00dev, true);
@@ -10416,6 +10500,8 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 	    !rt2x00_has_cap_external_lna_bg(rt2x00dev))
 		return;
 
+	rt6352_enable_pa_pin(rt2x00dev, 1);
+
 	if (rt2x00_has_cap_external_pa(rt2x00dev)) {
 		reg = rt2800_register_read(rt2x00dev, RF_CONTROL3);
 		reg |= 0x00000101;
@@ -10426,6 +10512,9 @@ static void rt2800_calibration_rt6352(struct rt2x00_dev *rt2x00dev)
 		rt2800_register_write(rt2x00dev, RF_BYPASS3, reg);
 	}
 
+	if (rt2800_hw_get_chippkg(rt2x00dev) != 1)
+		return;
+
 	if (rt2x00_has_cap_external_lna_bg(rt2x00dev)) {
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x66);
 		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x20);
@@ -10516,31 +10605,36 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
 	rt2800_rfcsr_write(rt2x00dev, 43, 0x00);
 
-	rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
-	if (rt2800_clk_is_20mhz(rt2x00dev))
-		rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
-	else
-		rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
-	rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
-	rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
-	rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
-	rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
-	rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
-	rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
-	rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
-	rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
-	rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
-	rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
-	rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
-	rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write(rt2x00dev, 11, 0x21);
+		if (rt2800_clk_is_20mhz(rt2x00dev))
+			rt2800_rfcsr_write(rt2x00dev, 13, 0x03);
+		else
+			rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 14, 0x7C);
+		rt2800_rfcsr_write(rt2x00dev, 16, 0x80);
+		rt2800_rfcsr_write(rt2x00dev, 17, 0x99);
+		rt2800_rfcsr_write(rt2x00dev, 18, 0x99);
+		rt2800_rfcsr_write(rt2x00dev, 19, 0x09);
+		rt2800_rfcsr_write(rt2x00dev, 20, 0x50);
+		rt2800_rfcsr_write(rt2x00dev, 21, 0xB0);
+		rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 23, 0x06);
+		rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 25, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 26, 0x5D);
+		rt2800_rfcsr_write(rt2x00dev, 27, 0x00);
+		rt2800_rfcsr_write(rt2x00dev, 28, 0x61);
+		rt2800_rfcsr_write(rt2x00dev, 29, 0xB5);
+		rt2800_rfcsr_write(rt2x00dev, 43, 0x02);
+	}
 
-	rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
-	rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
-	rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write(rt2x00dev, 28, 0x62);
+		rt2800_rfcsr_write(rt2x00dev, 29, 0xAD);
+		rt2800_rfcsr_write(rt2x00dev, 39, 0x80);
+	}
 
 	/* Initialize RF channel register to default value */
 	rt2800_rfcsr_write_chanreg(rt2x00dev, 0, 0x03);
@@ -10606,63 +10700,71 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 
 	rt2800_rfcsr_write_bank(rt2x00dev, 6, 45, 0xC5);
 
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
-	rt2800_rfcsr_write_bank(rt2x00dev, 4, 47, 0x67);
-	rt2800_rfcsr_write_bank(rt2x00dev, 6, 47, 0x69);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
-	rt2800_rfcsr_write_bank(rt2x00dev, 4, 54, 0x27);
-	rt2800_rfcsr_write_bank(rt2x00dev, 6, 54, 0x20);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
-
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
-
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
-
-	/* Initialize RF channel register for DRQFN */
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
-	rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x47);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x71);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x33);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x0E);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 17, 0x23);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA4);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 20, 0x02);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 21, 0x12);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x1C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 29, 0xEB);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 32, 0x7D);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 34, 0xD6);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 36, 0x08);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 38, 0xB4);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xB3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xD5);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 46, 0x27);
+		rt2800_rfcsr_write_bank(rt2x00dev, 4, 47, 0x67);
+		rt2800_rfcsr_write_bank(rt2x00dev, 6, 47, 0x69);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFF);
+		rt2800_rfcsr_write_bank(rt2x00dev, 4, 54, 0x27);
+		rt2800_rfcsr_write_bank(rt2x00dev, 6, 54, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xFF);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 57, 0x1C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x20);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xF7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 61, 0x09);
+	}
+
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 10, 0x51);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x06);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 19, 0xA7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 28, 0x2C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x64);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 8, 0x51);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 9, 0x36);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 11, 0x53);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 14, 0x16);
+
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x6C);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 48, 0xFC);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 49, 0x1F);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 54, 0x27);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x66);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 59, 0x6B);
+	}
+
+	if (rt2800_hw_get_chippkg(rt2x00dev) == 0 &&
+	    rt2800_hw_get_chipver(rt2x00dev) == 1) {
+		/* Initialize RF channel register for DRQFN */
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 43, 0xD3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 44, 0xE3);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 45, 0xE5);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 47, 0x28);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 55, 0x68);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 56, 0xF7);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 58, 0x02);
+		rt2800_rfcsr_write_chanreg(rt2x00dev, 60, 0xC7);
+	}
 
 	/* Initialize RF DC calibration register to default value */
 	rt2800_rfcsr_write_dccal(rt2x00dev, 0, 0x47);
@@ -10725,15 +10827,17 @@ static void rt2800_init_rfcsr_6352(struct rt2x00_dev *rt2x00dev)
 	rt2800_rfcsr_write_dccal(rt2x00dev, 62, 0x00);
 	rt2800_rfcsr_write_dccal(rt2x00dev, 63, 0x00);
 
-	rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
-
-	rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
-	rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1) {
+		rt2800_rfcsr_write_dccal(rt2x00dev, 3, 0x08);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 4, 0x04);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x20);
+	}
 
-	/* Do calibration and init PA/LNA */
-	rt2800_calibration_rt6352(rt2x00dev);
+	if (rt2800_hw_get_chipver(rt2x00dev) > 1 &&
+	    rt2800_hw_get_chipeco(rt2x00dev) >= 2) {
+		rt2800_rfcsr_write_dccal(rt2x00dev, 5, 0x00);
+		rt2800_rfcsr_write_dccal(rt2x00dev, 17, 0x7C);
+	}
 }
 
 static void rt2800_init_rfcsr(struct rt2x00_dev *rt2x00dev)
@@ -11276,6 +11380,17 @@ static int rt2800_init_eeprom(struct rt2x00_dev *rt2x00dev)
 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_assoc, LED_TYPE_ASSOC);
 	rt2800_init_led(rt2x00dev, &rt2x00dev->led_qual, LED_TYPE_QUALITY);
 
+	{
+		struct device_node *np = rt2x00dev->dev->of_node;
+		unsigned int led_polarity;
+
+		/* Allow overriding polarity from OF */
+		if (!of_property_read_u32(np, "ralink,led-polarity",
+					  &led_polarity))
+			rt2x00_set_field16(&eeprom, EEPROM_FREQ_LED_POLARITY,
+					   led_polarity);
+	}
+
 	rt2x00dev->led_mcu_reg = eeprom;
 #endif /* CPTCFG_RT2X00_LIB_LEDS */
 
@@ -12170,8 +12285,9 @@ int rt2800_conf_tx(struct ieee80211_hw *hw,
 	queue = rt2x00queue_get_tx_queue(rt2x00dev, queue_idx);
 
 	/* Update WMM TXOP register */
-	offset = WMM_TXOP0_CFG + (sizeof(u32) * (!!(queue_idx & 2)));
-	field.bit_offset = (queue_idx & 1) * 16;
+	offset = WMM_TXOP0_CFG +
+		 (sizeof(u32) * (!!(rt2x00_ac_to_hwq(queue_idx) & 2)));
+	field.bit_offset = (rt2x00_ac_to_hwq(queue_idx) & 1) * 16;
 	field.bit_mask = 0xffff << field.bit_offset;
 
 	reg = rt2800_register_read(rt2x00dev, offset);
@@ -12179,7 +12295,7 @@ int rt2800_conf_tx(struct ieee80211_hw *hw,
 	rt2800_register_write(rt2x00dev, offset, reg);
 
 	/* Update WMM registers */
-	field.bit_offset = queue_idx * 4;
+	field.bit_offset = rt2x00_ac_to_hwq(queue_idx) * 4;
 	field.bit_mask = 0xf << field.bit_offset;
 
 	reg = rt2800_register_read(rt2x00dev, WMM_AIFSN_CFG);
@@ -12195,7 +12311,7 @@ int rt2800_conf_tx(struct ieee80211_hw *hw,
 	rt2800_register_write(rt2x00dev, WMM_CWMAX_CFG, reg);
 
 	/* Update EDCA registers */
-	offset = EDCA_AC0_CFG + (sizeof(u32) * queue_idx);
+	offset = EDCA_AC0_CFG + (sizeof(u32) * rt2x00_ac_to_hwq(queue_idx));
 
 	reg = rt2800_register_read(rt2x00dev, offset);
 	rt2x00_set_field32(&reg, EDCA_AC0_CFG_TX_OP, queue->txop);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
index 620a3d9..4131650 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800lib.h
@@ -76,6 +76,9 @@ struct rt2800_ops {
 	int (*drv_init_registers)(struct rt2x00_dev *rt2x00dev);
 	__le32 *(*drv_get_txwi)(struct queue_entry *entry);
 	unsigned int (*drv_get_dma_done)(struct data_queue *queue);
+	int (*hw_get_chippkg)(void);
+	int (*hw_get_chipver)(void);
+	int (*hw_get_chipeco)(void);
 };
 
 static inline u32 rt2800_register_read(struct rt2x00_dev *rt2x00dev,
@@ -184,6 +187,27 @@ static inline unsigned int rt2800_drv_get_dma_done(struct data_queue *queue)
 	return rt2800ops->drv_get_dma_done(queue);
 }
 
+static inline int rt2800_hw_get_chippkg(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chippkg();
+}
+
+static inline int rt2800_hw_get_chipver(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chipver();
+}
+
+static inline int rt2800_hw_get_chipeco(struct rt2x00_dev *rt2x00dev)
+{
+	const struct rt2800_ops *rt2800ops = rt2x00dev->ops->drv;
+
+	return rt2800ops->hw_get_chipeco();
+}
+
 void rt2800_mcu_request(struct rt2x00_dev *rt2x00dev,
 			const u8 command, const u8 token,
 			const u8 arg0, const u8 arg1);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
index 45775ec..e14bc9e 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800mmio.c
@@ -35,7 +35,7 @@ unsigned int rt2800mmio_get_dma_done(struct data_queue *queue)
 	case QID_AC_VI:
 	case QID_AC_BE:
 	case QID_AC_BK:
-		qid = queue->qid;
+		qid = rt2x00_ac_to_hwq(queue->qid);
 		idx = rt2x00mmio_register_read(rt2x00dev, TX_DTX_IDX(qid));
 		break;
 	case QID_MGMT:
@@ -456,6 +456,7 @@ void rt2800mmio_kick_queue(struct data_queue *queue)
 {
 	struct rt2x00_dev *rt2x00dev = queue->rt2x00dev;
 	struct queue_entry *entry;
+	u8 qid;
 
 	switch (queue->qid) {
 	case QID_AC_VO:
@@ -464,7 +465,8 @@ void rt2800mmio_kick_queue(struct data_queue *queue)
 	case QID_AC_BK:
 		WARN_ON_ONCE(rt2x00queue_empty(queue));
 		entry = rt2x00queue_get_entry(queue, Q_INDEX);
-		rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(queue->qid),
+		qid = rt2x00_ac_to_hwq(queue->qid);
+		rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX(qid),
 					  entry->entry_idx);
 		hrtimer_start(&rt2x00dev->txstatus_timer,
 			      TXSTATUS_TIMEOUT, HRTIMER_MODE_REL);
@@ -666,36 +668,36 @@ int rt2800mmio_init_queues(struct rt2x00_dev *rt2x00dev)
 	 * Initialize registers.
 	 */
 	entry_priv = rt2x00dev->tx[0].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,
 				  rt2x00dev->tx[0].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);
 
 	entry_priv = rt2x00dev->tx[1].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,
 				  rt2x00dev->tx[1].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);
 
 	entry_priv = rt2x00dev->tx[2].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR2,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR0,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT2,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT0,
 				  rt2x00dev->tx[2].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX2, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX2, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX0, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX0, 0);
 
 	entry_priv = rt2x00dev->tx[3].entries[0].priv_data;
-	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR3,
+	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR1,
 				  entry_priv->desc_dma);
-	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT3,
+	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT1,
 				  rt2x00dev->tx[3].limit);
-	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX3, 0);
-	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX3, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_CTX_IDX1, 0);
+	rt2x00mmio_register_write(rt2x00dev, TX_DTX_IDX1, 0);
 
 	rt2x00mmio_register_write(rt2x00dev, TX_BASE_PTR4, 0);
 	rt2x00mmio_register_write(rt2x00dev, TX_MAX_CNT4, 0);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
index c891043..c1002bc 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800pci.c
@@ -278,6 +278,9 @@ static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
 {
 	int retval;
 
+	if (!rt2x00lib_read_eeprom(rt2x00dev))
+		return 0;
+
 	if (rt2800pci_efuse_detect(rt2x00dev))
 		retval = rt2800pci_read_eeprom_efuse(rt2x00dev);
 	else
@@ -286,6 +289,10 @@ static int rt2800pci_read_eeprom(struct rt2x00_dev *rt2x00dev)
 	return retval;
 }
 
+static int rt2800pci_get_chippkg(void) { return 0; }
+static int rt2800pci_get_chipver(void) { return 0; }
+static int rt2800pci_get_chipeco(void) { return 0; }
+
 static const struct ieee80211_ops rt2800pci_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -333,6 +340,9 @@ static const struct rt2800_ops rt2800pci_rt2800_ops = {
 	.drv_init_registers	= rt2800mmio_init_registers,
 	.drv_get_txwi		= rt2800mmio_get_txwi,
 	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+	.hw_get_chippkg		= rt2800pci_get_chippkg,
+	.hw_get_chipver		= rt2800pci_get_chipver,
+	.hw_get_chipeco		= rt2800pci_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800pci_rt2x00_ops = {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
index f62a43b..759ad7c 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800soc.c
@@ -27,6 +27,12 @@
 #include "rt2800lib.h"
 #include "rt2800mmio.h"
 
+/* Needed to probe CHIP_VER register on MT7620 */
+#ifdef CONFIG_SOC_MT7620
+#include <asm/mach-ralink/ralink_regs.h>
+#include <asm/mach-ralink/mt7620.h>
+#endif
+
 /* Allow hardware encryption to be disabled. */
 static bool modparam_nohwcrypt;
 module_param_named(nohwcrypt, modparam_nohwcrypt, bool, 0444);
@@ -90,19 +96,6 @@ static int rt2800soc_set_device_state(struct rt2x00_dev *rt2x00dev,
 	return retval;
 }
 
-static int rt2800soc_read_eeprom(struct rt2x00_dev *rt2x00dev)
-{
-	void __iomem *base_addr = ioremap(0x1F040000, EEPROM_SIZE);
-
-	if (!base_addr)
-		return -ENOMEM;
-
-	memcpy_fromio(rt2x00dev->eeprom, base_addr, EEPROM_SIZE);
-
-	iounmap(base_addr);
-	return 0;
-}
-
 /* Firmware functions */
 static char *rt2800soc_get_firmware_name(struct rt2x00_dev *rt2x00dev)
 {
@@ -149,6 +142,27 @@ static int rt2800soc_resume(struct platform_device *pdev)
 }
 #endif /* CONFIG_PM */
 
+#ifdef CONFIG_SOC_MT7620
+static int rt2800soc_get_chippkg(void)
+{
+	return mt7620_get_pkg();
+}
+
+static int rt2800soc_get_chipver(void)
+{
+	return mt7620_get_chipver();
+}
+
+static int rt2800soc_get_chipeco(void)
+{
+	return mt7620_get_eco();
+}
+#else
+static int rt2800soc_get_chippkg(void) { return 0; }
+static int rt2800soc_get_chipver(void) { return 0; }
+static int rt2800soc_get_chipeco(void) { return 0; }
+#endif
+
 static const struct ieee80211_ops rt2800soc_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -190,12 +204,15 @@ static const struct rt2800_ops rt2800soc_rt2800_ops = {
 	.register_multiread	= rt2x00mmio_register_multiread,
 	.register_multiwrite	= rt2x00mmio_register_multiwrite,
 	.regbusy_read		= rt2x00mmio_regbusy_read,
-	.read_eeprom		= rt2800soc_read_eeprom,
+	.read_eeprom		= rt2x00lib_read_eeprom,
 	.hwcrypt_disabled	= rt2800soc_hwcrypt_disabled,
 	.drv_write_firmware	= rt2800soc_write_firmware,
 	.drv_init_registers	= rt2800mmio_init_registers,
 	.drv_get_txwi		= rt2800mmio_get_txwi,
 	.drv_get_dma_done	= rt2800mmio_get_dma_done,
+	.hw_get_chippkg		= rt2800soc_get_chippkg,
+	.hw_get_chipver		= rt2800soc_get_chipver,
+	.hw_get_chipeco		= rt2800soc_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800soc_rt2x00_ops = {
@@ -304,12 +321,28 @@ static int rt2x00soc_probe(struct platform_device *pdev, const struct rt2x00_ops
 	rt2x00dev->name = pdev->dev.driver->name;
 	rt2x00dev->csr.base = mem;
 
+	set_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags);
 	rt2x00_set_chip_intf(rt2x00dev, RT2X00_CHIP_INTF_SOC);
 
 	retval = rt2x00lib_probe_dev(rt2x00dev);
 	if (retval)
 		goto exit_free_device;
 
+	rt2x00dev->pinctrl = devm_pinctrl_get(&pdev->dev);
+	if (IS_ERR(rt2x00dev->pinctrl)) {
+		rt2x00dev->pinctrl = NULL;
+		rt2x00dev->pins_default = NULL;
+		rt2x00dev->pins_pa_gpio = NULL;
+	} else {
+		rt2x00dev->pins_default = pinctrl_lookup_state(rt2x00dev->pinctrl, "default");
+		if (IS_ERR(rt2x00dev->pins_default))
+			rt2x00dev->pins_default = NULL;
+
+		rt2x00dev->pins_pa_gpio = pinctrl_lookup_state(rt2x00dev->pinctrl, "pa_gpio");
+		if (IS_ERR(rt2x00dev->pins_pa_gpio))
+			rt2x00dev->pins_pa_gpio = NULL;
+	}
+
 	return 0;
 
 exit_free_device:
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
index 7cf0b5c..143b2f9 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2800usb.c
@@ -628,6 +628,10 @@ static int rt2800usb_probe_hw(struct rt2x00_dev *rt2x00dev)
 	return 0;
 }
 
+static int rt2800usb_get_chippkg(void) { return 0; }
+static int rt2800usb_get_chipver(void) { return 0; }
+static int rt2800usb_get_chipeco(void) { return 0; }
+
 static const struct ieee80211_ops rt2800usb_mac80211_ops = {
 	.add_chanctx = ieee80211_emulate_add_chanctx,
 	.remove_chanctx = ieee80211_emulate_remove_chanctx,
@@ -676,6 +680,9 @@ static const struct rt2800_ops rt2800usb_rt2800_ops = {
 	.drv_init_registers	= rt2800usb_init_registers,
 	.drv_get_txwi		= rt2800usb_get_txwi,
 	.drv_get_dma_done	= rt2800usb_get_dma_done,
+	.hw_get_chippkg		= rt2800usb_get_chippkg,
+	.hw_get_chipver		= rt2800usb_get_chipver,
+	.hw_get_chipeco		= rt2800usb_get_chipeco,
 };
 
 static const struct rt2x00lib_ops rt2800usb_rt2x00_ops = {
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00.h b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
index 28e3d4e..b491b7f 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00.h
@@ -28,6 +28,7 @@
 #include <linux/average.h>
 #include <linux/usb.h>
 #include <linux/clk.h>
+#include <linux/pinctrl/consumer.h>
 
 #include <net/mac80211.h>
 
@@ -692,6 +693,7 @@ enum rt2x00_capability_flags {
 	REQUIRE_HT_TX_DESC,
 	REQUIRE_PS_AUTOWAKE,
 	REQUIRE_DELAYED_RFKILL,
+	REQUIRE_EEPROM_FILE,
 
 	/*
 	 * Capabilities
@@ -1014,6 +1016,11 @@ struct rt2x00_dev {
 
 	/* Clock for System On Chip devices. */
 	struct clk *clk;
+
+	/* pinctrl and states for System On Chip devices with PA/LNA. */
+	struct pinctrl *pinctrl;
+	struct pinctrl_state *pins_default;
+	struct pinctrl_state *pins_pa_gpio;
 };
 
 struct rt2x00_bar_list_entry {
@@ -1506,4 +1513,13 @@ void rt2x00lib_remove_dev(struct rt2x00_dev *rt2x00dev);
 int rt2x00lib_suspend(struct rt2x00_dev *rt2x00dev);
 int rt2x00lib_resume(struct rt2x00_dev *rt2x00dev);
 
+/*
+ * EEPROM file handlers.
+ */
+#ifdef CPTCFG_RT2X00_LIB_EEPROM
+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev);
+#else
+#define rt2x00lib_read_eeprom	NULL
+#endif /* CPTCFG_RT2X00_LIB_EEPROM */
+ 
 #endif /* RT2X00_H */
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
index e7eaa22..686ce71 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00dev.c
@@ -1007,6 +1007,14 @@ static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
 	struct ieee80211_rate *rates;
 	unsigned int num_rates;
 	unsigned int i;
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int enabled;
+	if (!of_property_read_u32(np, "ralink,2ghz",
+                                          &enabled) && !enabled)
+		spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
+	if (!of_property_read_u32(np, "ralink,5ghz",
+                                          &enabled) && !enabled)
+		spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
 
 	num_rates = 0;
 	if (spec->supported_rates & SUPPORT_RATE_CCK)
@@ -1330,7 +1338,7 @@ static inline void rt2x00lib_set_if_combinations(struct rt2x00_dev *rt2x00dev)
 	 */
 	if_limit = &rt2x00dev->if_limits_ap;
 	if_limit->max = rt2x00dev->ops->max_ap_intf;
-	if_limit->types = BIT(NL80211_IFTYPE_AP);
+	if_limit->types = BIT(NL80211_IFTYPE_AP) | BIT(NL80211_IFTYPE_STATION);
 #ifdef CPTCFG_MAC80211_MESH
 	if_limit->types |= BIT(NL80211_IFTYPE_MESH_POINT);
 #endif
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
new file mode 100644
index 0000000..36508a5
--- /dev/null
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00eeprom.c
@@ -0,0 +1,221 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*	Copyright (C) 2004 - 2009 Ivo van Doorn <IvDoorn@gmail.com>
+ *	Copyright (C) 2004 - 2009 Gertjan van Wingerde <gwingerde@gmail.com>
+ *	<http://rt2x00.serialmonkey.com>
+ */
+
+/*	Module: rt2x00lib
+ *	Abstract: rt2x00 eeprom file loading routines.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#if IS_ENABLED(CONFIG_MTD)
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
+#endif
+#include <linux/nvmem-consumer.h>
+
+#include "rt2x00.h"
+
+static void rt2800lib_eeprom_swap(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	size_t len = rt2x00dev->ops->eeprom_size;
+	int i;
+
+	if (!of_property_present(np, "ralink,eeprom-swap"))
+		return;
+
+	for (i = 0; i < len / sizeof(u16); i++)
+		rt2x00dev->eeprom[i] = swab16(rt2x00dev->eeprom[i]);
+}
+
+static int rt2800lib_read_eeprom_data(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int len = rt2x00dev->ops->eeprom_size;
+	const void *data;
+	int size;
+
+	data = of_get_property(np, "ralink,eeprom-data", &size);
+	if (!data)
+		return -ENOENT;
+
+	if (size != len) {
+		dev_err(rt2x00dev->dev, "invalid eeprom size, required: 0x%04x\n", len);
+		return -EINVAL;
+	}
+
+	memcpy(rt2x00dev->eeprom, data, size);
+
+	return 0;
+}
+
+#if IS_ENABLED(CONFIG_MTD)
+static int rt2800lib_read_eeprom_mtd(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node, *mtd_np = NULL;
+	int size, offset = 0;
+	struct mtd_info *mtd;
+	const char *part;
+	const __be32 *list;
+	phandle phandle;
+	size_t retlen;
+	int ret;
+
+	list = of_get_property(np, "ralink,mtd-eeprom", &size);
+	if (!list)
+		return -ENOENT;
+
+	phandle = be32_to_cpup(list++);
+	if (phandle)
+		mtd_np = of_find_node_by_phandle(phandle);
+	if (!mtd_np) {
+		dev_err(rt2x00dev->dev, "failed to load mtd phandle\n");
+		return -EINVAL;
+	}
+
+	part = of_get_property(mtd_np, "label", NULL);
+	if (!part)
+		part = mtd_np->name;
+
+	mtd = get_mtd_device_nm(part);
+	if (IS_ERR(mtd)) {
+		dev_err(rt2x00dev->dev, "failed to get mtd device \"%s\"\n", part);
+		return PTR_ERR(mtd);
+	}
+
+	if (size > sizeof(*list))
+		offset = be32_to_cpup(list);
+
+	ret = mtd_read(mtd, offset, rt2x00dev->ops->eeprom_size,
+		       &retlen, (u_char *)rt2x00dev->eeprom);
+	put_mtd_device(mtd);
+
+	if (ret || retlen != rt2x00dev->ops->eeprom_size) {
+		dev_err(rt2x00dev->dev, "failed to load eeprom from device \"%s\"\n", part);
+		return ret;
+	}
+
+	rt2800lib_eeprom_swap(rt2x00dev);
+
+	dev_info(rt2x00dev->dev, "loaded eeprom from mtd device \"%s\"\n", part);
+
+	return ret;
+}
+#endif
+
+static int rt2800lib_read_eeprom_nvmem(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	unsigned int len = rt2x00dev->ops->eeprom_size;
+	struct nvmem_cell *cell;
+	const void *data;
+	size_t retlen;
+	int ret = 0;
+
+	cell = of_nvmem_cell_get(np, "eeprom");
+	if (IS_ERR(cell))
+		return PTR_ERR(cell);
+
+	data = nvmem_cell_read(cell, &retlen);
+	nvmem_cell_put(cell);
+
+	if (IS_ERR(data))
+		return PTR_ERR(data);
+
+	if (retlen != len) {
+		dev_err(rt2x00dev->dev, "invalid eeprom size, required: 0x%04x\n", len);
+		ret = -EINVAL;
+		goto exit;
+	}
+
+	memcpy(rt2x00dev->eeprom, data, len);
+
+	rt2800lib_eeprom_swap(rt2x00dev);
+
+exit:
+	kfree(data);
+	return ret;
+}
+
+static const char *
+rt2x00lib_get_eeprom_file_name(struct rt2x00_dev *rt2x00dev)
+{
+	struct device_node *np = rt2x00dev->dev->of_node;
+	const char *eep;
+
+	if (np && !of_property_read_string(np, "ralink,eeprom", &eep))
+		return eep;
+
+	return NULL;
+}
+
+static int rt2x00lib_read_eeprom_file(struct rt2x00_dev *rt2x00dev)
+{
+	const struct firmware *ee;
+	const char *ee_name;
+	int retval;
+
+	ee_name = rt2x00lib_get_eeprom_file_name(rt2x00dev);
+	if (!ee_name && test_bit(REQUIRE_EEPROM_FILE, &rt2x00dev->cap_flags)) {
+		rt2x00_err(rt2x00dev, "Required EEPROM name is missing.");
+		return -EINVAL;
+	}
+
+	if (!ee_name)
+		return -ENOENT;
+
+	rt2x00_info(rt2x00dev, "Loading EEPROM data from '%s'.\n", ee_name);
+
+	retval = request_firmware(&ee, ee_name, rt2x00dev->dev);
+	if (retval) {
+		rt2x00_err(rt2x00dev, "Failed to request EEPROM.\n");
+		return retval;
+	}
+
+	if (!ee || !ee->size || !ee->data) {
+		rt2x00_err(rt2x00dev, "Failed to read EEPROM file.\n");
+		retval = -ENOENT;
+		goto err_exit;
+	}
+
+	if (ee->size != rt2x00dev->ops->eeprom_size) {
+		rt2x00_err(rt2x00dev,
+			   "EEPROM file size is invalid, it should be %d bytes\n",
+			   rt2x00dev->ops->eeprom_size);
+		retval = -EINVAL;
+		goto err_release_ee;
+	}
+
+	memcpy(rt2x00dev->eeprom, ee->data, rt2x00dev->ops->eeprom_size);
+
+err_release_ee:
+	release_firmware(ee);
+err_exit:
+	return retval;
+}
+
+int rt2x00lib_read_eeprom(struct rt2x00_dev *rt2x00dev)
+{
+	int ret;
+
+	ret = rt2800lib_read_eeprom_data(rt2x00dev);
+	if (!ret)
+		return 0;
+
+#if IS_ENABLED(CONFIG_MTD)
+	ret = rt2800lib_read_eeprom_mtd(rt2x00dev);
+	if (!ret)
+		return 0;
+#endif
+
+	ret = rt2800lib_read_eeprom_nvmem(rt2x00dev);
+	if (!ret)
+		return 0;
+
+	return rt2x00lib_read_eeprom_file(rt2x00dev);
+}
+EXPORT_SYMBOL_GPL(rt2x00lib_read_eeprom);
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
index f5361d5..bad5ce2 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00leds.c
@@ -98,6 +98,9 @@ static int rt2x00leds_register_led(struct rt2x00_dev *rt2x00dev,
 	led->led_dev.name = name;
 	led->led_dev.brightness = LED_OFF;
 
+	if (rt2x00_is_soc(rt2x00dev))
+		led->led_dev.brightness_set(&led->led_dev, LED_OFF);
+
 	retval = led_classdev_register(device, &led->led_dev);
 	if (retval) {
 		rt2x00_err(rt2x00dev, "Failed to register led handler\n");
diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
index 23739dd..fe9102e 100644
--- a/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00queue.h
@@ -56,6 +56,26 @@ enum data_queue_qid {
 	QID_ATIM,
 };
 
+/**
+ * rt2x00_ac_to_hwq - Convert IEEE80211 queue id to Ralink hardware
+ * queue register index.
+ * @ac: TX queue id.
+ */
+static inline u8 rt2x00_ac_to_hwq(enum data_queue_qid ac)
+{
+	static const u8 ralink_queue_map[] = {
+		[IEEE80211_AC_BE] = 0,
+		[IEEE80211_AC_BK] = 1,
+		[IEEE80211_AC_VI] = 2,
+		[IEEE80211_AC_VO] = 3,
+	};
+
+	if (unlikely(ac >= IEEE80211_NUM_ACS))
+		return ac;
+
+	return ralink_queue_map[ac];
+}
+
 /**
  * enum skb_frame_desc_flags: Flags for &struct skb_frame_desc
  *
diff --git a/drivers/net/wireless/realtek/rtw88/usb.c b/drivers/net/wireless/realtek/rtw88/usb.c
index 3b5126f..d9c97ad 100644
--- a/drivers/net/wireless/realtek/rtw88/usb.c
+++ b/drivers/net/wireless/realtek/rtw88/usb.c
@@ -965,7 +965,11 @@ static int rtw_usb_init_rx(struct rtw_dev *rtwdev)
 	struct sk_buff *rx_skb;
 	int i;
 
+#if LINUX_VERSION_IS_GEQ(6,9,0)
 	rtwusb->rxwq = alloc_workqueue("rtw88_usb: rx wq", WQ_BH, 0);
+#else
+	rtwusb->rxwq = create_singlethread_workqueue("rtw88_usb: rx wq");
+#endif
 	if (!rtwusb->rxwq) {
 		rtw_err(rtwdev, "failed to create RX work queue\n");
 		return -ENOMEM;
diff --git a/drivers/net/wireless/virtual/mac80211_hwsim.c b/drivers/net/wireless/virtual/mac80211_hwsim.c
index da5c01a..88ad320 100644
--- a/drivers/net/wireless/virtual/mac80211_hwsim.c
+++ b/drivers/net/wireless/virtual/mac80211_hwsim.c
@@ -6927,6 +6927,7 @@ static void hwsim_virtio_rx_done(struct virtqueue *vq)
 
 static int init_vqs(struct virtio_device *vdev)
 {
+#if LINUX_VERSION_IS_GEQ(6,11,0)
 	struct virtqueue_info vqs_info[HWSIM_NUM_VQS] = {
 		[HWSIM_VQ_TX] = { "tx", hwsim_virtio_tx_done },
 		[HWSIM_VQ_RX] = { "rx", hwsim_virtio_rx_done },
@@ -6934,6 +6935,19 @@ static int init_vqs(struct virtio_device *vdev)
 
 	return virtio_find_vqs(vdev, HWSIM_NUM_VQS,
 			       hwsim_vqs, vqs_info, NULL);
+#else /* Using the old ABI, copied from kernel 6.6 */
+	vq_callback_t *callbacks[HWSIM_NUM_VQS] = {
+		[HWSIM_VQ_TX] = hwsim_virtio_tx_done,
+		[HWSIM_VQ_RX] = hwsim_virtio_rx_done,
+	};
+	const char *names[HWSIM_NUM_VQS] = {
+		[HWSIM_VQ_TX] = "tx",
+		[HWSIM_VQ_RX] = "rx",
+	};
+
+	return virtio_find_vqs(vdev, HWSIM_NUM_VQS,
+			       hwsim_vqs, callbacks, names, NULL);
+#endif
 }
 
 static int fill_vq(struct virtqueue *vq)
diff --git a/include/linux/ath5k_platform.h b/include/linux/ath5k_platform.h
new file mode 100644
index 0000000..ec85224
--- /dev/null
+++ b/include/linux/ath5k_platform.h
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2008 Atheros Communications Inc.
+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
+ *
+ * Permission to use, copy, modify, and/or distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#ifndef _LINUX_ATH5K_PLATFORM_H
+#define _LINUX_ATH5K_PLATFORM_H
+
+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
+
+struct ath5k_platform_data {
+	u16 *eeprom_data;
+	u8 *macaddr;
+};
+
+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff --git a/include/linux/mhi.h b/include/linux/mhi.h
deleted file mode 100644
index dd372b0..0000000
--- a/include/linux/mhi.h
+++ /dev/null
@@ -1,812 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0 */
-/*
- * Copyright (c) 2018-2020, The Linux Foundation. All rights reserved.
- *
- */
-#ifndef _MHI_H_
-#define _MHI_H_
-
-#include <linux/device.h>
-#include <linux/dma-direction.h>
-#include <linux/mutex.h>
-#include <linux/skbuff.h>
-#include <linux/slab.h>
-#include <linux/spinlock.h>
-#include <linux/wait.h>
-#include <linux/workqueue.h>
-
-#define MHI_MAX_OEM_PK_HASH_SEGMENTS 16
-
-struct mhi_chan;
-struct mhi_event;
-struct mhi_ctxt;
-struct mhi_cmd;
-struct mhi_buf_info;
-
-/**
- * enum mhi_callback - MHI callback
- * @MHI_CB_IDLE: MHI entered idle state
- * @MHI_CB_PENDING_DATA: New data available for client to process
- * @MHI_CB_LPM_ENTER: MHI host entered low power mode
- * @MHI_CB_LPM_EXIT: MHI host about to exit low power mode
- * @MHI_CB_EE_RDDM: MHI device entered RDDM exec env
- * @MHI_CB_EE_MISSION_MODE: MHI device entered Mission Mode exec env
- * @MHI_CB_SYS_ERROR: MHI device entered error state (may recover)
- * @MHI_CB_FATAL_ERROR: MHI device entered fatal error state
- * @MHI_CB_BW_REQ: Received a bandwidth switch request from device
- */
-enum mhi_callback {
-	MHI_CB_IDLE,
-	MHI_CB_PENDING_DATA,
-	MHI_CB_LPM_ENTER,
-	MHI_CB_LPM_EXIT,
-	MHI_CB_EE_RDDM,
-	MHI_CB_EE_MISSION_MODE,
-	MHI_CB_SYS_ERROR,
-	MHI_CB_FATAL_ERROR,
-	MHI_CB_BW_REQ,
-};
-
-/**
- * enum mhi_flags - Transfer flags
- * @MHI_EOB: End of buffer for bulk transfer
- * @MHI_EOT: End of transfer
- * @MHI_CHAIN: Linked transfer
- */
-enum mhi_flags {
-	MHI_EOB = BIT(0),
-	MHI_EOT = BIT(1),
-	MHI_CHAIN = BIT(2),
-};
-
-/**
- * enum mhi_device_type - Device types
- * @MHI_DEVICE_XFER: Handles data transfer
- * @MHI_DEVICE_CONTROLLER: Control device
- */
-enum mhi_device_type {
-	MHI_DEVICE_XFER,
-	MHI_DEVICE_CONTROLLER,
-};
-
-/**
- * enum mhi_ch_type - Channel types
- * @MHI_CH_TYPE_INVALID: Invalid channel type
- * @MHI_CH_TYPE_OUTBOUND: Outbound channel to the device
- * @MHI_CH_TYPE_INBOUND: Inbound channel from the device
- * @MHI_CH_TYPE_INBOUND_COALESCED: Coalesced channel for the device to combine
- *				   multiple packets and send them as a single
- *				   large packet to reduce CPU consumption
- */
-enum mhi_ch_type {
-	MHI_CH_TYPE_INVALID = 0,
-	MHI_CH_TYPE_OUTBOUND = DMA_TO_DEVICE,
-	MHI_CH_TYPE_INBOUND = DMA_FROM_DEVICE,
-	MHI_CH_TYPE_INBOUND_COALESCED = 3,
-};
-
-/**
- * struct image_info - Firmware and RDDM table
- * @mhi_buf: Buffer for firmware and RDDM table
- * @entries: # of entries in table
- */
-struct image_info {
-	struct mhi_buf *mhi_buf;
-	/* private: from internal.h */
-	struct bhi_vec_entry *bhi_vec;
-	/* public: */
-	u32 entries;
-};
-
-/**
- * struct mhi_link_info - BW requirement
- * target_link_speed - Link speed as defined by TLS bits in LinkControl reg
- * target_link_width - Link width as defined by NLW bits in LinkStatus reg
- */
-struct mhi_link_info {
-	unsigned int target_link_speed;
-	unsigned int target_link_width;
-};
-
-/**
- * enum mhi_ee_type - Execution environment types
- * @MHI_EE_PBL: Primary Bootloader
- * @MHI_EE_SBL: Secondary Bootloader
- * @MHI_EE_AMSS: Modem, aka the primary runtime EE
- * @MHI_EE_RDDM: Ram dump download mode
- * @MHI_EE_WFW: WLAN firmware mode
- * @MHI_EE_PTHRU: Passthrough
- * @MHI_EE_EDL: Embedded downloader
- * @MHI_EE_FP: Flash Programmer Environment
- */
-enum mhi_ee_type {
-	MHI_EE_PBL,
-	MHI_EE_SBL,
-	MHI_EE_AMSS,
-	MHI_EE_RDDM,
-	MHI_EE_WFW,
-	MHI_EE_PTHRU,
-	MHI_EE_EDL,
-	MHI_EE_FP,
-	MHI_EE_MAX_SUPPORTED = MHI_EE_FP,
-	MHI_EE_DISABLE_TRANSITION, /* local EE, not related to mhi spec */
-	MHI_EE_NOT_SUPPORTED,
-	MHI_EE_MAX,
-};
-
-/**
- * enum mhi_state - MHI states
- * @MHI_STATE_RESET: Reset state
- * @MHI_STATE_READY: Ready state
- * @MHI_STATE_M0: M0 state
- * @MHI_STATE_M1: M1 state
- * @MHI_STATE_M2: M2 state
- * @MHI_STATE_M3: M3 state
- * @MHI_STATE_M3_FAST: M3 Fast state
- * @MHI_STATE_BHI: BHI state
- * @MHI_STATE_SYS_ERR: System Error state
- */
-enum mhi_state {
-	MHI_STATE_RESET = 0x0,
-	MHI_STATE_READY = 0x1,
-	MHI_STATE_M0 = 0x2,
-	MHI_STATE_M1 = 0x3,
-	MHI_STATE_M2 = 0x4,
-	MHI_STATE_M3 = 0x5,
-	MHI_STATE_M3_FAST = 0x6,
-	MHI_STATE_BHI = 0x7,
-	MHI_STATE_SYS_ERR = 0xFF,
-	MHI_STATE_MAX,
-};
-
-/**
- * enum mhi_ch_ee_mask - Execution environment mask for channel
- * @MHI_CH_EE_PBL: Allow channel to be used in PBL EE
- * @MHI_CH_EE_SBL: Allow channel to be used in SBL EE
- * @MHI_CH_EE_AMSS: Allow channel to be used in AMSS EE
- * @MHI_CH_EE_RDDM: Allow channel to be used in RDDM EE
- * @MHI_CH_EE_PTHRU: Allow channel to be used in PTHRU EE
- * @MHI_CH_EE_WFW: Allow channel to be used in WFW EE
- * @MHI_CH_EE_EDL: Allow channel to be used in EDL EE
- */
-enum mhi_ch_ee_mask {
-	MHI_CH_EE_PBL = BIT(MHI_EE_PBL),
-	MHI_CH_EE_SBL = BIT(MHI_EE_SBL),
-	MHI_CH_EE_AMSS = BIT(MHI_EE_AMSS),
-	MHI_CH_EE_RDDM = BIT(MHI_EE_RDDM),
-	MHI_CH_EE_PTHRU = BIT(MHI_EE_PTHRU),
-	MHI_CH_EE_WFW = BIT(MHI_EE_WFW),
-	MHI_CH_EE_EDL = BIT(MHI_EE_EDL),
-};
-
-/**
- * enum mhi_er_data_type - Event ring data types
- * @MHI_ER_DATA: Only client data over this ring
- * @MHI_ER_CTRL: MHI control data and client data
- */
-enum mhi_er_data_type {
-	MHI_ER_DATA,
-	MHI_ER_CTRL,
-};
-
-/**
- * enum mhi_db_brst_mode - Doorbell mode
- * @MHI_DB_BRST_DISABLE: Burst mode disable
- * @MHI_DB_BRST_ENABLE: Burst mode enable
- */
-enum mhi_db_brst_mode {
-	MHI_DB_BRST_DISABLE = 0x2,
-	MHI_DB_BRST_ENABLE = 0x3,
-};
-
-/**
- * struct mhi_channel_config - Channel configuration structure for controller
- * @name: The name of this channel
- * @num: The number assigned to this channel
- * @num_elements: The number of elements that can be queued to this channel
- * @local_elements: The local ring length of the channel
- * @event_ring: The event ring index that services this channel
- * @dir: Direction that data may flow on this channel
- * @type: Channel type
- * @ee_mask: Execution Environment mask for this channel
- * @pollcfg: Polling configuration for burst mode.  0 is default.  milliseconds
-	     for UL channels, multiple of 8 ring elements for DL channels
- * @doorbell: Doorbell mode
- * @lpm_notify: The channel master requires low power mode notifications
- * @offload_channel: The client manages the channel completely
- * @doorbell_mode_switch: Channel switches to doorbell mode on M0 transition
- * @auto_queue: Framework will automatically queue buffers for DL traffic
- * @wake-capable: Channel capable of waking up the system
- */
-struct mhi_channel_config {
-	char *name;
-	u32 num;
-	u32 num_elements;
-	u32 local_elements;
-	u32 event_ring;
-	enum dma_data_direction dir;
-	enum mhi_ch_type type;
-	u32 ee_mask;
-	u32 pollcfg;
-	enum mhi_db_brst_mode doorbell;
-	bool lpm_notify;
-	bool offload_channel;
-	bool doorbell_mode_switch;
-	bool auto_queue;
-	bool wake_capable;
-};
-
-/**
- * struct mhi_event_config - Event ring configuration structure for controller
- * @num_elements: The number of elements that can be queued to this ring
- * @irq_moderation_ms: Delay irq for additional events to be aggregated
- * @irq: IRQ associated with this ring
- * @channel: Dedicated channel number. U32_MAX indicates a non-dedicated ring
- * @priority: Priority of this ring. Use 1 for now
- * @mode: Doorbell mode
- * @data_type: Type of data this ring will process
- * @hardware_event: This ring is associated with hardware channels
- * @client_managed: This ring is client managed
- * @offload_channel: This ring is associated with an offloaded channel
- */
-struct mhi_event_config {
-	u32 num_elements;
-	u32 irq_moderation_ms;
-	u32 irq;
-	u32 channel;
-	u32 priority;
-	enum mhi_db_brst_mode mode;
-	enum mhi_er_data_type data_type;
-	bool hardware_event;
-	bool client_managed;
-	bool offload_channel;
-};
-
-/**
- * struct mhi_controller_config - Root MHI controller configuration
- * @max_channels: Maximum number of channels supported
- * @timeout_ms: Timeout value for operations. 0 means use default
- * @ready_timeout_ms: Timeout value for waiting device to be ready (optional)
- * @buf_len: Size of automatically allocated buffers. 0 means use default
- * @num_channels: Number of channels defined in @ch_cfg
- * @ch_cfg: Array of defined channels
- * @num_events: Number of event rings defined in @event_cfg
- * @event_cfg: Array of defined event rings
- * @use_bounce_buf: Use a bounce buffer pool due to limited DDR access
- * @m2_no_db: Host is not allowed to ring DB in M2 state
- */
-struct mhi_controller_config {
-	u32 max_channels;
-	u32 timeout_ms;
-	u32 ready_timeout_ms;
-	u32 buf_len;
-	u32 num_channels;
-	const struct mhi_channel_config *ch_cfg;
-	u32 num_events;
-	struct mhi_event_config *event_cfg;
-	bool use_bounce_buf;
-	bool m2_no_db;
-};
-
-/**
- * struct mhi_controller - Master MHI controller structure
- * @name: Device name of the MHI controller
- * @cntrl_dev: Pointer to the struct device of physical bus acting as the MHI
- *            controller (required)
- * @mhi_dev: MHI device instance for the controller
- * @debugfs_dentry: MHI controller debugfs directory
- * @regs: Base address of MHI MMIO register space (required)
- * @bhi: Points to base of MHI BHI register space
- * @bhie: Points to base of MHI BHIe register space
- * @wake_db: MHI WAKE doorbell register address
- * @iova_start: IOMMU starting address for data (required)
- * @iova_stop: IOMMU stop address for data (required)
- * @fw_image: Firmware image name for normal booting (optional)
- * @fw_data: Firmware image data content for normal booting, used only
- *           if fw_image is NULL and fbc_download is true (optional)
- * @fw_sz: Firmware image data size for normal booting, used only if fw_image
- *         is NULL and fbc_download is true (optional)
- * @edl_image: Firmware image name for emergency download mode (optional)
- * @rddm_size: RAM dump size that host should allocate for debugging purpose
- * @sbl_size: SBL image size downloaded through BHIe (optional)
- * @seg_len: BHIe vector size (optional)
- * @reg_len: Length of the MHI MMIO region (required)
- * @fbc_image: Points to firmware image buffer
- * @rddm_image: Points to RAM dump buffer
- * @mhi_chan: Points to the channel configuration table
- * @lpm_chans: List of channels that require LPM notifications
- * @irq: base irq # to request (required)
- * @max_chan: Maximum number of channels the controller supports
- * @total_ev_rings: Total # of event rings allocated
- * @hw_ev_rings: Number of hardware event rings
- * @sw_ev_rings: Number of software event rings
- * @nr_irqs: Number of IRQ allocated by bus master (required)
- * @serial_number: MHI controller serial number obtained from BHI
- * @mhi_event: MHI event ring configurations table
- * @mhi_cmd: MHI command ring configurations table
- * @mhi_ctxt: MHI device context, shared memory between host and device
- * @pm_mutex: Mutex for suspend/resume operation
- * @pm_lock: Lock for protecting MHI power management state
- * @timeout_ms: Timeout in ms for state transitions
- * @ready_timeout_ms: Timeout in ms for waiting device to be ready (optional)
- * @pm_state: MHI power management state
- * @db_access: DB access states
- * @ee: MHI device execution environment
- * @dev_state: MHI device state
- * @dev_wake: Device wakeup count
- * @pending_pkts: Pending packets for the controller
- * @M0, M2, M3: Counters to track number of device MHI state changes
- * @transition_list: List of MHI state transitions
- * @transition_lock: Lock for protecting MHI state transition list
- * @wlock: Lock for protecting device wakeup
- * @mhi_link_info: Device bandwidth info
- * @st_worker: State transition worker
- * @hiprio_wq: High priority workqueue for MHI work such as state transitions
- * @state_event: State change event
- * @status_cb: CB function to notify power states of the device (required)
- * @wake_get: CB function to assert device wake (optional)
- * @wake_put: CB function to de-assert device wake (optional)
- * @wake_toggle: CB function to assert and de-assert device wake (optional)
- * @runtime_get: CB function to controller runtime resume (required)
- * @runtime_put: CB function to decrement pm usage (required)
- * @map_single: CB function to create TRE buffer
- * @unmap_single: CB function to destroy TRE buffer
- * @read_reg: Read a MHI register via the physical link (required)
- * @write_reg: Write a MHI register via the physical link (required)
- * @reset: Controller specific reset function (optional)
- * @edl_trigger: CB function to trigger EDL mode (optional)
- * @buffer_len: Bounce buffer length
- * @index: Index of the MHI controller instance
- * @bounce_buf: Use of bounce buffer
- * @fbc_download: MHI host needs to do complete image transfer (optional)
- * @wake_set: Device wakeup set flag
- * @irq_flags: irq flags passed to request_irq (optional)
- * @mru: the default MRU for the MHI device
- *
- * Fields marked as (required) need to be populated by the controller driver
- * before calling mhi_register_controller(). For the fields marked as (optional)
- * they can be populated depending on the usecase.
- */
-struct mhi_controller {
-	const char *name;
-	struct device *cntrl_dev;
-	struct mhi_device *mhi_dev;
-	struct dentry *debugfs_dentry;
-	void __iomem *regs;
-	void __iomem *bhi;
-	void __iomem *bhie;
-	void __iomem *wake_db;
-
-	dma_addr_t iova_start;
-	dma_addr_t iova_stop;
-	const char *fw_image;
-	const u8 *fw_data;
-	size_t fw_sz;
-	const char *edl_image;
-	size_t rddm_size;
-	size_t sbl_size;
-	size_t seg_len;
-	size_t reg_len;
-	struct image_info *fbc_image;
-	struct image_info *rddm_image;
-	struct mhi_chan *mhi_chan;
-	struct list_head lpm_chans;
-	int *irq;
-	u32 max_chan;
-	u32 total_ev_rings;
-	u32 hw_ev_rings;
-	u32 sw_ev_rings;
-	u32 nr_irqs;
-	u32 serial_number;
-
-	struct mhi_event *mhi_event;
-	struct mhi_cmd *mhi_cmd;
-	struct mhi_ctxt *mhi_ctxt;
-
-	struct mutex pm_mutex;
-	rwlock_t pm_lock;
-	u32 timeout_ms;
-	u32 ready_timeout_ms;
-	u32 pm_state;
-	u32 db_access;
-	enum mhi_ee_type ee;
-	enum mhi_state dev_state;
-	atomic_t dev_wake;
-	atomic_t pending_pkts;
-	u32 M0, M2, M3;
-	struct list_head transition_list;
-	spinlock_t transition_lock;
-	spinlock_t wlock;
-	struct mhi_link_info mhi_link_info;
-	struct work_struct st_worker;
-	struct workqueue_struct *hiprio_wq;
-	wait_queue_head_t state_event;
-
-	void (*status_cb)(struct mhi_controller *mhi_cntrl,
-			  enum mhi_callback cb);
-	void (*wake_get)(struct mhi_controller *mhi_cntrl, bool override);
-	void (*wake_put)(struct mhi_controller *mhi_cntrl, bool override);
-	void (*wake_toggle)(struct mhi_controller *mhi_cntrl);
-	int (*runtime_get)(struct mhi_controller *mhi_cntrl);
-	void (*runtime_put)(struct mhi_controller *mhi_cntrl);
-	int (*map_single)(struct mhi_controller *mhi_cntrl,
-			  struct mhi_buf_info *buf);
-	void (*unmap_single)(struct mhi_controller *mhi_cntrl,
-			     struct mhi_buf_info *buf);
-	int (*read_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,
-			u32 *out);
-	void (*write_reg)(struct mhi_controller *mhi_cntrl, void __iomem *addr,
-			  u32 val);
-	void (*reset)(struct mhi_controller *mhi_cntrl);
-	int (*edl_trigger)(struct mhi_controller *mhi_cntrl);
-
-	size_t buffer_len;
-	int index;
-	bool bounce_buf;
-	bool fbc_download;
-	bool wake_set;
-	unsigned long irq_flags;
-	u32 mru;
-};
-
-/**
- * struct mhi_device - Structure representing an MHI device which binds
- *                     to channels or is associated with controllers
- * @id: Pointer to MHI device ID struct
- * @name: Name of the associated MHI device
- * @mhi_cntrl: Controller the device belongs to
- * @ul_chan: UL channel for the device
- * @dl_chan: DL channel for the device
- * @dev: Driver model device node for the MHI device
- * @dev_type: MHI device type
- * @ul_chan_id: MHI channel id for UL transfer
- * @dl_chan_id: MHI channel id for DL transfer
- * @dev_wake: Device wakeup counter
- */
-struct mhi_device {
-	const struct mhi_device_id *id;
-	const char *name;
-	struct mhi_controller *mhi_cntrl;
-	struct mhi_chan *ul_chan;
-	struct mhi_chan *dl_chan;
-	struct device dev;
-	enum mhi_device_type dev_type;
-	int ul_chan_id;
-	int dl_chan_id;
-	u32 dev_wake;
-};
-
-/**
- * struct mhi_result - Completed buffer information
- * @buf_addr: Address of data buffer
- * @bytes_xferd: # of bytes transferred
- * @dir: Channel direction
- * @transaction_status: Status of last transaction
- */
-struct mhi_result {
-	void *buf_addr;
-	size_t bytes_xferd;
-	enum dma_data_direction dir;
-	int transaction_status;
-};
-
-/**
- * struct mhi_buf - MHI Buffer description
- * @buf: Virtual address of the buffer
- * @name: Buffer label. For offload channel, configurations name must be:
- *        ECA - Event context array data
- *        CCA - Channel context array data
- * @dma_addr: IOMMU address of the buffer
- * @len: # of bytes
- */
-struct mhi_buf {
-	void *buf;
-	const char *name;
-	dma_addr_t dma_addr;
-	size_t len;
-};
-
-/**
- * struct mhi_driver - Structure representing a MHI client driver
- * @probe: CB function for client driver probe function
- * @remove: CB function for client driver remove function
- * @ul_xfer_cb: CB function for UL data transfer
- * @dl_xfer_cb: CB function for DL data transfer
- * @status_cb: CB functions for asynchronous status
- * @driver: Device driver model driver
- */
-struct mhi_driver {
-	const struct mhi_device_id *id_table;
-	int (*probe)(struct mhi_device *mhi_dev,
-		     const struct mhi_device_id *id);
-	void (*remove)(struct mhi_device *mhi_dev);
-	void (*ul_xfer_cb)(struct mhi_device *mhi_dev,
-			   struct mhi_result *result);
-	void (*dl_xfer_cb)(struct mhi_device *mhi_dev,
-			   struct mhi_result *result);
-	void (*status_cb)(struct mhi_device *mhi_dev, enum mhi_callback mhi_cb);
-	struct device_driver driver;
-};
-
-#define to_mhi_driver(drv) container_of_const(drv, struct mhi_driver, driver)
-#define to_mhi_device(dev) container_of(dev, struct mhi_device, dev)
-
-/**
- * mhi_alloc_controller - Allocate the MHI Controller structure
- * Allocate the mhi_controller structure using zero initialized memory
- */
-struct mhi_controller *mhi_alloc_controller(void);
-
-/**
- * mhi_free_controller - Free the MHI Controller structure
- * Free the mhi_controller structure which was previously allocated
- */
-void mhi_free_controller(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_register_controller - Register MHI controller
- * @mhi_cntrl: MHI controller to register
- * @config: Configuration to use for the controller
- */
-int mhi_register_controller(struct mhi_controller *mhi_cntrl,
-			const struct mhi_controller_config *config);
-
-/**
- * mhi_unregister_controller - Unregister MHI controller
- * @mhi_cntrl: MHI controller to unregister
- */
-void mhi_unregister_controller(struct mhi_controller *mhi_cntrl);
-
-/*
- * module_mhi_driver() - Helper macro for drivers that don't do
- * anything special other than using default mhi_driver_register() and
- * mhi_driver_unregister().  This eliminates a lot of boilerplate.
- * Each module may only use this macro once.
- */
-#define module_mhi_driver(mhi_drv) \
-	module_driver(mhi_drv, mhi_driver_register, \
-		      mhi_driver_unregister)
-
-/*
- * Macro to avoid include chaining to get THIS_MODULE
- */
-#define mhi_driver_register(mhi_drv) \
-	__mhi_driver_register(mhi_drv, THIS_MODULE)
-
-/**
- * __mhi_driver_register - Register driver with MHI framework
- * @mhi_drv: Driver associated with the device
- * @owner: The module owner
- */
-int __mhi_driver_register(struct mhi_driver *mhi_drv, struct module *owner);
-
-/**
- * mhi_driver_unregister - Unregister a driver for mhi_devices
- * @mhi_drv: Driver associated with the device
- */
-void mhi_driver_unregister(struct mhi_driver *mhi_drv);
-
-/**
- * mhi_set_mhi_state - Set MHI device state
- * @mhi_cntrl: MHI controller
- * @state: State to set
- */
-void mhi_set_mhi_state(struct mhi_controller *mhi_cntrl,
-		       enum mhi_state state);
-
-/**
- * mhi_notify - Notify the MHI client driver about client device status
- * @mhi_dev: MHI device instance
- * @cb_reason: MHI callback reason
- */
-void mhi_notify(struct mhi_device *mhi_dev, enum mhi_callback cb_reason);
-
-/**
- * mhi_get_free_desc_count - Get transfer ring length
- * Get # of TD available to queue buffers
- * @mhi_dev: Device associated with the channels
- * @dir: Direction of the channel
- */
-int mhi_get_free_desc_count(struct mhi_device *mhi_dev,
-				enum dma_data_direction dir);
-
-/**
- * mhi_prepare_for_power_up - Do pre-initialization before power up.
- *                            This is optional, call this before power up if
- *                            the controller does not want bus framework to
- *                            automatically free any allocated memory during
- *                            shutdown process.
- * @mhi_cntrl: MHI controller
- */
-int mhi_prepare_for_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_async_power_up - Start MHI power up sequence
- * @mhi_cntrl: MHI controller
- */
-int mhi_async_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_sync_power_up - Start MHI power up sequence and wait till the device
- *                     enters valid EE state
- * @mhi_cntrl: MHI controller
- */
-int mhi_sync_power_up(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_power_down - Power down the MHI device and also destroy the
- *                  'struct device' for the channels associated with it.
- *                  See also mhi_power_down_keep_dev() which is a variant
- *                  of this API that keeps the 'struct device' for channels
- *                  (useful during suspend/hibernation).
- * @mhi_cntrl: MHI controller
- * @graceful: Link is still accessible, so do a graceful shutdown process
- */
-void mhi_power_down(struct mhi_controller *mhi_cntrl, bool graceful);
-
-/**
- * mhi_power_down_keep_dev - Power down the MHI device but keep the 'struct
- *                           device' for the channels associated with it.
- *                           This is a variant of 'mhi_power_down()' and
- *                           useful in scenarios such as suspend/hibernation
- *                           where destroying of the 'struct device' is not
- *                           needed.
- * @mhi_cntrl: MHI controller
- * @graceful: Link is still accessible, so do a graceful shutdown process
- */
-void mhi_power_down_keep_dev(struct mhi_controller *mhi_cntrl, bool graceful);
-
-/**
- * mhi_unprepare_after_power_down - Free any allocated memory after power down
- * @mhi_cntrl: MHI controller
- */
-void mhi_unprepare_after_power_down(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_suspend - Move MHI into a suspended state
- * @mhi_cntrl: MHI controller
- */
-int mhi_pm_suspend(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_resume - Resume MHI from suspended state
- * @mhi_cntrl: MHI controller
- */
-int mhi_pm_resume(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_pm_resume_force - Force resume MHI from suspended state
- * @mhi_cntrl: MHI controller
- *
- * Resume the device irrespective of its MHI state. As per the MHI spec, devices
- * has to be in M3 state during resume. But some devices seem to be in a
- * different MHI state other than M3 but they continue working fine if allowed.
- * This API is intented to be used for such devices.
- *
- * Return: 0 if the resume succeeds, a negative error code otherwise
- */
-int mhi_pm_resume_force(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_download_rddm_image - Download ramdump image from device for
- *                           debugging purpose.
- * @mhi_cntrl: MHI controller
- * @in_panic: Download rddm image during kernel panic
- */
-int mhi_download_rddm_image(struct mhi_controller *mhi_cntrl, bool in_panic);
-
-/**
- * mhi_force_rddm_mode - Force device into rddm mode
- * @mhi_cntrl: MHI controller
- */
-int mhi_force_rddm_mode(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_get_exec_env - Get BHI execution environment of the device
- * @mhi_cntrl: MHI controller
- */
-enum mhi_ee_type mhi_get_exec_env(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_get_mhi_state - Get MHI state of the device
- * @mhi_cntrl: MHI controller
- */
-enum mhi_state mhi_get_mhi_state(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_soc_reset - Trigger a device reset. This can be used as a last resort
- *		   to reset and recover a device.
- * @mhi_cntrl: MHI controller
- */
-void mhi_soc_reset(struct mhi_controller *mhi_cntrl);
-
-/**
- * mhi_device_get_sync - Disable device low power mode. Synchronously
- *                       take the controller out of suspended state
- * @mhi_dev: Device associated with the channel
- */
-int mhi_device_get_sync(struct mhi_device *mhi_dev);
-
-/**
- * mhi_device_put - Re-enable device low power mode
- * @mhi_dev: Device associated with the channel
- */
-void mhi_device_put(struct mhi_device *mhi_dev);
-
-/**
- * mhi_prepare_for_transfer - Setup UL and DL channels for data transfer.
- * @mhi_dev: Device associated with the channels
- *
- * Allocate and initialize the channel context and also issue the START channel
- * command to both channels. Channels can be started only if both host and
- * device execution environments match and channels are in a DISABLED state.
- */
-int mhi_prepare_for_transfer(struct mhi_device *mhi_dev);
-
-/**
- * mhi_prepare_for_transfer_autoqueue - Setup UL and DL channels with auto queue
- *                                      buffers for DL traffic
- * @mhi_dev: Device associated with the channels
- *
- * Allocate and initialize the channel context and also issue the START channel
- * command to both channels. Channels can be started only if both host and
- * device execution environments match and channels are in a DISABLED state.
- * The MHI core will automatically allocate and queue buffers for the DL traffic.
- */
-int mhi_prepare_for_transfer_autoqueue(struct mhi_device *mhi_dev);
-
-/**
- * mhi_unprepare_from_transfer - Reset UL and DL channels for data transfer.
- *                               Issue the RESET channel command and let the
- *                               device clean-up the context so no incoming
- *                               transfers are seen on the host. Free memory
- *                               associated with the context on host. If device
- *                               is unresponsive, only perform a host side
- *                               clean-up. Channels can be reset only if both
- *                               host and device execution environments match
- *                               and channels are in an ENABLED, STOPPED or
- *                               SUSPENDED state.
- * @mhi_dev: Device associated with the channels
- */
-void mhi_unprepare_from_transfer(struct mhi_device *mhi_dev);
-
-/**
- * mhi_queue_buf - Send or receive raw buffers from client device over MHI
- *                 channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @buf: Buffer for holding the data
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_buf(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  void *buf, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_skb - Send or receive SKBs from client device over MHI channel
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- * @skb: Buffer for holding SKBs
- * @len: Buffer length
- * @mflags: MHI transfer flags used for the transfer
- */
-int mhi_queue_skb(struct mhi_device *mhi_dev, enum dma_data_direction dir,
-		  struct sk_buff *skb, size_t len, enum mhi_flags mflags);
-
-/**
- * mhi_queue_is_full - Determine whether queueing new elements is possible
- * @mhi_dev: Device associated with the channels
- * @dir: DMA direction for the channel
- */
-bool mhi_queue_is_full(struct mhi_device *mhi_dev, enum dma_data_direction dir);
-
-/**
- * mhi_get_channel_doorbell_offset - Get the channel doorbell offset
- * @mhi_cntrl: MHI controller
- * @chdb_offset: Read channel doorbell offset
- *
- * Return: 0 if the read succeeds, a negative error code otherwise
- */
-int mhi_get_channel_doorbell_offset(struct mhi_controller *mhi_cntrl, u32 *chdb_offset);
-
-#endif /* _MHI_H_ */
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 41ac0de..ada352b 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -187,6 +187,8 @@ enum ieee80211_channel_flags {
  * @dfs_state: current state of this channel. Only relevant if radar is required
  *	on this channel.
  * @dfs_state_entered: timestamp (jiffies) when the dfs state was entered.
+ * @dfs_state_last_available: timestamp (jiffies) of the last time when the
+ *	channel was available.
  * @dfs_cac_ms: DFS CAC time in milliseconds, this is valid for DFS channels.
  * @psd: power spectral density (in dBm)
  */
@@ -204,6 +206,7 @@ struct ieee80211_channel {
 	int orig_mag, orig_mpwr;
 	enum nl80211_dfs_state dfs_state;
 	unsigned long dfs_state_entered;
+	unsigned long dfs_state_last_available;
 	unsigned int dfs_cac_ms;
 	s8 psd;
 };
@@ -3601,6 +3604,7 @@ enum wiphy_params_flags {
 /* The per TXQ device queue limit in airtime */
 #define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_L	5000
 #define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_H	12000
+#define IEEE80211_DEFAULT_AQL_TXQ_LIMIT_BC	50000
 
 /* The per interface airtime threshold to switch to lower queue limit */
 #define IEEE80211_AQL_THRESHOLD			24000
diff --git a/include/net/mac80211.h b/include/net/mac80211.h
index 3db32bf..2b9c0e7 100644
--- a/include/net/mac80211.h
+++ b/include/net/mac80211.h
@@ -1249,8 +1249,8 @@ struct ieee80211_tx_info {
 	    status_data_idr:1,
 	    status_data:13,
 	    hw_queue:4,
+	    tx_time_mc:1,
 	    tx_time_est:10;
-	/* 1 free bit */
 
 	union {
 		struct {
diff --git a/include/trace/events/qrtr.h b/include/trace/events/qrtr.h
index 14f8229..d5e9022 100644
--- a/include/trace/events/qrtr.h
+++ b/include/trace/events/qrtr.h
@@ -102,7 +102,11 @@ TRACE_EVENT(qrtr_ns_message,
 	),
 
 	TP_fast_assign(
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(ctrl_pkt_str);
+#else
+		__assign_str(ctrl_pkt_str, ctrl_pkt_str);
+#endif
 		__entry->sq_node = sq_node;
 		__entry->sq_port = sq_port;
 	),
diff --git a/kconf/Makefile b/kconf/Makefile
index 2004c44..c1bd620 100644
--- a/kconf/Makefile
+++ b/kconf/Makefile
@@ -1,9 +1,9 @@
-CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer
+CFLAGS=-Wall -Wmissing-prototypes -Wstrict-prototypes -O2 -fomit-frame-pointer -DKBUILD_NO_NLS
 
 LXDIALOG := lxdialog/checklist.o lxdialog/inputbox.o lxdialog/menubox.o lxdialog/textbox.o lxdialog/util.o lxdialog/yesno.o
 
 conf: conf.o zconf.tab.o
-mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags) -DLOCALE
+mconf_CFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ccflags)
 mconf_LDFLAGS := $(shell ./lxdialog/check-lxdialog.sh -ldflags $(CC))
 mconf: CFLAGS += $(mconf_CFLAGS)
 
@@ -17,7 +17,7 @@ clean:
 zconf.tab.c: zconf.lex.c
 
 %.tab.c: %.y
-	$(YACC) -o$@ -t -l $<
+	$(YACC) -Wno-yacc -o$@ -t -l $<
 
 %.lex.c: %.l
 	$(LEX) -o$@ -L $<
diff --git a/kconf/conf.c b/kconf/conf.c
index 283eeed..162fa6b 100644
--- a/kconf/conf.c
+++ b/kconf/conf.c
@@ -86,7 +86,7 @@ static int conf_askvalue(struct symbol *sym, const char *def)
 	enum symbol_type type = sym_get_type(sym);
 
 	if (!sym_has_value(sym))
-		printf(_("(NEW) "));
+		printf("%s", _("(NEW) "));
 
 	line[0] = '\n';
 	line[1] = 0;
@@ -282,7 +282,7 @@ static int conf_choice(struct menu *menu)
 			if (child->sym->name)
 				printf(" (%s)", child->sym->name);
 			if (!sym_has_value(child->sym))
-				printf(_(" (NEW)"));
+				printf("%s", _(" (NEW)"));
 			printf("\n");
 		}
 		printf(_("%*schoice"), indent - 1, "");
@@ -437,7 +437,7 @@ static void check_conf(struct menu *menu)
 				}
 			} else {
 				if (!conf_cnt++)
-					printf(_("*\n* Restart config...\n*\n"));
+					printf("%s", _("*\n* Restart config...\n*\n"));
 				rootEntry = menu_get_parent_menu(menu);
 				conf(rootEntry);
 			}
@@ -598,40 +598,12 @@ int main(int ac, char **av)
 	case oldconfig:
 	case listnewconfig:
 	case olddefconfig:
-		conf_read(NULL);
-		break;
 	case allnoconfig:
 	case allyesconfig:
 	case allmodconfig:
 	case alldefconfig:
 	case randconfig:
-		name = getenv("KCONFIG_ALLCONFIG");
-		if (!name)
-			break;
-		if ((strcmp(name, "") != 0) && (strcmp(name, "1") != 0)) {
-			if (conf_read_simple(name, S_DEF_USER)) {
-				fprintf(stderr,
-					_("*** Can't read seed configuration \"%s\"!\n"),
-					name);
-				exit(1);
-			}
-			break;
-		}
-		switch (input_mode) {
-		case allnoconfig:	name = "allno.config"; break;
-		case allyesconfig:	name = "allyes.config"; break;
-		case allmodconfig:	name = "allmod.config"; break;
-		case alldefconfig:	name = "alldef.config"; break;
-		case randconfig:	name = "allrandom.config"; break;
-		default: break;
-		}
-		if (conf_read_simple(name, S_DEF_USER) &&
-		    conf_read_simple("all.config", S_DEF_USER)) {
-			fprintf(stderr,
-				_("*** KCONFIG_ALLCONFIG set, but no \"%s\" or \"all.config\" file found\n"),
-				name);
-			exit(1);
-		}
+		conf_read(NULL);
 		break;
 	default:
 		break;
@@ -642,7 +614,7 @@ int main(int ac, char **av)
 			name = getenv("KCONFIG_NOSILENTUPDATE");
 			if (name && *name) {
 				fprintf(stderr,
-					_("\n*** The configuration requires explicit update.\n\n"));
+					"%s", _("\n*** The configuration requires explicit update.\n\n"));
 				return 1;
 			}
 		}
@@ -694,22 +666,22 @@ int main(int ac, char **av)
 		 * All other commands are only used to generate a config.
 		 */
 		if (conf_get_changed() && conf_write(NULL)) {
-			fprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during writing of the configuration.\n\n"));
 			exit(1);
 		}
 		if (conf_write_autoconf()) {
-			fprintf(stderr, _("\n*** Error during update of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during update of the configuration.\n\n"));
 			return 1;
 		}
 	} else if (input_mode == savedefconfig) {
 		if (conf_write_defconfig(defconfig_file)) {
-			fprintf(stderr, _("n*** Error while saving defconfig to: %s\n\n"),
+			fprintf(stderr, _("\n*** Error while saving defconfig to: %s\n\n"),
 				defconfig_file);
 			return 1;
 		}
 	} else if (input_mode != listnewconfig) {
 		if (conf_write(NULL)) {
-			fprintf(stderr, _("\n*** Error during writing of the configuration.\n\n"));
+			fprintf(stderr, "%s", _("\n*** Error during writing of the configuration.\n\n"));
 			exit(1);
 		}
 	}
diff --git a/kconf/confdata.c b/kconf/confdata.c
index df26c7b..1038c30 100644
--- a/kconf/confdata.c
+++ b/kconf/confdata.c
@@ -1170,6 +1170,8 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 	}
 	bool has_changed = false;
 
+	sym_clear_all_valid();
+
 	for_all_symbols(i, sym) {
 		if (sym_has_value(sym) || (sym->flags & SYMBOL_VALID))
 			continue;
@@ -1213,8 +1215,6 @@ bool conf_set_all_new_symbols(enum conf_def_mode mode)
 
 	}
 
-	sym_clear_all_valid();
-
 	/*
 	 * We have different type of choice blocks.
 	 * If curr.tri equals to mod then we can select several
diff --git a/local-symbols b/local-symbols
index 4dd646a..2871124 100644
--- a/local-symbols
+++ b/local-symbols
@@ -53,14 +53,6 @@ MAC80211_MESH_PS_DEBUG=
 MAC80211_TDLS_DEBUG=
 MAC80211_DEBUG_COUNTERS=
 MAC80211_STA_HASH_MAX_SIZE=
-QRTR=
-QRTR_SMD=
-QRTR_TUN=
-QRTR_MHI=
-MHI_BUS=
-MHI_BUS_DEBUG=
-MHI_BUS_PCI_GENERIC=
-MHI_BUS_EP=
 QCOM_AOSS_QMP=
 QCOM_COMMAND_DB=
 QCOM_GENI_SE=
@@ -99,6 +91,7 @@ ADM8211=
 ATH_COMMON=
 WLAN_VENDOR_ATH=
 ATH_DEBUG=
+ATH_USER_REGD=
 ATH_TRACEPOINTS=
 ATH_REG_DYNAMIC_USER_REG_HINTS=
 ATH_REG_DYNAMIC_USER_CERT_TESTING=
@@ -125,6 +118,7 @@ ATH9K_WOW=
 ATH9K_RFKILL=
 ATH9K_CHANNEL_CONTEXT=
 ATH9K_PCOEM=
+ATH9K_UBNTHSR=
 ATH9K_PCI_NO_EEPROM=
 ATH9K_HTC=
 ATH9K_HTC_DEBUGFS=
@@ -157,6 +151,7 @@ ATH10K_DEBUG=
 ATH10K_DEBUGFS=
 ATH10K_LEDS=
 ATH10K_SPECTRAL=
+ATH10K_THERMAL=
 ATH10K_TRACING=
 ATH10K_DFS_CERTIFIED=
 WCN36XX=
@@ -168,6 +163,7 @@ ATH11K_DEBUG=
 ATH11K_DEBUGFS=
 ATH11K_TRACING=
 ATH11K_SPECTRAL=
+ATH11K_THERMAL=
 ATH12K=
 ATH12K_AHB=
 ATH12K_DEBUG=
@@ -340,6 +336,7 @@ RT2X00_LIB_FIRMWARE=
 RT2X00_LIB_CRYPTO=
 RT2X00_LIB_LEDS=
 RT2X00_LIB_DEBUGFS=
+RT2X00_LIB_EEPROM=
 RT2X00_DEBUG=
 WLAN_VENDOR_REALTEK=
 RTL8180=
diff --git a/net/mac80211/airtime.c b/net/mac80211/airtime.c
index c61df63..0c54cdb 100644
--- a/net/mac80211/airtime.c
+++ b/net/mac80211/airtime.c
@@ -685,7 +685,7 @@ static int ieee80211_fill_rx_status(struct ieee80211_rx_status *stat,
 	if (ieee80211_fill_rate_info(hw, stat, band, ri))
 		return 0;
 
-	if (!ieee80211_rate_valid(rate))
+	if (!rate || !ieee80211_rate_valid(rate))
 		return -1;
 
 	if (rate->flags & IEEE80211_TX_RC_160_MHZ_WIDTH)
@@ -753,6 +753,53 @@ u32 ieee80211_calc_tx_airtime(struct ieee80211_hw *hw,
 }
 EXPORT_SYMBOL_GPL(ieee80211_calc_tx_airtime);
 
+u32 ieee80211_rate_expected_tx_airtime(struct ieee80211_hw *hw,
+				       struct ieee80211_tx_rate *tx_rate,
+				       struct rate_info *ri,
+				       enum nl80211_band band,
+				       bool ampdu, int len)
+{
+	struct ieee80211_rx_status stat;
+	u32 duration, overhead;
+	u8 agg_shift;
+
+	if (ieee80211_fill_rx_status(&stat, hw, tx_rate, ri, band, len))
+		return 0;
+
+	if (stat.encoding == RX_ENC_LEGACY || !ampdu)
+		return ieee80211_calc_rx_airtime(hw, &stat, len) * 1024;
+
+	duration = ieee80211_get_rate_duration(hw, &stat, &overhead);
+
+	/*
+	 * Assume that HT/VHT transmission on any AC except VO will
+	 * use aggregation. Since we don't have reliable reporting
+	 * of aggregation length, assume an average size based on the
+	 * tx rate.
+	 * This will not be very accurate, but much better than simply
+	 * assuming un-aggregated tx in all cases.
+	 */
+	if (duration > 400 * 1024) /* <= VHT20 MCS2 1S */
+		agg_shift = 1;
+	else if (duration > 250 * 1024) /* <= VHT20 MCS3 1S or MCS1 2S */
+		agg_shift = 2;
+	else if (duration > 150 * 1024) /* <= VHT20 MCS5 1S or MCS2 2S */
+		agg_shift = 3;
+	else if (duration > 70 * 1024) /* <= VHT20 MCS5 2S */
+		agg_shift = 4;
+	else if (stat.encoding != RX_ENC_HE ||
+		 duration > 20 * 1024) /* <= HE40 MCS6 2S */
+		agg_shift = 5;
+	else
+		agg_shift = 6;
+
+	duration *= len;
+	duration /= AVG_PKT_SIZE;
+	duration += (overhead * 1024 >> agg_shift);
+
+	return duration;
+}
+
 u32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif,
 				       struct ieee80211_sta *pubsta,
@@ -775,45 +822,13 @@ u32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,
 	if (pubsta) {
 		struct sta_info *sta = container_of(pubsta, struct sta_info,
 						    sta);
-		struct ieee80211_rx_status stat;
 		struct ieee80211_tx_rate *tx_rate = &sta->deflink.tx_stats.last_rate;
 		struct rate_info *ri = &sta->deflink.tx_stats.last_rate_info;
-		u32 duration, overhead;
-		u8 agg_shift;
-
-		if (ieee80211_fill_rx_status(&stat, hw, tx_rate, ri, band, len))
-			return 0;
+		u32 duration;
 
-		if (stat.encoding == RX_ENC_LEGACY || !ampdu)
-			return ieee80211_calc_rx_airtime(hw, &stat, len);
-
-		duration = ieee80211_get_rate_duration(hw, &stat, &overhead);
-		/*
-		 * Assume that HT/VHT transmission on any AC except VO will
-		 * use aggregation. Since we don't have reliable reporting
-		 * of aggregation length, assume an average size based on the
-		 * tx rate.
-		 * This will not be very accurate, but much better than simply
-		 * assuming un-aggregated tx in all cases.
-		 */
-		if (duration > 400 * 1024) /* <= VHT20 MCS2 1S */
-			agg_shift = 1;
-		else if (duration > 250 * 1024) /* <= VHT20 MCS3 1S or MCS1 2S */
-			agg_shift = 2;
-		else if (duration > 150 * 1024) /* <= VHT20 MCS5 1S or MCS2 2S */
-			agg_shift = 3;
-		else if (duration > 70 * 1024) /* <= VHT20 MCS5 2S */
-			agg_shift = 4;
-		else if (stat.encoding != RX_ENC_HE ||
-			 duration > 20 * 1024) /* <= HE40 MCS6 2S */
-			agg_shift = 5;
-		else
-			agg_shift = 6;
-
-		duration *= len;
-		duration /= AVG_PKT_SIZE;
+		duration = ieee80211_rate_expected_tx_airtime(hw, tx_rate, ri,
+							      band, true, len);
 		duration /= 1024;
-		duration += (overhead >> agg_shift);
 
 		return max_t(u32, duration, 4);
 	}
diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c
index bc25455..aea3509 100644
--- a/net/mac80211/cfg.c
+++ b/net/mac80211/cfg.c
@@ -1882,12 +1882,6 @@ static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev,
 
 	__sta_info_flush(sdata, true, link_id, NULL);
 
-	ieee80211_remove_link_keys(link, &keys);
-	if (!list_empty(&keys)) {
-		synchronize_net();
-		ieee80211_free_key_list(local, &keys);
-	}
-
 	ieee80211_stop_mbssid(sdata);
 	RCU_INIT_POINTER(link_conf->tx_bss_conf, NULL);
 
@@ -3137,6 +3131,8 @@ static int ieee80211_scan(struct wiphy *wiphy,
 		 */
 		fallthrough;
 	case NL80211_IFTYPE_AP:
+		/* skip check */
+		break;
 		/*
 		 * If the scan has been forced (and the driver supports
 		 * forcing), don't care about being beaconing already.
@@ -3829,6 +3825,27 @@ static bool ieee80211_is_scan_ongoing(struct wiphy *wiphy,
 	return false;
 }
 
+bool ieee80211_scanning_busy(struct ieee80211_local *local,
+			     struct cfg80211_chan_def *chandef)
+{
+	struct cfg80211_scan_request *scan_req;
+	struct wiphy *wiphy = local->hw.wiphy;
+	u32 mask;
+
+	if (!ieee80211_is_scan_ongoing(wiphy, local, chandef))
+		return false;
+
+	if (!wiphy->n_radio)
+		return true;
+
+	mask = ieee80211_offchannel_radio_mask(local);
+	scan_req = wiphy_dereference(wiphy, local->scan_req);
+	if (scan_req)
+		mask |= ieee80211_scan_req_radio_mask(local, scan_req);
+
+	return mask & ieee80211_chandef_radio_mask(local, chandef);
+}
+
 static int ieee80211_start_radar_detection(struct wiphy *wiphy,
 					   struct net_device *dev,
 					   struct cfg80211_chan_def *chandef,
@@ -3842,7 +3859,7 @@ static int ieee80211_start_radar_detection(struct wiphy *wiphy,
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	if (ieee80211_is_scan_ongoing(wiphy, local, chandef))
+	if (ieee80211_scanning_busy(local, chandef))
 		return -EBUSY;
 
 	link_data = sdata_dereference(sdata->link[link_id], sdata);
@@ -4334,7 +4351,7 @@ __ieee80211_channel_switch(struct wiphy *wiphy, struct net_device *dev,
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	if (ieee80211_is_scan_ongoing(wiphy, local, &params->chandef))
+	if (ieee80211_scanning_busy(local, &params->chandef))
 		return -EBUSY;
 
 	if (sdata->wdev.links[link_id].cac_started)
@@ -4577,7 +4594,9 @@ static int ieee80211_probe_client(struct wiphy *wiphy, struct net_device *dev,
 	struct ieee80211_tx_info *info;
 	struct sta_info *sta;
 	struct ieee80211_chanctx_conf *chanctx_conf;
+	struct ieee80211_bss_conf *link_conf;
 	enum nl80211_band band;
+	u8 link_id;
 	int ret;
 
 	/* the lock is needed to assign the cookie later */
@@ -4592,7 +4611,23 @@ static int ieee80211_probe_client(struct wiphy *wiphy, struct net_device *dev,
 
 	qos = sta->sta.wme;
 
-	chanctx_conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
+	if (ieee80211_vif_is_mld(&sdata->vif)) {
+		if (sta->sta.valid_links)
+			link_id = ffs(sta->sta.valid_links) - 1;
+		else
+			link_id = sta->deflink.link_id;
+
+		link_conf = rcu_dereference(sdata->vif.link_conf[link_id]);
+		if (unlikely(!link_conf)) {
+			ret = -ENOLINK;
+			goto unlock;
+		}
+	} else {
+		link_id = IEEE80211_LINK_UNSPECIFIED;
+		link_conf = &sdata->vif.bss_conf;
+	}
+
+	chanctx_conf = rcu_dereference(link_conf->chanctx_conf);
 	if (WARN_ON(!chanctx_conf)) {
 		ret = -EINVAL;
 		goto unlock;
@@ -4624,14 +4659,15 @@ static int ieee80211_probe_client(struct wiphy *wiphy, struct net_device *dev,
 	nullfunc->frame_control = fc;
 	nullfunc->duration_id = 0;
 	memcpy(nullfunc->addr1, sta->sta.addr, ETH_ALEN);
-	memcpy(nullfunc->addr2, sdata->vif.addr, ETH_ALEN);
-	memcpy(nullfunc->addr3, sdata->vif.addr, ETH_ALEN);
+	memcpy(nullfunc->addr2, link_conf->addr, ETH_ALEN);
+	memcpy(nullfunc->addr3, link_conf->addr, ETH_ALEN);
 	nullfunc->seq_ctrl = 0;
 
 	info = IEEE80211_SKB_CB(skb);
 
 	info->flags |= IEEE80211_TX_CTL_REQ_TX_STATUS |
 		       IEEE80211_TX_INTFL_NL80211_FRAME_TX;
+	info->control.flags |= u32_encode_bits(link_id, IEEE80211_TX_CTRL_MLO_LINK);
 	info->band = band;
 
 	skb_set_queue_mapping(skb, IEEE80211_AC_VO);
diff --git a/net/mac80211/chan.c b/net/mac80211/chan.c
index 7f8799f..bf00beb 100644
--- a/net/mac80211/chan.c
+++ b/net/mac80211/chan.c
@@ -644,10 +644,11 @@ ieee80211_find_chanctx(struct ieee80211_local *local,
 	return NULL;
 }
 
-bool ieee80211_is_radar_required(struct ieee80211_local *local,
+bool ieee80211_is_radar_required(struct ieee80211_local *local, u32 radio_mask,
 				 struct cfg80211_scan_request *req)
 {
 	struct wiphy *wiphy = local->hw.wiphy;
+	struct ieee80211_chanctx_conf *conf;
 	struct ieee80211_link_data *link;
 	struct ieee80211_channel *chan;
 	int radio_idx;
@@ -658,14 +659,25 @@ bool ieee80211_is_radar_required(struct ieee80211_local *local,
 		return false;
 
 	for_each_sdata_link(local, link) {
-		if (link->radar_required) {
-			chan = link->conf->chanreq.oper.chan;
-			radio_idx = cfg80211_get_radio_idx_by_chan(wiphy, chan);
+		if (!link->radar_required)
+			continue;
 
-			if (ieee80211_is_radio_idx_in_scan_req(wiphy, req,
-							       radio_idx))
-				return true;
-		}
+		chan = link->conf->chanreq.oper.chan;
+		radio_idx = cfg80211_get_radio_idx_by_chan(wiphy, chan);
+
+		if (ieee80211_is_radio_idx_in_scan_req(wiphy, req,
+						      radio_idx))
+			return true;
+
+		if (!local->hw.wiphy->n_radio)
+			return true;
+
+		conf = wiphy_dereference(local->hw.wiphy, link->conf->chanctx_conf);
+		if (!conf)
+			continue;
+
+		if (conf->radio_idx >= 0 && (radio_mask & BIT(conf->radio_idx)))
+			return true;
 	}
 
 	return false;
diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c
index 8c49675..e430728 100644
--- a/net/mac80211/debugfs.c
+++ b/net/mac80211/debugfs.c
@@ -42,8 +42,9 @@ static ssize_t name## _read(struct file *file, char __user *userbuf,	\
 }
 
 #define DEBUGFS_READONLY_FILE_OPS(name)			\
-static const struct debugfs_short_fops name## _ops = {				\
+static const struct file_operations name## _ops = {			\
 	.read = name## _read,						\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 };
 
@@ -139,9 +140,10 @@ static ssize_t aqm_write(struct file *file,
 	return -EINVAL;
 }
 
-static const struct debugfs_short_fops aqm_ops = {
+static const struct file_operations aqm_ops = {
 	.write = aqm_write,
 	.read = aqm_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -190,9 +192,10 @@ static ssize_t airtime_flags_write(struct file *file,
 	return count;
 }
 
-static const struct debugfs_short_fops airtime_flags_ops = {
+static const struct file_operations airtime_flags_ops = {
 	.write = airtime_flags_write,
 	.read = airtime_flags_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -210,18 +213,21 @@ static ssize_t aql_pending_read(struct file *file,
 			"VI     %u us\n"
 			"BE     %u us\n"
 			"BK     %u us\n"
+			"BC/MC  %u us\n"
 			"total  %u us\n",
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VO]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_VI]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BE]),
 			atomic_read(&local->aql_ac_pending_airtime[IEEE80211_AC_BK]),
+			atomic_read(&local->aql_bc_pending_airtime),
 			atomic_read(&local->aql_total_pending_airtime));
 	return simple_read_from_buffer(user_buf, count, ppos,
 				       buf, len);
 }
 
-static const struct debugfs_short_fops aql_pending_ops = {
+static const struct file_operations aql_pending_ops = {
 	.read = aql_pending_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -239,7 +245,8 @@ static ssize_t aql_txq_limit_read(struct file *file,
 			"VO	%u		%u\n"
 			"VI	%u		%u\n"
 			"BE	%u		%u\n"
-			"BK	%u		%u\n",
+			"BK	%u		%u\n"
+			"BC/MC	%u\n",
 			local->aql_txq_limit_low[IEEE80211_AC_VO],
 			local->aql_txq_limit_high[IEEE80211_AC_VO],
 			local->aql_txq_limit_low[IEEE80211_AC_VI],
@@ -247,7 +254,8 @@ static ssize_t aql_txq_limit_read(struct file *file,
 			local->aql_txq_limit_low[IEEE80211_AC_BE],
 			local->aql_txq_limit_high[IEEE80211_AC_BE],
 			local->aql_txq_limit_low[IEEE80211_AC_BK],
-			local->aql_txq_limit_high[IEEE80211_AC_BK]);
+			local->aql_txq_limit_high[IEEE80211_AC_BK],
+			local->aql_txq_limit_bc);
 	return simple_read_from_buffer(user_buf, count, ppos,
 				       buf, len);
 }
@@ -273,6 +281,11 @@ static ssize_t aql_txq_limit_write(struct file *file,
 	else
 		buf[count] = '\0';
 
+	if (sscanf(buf, "mcast %u", &q_limit_low) == 1) {
+		local->aql_txq_limit_bc = q_limit_low;
+		return count;
+	}
+
 	if (sscanf(buf, "%u %u %u", &ac, &q_limit_low, &q_limit_high) != 3)
 		return -EINVAL;
 
@@ -299,9 +312,10 @@ static ssize_t aql_txq_limit_write(struct file *file,
 	return count;
 }
 
-static const struct debugfs_short_fops aql_txq_limit_ops = {
+static const struct file_operations aql_txq_limit_ops = {
 	.write = aql_txq_limit_write,
 	.read = aql_txq_limit_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -348,9 +362,10 @@ static ssize_t aql_enable_write(struct file *file, const char __user *user_buf,
 	return count;
 }
 
-static const struct debugfs_short_fops aql_enable_ops = {
+static const struct file_operations aql_enable_ops = {
 	.write = aql_enable_write,
 	.read = aql_enable_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -398,9 +413,10 @@ static ssize_t force_tx_status_write(struct file *file,
 	return count;
 }
 
-static const struct debugfs_short_fops force_tx_status_ops = {
+static const struct file_operations force_tx_status_ops = {
 	.write = force_tx_status_write,
 	.read = force_tx_status_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 
@@ -425,8 +441,9 @@ static ssize_t reset_write(struct file *file, const char __user *user_buf,
 	return count;
 }
 
-static const struct debugfs_short_fops reset_ops = {
+static const struct file_operations reset_ops = {
 	.write = reset_write,
+	.open = simple_open,
 	.llseek = noop_llseek,
 };
 #endif
@@ -653,8 +670,9 @@ static ssize_t stats_ ##name## _read(struct file *file,			\
 				      print_devstats_##name);		\
 }									\
 									\
-static const struct debugfs_short_fops stats_ ##name## _ops = {			\
+static const struct file_operations stats_ ##name## _ops = {		\
 	.read = stats_ ##name## _read,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 };
 
diff --git a/net/mac80211/debugfs_key.c b/net/mac80211/debugfs_key.c
index 117f58a..9a335fa 100644
--- a/net/mac80211/debugfs_key.c
+++ b/net/mac80211/debugfs_key.c
@@ -26,15 +26,17 @@ static ssize_t key_##name##_read(struct file *file,			\
 #define KEY_READ_X(name) KEY_READ(name, name, "0x%x\n")
 
 #define KEY_OPS(name)							\
-static const struct debugfs_short_fops key_ ##name## _ops = {		\
+static const struct file_operations key_ ##name## _ops = {		\
 	.read = key_##name##_read,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
 #define KEY_OPS_W(name)							\
-static const struct debugfs_short_fops key_ ##name## _ops = {		\
+static const struct file_operations key_ ##name## _ops = {		\
 	.read = key_##name##_read,					\
 	.write = key_##name##_write,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
@@ -47,8 +49,9 @@ static const struct debugfs_short_fops key_ ##name## _ops = {		\
 #define KEY_CONF_READ_D(name) KEY_CONF_READ(name, "%d\n")
 
 #define KEY_CONF_OPS(name)						\
-static const struct debugfs_short_fops key_ ##name## _ops = {		\
+static const struct file_operations key_ ##name## _ops = {		\
 	.read = key_conf_##name##_read,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
diff --git a/net/mac80211/debugfs_netdev.c b/net/mac80211/debugfs_netdev.c
index 9f8d4af..095691c 100644
--- a/net/mac80211/debugfs_netdev.c
+++ b/net/mac80211/debugfs_netdev.c
@@ -221,9 +221,10 @@ static ssize_t ieee80211_if_fmt_##name(					\
 }
 
 #define _IEEE80211_IF_FILE_OPS(name, _read, _write)			\
-static const struct debugfs_short_fops name##_ops = {				\
+static const struct file_operations name##_ops = {			\
 	.read = (_read),						\
 	.write = (_write),						\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
diff --git a/net/mac80211/debugfs_sta.c b/net/mac80211/debugfs_sta.c
index ef75255..6b70e8a 100644
--- a/net/mac80211/debugfs_sta.c
+++ b/net/mac80211/debugfs_sta.c
@@ -30,15 +30,17 @@ static ssize_t sta_ ##name## _read(struct file *file,			\
 #define STA_READ_D(name, field) STA_READ(name, field, "%d\n")
 
 #define STA_OPS(name)							\
-static const struct debugfs_short_fops sta_ ##name## _ops = {		\
+static const struct file_operations sta_ ##name## _ops = {		\
 	.read = sta_##name##_read,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
 #define STA_OPS_RW(name)						\
-static const struct debugfs_short_fops sta_ ##name## _ops = {		\
+static const struct file_operations sta_ ##name## _ops = {		\
 	.read = sta_##name##_read,					\
 	.write = sta_##name##_write,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
@@ -440,8 +442,9 @@ STA_OPS_RW(agg_status);
 
 /* link sta attributes */
 #define LINK_STA_OPS(name)						\
-static const struct debugfs_short_fops link_sta_ ##name## _ops = {		\
+static const struct file_operations link_sta_ ##name## _ops = {		\
 	.read = link_sta_##name##_read,					\
+	.open = simple_open,						\
 	.llseek = generic_file_llseek,					\
 }
 
diff --git a/net/mac80211/ieee80211_i.h b/net/mac80211/ieee80211_i.h
index c3274ea..a61293e 100644
--- a/net/mac80211/ieee80211_i.h
+++ b/net/mac80211/ieee80211_i.h
@@ -111,6 +111,8 @@ ieee80211_sta_keep_active(struct sta_info *sta, u8 ac)
 	return time_before_eq(jiffies, sta->airtime[ac].last_active + HZ / 10);
 }
 
+#define AIRTIME_QUANTUM_SHIFT	3
+
 struct ieee80211_bss {
 	u32 device_ts_beacon, device_ts_presp;
 
@@ -1426,10 +1428,12 @@ struct ieee80211_local {
 	spinlock_t handle_wake_tx_queue_lock;
 
 	u16 airtime_flags;
+	u32 aql_txq_limit_bc;
 	u32 aql_txq_limit_low[IEEE80211_NUM_ACS];
 	u32 aql_txq_limit_high[IEEE80211_NUM_ACS];
 	u32 aql_threshold;
 	atomic_t aql_total_pending_airtime;
+	atomic_t aql_bc_pending_airtime;
 	atomic_t aql_ac_pending_airtime[IEEE80211_NUM_ACS];
 
 	const struct ieee80211_ops *ops;
@@ -2018,6 +2022,13 @@ int ieee80211_mesh_finish_csa(struct ieee80211_sub_if_data *sdata,
 			      u64 *changed);
 
 /* scan/BSS handling */
+u32 ieee80211_scan_req_radio_mask(struct ieee80211_local *local,
+				  struct cfg80211_scan_request *req);
+bool ieee80211_scanning_busy(struct ieee80211_local *local,
+			     struct cfg80211_chan_def *chandef);
+u32 ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
+			   struct cfg80211_scan_request *req,
+			   u32 radio_mask);
 void ieee80211_scan_work(struct wiphy *wiphy, struct wiphy_work *work);
 int ieee80211_request_ibss_scan(struct ieee80211_sub_if_data *sdata,
 				const u8 *ssid, u8 ssid_len,
@@ -2056,6 +2067,7 @@ void ieee80211_sched_scan_stopped_work(struct wiphy *wiphy,
 /* off-channel/mgmt-tx */
 void ieee80211_offchannel_stop_vifs(struct ieee80211_local *local);
 void ieee80211_offchannel_return(struct ieee80211_local *local);
+u32 ieee80211_offchannel_radio_mask(struct ieee80211_local *local);
 void ieee80211_roc_setup(struct ieee80211_local *local);
 void ieee80211_start_next_roc(struct ieee80211_local *local);
 void ieee80211_reconfig_roc(struct ieee80211_local *local);
@@ -2715,6 +2727,8 @@ bool ieee80211_chandef_s1g_oper(struct ieee80211_local *local,
 				struct cfg80211_chan_def *chandef);
 void ieee80211_chandef_downgrade(struct cfg80211_chan_def *chandef,
 				 struct ieee80211_conn_settings *conn);
+u32 ieee80211_chandef_radio_mask(struct ieee80211_local *local,
+				 struct cfg80211_chan_def *chandef);
 static inline void
 ieee80211_chanreq_downgrade(struct ieee80211_chan_req *chanreq,
 			    struct ieee80211_conn_settings *conn)
@@ -2771,7 +2785,7 @@ void ieee80211_recalc_chanctx_min_def(struct ieee80211_local *local,
 				      struct ieee80211_chanctx *ctx,
 				      struct ieee80211_link_data *rsvd_for,
 				      bool check_reserved);
-bool ieee80211_is_radar_required(struct ieee80211_local *local,
+bool ieee80211_is_radar_required(struct ieee80211_local *local, u32 radio_mask,
 				 struct cfg80211_scan_request *req);
 bool ieee80211_is_radio_idx_in_scan_req(struct wiphy *wiphy,
 					struct cfg80211_scan_request *scan_req,
@@ -2825,6 +2839,11 @@ u8 *ieee80211_get_bssid(struct ieee80211_hdr *hdr, size_t len,
 
 extern const struct ethtool_ops ieee80211_ethtool_ops;
 
+u32 ieee80211_rate_expected_tx_airtime(struct ieee80211_hw *hw,
+				       struct ieee80211_tx_rate *tx_rate,
+				       struct rate_info *ri,
+				       enum nl80211_band band,
+				       bool ampdu, int len);
 u32 ieee80211_calc_expected_tx_airtime(struct ieee80211_hw *hw,
 				       struct ieee80211_vif *vif,
 				       struct ieee80211_sta *pubsta,
diff --git a/net/mac80211/main.c b/net/mac80211/main.c
index ed1b999..7c858f1 100644
--- a/net/mac80211/main.c
+++ b/net/mac80211/main.c
@@ -984,6 +984,7 @@ struct ieee80211_hw *ieee80211_alloc_hw_nm(size_t priv_data_len,
 	spin_lock_init(&local->rx_path_lock);
 	spin_lock_init(&local->queue_stop_reason_lock);
 
+	local->aql_txq_limit_bc = IEEE80211_DEFAULT_AQL_TXQ_LIMIT_BC;
 	for (i = 0; i < IEEE80211_NUM_ACS; i++) {
 		INIT_LIST_HEAD(&local->active_txqs[i]);
 		spin_lock_init(&local->active_txq_lock[i]);
@@ -1597,24 +1598,6 @@ int ieee80211_register_hw(struct ieee80211_hw *hw)
 
 	ieee80211_check_wbrf_support(local);
 
-	rtnl_lock();
-	wiphy_lock(hw->wiphy);
-
-	/* add one default STA interface if supported */
-	if (local->hw.wiphy->interface_modes & BIT(NL80211_IFTYPE_STATION) &&
-	    !ieee80211_hw_check(hw, NO_AUTO_VIF)) {
-		struct vif_params params = {0};
-
-		result = ieee80211_if_add(local, "wlan%d", NET_NAME_ENUM, NULL,
-					  NL80211_IFTYPE_STATION, &params);
-		if (result)
-			wiphy_warn(local->hw.wiphy,
-				   "Failed to add default virtual iface\n");
-	}
-
-	wiphy_unlock(hw->wiphy);
-	rtnl_unlock();
-
 #ifdef CONFIG_INET
 	local->ifa_notifier.notifier_call = ieee80211_ifa_changed;
 	result = register_inetaddr_notifier(&local->ifa_notifier);
diff --git a/net/mac80211/offchannel.c b/net/mac80211/offchannel.c
index d728667..c5a44d2 100644
--- a/net/mac80211/offchannel.c
+++ b/net/mac80211/offchannel.c
@@ -168,6 +168,35 @@ void ieee80211_offchannel_return(struct ieee80211_local *local)
 					false);
 }
 
+u32 ieee80211_offchannel_radio_mask(struct ieee80211_local *local)
+{
+	const struct wiphy_radio *radio;
+	struct ieee80211_roc_work *roc;
+	u32 mask = 0;
+	int r;
+
+	for (r = 0; r < local->hw.wiphy->n_radio; r++) {
+		radio = &local->hw.wiphy->radio[r];
+
+		list_for_each_entry(roc, &local->roc_list, list) {
+			struct cfg80211_chan_def chandef = {};
+
+			if (!roc->started)
+				continue;
+
+			cfg80211_chandef_create(&chandef, roc->chan,
+						NL80211_CHAN_NO_HT);
+			if (!cfg80211_radio_chandef_valid(radio, &chandef))
+				continue;
+
+			mask |= BIT(r);
+			break;
+		}
+	}
+
+	return mask;
+}
+
 static void ieee80211_roc_notify_destroy(struct ieee80211_roc_work *roc)
 {
 	/* was never transmitted */
@@ -566,8 +595,10 @@ static int ieee80211_start_roc_work(struct ieee80211_local *local,
 				    enum ieee80211_roc_type type)
 {
 	struct ieee80211_roc_work *roc, *tmp;
+	struct cfg80211_chan_def chandef = {};
 	bool queued = false, combine_started = true;
 	struct cfg80211_scan_request *req;
+	u32 radio_mask;
 	int ret;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
@@ -579,6 +610,12 @@ static int ieee80211_start_roc_work(struct ieee80211_local *local,
 	if (!local->emulate_chanctx && !local->ops->remain_on_channel)
 		return -EOPNOTSUPP;
 
+	cfg80211_chandef_create(&chandef, channel, NL80211_CHAN_NO_HT);
+	radio_mask = ieee80211_chandef_radio_mask(local, &chandef);
+	if (!ieee80211_can_leave_ch(sdata, req, radio_mask) &&
+	    !ieee80211_scanning_busy(local, &chandef))
+		return -EBUSY;
+
 	roc = kzalloc(sizeof(*roc), GFP_KERNEL);
 	if (!roc)
 		return -ENOMEM;
@@ -616,8 +653,7 @@ static int ieee80211_start_roc_work(struct ieee80211_local *local,
 	req = wiphy_dereference(local->hw.wiphy, local->scan_req);
 
 	/* if there's no need to queue, handle it immediately */
-	if (list_empty(&local->roc_list) &&
-	    !local->scanning && !ieee80211_is_radar_required(local, req)) {
+	if (list_empty(&local->roc_list) && !local->scanning) {
 		/* if not HW assist, just queue & schedule work */
 		if (!local->ops->remain_on_channel) {
 			list_add_tail(&roc->list, &local->roc_list);
diff --git a/net/mac80211/rate.c b/net/mac80211/rate.c
index 687674b..f3433e2 100644
--- a/net/mac80211/rate.c
+++ b/net/mac80211/rate.c
@@ -252,8 +252,9 @@ static ssize_t rcname_read(struct file *file, char __user *userbuf,
 				       ref->ops->name, len);
 }
 
-const struct debugfs_short_fops rcname_ops = {
+const struct file_operations rcname_ops = {
 	.read = rcname_read,
+	.open = simple_open,
 	.llseek = default_llseek,
 };
 #endif
diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index ba24a39..8285ddf 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -62,7 +62,7 @@ static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
 #endif
 }
 
-extern const struct debugfs_short_fops rcname_ops;
+extern const struct file_operations rcname_ops;
 
 static inline void rate_control_add_debugfs(struct ieee80211_local *local)
 {
diff --git a/net/mac80211/rc80211_minstrel_ht.c b/net/mac80211/rc80211_minstrel_ht.c
index 8d54073..5d0e2d4 100644
--- a/net/mac80211/rc80211_minstrel_ht.c
+++ b/net/mac80211/rc80211_minstrel_ht.c
@@ -580,6 +580,14 @@ minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
 	int cur_tp_avg, cur_group, cur_idx;
 	int max_gpr_group, max_gpr_idx;
 	int max_gpr_tp_avg, max_gpr_prob;
+	int min_dur;
+
+	min_dur = max(minstrel_get_duration(mi->max_tp_rate[0]),
+		      minstrel_get_duration(mi->max_tp_rate[1]));
+
+	/* make the rate at least 18% slower than max tp rates */
+	if (minstrel_get_duration(index) <= min_dur * 19 / 16)
+		return;
 
 	cur_group = MI_RATE_GROUP(index);
 	cur_idx = MI_RATE_IDX(index);
@@ -601,11 +609,6 @@ minstrel_ht_set_best_prob_rate(struct minstrel_ht_sta *mi, u16 *dest, u16 index)
 	    !minstrel_ht_is_legacy_group(max_tp_group))
 		return;
 
-	/* skip rates faster than max tp rate with lower prob */
-	if (minstrel_get_duration(mi->max_tp_rate[0]) > minstrel_get_duration(index) &&
-	    mrs->prob_avg < max_tp_prob)
-		return;
-
 	max_gpr_group = MI_RATE_GROUP(mg->max_group_prob_rate);
 	max_gpr_idx = MI_RATE_IDX(mg->max_group_prob_rate);
 	max_gpr_prob = mi->groups[max_gpr_group].rates[max_gpr_idx].prob_avg;
@@ -663,40 +666,6 @@ minstrel_ht_assign_best_tp_rates(struct minstrel_ht_sta *mi,
 
 }
 
-/*
- * Try to increase robustness of max_prob rate by decrease number of
- * streams if possible.
- */
-static inline void
-minstrel_ht_prob_rate_reduce_streams(struct minstrel_ht_sta *mi)
-{
-	struct minstrel_mcs_group_data *mg;
-	int tmp_max_streams, group, tmp_idx, tmp_prob;
-	int tmp_tp = 0;
-
-	if (!mi->sta->deflink.ht_cap.ht_supported)
-		return;
-
-	group = MI_RATE_GROUP(mi->max_tp_rate[0]);
-	tmp_max_streams = minstrel_mcs_groups[group].streams;
-	for (group = 0; group < ARRAY_SIZE(minstrel_mcs_groups); group++) {
-		mg = &mi->groups[group];
-		if (!mi->supported[group] || group == MINSTREL_CCK_GROUP)
-			continue;
-
-		tmp_idx = MI_RATE_IDX(mg->max_group_prob_rate);
-		tmp_prob = mi->groups[group].rates[tmp_idx].prob_avg;
-
-		if (tmp_tp < minstrel_ht_get_tp_avg(mi, group, tmp_idx, tmp_prob) &&
-		   (minstrel_mcs_groups[group].streams < tmp_max_streams)) {
-				mi->max_prob_rate = mg->max_group_prob_rate;
-				tmp_tp = minstrel_ht_get_tp_avg(mi, group,
-								tmp_idx,
-								tmp_prob);
-		}
-	}
-}
-
 static u16
 __minstrel_ht_get_sample_rate(struct minstrel_ht_sta *mi,
 			      enum minstrel_sample_type type)
@@ -769,7 +738,8 @@ minstrel_ht_calc_rate_stats(struct minstrel_priv *mp,
 	unsigned int cur_prob;
 
 	if (unlikely(mrs->attempts > 0)) {
-		cur_prob = MINSTREL_FRAC(mrs->success, mrs->attempts);
+		cur_prob = MINSTREL_FRAC(mrs->success + mrs->last_success,
+					 mrs->attempts + mrs->last_attempts);
 		minstrel_filter_avg_add(&mrs->prob_avg,
 					&mrs->prob_avg_1, cur_prob);
 		mrs->att_hist += mrs->attempts;
@@ -1175,8 +1145,6 @@ minstrel_ht_update_stats(struct minstrel_priv *mp, struct minstrel_ht_sta *mi)
 
 	mi->max_prob_rate = tmp_max_prob_rate;
 
-	/* Try to increase robustness of max_prob_rate*/
-	minstrel_ht_prob_rate_reduce_streams(mi);
 	minstrel_ht_refill_sample_rates(mi);
 
 #ifdef CPTCFG_MAC80211_DEBUGFS
@@ -1255,7 +1223,7 @@ minstrel_ht_ri_txstat_valid(struct minstrel_priv *mp,
 }
 
 static void
-minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
+minstrel_downgrade_prob_rate(struct minstrel_ht_sta *mi, u16 *idx)
 {
 	int group, orig_group;
 
@@ -1270,11 +1238,7 @@ minstrel_downgrade_rate(struct minstrel_ht_sta *mi, u16 *idx, bool primary)
 		    minstrel_mcs_groups[orig_group].streams)
 			continue;
 
-		if (primary)
-			*idx = mi->groups[group].max_group_tp_rate[0];
-		else
-			*idx = mi->groups[group].max_group_tp_rate[1];
-		break;
+		*idx = mi->groups[group].max_group_prob_rate;
 	}
 }
 
@@ -1285,7 +1249,7 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 	struct ieee80211_tx_info *info = st->info;
 	struct minstrel_ht_sta *mi = priv_sta;
 	struct ieee80211_tx_rate *ar = info->status.rates;
-	struct minstrel_rate_stats *rate, *rate2;
+	struct minstrel_rate_stats *rate;
 	struct minstrel_priv *mp = priv;
 	u32 update_interval = mp->update_interval;
 	bool last, update = false;
@@ -1353,18 +1317,13 @@ minstrel_ht_tx_status(void *priv, struct ieee80211_supported_band *sband,
 		/*
 		 * check for sudden death of spatial multiplexing,
 		 * downgrade to a lower number of streams if necessary.
+		 * only do this for the max_prob_rate to prevent spurious
+		 * rate fluctuations when the link changes suddenly
 		 */
-		rate = minstrel_get_ratestats(mi, mi->max_tp_rate[0]);
+		rate = minstrel_get_ratestats(mi, mi->max_prob_rate);
 		if (rate->attempts > 30 &&
 		    rate->success < rate->attempts / 4) {
-			minstrel_downgrade_rate(mi, &mi->max_tp_rate[0], true);
-			update = true;
-		}
-
-		rate2 = minstrel_get_ratestats(mi, mi->max_tp_rate[1]);
-		if (rate2->attempts > 30 &&
-		    rate2->success < rate2->attempts / 4) {
-			minstrel_downgrade_rate(mi, &mi->max_tp_rate[1], false);
+			minstrel_downgrade_prob_rate(mi, &mi->max_prob_rate);
 			update = true;
 		}
 	}
diff --git a/net/mac80211/rc80211_minstrel_ht.h b/net/mac80211/rc80211_minstrel_ht.h
index f385cf6..1f78a94 100644
--- a/net/mac80211/rc80211_minstrel_ht.h
+++ b/net/mac80211/rc80211_minstrel_ht.h
@@ -14,7 +14,7 @@
 
 /* scaled fraction values */
 #define MINSTREL_SCALE  12
-#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / div)
+#define MINSTREL_FRAC(val, div) (((val) << MINSTREL_SCALE) / (div))
 #define MINSTREL_TRUNC(val) ((val) >> MINSTREL_SCALE)
 
 #define EWMA_LEVEL	96	/* ewma weighting factor [/EWMA_DIV] */
diff --git a/net/mac80211/scan.c b/net/mac80211/scan.c
index bb9563f..22b1fc9 100644
--- a/net/mac80211/scan.c
+++ b/net/mac80211/scan.c
@@ -586,25 +586,72 @@ static int ieee80211_start_sw_scan(struct ieee80211_local *local,
 	return 0;
 }
 
-static bool __ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
-				     struct cfg80211_scan_request *req)
+u32 ieee80211_scan_req_radio_mask(struct ieee80211_local *local,
+				  struct cfg80211_scan_request *req)
+{
+	const struct wiphy_radio *radio;
+	u32 mask = 0;
+	int i, r;
+
+	for (r = 0; r < local->hw.wiphy->n_radio; r++) {
+		radio = &local->hw.wiphy->radio[r];
+
+		for (i = 0; i < req->n_channels; i++) {
+			struct cfg80211_chan_def chandef = {};
+
+			chandef.chan = req->channels[i];
+			cfg80211_chandef_create(&chandef, req->channels[i],
+						NL80211_CHAN_NO_HT);
+			if (!cfg80211_radio_chandef_valid(radio, &chandef))
+				continue;
+
+			mask |= BIT(r);
+			break;
+		}
+	}
+
+	return mask;
+}
+
+u32 ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
+			   struct cfg80211_scan_request *req,
+			   u32 radio_mask)
 {
 	struct ieee80211_local *local = sdata->local;
 	struct ieee80211_sub_if_data *sdata_iter;
+	struct wiphy *wiphy = local->hw.wiphy;
+	struct ieee80211_chanctx_conf *conf;
+	struct ieee80211_link_data *link;
 	unsigned int link_id;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	if (!ieee80211_is_radar_required(local, req))
+	if (!ieee80211_is_radar_required(local, radio_mask, req))
 		return true;
 
 	if (!regulatory_pre_cac_allowed(local->hw.wiphy))
 		return false;
 
 	list_for_each_entry(sdata_iter, &local->interfaces, list) {
-		for_each_valid_link(&sdata_iter->wdev, link_id)
-			if (sdata_iter->wdev.links[link_id].cac_started)
+		for_each_valid_link(&sdata_iter->wdev, link_id) {
+			if (!sdata_iter->wdev.links[link_id].cac_started)
+				continue;
+
+			if (!wiphy->n_radio)
+				return false;
+
+			link = sdata_dereference(sdata->link[link_id], sdata);
+			if (!link)
+				continue;
+
+			conf = wiphy_dereference(wiphy, link->conf->chanctx_conf);
+			if (!conf)
+				continue;
+
+			if (conf->radio_idx >= 0 &&
+			    (radio_mask & BIT(conf->radio_idx)))
 				return false;
+		}
 	}
 
 	return true;
@@ -612,12 +659,12 @@ static bool __ieee80211_can_leave_ch(struct ieee80211_sub_if_data *sdata,
 
 static bool ieee80211_can_scan(struct ieee80211_local *local,
 			       struct ieee80211_sub_if_data *sdata,
-			       struct cfg80211_scan_request *req)
+			       struct cfg80211_scan_request *req,
+			       u32 radio_mask)
 {
-	if (!__ieee80211_can_leave_ch(sdata, req))
-		return false;
-
-	if (!list_empty(&local->roc_list))
+	if (!list_empty(&local->roc_list) &&
+	    (!local->hw.wiphy->n_radio ||
+	     (radio_mask & ieee80211_offchannel_radio_mask(local))))
 		return false;
 
 	if (sdata->vif.type == NL80211_IFTYPE_STATION &&
@@ -629,19 +676,22 @@ static bool ieee80211_can_scan(struct ieee80211_local *local,
 
 void ieee80211_run_deferred_scan(struct ieee80211_local *local)
 {
+	struct ieee80211_sub_if_data *sdata;
 	struct cfg80211_scan_request *req;
+	u32 radio_mask;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
 
-	if (!local->scan_req || local->scanning)
+	req = wiphy_dereference(local->hw.wiphy, local->scan_req);
+	if (!req || local->scanning)
 		return;
 
-	req = wiphy_dereference(local->hw.wiphy, local->scan_req);
-	if (!ieee80211_can_scan(local,
-				rcu_dereference_protected(
-					local->scan_sdata,
-					lockdep_is_held(&local->hw.wiphy->mtx)),
-				req))
+	radio_mask = ieee80211_scan_req_radio_mask(local, req);
+	sdata = wiphy_dereference(local->hw.wiphy, local->scan_sdata);
+	if (!ieee80211_can_leave_ch(sdata, req, radio_mask))
+		return;
+
+	if (!ieee80211_can_scan(local, sdata, req, radio_mask))
 		return;
 
 	wiphy_delayed_work_queue(local->hw.wiphy, &local->scan_work,
@@ -724,6 +774,7 @@ static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,
 {
 	struct ieee80211_local *local = sdata->local;
 	bool hw_scan = local->ops->hw_scan;
+	u32 radio_mask;
 	int rc;
 
 	lockdep_assert_wiphy(local->hw.wiphy);
@@ -738,10 +789,11 @@ static int __ieee80211_start_scan(struct ieee80211_sub_if_data *sdata,
 	    !(sdata->vif.active_links & BIT(req->tsf_report_link_id)))
 		return -EINVAL;
 
-	if (!__ieee80211_can_leave_ch(sdata, req))
+	radio_mask = ieee80211_scan_req_radio_mask(local, req);
+	if (!ieee80211_can_leave_ch(sdata, req, radio_mask))
 		return -EBUSY;
 
-	if (!ieee80211_can_scan(local, sdata, req)) {
+	if (!ieee80211_can_scan(local, sdata, req, radio_mask)) {
 		/* wait for the work to finish/time out */
 		rcu_assign_pointer(local->scan_req, req);
 		rcu_assign_pointer(local->scan_sdata, sdata);
diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c
index 3ce5e8f..d7d9ce9 100644
--- a/net/mac80211/sta_info.c
+++ b/net/mac80211/sta_info.c
@@ -630,6 +630,7 @@ __sta_info_alloc(struct ieee80211_sub_if_data *sdata,
 	spin_lock_init(&sta->ps_lock);
 	INIT_WORK(&sta->drv_deliver_wk, sta_deliver_ps_frames);
 	wiphy_work_init(&sta->ampdu_mlme.work, ieee80211_ba_session_work);
+	sta->ampdu_mlme.dialog_token_allocator = get_random_u32_below(U8_MAX);
 #ifdef CPTCFG_MAC80211_MESH
 	if (ieee80211_vif_is_mesh(&sdata->vif)) {
 		sta->mesh = kzalloc(sizeof(*sta->mesh), gfp);
@@ -2430,13 +2431,28 @@ EXPORT_SYMBOL(ieee80211_sta_recalc_aggregates);
 
 void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
 					  struct sta_info *sta, u8 ac,
-					  u16 tx_airtime, bool tx_completed)
+					  u16 tx_airtime, bool tx_completed,
+					  bool mcast)
 {
 	int tx_pending;
 
 	if (!wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL))
 		return;
 
+	if (mcast) {
+		if (!tx_completed) {
+			atomic_add(tx_airtime, &local->aql_bc_pending_airtime);
+			return;
+		}
+
+		tx_pending = atomic_sub_return(tx_airtime,
+					       &local->aql_bc_pending_airtime);
+		if (tx_pending < 0)
+			atomic_cmpxchg(&local->aql_bc_pending_airtime,
+				       tx_pending, 0);
+		return;
+	}
+
 	if (!tx_completed) {
 		if (sta)
 			atomic_add(tx_airtime,
@@ -2526,6 +2542,13 @@ static void sta_stats_decode_rate(struct ieee80211_local *local, u32 rate,
 
 		sband = local->hw.wiphy->bands[band];
 
+		if (!sband) {
+			wiphy_warn(local->hw.wiphy,
+				    "Invalid band %d\n",
+				    band);
+			break;
+		}
+
 		if (WARN_ON_ONCE(!sband->bitrates))
 			break;
 
@@ -2954,6 +2977,29 @@ static void sta_set_link_sinfo(struct sta_info *sta,
 	}
 }
 
+static u32 sta_estimate_expected_throughput(struct sta_info *sta,
+					    struct station_info *sinfo)
+{
+	struct ieee80211_sub_if_data *sdata = sta->sdata;
+	struct ieee80211_local *local = sdata->local;
+	struct rate_info *ri = &sinfo->txrate;
+	struct ieee80211_hw *hw = &local->hw;
+	struct ieee80211_chanctx_conf *conf;
+	u32 duration;
+	u8 band = 0;
+
+	conf = rcu_dereference(sdata->vif.bss_conf.chanctx_conf);
+	if (conf)
+			band = conf->def.chan->band;
+
+	duration = ieee80211_rate_expected_tx_airtime(hw, NULL, ri, band, true, 1024);
+	duration += duration >> 4; /* add assumed packet error rate of ~6% */
+	if (!duration)
+		return 0;
+
+	return ((1024 * USEC_PER_SEC) / duration) * 8;
+}
+
 void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		   bool tidstats)
 {
@@ -3178,6 +3224,8 @@ void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo,
 		sinfo->sta_flags.set |= BIT(NL80211_STA_FLAG_TDLS_PEER);
 
 	thr = sta_get_expected_throughput(sta);
+	if (!thr && (sinfo->filled & BIT_ULL(NL80211_STA_INFO_TX_BITRATE)))
+	    thr = sta_estimate_expected_throughput(sta, sinfo);
 
 	if (thr != 0) {
 		sinfo->filled |= BIT_ULL(NL80211_STA_INFO_EXPECTED_THROUGHPUT);
diff --git a/net/mac80211/sta_info.h b/net/mac80211/sta_info.h
index 012bf7f..df136cf 100644
--- a/net/mac80211/sta_info.h
+++ b/net/mac80211/sta_info.h
@@ -147,7 +147,8 @@ struct airtime_info {
 
 void ieee80211_sta_update_pending_airtime(struct ieee80211_local *local,
 					  struct sta_info *sta, u8 ac,
-					  u16 tx_airtime, bool tx_completed);
+					  u16 tx_airtime, bool tx_completed,
+					  bool mcast);
 
 struct sta_info;
 
diff --git a/net/mac80211/status.c b/net/mac80211/status.c
index 4b38aa0..ccc37c4 100644
--- a/net/mac80211/status.c
+++ b/net/mac80211/status.c
@@ -751,7 +751,7 @@ static void ieee80211_report_used_skb(struct ieee80211_local *local,
 		ieee80211_sta_update_pending_airtime(local, sta,
 						     skb_get_queue_mapping(skb),
 						     tx_time_est,
-						     true);
+						     true, info->tx_time_mc);
 		rcu_read_unlock();
 	}
 
@@ -1160,10 +1160,11 @@ void ieee80211_tx_status_ext(struct ieee80211_hw *hw,
 		/* Do this here to avoid the expensive lookup of the sta
 		 * in ieee80211_report_used_skb().
 		 */
+		bool mcast = IEEE80211_SKB_CB(skb)->tx_time_mc;
 		ieee80211_sta_update_pending_airtime(local, sta,
 						     skb_get_queue_mapping(skb),
 						     tx_time_est,
-						     true);
+						     true, mcast);
 		ieee80211_info_set_tx_time_est(IEEE80211_SKB_CB(skb), 0);
 	}
 
diff --git a/net/mac80211/trace.h b/net/mac80211/trace.h
index 0bfbce1..bcc94c7 100644
--- a/net/mac80211/trace.h
+++ b/net/mac80211/trace.h
@@ -31,9 +31,15 @@
 #define VIF_ENTRY	__field(enum nl80211_iftype, vif_type) __field(void *, sdata)	\
 			__field(bool, p2p)						\
 			__string(vif_name, sdata->name)
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 #define VIF_ASSIGN	__entry->vif_type = sdata->vif.type; __entry->sdata = sdata;	\
 			__entry->p2p = sdata->vif.p2p;					\
 			__assign_str(vif_name)
+#else
+#define VIF_ASSIGN	__entry->vif_type = sdata->vif.type; __entry->sdata = sdata;	\
+			__entry->p2p = sdata->vif.p2p;					\
+			__assign_str(vif_name, sdata->name)
+#endif
 #define VIF_PR_FMT	" vif:%s(%d%s)"
 #define VIF_PR_ARG	__get_str(vif_name), __entry->vif_type, __entry->p2p ? "/p2p" : ""
 
diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c
index decef32..a4fb73a 100644
--- a/net/mac80211/tx.c
+++ b/net/mac80211/tx.c
@@ -2554,7 +2554,7 @@ static u16 ieee80211_store_ack_skb(struct ieee80211_local *local,
 
 		spin_lock_irqsave(&local->ack_status_lock, flags);
 		id = idr_alloc(&local->ack_status_frames, ack_skb,
-			       1, 0x2000, GFP_ATOMIC);
+			       1, 0x1000, GFP_ATOMIC);
 		spin_unlock_irqrestore(&local->ack_status_lock, flags);
 
 		if (id >= 0) {
@@ -3985,20 +3985,20 @@ begin:
 encap_out:
 	info->control.vif = vif;
 
-	if (tx.sta &&
-	    wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
-		bool ampdu = txq->ac != IEEE80211_AC_VO;
+	if (wiphy_ext_feature_isset(local->hw.wiphy, NL80211_EXT_FEATURE_AQL)) {
+		bool ampdu = txq->sta && txq->ac != IEEE80211_AC_VO;
 		u32 airtime;
 
 		airtime = ieee80211_calc_expected_tx_airtime(hw, vif, txq->sta,
 							     skb->len, ampdu);
-		if (airtime) {
-			airtime = ieee80211_info_set_tx_time_est(info, airtime);
-			ieee80211_sta_update_pending_airtime(local, tx.sta,
-							     txq->ac,
-							     airtime,
-							     false);
-		}
+		if (!airtime)
+			return skb;
+
+		airtime = ieee80211_info_set_tx_time_est(info, airtime);
+		info->tx_time_mc = !tx.sta;
+		ieee80211_sta_update_pending_airtime(local, tx.sta, txq->ac,
+						     airtime, false,
+						     info->tx_time_mc);
 	}
 
 	return skb;
@@ -4050,6 +4050,7 @@ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
 	struct ieee80211_txq *ret = NULL;
 	struct txq_info *txqi = NULL, *head = NULL;
 	bool found_eligible_txq = false;
+	bool aql_check;
 
 	spin_lock_bh(&local->active_txq_lock[ac]);
 
@@ -4073,26 +4074,26 @@ struct ieee80211_txq *ieee80211_next_txq(struct ieee80211_hw *hw, u8 ac)
 	if (!head)
 		head = txqi;
 
+	aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
+	if (aql_check)
+		found_eligible_txq = true;
+
 	if (txqi->txq.sta) {
 		struct sta_info *sta = container_of(txqi->txq.sta,
 						    struct sta_info, sta);
-		bool aql_check = ieee80211_txq_airtime_check(hw, &txqi->txq);
-		s32 deficit = ieee80211_sta_deficit(sta, txqi->txq.ac);
-
-		if (aql_check)
-			found_eligible_txq = true;
-
-		if (deficit < 0)
+		if (ieee80211_sta_deficit(sta, txqi->txq.ac) < 0) {
 			sta->airtime[txqi->txq.ac].deficit +=
-				sta->airtime_weight;
-
-		if (deficit < 0 || !aql_check) {
-			list_move_tail(&txqi->schedule_order,
-				       &local->active_txqs[txqi->txq.ac]);
-			goto begin;
+				sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
+			aql_check = false;
 		}
 	}
 
+	if (!aql_check) {
+		list_move_tail(&txqi->schedule_order,
+				   &local->active_txqs[txqi->txq.ac]);
+		goto begin;
+	}
+
 	if (txqi->schedule_round == local->schedule_round[ac])
 		goto out;
 
@@ -4159,7 +4160,8 @@ bool ieee80211_txq_airtime_check(struct ieee80211_hw *hw,
 		return true;
 
 	if (!txq->sta)
-		return true;
+		return atomic_read(&local->aql_bc_pending_airtime) <
+		       local->aql_txq_limit_bc;
 
 	if (unlikely(txq->tid == IEEE80211_NUM_TIDS))
 		return true;
@@ -4208,15 +4210,15 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 
 	spin_lock_bh(&local->active_txq_lock[ac]);
 
-	if (!txqi->txq.sta)
-		goto out;
-
 	if (list_empty(&txqi->schedule_order))
 		goto out;
 
 	if (!ieee80211_txq_schedule_airtime_check(local, ac))
 		goto out;
 
+	if (!txqi->txq.sta)
+		goto out;
+
 	list_for_each_entry_safe(iter, tmp, &local->active_txqs[ac],
 				 schedule_order) {
 		if (iter == txqi)
@@ -4229,7 +4231,8 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 		}
 		sta = container_of(iter->txq.sta, struct sta_info, sta);
 		if (ieee80211_sta_deficit(sta, ac) < 0)
-			sta->airtime[ac].deficit += sta->airtime_weight;
+			sta->airtime[ac].deficit += sta->airtime_weight <<
+						    AIRTIME_QUANTUM_SHIFT;
 		list_move_tail(&iter->schedule_order, &local->active_txqs[ac]);
 	}
 
@@ -4237,7 +4240,7 @@ bool ieee80211_txq_may_transmit(struct ieee80211_hw *hw,
 	if (sta->airtime[ac].deficit >= 0)
 		goto out;
 
-	sta->airtime[ac].deficit += sta->airtime_weight;
+	sta->airtime[ac].deficit += sta->airtime_weight << AIRTIME_QUANTUM_SHIFT;
 	list_move_tail(&txqi->schedule_order, &local->active_txqs[ac]);
 	spin_unlock_bh(&local->active_txq_lock[ac]);
 
diff --git a/net/mac80211/util.c b/net/mac80211/util.c
index c993153..2b6f529 100644
--- a/net/mac80211/util.c
+++ b/net/mac80211/util.c
@@ -877,6 +877,23 @@ struct wireless_dev *ieee80211_vif_to_wdev(struct ieee80211_vif *vif)
 }
 EXPORT_SYMBOL_GPL(ieee80211_vif_to_wdev);
 
+u32 ieee80211_chandef_radio_mask(struct ieee80211_local *local,
+				 struct cfg80211_chan_def *chandef)
+{
+	struct wiphy *wiphy = local->hw.wiphy;
+	const struct wiphy_radio *radio;
+	u32 mask = 0;
+	int i;
+
+	for (i = 0; i < wiphy->n_radio; i++) {
+		radio = &wiphy->radio[i];
+		if (cfg80211_radio_chandef_valid(radio, chandef))
+			mask |= BIT(i);
+	}
+
+	return mask;
+}
+
 /*
  * Nothing should have been stuffed into the workqueue during
  * the suspend->resume cycle. Since we can't check each caller
diff --git a/net/wireless/ap.c b/net/wireless/ap.c
index 9a9a870..9cd0ab4 100644
--- a/net/wireless/ap.c
+++ b/net/wireless/ap.c
@@ -30,6 +30,9 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 	if (!wdev->links[link_id].ap.beacon_interval)
 		return -ENOENT;
 
+	cfg80211_update_last_available(wdev->wiphy,
+				       &wdev->links[link_id].ap.chandef);
+
 	err = rdev_stop_ap(rdev, dev, link_id);
 	if (!err) {
 		wdev->conn_owner_nlportid = 0;
@@ -41,9 +44,6 @@ static int ___cfg80211_stop_ap(struct cfg80211_registered_device *rdev,
 		if (notify)
 			nl80211_send_ap_stopped(wdev, link_id);
 
-		/* Should we apply the grace period during beaconing interface
-		 * shutdown also?
-		 */
 		cfg80211_sched_dfs_chan_update(rdev);
 	}
 
diff --git a/net/wireless/chan.c b/net/wireless/chan.c
index d6839e7..3433a73 100644
--- a/net/wireless/chan.c
+++ b/net/wireless/chan.c
@@ -639,6 +639,8 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 
 		c->dfs_state = dfs_state;
 		c->dfs_state_entered = jiffies;
+		if (dfs_state == NL80211_DFS_AVAILABLE)
+			c->dfs_state_last_available = jiffies;
 	}
 }
 
@@ -990,6 +992,53 @@ bool cfg80211_any_wiphy_oper_chan(struct wiphy *wiphy,
 	return false;
 }
 
+static void
+__cfg80211_update_last_available(struct wiphy *wiphy,
+					 u32 center_freq,
+					 u32 bandwidth)
+{
+	struct ieee80211_channel *c;
+	u32 freq, start_freq, end_freq;
+
+	if (bandwidth <= MHZ_TO_KHZ(20))
+		start_freq = end_freq = center_freq;
+	else {
+		start_freq = center_freq - bandwidth / 2 + MHZ_TO_KHZ(10);
+		end_freq = center_freq + bandwidth / 2 - MHZ_TO_KHZ(10);
+	}
+
+	/*
+	 * Check entire range of channels for the bandwidth.
+	 * If any channel in between is disabled or has not
+	 * had gone through CAC return false
+	 */
+	for (freq = start_freq; freq <= end_freq; freq += MHZ_TO_KHZ(20)) {
+		c = ieee80211_get_channel_khz(wiphy, freq);
+		if (!c)
+			return;
+
+		c->dfs_state_last_available = jiffies;
+	}
+}
+
+void cfg80211_update_last_available(struct wiphy *wiphy,
+				    const struct cfg80211_chan_def *chandef)
+{
+	int width;
+
+	width = cfg80211_chandef_get_width(chandef);
+	if (width < 0)
+		return;
+
+	__cfg80211_update_last_available(wiphy, MHZ_TO_KHZ(chandef->center_freq1),
+						 width);
+	if (chandef->width != NL80211_CHAN_WIDTH_80P80)
+	    return;
+
+	__cfg80211_update_last_available(wiphy, MHZ_TO_KHZ(chandef->center_freq2),
+						 width);
+}
+
 static bool cfg80211_chandef_dfs_available(struct wiphy *wiphy,
 				const struct cfg80211_chan_def *chandef)
 {
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 66d45e9..de32ca5 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -162,11 +162,19 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 	list_for_each_entry(wdev, &rdev->wiphy.wdev_list, list) {
 		if (!wdev->netdev)
 			continue;
+#if LINUX_VERSION_IS_GEQ(6,15,0)
 		wdev->netdev->netns_immutable = false;
+#elif LINUX_VERSION_IS_GEQ(6,12,0)
+		wdev->netdev->netns_local = false;
+#endif
 		err = dev_change_net_namespace(wdev->netdev, net, "wlan%d");
 		if (err)
 			break;
+#if LINUX_VERSION_IS_GEQ(6,15,0)
 		wdev->netdev->netns_immutable = true;
+#elif LINUX_VERSION_IS_GEQ(6,12,0)
+		wdev->netdev->netns_local = true;
+#endif
 	}
 
 	if (err) {
@@ -178,11 +186,19 @@ int cfg80211_switch_netns(struct cfg80211_registered_device *rdev,
 						     list) {
 			if (!wdev->netdev)
 				continue;
+#if LINUX_VERSION_IS_GEQ(6,15,0)
 			wdev->netdev->netns_immutable = false;
+#elif LINUX_VERSION_IS_GEQ(6,12,0)
+			wdev->netdev->netns_local = false;
+#endif
 			err = dev_change_net_namespace(wdev->netdev, net,
 							"wlan%d");
 			WARN_ON(err);
+#if LINUX_VERSION_IS_GEQ(6,15,0)
 			wdev->netdev->netns_immutable = true;
+#elif LINUX_VERSION_IS_GEQ(6,12,0)
+			wdev->netdev->netns_local = true;
+#endif
 		}
 
 		return err;
@@ -663,21 +679,6 @@ int wiphy_verify_iface_combinations(struct wiphy *wiphy,
 				    c->limits[j].max > 1))
 				return -EINVAL;
 
-			/*
-			 * This isn't well-defined right now. If you have an
-			 * IBSS interface, then its beacon interval may change
-			 * by joining other networks, and nothing prevents it
-			 * from doing that.
-			 * So technically we probably shouldn't even allow AP
-			 * and IBSS in the same interface, but it seems that
-			 * some drivers support that, possibly only with fixed
-			 * beacon intervals for IBSS.
-			 */
-			if (WARN_ON(types & BIT(NL80211_IFTYPE_ADHOC) &&
-				    c->beacon_int_min_gcd)) {
-				return -EINVAL;
-			}
-
 			cnt += c->limits[j].max;
 			/*
 			 * Don't advertise an unsupported type
@@ -1549,7 +1550,11 @@ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
 		SET_NETDEV_DEVTYPE(dev, &wiphy_type);
 		wdev->netdev = dev;
 		/* can only change netns with wiphy */
+#if LINUX_VERSION_IS_GEQ(6,15,0)
 		dev->netns_immutable = true;
+#elif LINUX_VERSION_IS_GEQ(6,12,0)
+		dev->netns_local = true;
+#endif
 
 		cfg80211_init_wdev(wdev);
 		break;
diff --git a/net/wireless/core.h b/net/wireless/core.h
index 39b5953..e225bb7 100644
--- a/net/wireless/core.h
+++ b/net/wireless/core.h
@@ -481,6 +481,8 @@ void cfg80211_set_dfs_state(struct wiphy *wiphy,
 			    enum nl80211_dfs_state dfs_state);
 
 void cfg80211_dfs_channels_update_work(struct work_struct *work);
+void cfg80211_update_last_available(struct wiphy *wiphy,
+				    const struct cfg80211_chan_def *chandef);
 
 void cfg80211_sched_dfs_chan_update(struct cfg80211_registered_device *rdev);
 
diff --git a/net/wireless/mlme.c b/net/wireless/mlme.c
index 894d95a..5d6cb84 100644
--- a/net/wireless/mlme.c
+++ b/net/wireless/mlme.c
@@ -1056,6 +1056,8 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
 			if (c->dfs_state == NL80211_DFS_UNAVAILABLE) {
 				time_dfs_update = IEEE80211_DFS_MIN_NOP_TIME_MS;
 				radar_event = NL80211_RADAR_NOP_FINISHED;
+				timeout = c->dfs_state_entered +
+					  msecs_to_jiffies(time_dfs_update);
 			} else {
 				if (regulatory_pre_cac_allowed(wiphy) ||
 				    cfg80211_any_wiphy_oper_chan(wiphy, c))
@@ -1063,11 +1065,10 @@ void cfg80211_dfs_channels_update_work(struct work_struct *work)
 
 				time_dfs_update = REG_PRE_CAC_EXPIRY_GRACE_MS;
 				radar_event = NL80211_RADAR_PRE_CAC_EXPIRED;
+				timeout = c->dfs_state_last_available +
+					  msecs_to_jiffies(time_dfs_update);
 			}
 
-			timeout = c->dfs_state_entered +
-				  msecs_to_jiffies(time_dfs_update);
-
 			if (time_after_eq(jiffies, timeout)) {
 				c->dfs_state = NL80211_DFS_USABLE;
 				c->dfs_state_entered = jiffies;
diff --git a/net/wireless/reg.c b/net/wireless/reg.c
index 030be58..0cd2909 100644
--- a/net/wireless/reg.c
+++ b/net/wireless/reg.c
@@ -3335,6 +3335,8 @@ void regulatory_hint_country_ie(struct wiphy *wiphy, enum nl80211_band band,
 	enum environment_cap env = ENVIRON_ANY;
 	struct regulatory_request *request = NULL, *lr;
 
+	return;
+
 	/* IE len must be evenly divisible by 2 */
 	if (country_ie_len & 0x01)
 		return;
@@ -3584,6 +3586,7 @@ static bool is_wiphy_all_set_reg_flag(enum ieee80211_regulatory_flags flag)
 
 void regulatory_hint_disconnect(void)
 {
+	return;
 	/* Restore of regulatory settings is not required when wiphy(s)
 	 * ignore IE from connected access point but clearance of beacon hints
 	 * is required when wiphy(s) supports beacon hints.
diff --git a/net/wireless/sysfs.c b/net/wireless/sysfs.c
index 62f2661..4e7644f 100644
--- a/net/wireless/sysfs.c
+++ b/net/wireless/sysfs.c
@@ -24,18 +24,35 @@ static inline struct cfg80211_registered_device *dev_to_rdev(
 	return container_of(dev, struct cfg80211_registered_device, wiphy.dev);
 }
 
-#define SHOW_FMT(name, fmt, member)					\
+#define SHOW_FMT(name, fmt, member, mode)				\
 static ssize_t name ## _show(struct device *dev,			\
 			      struct device_attribute *attr,		\
 			      char *buf)				\
 {									\
 	return sprintf(buf, fmt "\n", dev_to_rdev(dev)->member);	\
 }									\
-static DEVICE_ATTR_RO(name)
+static DEVICE_ATTR_##mode(name)
 
-SHOW_FMT(index, "%d", wiphy_idx);
-SHOW_FMT(macaddress, "%pM", wiphy.perm_addr);
-SHOW_FMT(address_mask, "%pM", wiphy.addr_mask);
+static ssize_t macaddress_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	u8 mac[ETH_ALEN];
+
+	if (!mac_pton(buf, mac))
+		return -EINVAL;
+
+	if (buf[3 * ETH_ALEN - 1] && buf[3 * ETH_ALEN - 1] != '\n')
+		return -EINVAL;
+
+	memcpy(dev_to_rdev(dev)->wiphy.perm_addr, mac, ETH_ALEN);
+
+	return strnlen(buf, len);
+}
+
+SHOW_FMT(index, "%d", wiphy_idx, RO);
+SHOW_FMT(macaddress, "%pM", wiphy.perm_addr, RW);
+SHOW_FMT(address_mask, "%pM", wiphy.addr_mask, RO);
 
 static ssize_t name_show(struct device *dev,
 			 struct device_attribute *attr,
diff --git a/net/wireless/trace.h b/net/wireless/trace.h
index 3ede1e2..2ec326f 100644
--- a/net/wireless/trace.h
+++ b/net/wireless/trace.h
@@ -478,7 +478,11 @@ TRACE_EVENT(rdev_add_virtual_intf,
 	),
 	TP_fast_assign(
 		WIPHY_ASSIGN;
+#if LINUX_VERSION_IS_GEQ(6,10,0)
 		__assign_str(vir_intf_name);
+#else
+		__assign_str(vir_intf_name, name ? name : "<noname>");
+#endif
 		__entry->type = type;
 	),
 	TP_printk(WIPHY_PR_FMT ", virtual intf name: %s, type: %d",
diff --git a/net/wireless/util.c b/net/wireless/util.c
index 56724b3..addaff9 100644
--- a/net/wireless/util.c
+++ b/net/wireless/util.c
@@ -2964,6 +2964,9 @@ bool cfg80211_radio_chandef_valid(const struct wiphy_radio *radio,
 {
 	u32 freq, width;
 
+	if (!cfg80211_chandef_valid(chandef))
+		return false;
+
 	freq = ieee80211_chandef_to_khz(chandef);
 	width = MHZ_TO_KHZ(cfg80211_chandef_get_width(chandef));
 	if (!ieee80211_radio_freq_range_valid(radio, freq, width))
-- 
2.47.3

